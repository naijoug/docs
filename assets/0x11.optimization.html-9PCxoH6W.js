import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as e,a as l,b as r,f as s}from"./app-7SE9az9E.js";const t={},d=r("p",null,"程序开发中的“优化”，从程序的整个运行过程来说...",-1),h=s('<h2 id="前端优化" tabindex="-1"><a class="header-anchor" href="#前端优化" aria-hidden="true">#</a> 前端优化</h2><p>前端程序来说，由于是和用户交互，这些优化不仅涉及程序的本身的优化，还涉及一个用户体验方面的优化</p><h3 id="❓启动优化" tabindex="-1"><a class="header-anchor" href="#❓启动优化" aria-hidden="true">#</a> ❓启动优化</h3><details class="hint-container details"><summary>💡</summary><p>也就是打开程序的快慢。 App 角度来说就是用户点击打开 App 到看到首屏展示的速度。 Web 角度来说就是用户打开网站到网页加载完成。</p><ul><li>减小包体积。</li><li>减少启动逻辑，将启动无关的逻辑延迟加载。</li></ul></details><h3 id="❓数据优化" tabindex="-1"><a class="header-anchor" href="#❓数据优化" aria-hidden="true">#</a> ❓数据优化</h3><details class="hint-container details"><summary>💡</summary><p>这个是从程序角度进行数据的优化处理。主要体现在用户在进入页面后加载 loading 时间长，或者提交表单之后等待时间长等问题。</p><ul><li>分页 :</li><li>缓存 :</li><li>压缩 :</li><li>预加载 :</li></ul></details><h3 id="❓体验优化" tabindex="-1"><a class="header-anchor" href="#❓体验优化" aria-hidden="true">#</a> ❓体验优化</h3><details class="hint-container details"><summary>💡</summary><p>用户在使用前端应用过程是否出现卡顿、白屏、交互困难等问题</p><ul><li>耗时操作放入子线程</li><li>FPS 帧率调试</li></ul></details><hr><h2 id="后端优化" tabindex="-1"><a class="header-anchor" href="#后端优化" aria-hidden="true">#</a> 后端优化</h2><p>后端程序来说，由于主要是和数据打交道，这些优化主要是程序逻辑、数据处理、架构等方面的优化。</p><hr><h2 id="网络优化" tabindex="-1"><a class="header-anchor" href="#网络优化" aria-hidden="true">#</a> 网络优化</h2><hr><h2 id="数据库优化" tabindex="-1"><a class="header-anchor" href="#数据库优化" aria-hidden="true">#</a> 数据库优化</h2><h3 id="❓数据库的查询优化方案" tabindex="-1"><a class="header-anchor" href="#❓数据库的查询优化方案" aria-hidden="true">#</a> ❓数据库的查询优化方案</h3><details class="hint-container details"><summary>💡</summary><p>数据库查询优化是一个复杂的过程，其主要目标是减少查询的执行时间和系统的空间占用。下面列举一些常见的数据库查询优化方法：</p><ol><li><p>优化SQL语句：这是最直接也是最有效的优化手段。比如尽量避免全表扫描，减少JOIN操作的数量，使用WHERE子句而不是HAVING子句，用 EXISTS 代替 IN 等。</p></li><li><p>建立索引：索引是数据库中用于提高数据检索效率的数据结构。在适当的列上建立索引，可以显著减小查询的执行时间，但是要注意索引也会占用存储空间且对数据的插入、删除和修改有一定的先来花费。</p></li><li><p>数据库表分区：如果一个表中的数据量太大，可以将它分区，分散到多个磁盘或者表中。这样查询时只需从包含所需数据的表或磁盘中读取，可以减少IO操作。</p></li><li><p>数据库表分割：对于大量数据的表，考虑分割成多个小表，采用垂直分割或水平分割，这样可以提高查询效率以及数据操作效率。</p></li><li><p>使用视图：视图是一种虚拟的表，内容是由查询定义的。如果某一查询语句需要多个步骤执行，可以将其转化为视图，这样下次进行相同查询时，只需要查询视图就可以了。</p></li><li><p>优化数据模型：根据业务需求优化数据模型设计，第三范式是追求完全规范化、无冗余，而反范式则是为了追求高效的查询性能。</p></li><li><p>使用数据库的查询优化器：现代数据库系统，如MySQL, PostgreSQL等，通常自带查询优化器，它会对查询语句进行分析，并尝试找到最优的执行计划。</p></li></ol><p>每一种优化方式都有其适用的场景，需要根据实际情况选择最合适的方案。</p></details><h3 id="❓数据库的分库分表方案" tabindex="-1"><a class="header-anchor" href="#❓数据库的分库分表方案" aria-hidden="true">#</a> ❓数据库的分库分表方案</h3><details class="hint-container details"><summary>💡</summary><p>数据库的分库分表方案主要包括水平分表、垂直分表、水平分库、垂直分库四种形式。</p><ol><li><p>水平分表：将一个大表按照某种规则（例如ID范围，日期范围）拆分成多个小表。例如，用户表有百万甚至千万级别的数据行，可以按照用户 ID 的范围分成多个小表。</p></li><li><p>垂直分表：根据业务需求，将一个表分拆成多个业务相关的小表。例如，用户表中有很多字段，可以将一部分基础信息字段和一部分扩展信息字段拆分开来。</p></li><li><p>水平分库：和水平分表类似，只是在更大的维度上将一个数据库拆分成多个小数据库。仍以用户表为例，可以按照用户 ID 的范围将数据分散存储到多个数据库中。</p></li><li><p>垂直分库：根据业务关系将一个数据库的表分配到不同的数据库中，每个数据库负责整个业务流程中的一部分。例如，将订单表和用户信息表分配到不同的数据库中。</p></li></ol><p>这些方案根据具体业务场景需要灵活选择，有时候甚至会组合使用。例如大型的互联网产品，可能既需要按照业务拆分（垂直拆分），也需要按照数据量拆分（水平拆分）。选择合适的分库分表方案可以有效扩展数据库的处理能力，提高数据库的性能和稳定性。</p></details><h3 id="❓数据库存储的实现方案" tabindex="-1"><a class="header-anchor" href="#❓数据库存储的实现方案" aria-hidden="true">#</a> ❓数据库存储的实现方案</h3><details class="hint-container details"><summary>💡</summary><p>数据库存储实现方案有许多种，主要包括以下几种类型：</p><ol><li><p>堆文件组织：数据记录可以在文件中的任何位置，记录间没有任何排序关系也没有任何先后关系。这种方式非常简单，但是访问效率低，因为找到一个特定的数据，可能需要全文扫描。</p></li><li><p>顺序文件组织：该存储方法根据某一属性（或属性组合）的值的顺序，把记录插入到文件中对应的位置。尤其在进行大量的查找操作时性能优良，但插入单条数据或者更新数据的性能较差。</p></li><li><p>散列表组织：散列技术是把记录的位置与其关键字之间建立一种直接的对应关系，以便能直接访问到这个记录。但是，同时也会导致更新操作比较复杂，并且空间利用率相对较低。</p></li><li><p>B+树索引组织：将数据根据键值以B+树的方式组织，非常适合范围查询和排序返回等操作，也支持单值快速查找。</p></li><li><p>LSM树(LSM-Tree, Log-Structured Merge-Tree)：通过两种不同类型的数据结构，即内存中的数据结构和硬盘上的数据结构，组成一个高效的硬盘存储引擎。如RocksDB，LevelDB等。</p></li></ol><p>具体采取哪种方式，需要根据应用的需求，如查询性能要求、数据更新频率、存储空间等因素，进行综合考虑。在实际的数据库系统中，往往会采用结合多种策略的方式进行数据存储。</p></details>',21);function n(p,c){return i(),e("div",null,[d,l(" more "),h])}const u=a(t,[["render",n],["__file","0x11.optimization.html.vue"]]);export{u as default};

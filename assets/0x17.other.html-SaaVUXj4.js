import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,a as d,f as a}from"./app-51pB87w6.js";const i={},s=a(`<hr><h2 id="综合性问题" tabindex="-1"><a class="header-anchor" href="#综合性问题" aria-hidden="true">#</a> 综合性问题</h2><h3 id="❓ios-设备获取唯一设备号的历史变迁" tabindex="-1"><a class="header-anchor" href="#❓ios-设备获取唯一设备号的历史变迁" aria-hidden="true">#</a> ❓<code>iOS</code> 设备获取唯一设备号的历史变迁</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>UDID</code>（Unique Device Identifier）：在<code>iOS 5</code>之前，可以直接使用 <code>[UIDevice currentDevice].uniqueIdentifier</code> 来获取设备的 <code>UDID</code>，它是一个40位的十六进制序列，由设备的各种硬件信息生成，每台设备唯一。然而，由于隐私问题，<code>Apple</code> 在 <code>iOS 5</code> 及以后的版本中废弃了这个 <code>API</code>。</p></li><li><p><code>MAC</code> 地址：因为 <code>UDID</code> 被废弃，部分开发者开始使用设备的 <code>Wi-Fi chip</code> 的 <code>MAC</code> 地址作为替代。然而在 <code>iOS 7</code> 以后，<code>Apple</code> 也禁止了获取 <code>MAC</code> 地址，所有尝试获取的行为都会返回固定的&quot;02:00:00:00:00:00&quot;。</p></li><li><p><code>UUID</code>（Universally Unique Identifier）：<code>UUID</code> 是每次生成都不同的一串字符。在 <code>UDID</code> 和 <code>MAC</code> 地址都不能使用后，部分开发者开始产生一个 <code>UUID</code> 并将其存储在应用的 <code>KeyChain</code> 中，这样就可以保证同一台设备上不同的安装过程中获取的 <code>UUID</code> 相同。但是，如果应用被彻底删除后或者设备被重置后，之前的 <code>UUID</code> 将无法再被获取到。</p></li><li><p><code>IDFA</code>（Identifier for Advertisers）：在 <code>iOS 6</code> 及以后的版本中，<code>Apple</code> 引入了广告标识符 <code>IDFA</code>，主要用于广告商跟踪和标识用户。用户可以在设置中重置自己的 <code>IDFA</code>，或者完全关闭这个功能。</p></li><li><p><code>IDFV</code>（Identifier for Vendor）：在 <code>iOS 6</code> 及以后的版本中，<code>Apple</code> 也引入了 <code>IDFV</code>，这是一个针对同一开发者（<code>Vendor</code>）下的所有应用都相同的标识符。只有当用户将该厂商的所有应用全部删除后，这个标识符才会被重置。</p></li></ul><p>总结：为了保护用户隐私，<code>Apple</code> 不断的改变标识设备的方式，开发者必须适应这些变化并尊重用户的隐私。</p></details><h3 id="❓沙盒目录的每个文件夹划分的作用" tabindex="-1"><a class="header-anchor" href="#❓沙盒目录的每个文件夹划分的作用" aria-hidden="true">#</a> ❓沙盒目录的每个文件夹划分的作用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>沙盒(Sandbox)，每个应用都有一个自己的沙盒目录，其他应用应用或者外部环境无法访问该应用的沙盒。这是 <code>iOS</code> 保证用户数据隐私和安全的机制之一。在应用的沙盒内，又划分了一些目录文件夹，不同的目录有着不同的作用：</p></blockquote><ul><li><p><code>Documents</code>：用来存储用户创建或应用程序运行需要持久化的数据。<code>iTunes</code> 同步设备时会备份该目录内容。</p></li><li><p><code>tmp</code>：用于存放临时文件，当应用退出后，这个目录下的文件会被删除。所以有些临时产生的文件，如缓存的图片或者下载的临时的文件可以放在这里。</p></li><li><p><code>Library</code>：Library目录下有两个子目录，<code>Caches</code> 和 <code>Preferences</code>。其中 <code>Caches</code> 目录主要存放缓存文件，<code>Preferences</code> 目录主要存放应用的配置信息，这些数据在设备的设置应用中设置。此外，<code>Library</code> 还可以存放应用的其他一些持久性的文件。</p></li><li><p><code>Library/Caches</code>：保存应用程序使用时产生的需要持久化的数据，<code>iTunes</code> 不会备份该目录，此目录下文件不会在应用退出后删除。</p></li></ul></details><h3 id="❓苹果使用证书的目的是什么" tabindex="-1"><a class="header-anchor" href="#❓苹果使用证书的目的是什么" aria-hidden="true">#</a> ❓苹果使用证书的目的是什么</h3><details class="hint-container details"><summary>💡</summary><p>苹果使用证书的主要目的：为了保护开发者和用户的安全，以及确保应用的完整性和权威性。</p><ul><li><p><strong>身份验证：</strong> 给开发者提供了一种手段以证明自己的身份。证书包含了开发者的信息，因此可以被用于表示开发者的身份。</p></li><li><p><strong>数据加密：</strong> 证书包含了公钥，可以用于加密信息以保证数据的安全传输。</p></li><li><p><strong>代码签名：</strong> 开发者可以使用私钥来签名应用，用户可以使用开发者公钥来验证签名，确保应用没有被篡改并且确实来自预期的开发者。</p></li><li><p><strong>权限申请：</strong> 通过证书，开发者可以申请使用一些特定的功能，如推送通知、使用苹果支付等。</p></li><li><p><strong>应用分发：</strong> 在将应用提交给 <code>App Store</code> 审核或企业内部分发时，都需要对应用进行签名。并且，只有有效证书签名的应用才能被安装在 <code>iOS</code> 设备上。</p></li></ul></details><h3 id="❓apn-的基本原理" tabindex="-1"><a class="header-anchor" href="#❓apn-的基本原理" aria-hidden="true">#</a> ❓<code>APN</code> 的基本原理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>APN</code>(<code>Apple Push Notification service</code>)是苹果公司开发的一套远程推送服务。其基本原理可以归纳如下几步：</p></blockquote><ul><li><p><strong>注册设备标识符 Device Token</strong>：当用户启动应用时，通过调用推送注册接口，注册设备推送标识符，然后调用服务器接口提交这个设备标识符。</p></li><li><p><strong>应用服务器向 Apple Push Notification Service 发送通知请求：</strong> 当应用需要向用户设备发送通知时，服务器会生成一个通知请求，包括设备标识符（<code>Device Token</code>）和通知内容，并将请求发送至苹果的推送通知服务。</p></li><li><p><strong>Apple Push Notification Service 将通知推送给目标设备：</strong> 当苹果的推送通知服务收到来自应用服务器的推送请求后，会根据提供的设备标识符将通知传送到目标设备。</p></li><li><p><strong>目标设备接收到通知：</strong> 当设备接收到苹果推送的通知后，会根据用户的设置和应用的状态来显示通知。</p><blockquote><p>例如，设备锁屏时，通知会显示在锁屏界面；设备解锁时，通知会显示在通知中心；如果应用正在前台运行，可以自定义是否显示通知。</p></blockquote></li><li><p><strong>用户点击通知：</strong> 用户在收到通知后可以选择直接点击打开，此时应用会收到一个打开通知的事件，可以根据需要做出相应的反应。</p></li></ul></details><h3 id="❓appstore-安装-app-时的认证流程" tabindex="-1"><a class="header-anchor" href="#❓appstore-安装-app-时的认证流程" aria-hidden="true">#</a> ❓<code>AppStore</code> 安装 <code>app</code> 时的认证流程</h3><details class="hint-container details"><summary>💡</summary><p>认证流程：</p><ul><li><p>开发者提交应用：开发者完成应用编写后，使用开发者证书进行代码签名，并提交给App Store进行审核。这个证书由苹果提供，并和开发者账户绑定，可以确保应用来源的可靠性。</p></li><li><p><code>App Store</code> 审核应用：苹果会对提交的应用进行审核，以确保应用的质量和安全性。这包括对应用的功能、性能、安全性、隐私保护等多个方面的评审。</p></li><li><p>用户下载和安装应用：审核通过后，应用就会出现在 <code>App Store</code> 上。用户在下载和安装应用时，<code>iOS</code> 系统会检查应用的签名和证书。这既包括开发者的证书，也包括 <code>App Store</code> 的证书，它们可以确保应用的来源和完整性。</p></li><li><p>应用运行：应用在安装后首次运行时，系统会进行一次额外的签名检查。此外，运行时的应用也需要遵守一些权限和用户设定的规范，否则可能会被系统限制其行为。</p></li></ul></details><hr><h2 id="xcode" tabindex="-1"><a class="header-anchor" href="#xcode" aria-hidden="true">#</a> Xcode</h2><h3 id="❓xcode-证书校验流程" tabindex="-1"><a class="header-anchor" href="#❓xcode-证书校验流程" aria-hidden="true">#</a> ❓<code>Xcode</code> 证书校验流程</h3><details class="hint-container details"><summary>💡</summary><p>在使用<code>Xcode</code>进行开发并打包应用进行发布时，证书（<code>Certificate</code>）和配置文件（<code>Provisioning Profile</code>）是必要的步骤。证书和配置文件能够验证开发者和应用的身份，并限制应用能够运行在哪些设备上。</p><p><code>Xcode</code> 进行应用打包的证书校验流程：</p><ul><li><p><strong>注册 Apple Developer 帐户：</strong> 首先需要在苹果开发者网站注册一名开发者帐户。</p></li><li><p><strong>创建开发者（Developer）和分发（Distribution）证书：</strong> 在苹果开发者网站里，需要创建一对开发者和分发用途的证书。开发者证书会在进行开发和调试应用时用到，分发证书将会在需要将应用提交到 <code>App Store</code> 或者 <code>Ad Hoc</code> 分发时用到。</p></li><li><p><strong>从 Keychain Access 中导出 .cer 文件：</strong> 在开发者网站中创建好证书后，会得到一个 <code>.cer</code> 文件。这个文件需要在<code>Keychain Access</code> （钥匙串访问）中进行安装。</p></li><li><p><strong>创建 App ID：</strong> 每一个应用都需要一个唯一的标识符，也就是 <code>App ID</code>。需要在开发者网站创建一个 <code>App ID</code>，并且连接到你的证书。</p></li><li><p><strong>创建配置文件（Provisioning Profile）：</strong> 这个文件包含了你的证书，<code>App ID</code> 以及能够调试的设备列表。开发版和分发版的配置文件都需要创建。</p></li><li><p><strong>在 Xcode 中安装证书和配置文件：</strong> 将从开发者网站下载的配置文件直接拖入到 <code>Xcode</code> 中，<code>Xcode</code> 会自动安装并将它与你的证书进行关联。</p></li><li><p><strong>在 Xcode 中选择正确的证书和配置文件进行打包：</strong> 在进行打包（<code>Archive</code>）操作之前，需要设置正确的 <code>bundle ID</code>，然后 <code>Xcode</code> 会自动选择相匹配的证书和配置文件等设置。</p></li><li><p><strong>分发应用：</strong> 如果证书和配置文件没有问题，那么 <code>Xcode</code> 会顺利的打包出应用，并且能够提交到 <code>App Store</code> 或 <code>Ad Hoc</code> 设备中进行安装。</p></li></ul></details><h3 id="❓xcode-打包流程" tabindex="-1"><a class="header-anchor" href="#❓xcode-打包流程" aria-hidden="true">#</a> ❓<code>Xcode</code> 打包流程</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>清理 Build 目录：</strong> 在点击 <code>Xcode</code> 顶部菜单栏的 <code>Product</code> 选项下面，选择 <code>Clean</code> 开始进行清理。这样做的目的是确保可以从干净的状态开始打包。</p></li><li><p><strong>编译：</strong> 切换到需要发布的 <code>Schema</code>（比如 <code>Release</code> 模式或者 <code>Debug</code> 模式），选择需要打包的 <code>Scheme</code>，然后再点击 <code>Product</code> 选择 <code>Build</code> 开始进行编译。</p></li><li><p><strong>归档：</strong> 编译成功后，选择 <code>Product</code> 下的 <code>Archive</code> 开始进行归档。归档过程会生成一个 <code>.xcarchive</code> 文件，这个文件包含了应用的可执行文件和其他一些资源文件。</p></li><li><p><strong>导出 ipa 包：</strong> 归档结束后，<code>Organizer</code> 窗口将会自动弹出，里面会列出生成的所有归档文件。选择需要的归档，点击右侧的<code>Export</code> 按钮，然后可以选择需要的打包方式（比如<code>App Store</code>, <code>Ad-Hoc</code>, <code>Enterprise</code>等），之后会要求选择一个存放 <code>ipa</code> 包的位置，等待进度条完成就签名导出完成了。</p></li><li><p><strong>验证：</strong> 如果想将应用上传到 <code>App Store</code>，那么在导出 <code>ipa</code> 包之后，可以再点击一次 <code>Validate App</code> 进行验证，看看是否符合苹果的标准。</p></li><li><p><strong>上传至 App Store：</strong> 如果一切顺利，最后点击 <code>Upload to App Store.</code> 提交应用给苹果审查。</p></li><li><p><strong>查看 App Connect：</strong> 上传结束后，过几分钟登陆 <code>App Connect</code> 网站，就可以看到你上传的应用。</p></li></ul></details><h3 id="❓xcode-的-workspace、project、target-的区别和联系是什么" tabindex="-1"><a class="header-anchor" href="#❓xcode-的-workspace、project、target-的区别和联系是什么" aria-hidden="true">#</a> ❓<code>Xcode</code> 的 <code>workspace</code>、<code>project</code>、<code>target</code> 的区别和联系是什么</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>workspace</code>, <code>project</code> 和 <code>target</code> 是Xcode中管理工程的三个重要概念，它们之间的关系颇为密切。</p></blockquote><ul><li><p><strong>Workspace</strong>：可以看做是一个大的容器，里面可以包含不同的 <code>project</code> 和文件，甚至其他的 <code>workspace</code>。<code>Workspace</code> 主要用于管理代码组织，且可以共享 <code>workspace</code> 内部多个 <code>project</code> 的编译信息。因此，在大型项目或者多模块项目开发中，<code>workspace</code> 可以帮助我们将工程有效的组织在一起。</p></li><li><p><strong>Project</strong>：是 <code>Xcode</code> 中的一个最常见的工程项目，任何一个app工程基本上就是一个 <code>project</code>。它可以包含 <code>build</code> 配置和一个或多个 <code>targets</code>。<code>project</code> 内的(<code>targets</code>)产品可以在 <code>workspace</code> 内的其他项目中被引用。</p></li><li><p><strong>Target</strong>：定义了一系列的编译设置和要编译的文件，可以把它看作是 <code>project</code> 中的一个模块。一个项目可以包含多个 <code>Target</code>，每个 <code>Target</code> 会生成一个 <code>App</code>，一个项目打包可以出多个版本的<code>App</code>。例如，可以为项目定义分别对应调试版、正式版和企业版的三个 <code>target</code>。</p></li></ul><p>三者关系：<code>workspace</code> 包含多个 <code>project</code>，而 <code>project</code> 又可以包含多个 <code>target</code>。同时同一 <code>project</code> 下的不同 <code>target</code> 可以共享代码和资源。这样，开发工程可以在一个 <code>workspace</code> 中从属于不同的 <code>project</code>，而每个 <code>project</code> 中可以包含多个 <code>target</code>，每个 <code>target</code> 可以根据不同的需求配置不同的编译选项和链接选项。</p></details><h3 id="❓ccache-的原理是啥-它跟-xcode-里的-derived-data-有什么区别" tabindex="-1"><a class="header-anchor" href="#❓ccache-的原理是啥-它跟-xcode-里的-derived-data-有什么区别" aria-hidden="true">#</a> ❓<code>CCache</code> 的原理是啥，它跟 <code>Xcode</code> 里的 <code>Derived Data</code> 有什么区别</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>CCache</code> 是一个编译缓存工具，它主要通过接管编译器的调用，保存编译结果到缓存，以加快重复编译的速度。</p></blockquote><p>基本原理：</p><p>当编译源文件时，<code>CCache</code> 会首先计算源文件及编译命令的哈希值，然后用哈希值作为 <code>key</code> 在缓存中查找是否有对应的编译结果。如果有，<code>CCache</code> 则直接使用缓存中的编译结果，而不再执行实际的编译。如果没有，<code>CCache</code> 则会执行实际的编译，并将编译结果保存在缓存中，以供后续使用。</p><p>主要区别：</p><ul><li><p>工作原理</p><ul><li><code>CCache</code> 是一款通用的开源软件，主要目标是缩短 <code>C、C++、Objective-C</code> 或 <code>Objective-C++</code> 的编译时间，适用于多种编译器和操作系统。</li><li><code>Derived Data</code> 特指 <code>Xcode</code> 的一个机制，主要用于存储项目编译过程中产生的中间文件。</li></ul></li><li><p>缓存内容</p><ul><li><code>CCache</code> 主要通过缓存编译结果以加速构建过程，适用于完全重复的编译任务。</li><li><code>Derived Data</code> 的机制更强大，它不仅会缓存编译结果，还会缓存很多其他中间产物，如索引、预编译头文件等。</li></ul></li><li><p>适用场景</p><ul><li><code>CCache</code> 适合在代码或编译参数没有变化、目标文件被删除或移动的情况下加速编译。</li><li><code>Derived Data</code> 适用于 <code>Xcode</code> 构建系统，对于大型项目的编译优化更为明显。</li></ul></li></ul><p>总结：使用 <code>CCache</code> 可以显著加快源代码的重新编译速度，尤其是在频繁修改、编译源代码时。而使用 <code>Derived Data</code> 可以更好地管理 <code>Xcode</code> 的编译过程和构建过程，并可以加速 <code>Xcode</code> 项目的构建速度。</p></details><hr><h2 id="开源库" tabindex="-1"><a class="header-anchor" href="#开源库" aria-hidden="true">#</a> 开源库</h2><h3 id="❓说说你最熟悉的第三方-知晓其原理吗" tabindex="-1"><a class="header-anchor" href="#❓说说你最熟悉的第三方-知晓其原理吗" aria-hidden="true">#</a> ❓说说你最熟悉的第三方，知晓其原理吗</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>AFNetworking/Alamofire</strong>：第三方网络请求库，通过封装苹果系统提供的 <code>NSURLSession</code>，简化了发送网络请求的步骤，同时还提供了很多方便实用的功能，如图片下载与缓存，网络状态监测等。底层主要是通过 <code>NSOperation</code> 及 <code>GCD</code> 来实现多线程操作。</p></li><li><p><strong>Masonry/SnapKit</strong>：第三方 <code>AutoLayout</code> 库，它通过链式语法简化了布局代码，使得我们可以直观地编写约束。底层其实就是封装了苹果的 <code>AutoLayout</code> 系统，通过 <code>DSL</code>(<code>Domain Specific Language</code>)使其使用起来简单方便。</p></li><li><p><strong>SDWebImage</strong>：主要用于处理网络图片的下载和缓存，它提供了一个 <code>UIImageView</code> 的扩展，方便的设置在线图片及占位图，同时进行图片缓存。主要原理是采用 <code>NSCache</code> 进行内存缓存，采用沙盒进行硬盘缓存，针对图片解码、渲染时机进行了优化处理。</p></li><li><p><strong>ReactiveCocoa/ReactiveSwift</strong>：这个库提供了函数响应式编程的接口，可以使用事件流的方式处理各种异步操作，使得代码更加整洁并提高了可读性。它的核心是 <code>Signal</code> 和 <code>Observer</code>，通过创建信号并添加观察者的方式来进行编程。</p></li></ul></details><h3 id="❓rxswift-的实现原理" tabindex="-1"><a class="header-anchor" href="#❓rxswift-的实现原理" aria-hidden="true">#</a> ❓<code>RxSwift</code> 的实现原理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>RxSwift</code>（<code>ReactiveX for Swift</code>）是一个基于 <code>Swift</code> 编程语言实现的响应式编程库。</p></blockquote><p>基本原理：</p><ul><li><p><strong>响应式流（Reactive Streams）</strong>：<code>RxSwift</code> 基于观察者模式，使用一种称为响应式流的新型抽象概念。可以发出事件，事件可以被观察，并在每次有新事件时触发行为。</p><blockquote><p>在 <code>RxSwift</code> 世界中，这些事件成为观察者模式 <code>Observable sequences</code>，它们展示了过去和未来的一系列元素。</p></blockquote></li><li><p><strong>操作符</strong>：<code>RxSwift</code> 提供了一套丰富的操作符 <code>API</code>，可以用于创建、转换、过滤、组合和错误处理等 <code>Observable sequences</code>。</p><blockquote><p>例如<code>map</code>，<code>flatMap</code>，<code>filter</code>，<code>combineLatest</code>，<code>catchError</code>等。</p></blockquote></li><li><p><strong>订阅者/观察者</strong>：通过 <code>subscribe</code> 函数来指定当发生事件（元素发出、错误发生、完成事件）时应该执行的操作。使用 <code>DisposeBag</code> 来负责处理订阅对象的销毁，防止内存泄漏。</p></li><li><p><strong>调度器</strong>：提供了 <code>schedulers</code> 来指定代码的执行环境。<code>Schedulers</code> 也是用来控制并发和线程管理。</p></li></ul><p>总结：<code>RxSwift</code> 的原理是抽象出一套响应式编程的接口，使得可以更方便的进行异步编程和数据流管理。遵循一个核心概念： &quot;将异步事件转化为一系列可观察序列，然后组合和订阅这些序列。”</p></details><h3 id="sdwebimage" tabindex="-1"><a class="header-anchor" href="#sdwebimage" aria-hidden="true">#</a> SDWebImage</h3><h4 id="❓sdwebimage-的缓存机制" tabindex="-1"><a class="header-anchor" href="#❓sdwebimage-的缓存机制" aria-hidden="true">#</a> ❓<code>SDWebImage</code> 的缓存机制</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>内存缓存</strong>：当一个图片数据被加载后，为了提高下次访问图片的效率，SDWebImage 会将图像数据缓存在内存中。如果你尝试加载已经在内存中的图像数据，会发现它加载的非常快，因为不需要再去磁盘或者网络下载。但是，由于应用程序对内存的使用有严格的限制，当内存达到一定的阈值或者收到内存警告时，SDWebImage 会自动清理内存中的缓存。</p></li><li><p><strong>磁盘缓存</strong>：对于内存中无法缓存的图像，或者应用在后台运行时，SDWebImage 会默认将图像数据缓存在应用的&quot;Library/Caches&quot;目录下。这样在应用重新启动后，不需要重新下载图像可以直接从磁盘读取以快速加载，这既减少了网络的使用也提高了用户体验。同时，磁盘缓存也可以设置最大缓存时间和最大缓存空间限制，超过限制后将自动清理。</p></li><li><p><strong>自动管理缓存</strong>：SDWebImage 提供了自动清理过期缓存的功能，并在 App 进入后台或者收到内存警告时，自动清理不需要的缓存，以确保不会影响设备的性能。</p></li></ul></details><h4 id="❓sdwebimage-的清除缓存策略" tabindex="-1"><a class="header-anchor" href="#❓sdwebimage-的清除缓存策略" aria-hidden="true">#</a> ❓<code>SDWebImage</code> 的清除缓存策略</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>手动清除缓存</strong>：可以针对特定的 <code>URL</code> 或全部缓存进行清除。</p><ul><li><code>removeImageForKey:</code>：清除指定键（通常是图片的 <code>URL</code>）的缓存。</li><li><code>clearMemory</code>：清除所有内存中的缓存。</li><li><code>clearDiskOnCompletion:</code>：清除所有硬盘中的缓存。这是异步操作，可以在清除完成后执行一段代码块。</li></ul></li><li><p><strong>自动清除缓存</strong>：<code>SDWebImage</code> 缓存类 <code>SDImageCache</code> 有个属性 <code>config</code> ，其 <code>maxCacheAge</code> 和 <code>maxCacheSize</code> 分别代表缓存的最大时间和最大尺寸。缓存的图片会根据设定的策略进行自动清除。</p><blockquote><p>当设备磁盘空间不足，或 <code>App</code> 进入后台，或内存警告时，<code>SDWebImage</code> 会自动清理过期和不需要的缓存。</p></blockquote></li><li><p><strong>后台清除缓存</strong>：当应用在后台运行时，<code>SDWebImage</code> 会用到 <code>UIApplicationDidEnterBackgroundNotification</code> ，在收到 <code>App</code> 进入后台的通知后，开始后台清理过期的图片和检查缓存大小。</p></li></ul></details><h4 id="❓如何从磁盘快速显示图片-sdwebimage-做了什么" tabindex="-1"><a class="header-anchor" href="#❓如何从磁盘快速显示图片-sdwebimage-做了什么" aria-hidden="true">#</a> ❓如何从磁盘快速显示图片，<code>SDWebImage</code> 做了什么</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>缓存策略</strong>: 默认使用异步磁盘缓存，意味着图片在后台线程进行解码，并缓存在内存中，然后在主线程显示。此外，磁盘中的图片缓存会有一个过期时间，过期的缓存图片会自动被清理，这样就不会占用太多用户的磁盘空间。</p></li><li><p><strong>图片解码优化</strong>：图片的解码通常是非常消耗 <code>CPU</code> 的，在加载大量图片时可能导致界面卡顿。在后台线程进行图片解码，减少了在主线程进行解码的操作，这就大大提高了主线程的性能，使得图片展示更为流畅。</p></li><li><p><strong>图片解压缩</strong>: 在图片从磁盘缓存加载到内存时，提供了预解压缩功能，因此在主线程使用这些图片时能够更为迅速。</p></li><li><p><strong>内存缓存</strong>：一旦从磁盘缓存加载的图片被解码，会把这个图片对象缓存到内存中，当下次需要使用这个图片时，直接返回这个内存中已缓存的图片，这大大缩短了图片加载的时间。</p></li></ul></details><h4 id="❓sdwebimage-是如何解决-uitableviewcell-复用时出现图片错乱问题" tabindex="-1"><a class="header-anchor" href="#❓sdwebimage-是如何解决-uitableviewcell-复用时出现图片错乱问题" aria-hidden="true">#</a> ❓<code>SDWebImage</code> 是如何解决 <code>UITableViewCell</code> 复用时出现图片错乱问题</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>取消之前的下载操作</strong>: 当 <code>UITableViewCell</code> 被复用时，<code>SDWebImage</code> 会取消原来 <code>TCell</code> 上的图片下载操作。这是通过 <code>sd_cancelImageLoadOperationWithKey:</code> 方法实现的。这样做可以保证一旦 <code>Cell</code> 被分配给新的数据源，它不会显示旧的、尚未完成下载的图片。</p></li><li><p><strong>对比URL判断配对</strong>: <code>SDWebImage</code> 在设置 <code>UIImage</code> 的图片数据时，会检查当前的 <code>URL</code> 是否与开始下载图片时的 <code>URL</code> 是一样的。如果 <code>URL</code> 发生了改变（这可能在由于单元格复用而发生），那么图片则不会设置到 <code>UIImageView</code> 上。以此来确保单元格显示的总是与其数据源匹配的图片。</p></li></ul></details><h4 id="❓sdwebimage-使用过吗-解码过程中是怎么样的" tabindex="-1"><a class="header-anchor" href="#❓sdwebimage-使用过吗-解码过程中是怎么样的" aria-hidden="true">#</a> ❓<code>SDWebimage</code> 使用过吗，解码过程中是怎么样的</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>获取图片数据</strong>：根据图片的 <code>URL</code> 从网络，内存或者硬盘中获取图片的二进制数据。这个过程是异步进行的，所以不会阻塞主线程。</p></li><li><p><strong>图片解码</strong>：获取到二进制的图片数据之后，会在后台线程进行图片解码。图片解码是一个把图片的二进制数据转换为可以在屏幕上显示的位图数据的过程。这个过程相对较慢，需要消耗 <code>CPU</code> 资源。但由于 在后台线程进行解码，所以不会阻塞主线程，不会影响 <code>UI</code> 的响应。</p></li><li><p><strong>图片解压缩</strong>：解码之后，图片通常还会进一步进行解压缩，为了避免在主线程渲染时进行解压缩操作。提供了图片预解压缩的功能，避免了在主线程中进行解压缩的操作，使得在主线程中的图片渲染更加迅速。这个过程也是在后台线程进行的。</p></li><li><p><strong>显示图片</strong>：最后会在主线程将解码、解压缩后的图片设置到 <code>UIImageView</code> 上进行显示。这个过程是在主线程进行的，因为所有的 <code>UI</code> 操作都必须在主线程进行。</p></li></ul></details><h3 id="yykit" tabindex="-1"><a class="header-anchor" href="#yykit" aria-hidden="true">#</a> YYKit</h3><h4 id="❓yykit-使用过吗-你觉得有哪些值得你学习的地方" tabindex="-1"><a class="header-anchor" href="#❓yykit-使用过吗-你觉得有哪些值得你学习的地方" aria-hidden="true">#</a> ❓<code>YYKit</code> 使用过吗，你觉得有哪些值得你学习的地方</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>YYKit</code> 是一款非常强大的 iOS 开发工具库，它提供了许多处理字符串、数组、字典、日期、网络请求、图片加载、缓存处理等常见功能的封装。</p></blockquote><ul><li><p><strong>代码的组织结构</strong>：<code>YYKit</code> 将各个不同功能模块进行了封装，并按功能模块进行分类。这样的组织结构有利于模块化开发和代码复用，提高了代码的可读性和可维护性。</p></li><li><p><strong>照顾到每个细节</strong>：<code>YYKit</code> 在实现各个功能模块时考虑到了非常多的细节，包括各种可能的异常处理和性能优化，这对于我们在写代码时如何处理好每个细节、如何提高代码的健壮性和性能非常有参考价值。</p></li><li><p><strong>简洁高效的方法命名</strong>：<code>YYKit</code> 的方法命名简洁明了，通过名称就能直观理解出方法的作用，非常符合“代码是给人看的”这一理念。</p></li><li><p><strong>优秀的性能优化</strong>：<code>YYKit</code> 在处理字符串、图片加载、缓存处理等操作时都进行了许多性能优化，如在后台线程进行图片解码和缓存操作，减少了对主线程的影响，提高了 <code>App</code> 的性能。如何做好性能优化也是值得我们学习和借鉴的地方。</p></li><li><p><strong>丰富的注释</strong>：在 <code>YYKit</code> 的源码中，很多代码都配备了详细的注释，这使得阅读和理解源码变得更加容易。这也是我们在写代码时应该养成的好习惯。</p></li></ul></details><h4 id="❓yymodel-的实现原理" tabindex="-1"><a class="header-anchor" href="#❓yymodel-的实现原理" aria-hidden="true">#</a> ❓<code>YYModel</code> 的实现原理</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>YYModel</code> 是 <code>YYKit</code> 中的一部分，它是一个高性能的模型框架，可以将 <code>JSON</code> 数据转换为 <code>Objective-C</code> 的对象，也可以将 <code>Objective-C</code> 的对象转换为 <code>JSON</code> 数据。</p></blockquote><ul><li><p><strong>Runtime</strong>：<code>YYModel</code> 使用 <code>Objective-C</code> 的 <code>Runtime</code> 系统来获取对象的属性信息，并基于这些信息进行 <code>JSON</code> 到模型对象或模型对象到 <code>JSON</code> 的转换。</p></li><li><p><strong>Caching</strong>：<code>YYModel</code> 为每个模型类创建了一个元数据 (<code>MetaData</code>) 对象，这个对象包含了模型类的所有必要信息 (<code>property</code>, <code>encoding type</code>, <code>JSON key-mapping</code>)。在第一次使用模型类时，<code>YYModel</code> 会把这个元数据进行缓存，后续转换时直接使用缓存的数据，这样可以极大提高转换的性能。</p></li><li><p><strong>抽象和封装</strong>：<code>YYModel</code> 抽象出一些通用的方法和逻辑，利用 <code>Objective-C </code>的面向对象设计，进行合理的封装，使得 <code>YYModel</code> 的源代码逻辑清晰，易于阅读和维护。</p></li><li><p><strong>处理 JSON 特性</strong>：<code>YYModel</code> 能够有效地处理一些特殊 <code>JSON</code> 数据格式，如：数据可能是 <code>NSNull</code>，日期字符串的解析，容器类属性(如数组，字典)中的元素如何转换等。</p></li></ul><p>总结：<code>YYModel</code> 使用了 <code>Runtime</code>、元数据缓存等技术，实现了 <code>JSON</code> 和模型对象之间高效的双向转换，并且提供了处理一些特殊 <code>JSON</code> 数据的能力。</p></details><h4 id="❓yyasynclayer-如何异步绘制" tabindex="-1"><a class="header-anchor" href="#❓yyasynclayer-如何异步绘制" aria-hidden="true">#</a> ❓<code>YYAsyncLayer</code> 如何异步绘制</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>YYAsyncLayer</code> 是 <code>YYKit</code> 中的一个工具组件，它是一个解决 <code>iOS</code> 卡顿问题的底层技术，使用了异步绘制的方法来提高 <code>APP</code> 的显示性能。</p></blockquote><p>主要原理：</p><ul><li><p><strong>子线程绘制</strong>：在子线程中执行绘制的任务，包括创建绘图上下文、进行绘图等操作。这样可以避免直接在主线程上执行绘制操作导致的 <code>UI</code> 卡顿。</p></li><li><p><strong>取消绘制策略</strong>：在进行新的绘制任务时，会取消之前未完成的绘制任务。这样做的目的是避免因为滚动速度较快或者视图快速重绘导致大量的绘制任务堆积在子线程中，从而引发性能问题。</p></li><li><p><strong>将绘制结果返回给主线程</strong>：子线程绘制完毕后，会将绘制的结果传递到主线程进行展示。这个过程需要保证线程安全性，避免因为线程同步问题造成的 <code>UI</code> 问题。</p></li><li><p><strong>释放绘制上下文</strong>：在不需要进行绘制或者视图将要被销毁的时候，异步释放相关的上下文，释放内存。</p></li></ul><p>通过这种方式，<code>YYAsyncLayer</code> 实现了将绘制任务放到子线程上执行，从而提高了应用的性能表现，避免了由于绘制操作导致的主线程阻塞。</p></details><h4 id="❓yykit-加载图片和-sdwebimage-加载图片有什么区别吗" tabindex="-1"><a class="header-anchor" href="#❓yykit-加载图片和-sdwebimage-加载图片有什么区别吗" aria-hidden="true">#</a> ❓<code>YYKit</code> 加载图片和 <code>SDWebImage</code> 加载图片有什么区别吗</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>算法实现</strong>：</p><ul><li><code>SDWebImage</code> 在处理图片方面，采用了 LRU（Least Recently Used，最近最少使用）算法，既有磁盘缓存又有内存缓存。</li><li><code>YYWebImage</code> 采取的则是 LRU + FIFO (First In First Out，先进先出)的混合算法，并且 <code>YYWebImage</code> 的磁盘缓存是可控的，可以按文件数量，按文件总尺寸，按文件的最长存活时间来进行调整。</li></ul></li><li><p><strong>异步解码和缓存</strong>：</p><ul><li><code>SDWebImage</code> 的图片解码也是同步进行的，图片会在需要显示出来的时候进行解码。</li><li><code>YYWebImage</code> 则是在下载完图片后，就开启一个异步线程来进行解码，并且会缓存解码后的图片。往后如果再有相同的 URL 需要加载，就会直接显示这个已经解码的图片，这样可以尽可能地减少内存的使用。</li></ul></li><li><p><strong>清理缓存机制</strong>：</p><ul><li><code>SDWebImage</code>只提供了一个手动清理缓存的 API ，有些时候可能会导致应用占用的磁盘空间过大。</li><li><code>YYWebImage</code> 则提供了一个自动清理缓存的机制。当磁盘剩余空间小于某个阈值时，缓存中的文件会被清空。这样就避免了应用占用了过多的磁盘空间。</li></ul></li></ul><p>总结：虽然两者都是处理网络图片的库，但是 <code>YYWebImage</code> 在很多细节上做了优化，给用户提供了多种选择，并且相比 <code>SDWebImage</code>， <code>YYWebImage</code> 相对要更精细一些。</p></details><h3 id="jspatch" tabindex="-1"><a class="header-anchor" href="#jspatch" aria-hidden="true">#</a> JSPatch</h3><h4 id="❓jspatch、aspects" tabindex="-1"><a class="header-anchor" href="#❓jspatch、aspects" aria-hidden="true">#</a> ❓<code>JSPatch</code>、<code>Aspects</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>JSPatch</code> 和 <code>Aspects</code> 都是 <code>Objective-C</code> 的热修复框架，都可以动态改变程序的行为。</p></blockquote><ul><li><p><strong>JSPatch</strong>: 可以使用 <code>JavaScript</code> 来修改 <code>Objective-C</code> 代码，修复线上 <code>bug</code> 或增加一些功能，无需 <code>App Store</code> 审核。</p><blockquote><p><code>JSPatch</code> 的主要原理是基于 <code>Objective-C</code> 的运行时(<code>Runtime</code>)，利用 <code>JavaScriptCore</code> 提供的 <code>JavaScript</code> 引擎来运行和解析 <code>JavaScript</code>，然后调用 <code>Objective-C</code> 的方法完成代码的修复和更新。</p></blockquote></li><li><p><strong>Aspects</strong>: 一个 <code>AOP</code>（面向切面编程）框架。</p><blockquote><p>它是基于 <code>Objective-C</code> 的消息转发机制实现的。<code>Aspects</code> 可以在运行时为类或对象添加一些代码，这些代码可以在方法调用前、方法调用后或方法替换时执行。<code>Aspects</code> 的特点是使用简单，但由于基于消息转发机制，对性能有一定影响。</p></blockquote></li></ul><p>总结：两者都是依赖于 <code>OC</code> 的动态性，<code>JSPatch</code> 相当于通过 <code>JS</code> 来写 <code>OC</code> 代码，可以直接修改 <code>OC</code> 的类和方法；而 <code>Aspects</code> 是做拦截，在不改变原有代码的情况下，实现一些额外的操作。<code>JSPatch</code> 更新代码更为灵活，可以直接修复线上问题，而 <code>Aspects</code> 更多用于日志打印、用户行为统计、事务处理等方面。</p><p>注意：由于 <code>Apple</code> 在审核政策上对热修复框架有所限制，开发者要慎重选择使用。</p></details><h4 id="❓jspatch-是如何处理-block-的" tabindex="-1"><a class="header-anchor" href="#❓jspatch-是如何处理-block-的" aria-hidden="true">#</a> ❓<code>JSPatch</code> 是如何处理 <code>block</code> 的</h4><details class="hint-container details"><summary>💡</summary><p>在使用 <code>JSPatch</code> 进行 <code>iOS</code> 开发时，可能会遇到需要在 <code>JavaScript</code> 中使用 <code>Objective-C</code> 的 <code>Block</code> 代码的情况。<code>JSPatch</code> 引入了一种特殊的 <code>Block</code> 处理方式来解决该问题。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在普通的 JavaScript 函数中 JSPatch  使用 block 函数来定义一个 OC 中的 block 对象</span>
<span class="token comment">//      &quot;void, NSError *&quot; 是一个 Objective-C 的方法签名，</span>
<span class="token comment">//          它表示这个 Block 有一个NSError* 类型的参数并返回 void。</span>
<span class="token comment">//          这个签名对应 Objective-C 的 \`^(NSError *error){}\`。</span>
<span class="token keyword">var</span> block <span class="token operator">=</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token string">&quot;void, NSError *&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里的 Javascript 代码会在 Block 被调用时执行</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 __weak 或 __autoreleasing 来避免循环引用或提前释放的问题</span>
<span class="token keyword">var</span> weakSelf <span class="token operator">=</span> <span class="token function">__weak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
<span class="token comment">// or</span>
<span class="token keyword">var</span> weakSelf <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">__autoreleasing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="开放性问题" tabindex="-1"><a class="header-anchor" href="#开放性问题" aria-hidden="true">#</a> 开放性问题</h2><h3 id="❓平常有看过什么技术书籍吗" tabindex="-1"><a class="header-anchor" href="#❓平常有看过什么技术书籍吗" aria-hidden="true">#</a> ❓平常有看过什么技术书籍吗</h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓什么时候接触ios开发-学习路径" tabindex="-1"><a class="header-anchor" href="#❓什么时候接触ios开发-学习路径" aria-hidden="true">#</a> ❓什么时候接触<code>iOS</code>开发，学习路径</h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓你是如何学习提升-ios-相关知识技能" tabindex="-1"><a class="header-anchor" href="#❓你是如何学习提升-ios-相关知识技能" aria-hidden="true">#</a> ❓你是如何学习提升 <code>iOS</code> 相关知识技能</h3><details class="hint-container details"><summary>💡</summary></details>`,61);function t(r,n){return o(),c("div",null,[d(" more "),s])}const h=e(i,[["render",t],["__file","0x17.other.html.vue"]]);export{h as default};

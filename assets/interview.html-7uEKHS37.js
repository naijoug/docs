import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,a as d,f as t}from"./app-gIO09NSJ.js";const a={},l=t('<h2 id="dart" tabindex="-1"><a class="header-anchor" href="#dart" aria-hidden="true">#</a> <code>Dart</code></h2><blockquote><p><code>final</code> 与 <code>const</code> 区别？</p></blockquote><ul><li><code>const</code> : 是编译时常量，必须初始化。</li><li><code>final</code> : 运行时常量，支持惰性初始化，只能被赋值一次的变量。</li></ul><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">final</span> date <span class="token operator">=</span> <span class="token class-name">DateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅</span>\n<span class="token keyword">const</span> date <span class="token operator">=</span> <span class="token class-name">DateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ❌ 编译错误</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>mixin</code> <code>extends</code> <code>implement</code> 之间的关系</p></blockquote><blockquote><p><code>await for</code> 如何使用</p></blockquote><blockquote><p><code>isolate</code> <code>compute</code> 是如何运行的？</p></blockquote><blockquote><p>如何使用反射?</p></blockquote><p>使用 <code>Mirror</code></p><ul><li><code>ClassMirror</code> : 类</li><li><code>InstanceMirror</code> : 实例</li><li><code>ClosureMirror</code> : 闭包</li><li><code>DeclarationMirror</code> : 类属性</li><li><code>IsolateMirror</code> : Isolate</li><li><code>MethodMirror</code> : 方法</li></ul><blockquote><p><code>Dart</code> 为啥没有反射？</p></blockquote><p>因为发射会影响 <code>Dart</code> 的 <code>tree shaking</code>(摇树优化)。这是一种无用代码裁剪技术，有利于优化发布版本的 <code>App</code> 体积。如果反射机制存在，会存在隐式代码，<code>tree shaking</code> 时无法准确定位运行时哪些代码不会被调用，冗余代码就没法被裁剪。</p><h2 id="flutter" tabindex="-1"><a class="header-anchor" href="#flutter" aria-hidden="true">#</a> <code>Flutter</code></h2><blockquote><p>命令式 <code>UI</code> vs 声明式 <code>UI</code></p></blockquote><ul><li>命令式 : 告诉程序一步一步如何搭建我所需要的界面，类似做菜的教程</li><li>声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单</li></ul><blockquote><p><code>Widget</code> <code>Element</code> <code>RenderObject</code> 之间的关系？</p></blockquote><p><code>Flutter</code> 的三棵树，代表了使用树的数据结构构成的三种元素。</p><ul><li><code>Widget</code> 树，可以理解为对 <code>UI</code> 的一些配置。</li><li><code>Element</code> 树，这个是真正进行 <code>UI</code> 元素。</li><li><code>RenderObject</code> 树，代表渲染树</li></ul><blockquote><p><code>Flutter</code> 跨平台是如何实现的？</p></blockquote><p><code>Flutter</code> 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。</p><ul><li>界面渲染 : <code>Skia</code> 绘制引擎进行视图的统一渲染</li><li>原生通信 : 通过 <code>Channel</code> 机制进行与原生进行交互 <ul><li><code>BasicMessageChannel</code> : 用于基本的字符串信息通信</li><li><code>MethodChannel</code> : 方法调用通信</li><li><code>EventChannel</code> : 数据流通信</li></ul></li></ul><blockquote><p><code>Flutter</code> 与 <code>RN</code> (<code>React Native</code>) 不同之处？</p></blockquote><blockquote><p>为什么说 <code>Flutter</code> 是原生的？</p></blockquote><blockquote><p><code>Flutter</code> 的优缺点?</p></blockquote><blockquote><p><code>Flutter</code> 的渲染原理？</p></blockquote><h2 id="widget" tabindex="-1"><a class="header-anchor" href="#widget" aria-hidden="true">#</a> <code>Widget</code></h2><blockquote><p><code>ListView</code> 与 <code>Sliver</code> 区别</p></blockquote><blockquote><p><code>InheritedWidget</code> 作用</p></blockquote><h2 id="lifecycle-生命周期" tabindex="-1"><a class="header-anchor" href="#lifecycle-生命周期" aria-hidden="true">#</a> <code>lifecycle</code> - “生命周期”</h2><blockquote><p><code>Flutter</code> 的生命周期？</p></blockquote><ul><li><code>StatelessWidget</code> : <code>build</code></li><li><code>StatefulWidget</code> : <code>initState</code> -&gt; ``</li></ul><h2 id="state-状态管理" tabindex="-1"><a class="header-anchor" href="#state-状态管理" aria-hidden="true">#</a> <code>state</code> - “状态管理”</h2><blockquote><p><code>Provider</code> <code>BLoc</code> <code>GetX</code> 区别</p></blockquote><h2 id="hot-reload-热重载" tabindex="-1"><a class="header-anchor" href="#hot-reload-热重载" aria-hidden="true">#</a> <code>hot reload</code> - “热重载”</h2><blockquote><p><code>hot reload</code>(热重载)、<code>hot restart</code>(热重启)、<code>hot update</code>(热更新)？</p></blockquote><blockquote><p><code>Flutter</code> 是如何实现热重载的？</p></blockquote><h2 id="thread-线程模型" tabindex="-1"><a class="header-anchor" href="#thread-线程模型" aria-hidden="true">#</a> <code>thread</code> - “线程模型”</h2><blockquote><p><code>Future</code> 与 <code>microtask</code> 两者的执行顺序</p></blockquote><h2 id="memory-内存管理" tabindex="-1"><a class="header-anchor" href="#memory-内存管理" aria-hidden="true">#</a> <code>memory</code> - “内存管理”</h2><blockquote><p><code>Flutter</code> 的内存管理</p></blockquote><h2 id="optimization-优化" tabindex="-1"><a class="header-anchor" href="#optimization-优化" aria-hidden="true">#</a> <code>optimization</code> - “优化”</h2><blockquote><p><code>Flutter</code> 列表优化方案？</p></blockquote><blockquote><p><code>Flutter</code> 包体积如何优化？</p></blockquote><p>包体积的优化说到底就是包里面所含有资源的优化，主要包含两类文件一类是资源文件，另一个类是二进制文件。</p><ul><li>资源文件的优化: 图片的压缩，bundle 优化，无用资源的移除，资源的动态下发</li><li>二进制文件优化: 无用代码的移除；减少第三方的依赖；编译优化，主要有编译参数相关，以及底层编译生成产物优化，需要去进行底层研究对一些无用功能的裁剪。</li></ul><blockquote><p><code>Flutter</code> 渲染优化方案？</p></blockquote><p>渲染优化来说主要涉及两个方面，其一是首次加载的渲染，其二是 <code>StatefulWidget</code> 状态改变时页面的重建渲染。</p><ul><li>首次渲染方面: 构建 <code>Widget</code> 时应该合理搭建，减少复杂度；能使用 <code>const</code> 的地方尽量使用</li><li>重建渲染方面: 尽量减少状态改变引起重建区域；减少 <code>saveLayer()</code>的触发</li></ul><p>触发 <code>saveLayer()</code> * ShaderMask * ColorFilter * Chip &amp; <code>disabledColorAlpha != 0xff</code> * Text &amp; <code>overflowShader</code></p>',49);function n(i,s){return o(),c("div",null,[d(" more "),l])}const u=e(a,[["render",n],["__file","interview.html.vue"]]);export{u as default};

import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as h,c as e,f as l}from"./app-b_rSVNxV.js";const a={},o=l('<h2 id="_4-树与图-9" tabindex="-1"><a class="header-anchor" href="#_4-树与图-9" aria-hidden="true">#</a> 4 树与图 (9)</h2><ul><li><p>4.1 二叉树平衡检查</p><blockquote><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.2 有向路径检查</p><blockquote><p>给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.3 高度最小的 BST</p><blockquote><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.4 输出单层结点</p><blockquote><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.5 检查是否为 BST</p><blockquote><p>实现一个函数，检查一棵二叉树是否为二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.6 寻找下一个结点</p><blockquote><p>设计一个算法，找出二叉查找树中指定结点的 &quot;下一个&quot; 结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.7 最近公共祖先</p><blockquote><p>设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.8 子树判断</p><blockquote><p>你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一个结点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树。也就是说，从结点 n 处把树砍断，得到的树与 T2 完全相同。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.9 二叉树中和为某一值的路径</p><blockquote><p>给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul>',2),p=[o];function r(b,c){return h(),e("div",null,p)}const u=t(a,[["render",r],["__file","0x04.tree-graph.html.vue"]]);export{u as default};

import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as a,o as i,c,a as r,b as e,e as l,d as n,f as s}from"./app-9H1pRb3K.js";const h={},d=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),l(" reference")],-1),u={href:"https://visualgo.net/zh/hashtable/print",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/apple/swift-corelibs-foundation/blob/main/CoreFoundation/Collections.subproj/CFDictionary.c",target:"_blank",rel:"noopener noreferrer"},p={href:"https://github.com/apple/swift/blob/main/stdlib/public/core/Dictionary.swift",target:"_blank",rel:"noopener noreferrer"},f=e("hr",null,null,-1),b={href:"https://github.com/apple/swift-collections/blob/main/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary.swift",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/LinkedHashMap.java",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/python/cpython/blob/main/Lib/collections/__init__.py#L83",target:"_blank",rel:"noopener noreferrer"},y=e("h2",{id:"lru-cache-最近最少使用缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#lru-cache-最近最少使用缓存","aria-hidden":"true"},"#"),l(),e("code",null,"LRU Cache"),l(" - “最近最少使用缓存”")],-1),g={href:"https://leetcode.cn/problems/lru-cache",target:"_blank",rel:"noopener noreferrer"},O=e("blockquote",null,[e("p",null,[e("code",null,"get"),l(),e("code",null,"put"),l(" 操作需要 O(1) 的平均时间复杂度")])],-1),L=s('<details class="hint-container details"><summary>💡</summary><p>【思路】: 哈希表 + 双向链表</p><ul><li>首先解决数据的缓存问题。由于需要 O(1) 的时间复杂度，所以应该很自然的想到了使用哈希表来保存数据。这样保存和查询都可以做到 O(1) 的时间复杂度。</li><li>再来解决最近最少使用的问题。这需要使用双向链表的结构来保存数据，链表头部为最少使用的数据，链表尾部为最近使用的数据。 <ul><li>查询数据时，这个查询过的数据为最近使用，也就是需要移除就之前链表中的这个数据，将这个数据重新加入到链表尾部。</li><li>添加数据时，如果这个 key 已存在，则移除旧数据，将新数据加入链表尾部；如果 key 不存在，需要判断缓存是否已满，如果已满则移除链表头部最少使用数据，添加新数据到链表尾部，如果未满则直接添加新数据到链表尾部。</li></ul></li></ul></details><h2 id="lfu-cache-最不经常使用缓存" tabindex="-1"><a class="header-anchor" href="#lfu-cache-最不经常使用缓存" aria-hidden="true">#</a> <code>LFU Cache</code> - “最不经常使用缓存”</h2>',2),x={href:"https://leetcode.cn/problems/lfu-cache",target:"_blank",rel:"noopener noreferrer"},v=e("blockquote",null,[e("p",null,[e("code",null,"get"),l(),e("code",null,"put"),l(" 操作需要 O(1) 的时间复杂度")])],-1),C=e("details",{class:"hint-container details"},[e("summary",null,"💡"),e("p",null,"【思路】: 双哈希表"),e("ul",null,[e("li",null,[l("数据缓存的问题。同 "),e("code",null,"LRU"),l(" 一样需要哈希表来保证数据存取的 O(1) 的时间复杂度。")]),e("li",null,"最不经常时间的问题。这个需要为没有数据加上一个 frequency 使用频率计数值来进行标记。关键点在于需要 O(1) 时间复杂度，那么使用")])],-1);function D(w,j){const t=a("ExternalLinkIcon");return i(),c("div",null,[r(" more "),d,e("ul",null,[e("li",null,[e("a",u,[l("哈希表"),n(t)])]),e("li",null,[e("a",_,[l("NSDictionary"),n(t)])]),e("li",null,[e("a",p,[l("Swift- Dictionary"),n(t)])])]),f,r(" `Ordered Hash Table` - “有序哈希表” "),e("ul",null,[e("li",null,[e("a",b,[l("Swift - OrderedDictionary"),n(t)])]),e("li",null,[e("a",m,[l("Java - LinkedHashMap"),n(t)])]),e("li",null,[e("a",k,[l("Python - OrderedDict"),n(t)])])]),y,e("ul",null,[e("li",null,[e("a",g,[l("🟠 146 - LRU 缓存"),n(t)]),O])]),L,e("ul",null,[e("li",null,[e("a",x,[l("🔴 460 - LFU 缓存"),n(t)]),v])]),C])}const U=o(h,[["render",D],["__file","hash-table.html.vue"]]);export{U as default};

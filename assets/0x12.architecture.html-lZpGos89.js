import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as s,o as c,c as d,a as n,b as e,e as l,d as a,f as p}from"./app-tIn8wIjG.js";const t={},r=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),l(" reference")],-1),u=e("a",{href:""},null,-1),h={href:"https://juejin.cn/post/7149569350012239909",target:"_blank",rel:"noopener noreferrer"},m=e("a",{href:""},null,-1),k={href:"https://juejin.cn/post/7153454532406542343",target:"_blank",rel:"noopener noreferrer"},b=p(`<hr><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h2><h3 id="❓设计模式的成员构成和工作机制是什么" tabindex="-1"><a class="header-anchor" href="#❓设计模式的成员构成和工作机制是什么" aria-hidden="true">#</a> ❓设计模式的成员构成和工作机制是什么</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>创建部分（<code>Creational</code>）：它涉及到类的实例化。它提供了一种在不指定具体类的情况下创建对象的方式。</p><ul><li><p>工厂方法：工厂方法设计模式通过在工厂接口中添加一个返回新对象的方法来实现。</p><blockquote><p>客户端可以调用这个方法获得一个新的对象，而不需要关心这个对象如何被创建或初始化。这对于需要创建多种类型的对象的情况十分适用。</p></blockquote></li><li><p>抽象工厂：抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定这些对象具体的类。</p><blockquote><p>通常每个具体工厂负责创建一系列相互依赖的对象，这样消费者可以只使用一个工厂而不需要和具体的产品类交互。</p></blockquote></li><li><p>建造者：建造者模式将一个复杂对象的构造过程与其表现方式（它的部件如何组合在一起）分离开来，使得同样的构造过程可以创建不同的表现形式。</p><blockquote><p>适用于创建复杂对象的场景，尤其是当对象的构造过程（初始化参数）比较复杂时。</p></blockquote></li><li><p>原型：原型模式用于创建复杂的或者构造成本大的实例。</p><blockquote><p>它通过复制一个已经存在的实例（原型）来返回新的实例，以此来减低创建新实例的系统开销。</p></blockquote></li><li><p>单例：单例模式保证了一个类只有一个实例，并且该实例容易被外界访问，以此来对整个系统提供一个全局访问点。</p><blockquote><p>适用于那些只需要一个实例就能完成其功能，而且该实例又需要被频繁访问的情况。</p></blockquote></li></ul></li><li><p>结构部分（<code>Structural</code>）：它定义了各个类和对象（也称为角色）之间的组成和相互作用的方式。</p><ul><li><p>适配器：适配器模式将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容不能在一起工作的那些类可以在一起工作。</p><blockquote><p>适用于系统需要使用现有的类，而这些类的接口又不符合系统的需要的情况。</p></blockquote></li><li><p>桥接：桥接模式主要是将抽象部分与它的实现部分分离，使它们可以独立变化。</p><blockquote><p>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少他们之间的耦合。</p></blockquote></li><li><p>组合：在组合模式中，有一个组合类，这个类可以包含其他的对象，这些对象可能是组合对象，也可能是个体对象。</p><blockquote><p>组合模式允许客户端以一致的方式处理个体对象以及组合对象。</p></blockquote></li><li><p>装饰：装饰模式能够提供比继承更灵活的扩展对象功能的方式，通过将对象嵌入到特殊的装饰器对象中来增强其功能，而装饰器对象则属于同一的接口。</p></li><li><p>外观：外观模式就是拉出一个“代理”“中介”来隔离复杂的操作。</p><blockquote><p>适用于需要对一系列复杂的子系统进行访问的场景。</p></blockquote></li><li><p>享元：享元模式就是运用共享技术来有效支持大量细粒度的对象。</p><blockquote><p>适用于大量对象造成内存开销比较大的情况。</p></blockquote></li><li><p>代理：代理模式就是为其他对象提供一种代理以控制对这个对象的访问。</p><blockquote><p>和外观模式类似，只是侧重点不同，代理模式侧重于网络和性能优化，以及对访问的权限控制。例如，远程代理、虚拟代理、保护代理等等。</p></blockquote></li></ul></li><li><p>行为部分（<code>Behavioral</code>）：它定义了类和对象如何交互，以及各自的责任。</p><ul><li><p>观察者：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></li><li><p>中介者：中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></li><li><p>解释器：解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该表示来解释语言中的句子。</p></li><li><p>迭代器：迭代器模式提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p></li><li><p>命令：命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。</p></li><li><p>责任链：责任链模式通过建立一条链，将请求的发送者和接收者解耦，使多个对象都有机会处理这个请求。</p></li><li><p>策略：策略模式定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换，让算法独立于使用它的客户。</p></li><li><p>模板方法：模板方法模式定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></li><li><p>访问者：访问者模式提供了一种将算法和对象结构分离的方法，这意味着可以添加新的操作而无需修改对象的结构。</p></li><li><p>备忘录：备忘录模式在不破坏封装的前提下，获取对象的内部状态，以便于在以后需要时，可以将该对象恢复到原来的状态。</p></li><li><p>状态：在状态模式中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为模式。</p></li></ul></li></ul></details><h3 id="❓你最喜欢的设计模式" tabindex="-1"><a class="header-anchor" href="#❓你最喜欢的设计模式" aria-hidden="true">#</a> ❓你最喜欢的设计模式</h3><details class="hint-container details"><summary>💡</summary><p>策略模式（<code>Strategy Pattern</code>）允许你根据运行时的决策来选择对象的行为。这种模式定义了一组算法并将每一个算法封装起来，使他们可以相互替换。该模式让算法的变化独立于使用算法的客户。</p><p>策略模式的主要优点：提供了一种管理复杂性的方法，并且它提供了一种可插拔的方式来改变行为，这将代码的耦合度降至最低。它支持开放/封闭原则，使得代码易于测试、理解和扩展。</p><p>🌰 假如正在开发一个电子商务系统，可能想要根据当前的需求或优惠来改变定价策略。使用策略模式，可以创建一个定价策略接口，然后为每种定价策略创建一个策略类。这样，可以在运行时选择或改变定价策略，而不需要修改任何使用定价策略的代码。</p></details><h3 id="❓设计模式的是为了解决什么问题" tabindex="-1"><a class="header-anchor" href="#❓设计模式的是为了解决什么问题" aria-hidden="true">#</a> ❓设计模式的是为了解决什么问题</h3><details class="hint-container details"><summary>💡</summary><p>设计模式是一种在特定环境中解决特定问题的优秀解决方案。它们概括并描述了面向对象设计中遇到的问题，并提供了解决这些问题的框架。</p><ul><li><p>代码重用性：设计模式提供了一种方式，可以使代码有更好的重用性。</p></li><li><p>易于维护：当面临代码更改时，设计模式可以让代码以一种更容易维护的方式来进行更改。</p></li><li><p>提高效率：设计模式提供了在特定环境中解决特定问题的模板，一旦理解了设计模式，就可以更快地解决新问题。</p></li><li><p>增强代码的可读性：因为设计模式是通用的解决方案，所以其他程序员通常也理解设计模式，这可以增强代码的可读性。</p></li><li><p>处理复杂性：设计模式通常抽象出问题和其解决方案的关键部分，可以更好地处理和管理代码的复杂性。</p></li></ul></details><h3 id="❓设计模式的优缺点" tabindex="-1"><a class="header-anchor" href="#❓设计模式的优缺点" aria-hidden="true">#</a> ❓设计模式的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>优点：</p><ul><li><p>代码可重用：设计模式提供了一种方式来重用最佳的设计和架构。</p></li><li><p>提高代码可读性：因为设计模式具有一致性，所以可以使代码更易于理解和调试。</p></li><li><p>提高软件质量：设计模式已经过时间的考验并被广泛接受，是实践中发现的行之有效的设计思想，使用它们可以提高软件的健壮性和效率。</p></li><li><p>促进沟通：设计模式提供了一种共享词汇和一种有效的沟通方式，开发人员可以使用这种词汇来交流设计思路。</p></li><li><p>提高效率：对于许多复杂设计问题，设计模式提供了已经准备好的通用解决方案，可以让开发人员更快地进行软件开发。</p></li></ul><p>缺点：</p><ul><li><p>需要认识到，设计模式并不适用于所有情况，每种模式都有其适用的环境。在不合适的地方应用设计模式会增加不必要的复杂性和代码难度。</p></li><li><p>设计模式需要正确且恰当的应用，如果错误地使用，可能会导致代码迷惑不解甚至错误，由此可能带来更多的问题而不是解决问题。</p></li><li><p>对于初级开发者来说，学习和理解设计模式有一定的学习曲线。</p></li><li><p>过度使用设计模式可能会导致代码变得过于复杂，并且可能会降低代码效率。即使设计模式可以提供很多好处，但也并不是越多越好，需要根据实际情况去权衡。</p></li></ul></details><h3 id="❓单例的弊端" tabindex="-1"><a class="header-anchor" href="#❓单例的弊端" aria-hidden="true">#</a> ❓单例的弊端</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>全局变量：单例模式实质上就是在创建一个全局变量。过度使用全局变量可能导致系统设计上的问题，如命名冲突，不易于管理和维护，增加了代码之间的耦合度。</p></li><li><p>对象生命周期：单例对象的生命周期是整个应用程序周期，这可能导致资源的浪费，特别是那种实例化和运行成本较高的对象。</p></li><li><p>多线程问题：在多线程环境下，如果没有适当的同步机制，可能会导致多次创建单例对象的情况，去掉这种情况则需采取额外的同步处理，增加了系统开销。</p></li><li><p>可测试性：由于单例模式需要保持全局状态，这可能使得单元测试成为困难，因为所有的测试用例公用一个实例，状态分离变得困难。同时，由于单例隐藏了它的依赖性，可能会导致代码隐藏潜在的错误和代码臭味。</p></li><li><p>扩展困难：由于单例模式的中心化管理，要扩展这个唯一的实例也变得困难。</p></li></ul></details><h3 id="❓如果存在单例滥用的情况-如何避免" tabindex="-1"><a class="header-anchor" href="#❓如果存在单例滥用的情况-如何避免" aria-hidden="true">#</a> ❓如果存在单例滥用的情况，如何避免</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>单例模式在某些情况下是非常有用的，它可以保证在应用程序的整个生命周期中，某个类仅有一个实例存在。然而，滥用单例模式可能带来麻烦，比如全局状态管理变得困难，单元测试变得更困难，甚至可能会产生内存泄露。</p></blockquote><p>避免方案：</p><ul><li><p>使用依赖注入：依赖注入是一种更好的管理对象和类之间依赖关系的方式，它可以让你更灵活地管理对象的生命周期，并有助于解耦和提高代码的可测试性。</p></li><li><p>清晰定义作用域：尽量避免把对象生命周期延伸到全局。定义清晰的对象作用域，理解对象在哪个环节创建，在哪个环节销毁。</p></li><li><p>避免用单例存储状态：对于需要存储状态的对象，应当更善用数据库或者其他持久化方案，而不是简单地使用单例保存。</p></li><li><p>更频繁地使用不可变对象：不可变对象是线程安全的，并且可以避免多个线程修改同一状态引发的问题。</p></li><li><p>使用其他设计模式：有些时候，我们可能可以使用其他设计模式替代单例，比如工厂模式，建造者模式，原型模式等。</p></li><li><p>在单元测试中，能够对单例类进行存根（stub）或模拟（mock），可以帮助解决由于单例而导致的测试困难。但是，过度依赖单例模式可能会使这种技术变得复杂和困难。</p></li></ul></details><hr><h2 id="功能设计" tabindex="-1"><a class="header-anchor" href="#功能设计" aria-hidden="true">#</a> 功能设计</h2><h3 id="❓一个操作如果耗时-5s-后返回-nil-否则返回一个字符串-你怎么设计" tabindex="-1"><a class="header-anchor" href="#❓一个操作如果耗时-5s-后返回-nil-否则返回一个字符串-你怎么设计" aria-hidden="true">#</a> ❓一个操作如果耗时 5s 后返回 <code>nil</code>，否则返回一个字符串，你怎么设计</h3><details class="hint-container details"><summary>💡</summary><p>这个需求可以通过异步编程和超时控制来实现。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 使用 Python 中的 concurrent.futures 库实现</span>
<span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span> TimeoutError

<span class="token keyword">def</span> <span class="token function">some_operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 这里是你的操作，可能会返回一个字符串，也可能会执行很长时间。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> result

<span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>
    future <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>some_operation<span class="token punctuation">)</span>  <span class="token comment"># 将操作放在一个单独的线程中执行</span>

    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果在规定的时间（5秒）内，还没有得到结果，就主动停止等待</span>
        result <span class="token operator">=</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 等待 5 秒，看是否能获取到结果</span>
    <span class="token keyword">except</span> TimeoutError<span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 如果 5 秒内还没有结果，就返回 nil</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓如何设计一个高效、线程安全的缓存" tabindex="-1"><a class="header-anchor" href="#❓如何设计一个高效、线程安全的缓存" aria-hidden="true">#</a> ❓如何设计一个高效、线程安全的缓存</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>使用合适的数据结构：哈希表是构建缓存的基础。可以在 <code>O(1)</code> 的时间复杂度内实现数据的读取，如果哈希函数设计得足够好，冲突的情况会相对较少。</p></li><li><p>缓存淘汰策略（<code>LRU</code>，<code>LFU</code>等）：当缓存满时，需要选择合适的策略来淘汰一些缓存项。</p></li><li><p>线程安全：如果缓存系统被多线程访问，就必须保证线程安全。可以使用锁（包括读锁和写锁）、原子操作等方式来保证线程安全。</p><blockquote><p>如果使用<code>Java</code>，可以使用 <code>ConcurrentHashMap</code>，它在保证线程安全的同时提供了很高的并发性能。</p></blockquote></li><li><p>高效的并发控制：在高并发环境下，应尽量减少锁的使用，尽可能地使多的线程可以同时访问缓存。</p><blockquote><p>例如使用读写锁代替互斥锁，读写锁允许多个读操作并发执行，而写操作会阻塞读写所有操作。</p></blockquote></li><li><p>缓存的有效期：有些情况下，可能希望缓存的数据能够在一段时间后自动失效。</p></li><li><p>选择合适的加载策略：如何获取缺失的缓存项也很重要，包括但不限于&quot;缓存击穿&quot;，&quot;缓存雪崩&quot;的问题，可以通过设置热点数据永不过期，对于可能的高并发查询，先做好预热等来防止。</p></li></ul></details><h3 id="❓如何设计一个网络库" tabindex="-1"><a class="header-anchor" href="#❓如何设计一个网络库" aria-hidden="true">#</a> ❓如何设计一个网络库</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>协议选择：确定网络库是基于 <code>TCP</code> 还是 <code>UDP</code>。</p><ul><li><code>TCP</code> 提供了可靠的连接，适合需要可靠传输的场景。</li><li><code>UDP</code> 则是无连接的，适合需要快速传输的场景，比如语音聊天、视频聊天等。</li></ul></li><li><p>网络模型：选择同步还是异步模型。</p><ul><li>同步模型，输入/输出操作是阻塞的，一旦开始就必须等待它完成以后才能进行其他操作。</li><li>异步模型，输入/输出操作是非阻塞的，可以在等待数据到来或发送完成的同时进行其他操作。</li></ul></li><li><p>线程模型：确定是使用多线程还是事件驱动模型。</p><ul><li>多线程，每个请求或者连接有一个独立的线程处理，适合 <code>CPU</code> 密集型任务。</li><li>事件驱动，则是在一个线程中处理多个请求或连接，适合 <code>I/O</code> 密集型任务。</li></ul></li><li><p>接口设计：应提供简单易用的 <code>API</code>，尽可能让用户不需要关注底层细节。接口设计应符合 “高内聚，低耦合” 的原则，模块之间应独立，易于扩展和修改。</p></li><li><p>异常处理：网络编程中，难免会遇到各种问题，比如连接失败、数据丢失等，需要预先考虑到这些情况，并且提供适当的异常处理机制。</p></li><li><p>性能管理：注意内存和连接的管理，避免内存泄漏和连接泄漏。同时，也要考虑并发性能，尽量提高网络库的吞吐量和并发处理能力。</p></li><li><p>扩展性：设计时考虑扩展性，使得新增功能或者处理更多种类的协议可以更加容易。</p></li><li><p>安全性：对于需要加密的场景，需要支持相关的加密协议，比如 <code>SSL/TLS</code>，防止数据被窃取或篡改。同时，也需要处理网络攻击，比如拒绝服务攻击(<code>DoS</code>)。</p></li></ul></details><h3 id="❓如何设计一个-git-diff" tabindex="-1"><a class="header-anchor" href="#❓如何设计一个-git-diff" aria-hidden="true">#</a> ❓如何设计一个 <code>git diff</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>git diff</code> 是一个用于比较 <code>Git</code> 仓库中文件差异的工具。它可以对比工作区、暂存区，甚至是不同提交之间的文件差异。</p></blockquote><p>设计一个 <code>git diff</code> 的核心是设计一个能够比较两个文件间差异的算法。最知名的算法是 <code>Myers</code> 算法，也是 <code>Git</code> 使用的算法。它是一种动态规划算法，寻找两个序列（文件）之间的最短编辑距离——可以通过最少的添加、删除操作将一个序列转为另一个序列。</p><p>具体设计步骤：</p><ul><li><p>文件比较算法：实现一个支持 <code>Myers</code> 算法的文件比较方法。首先把文件内容拆分为多个行，这样就把问题转化为两个字符串数组的比较问题。然后可以使用动态规划来进行这种比较。</p></li><li><p>工作区文件与暂存区文件比较：对于工作区文件与暂存区文件比较，直接拿它们的内容进行比较即可。</p></li><li><p>工作区、暂存区与提交对象比较：对于这种情况，需要借助 <code>Git</code> 的内部数据结构。需要读取 <code>Git</code> 仓库内部的 <code>blob</code> 对象，将对应的内容进行比较。</p></li><li><p>不同提交对象之间比较：如果要实现不同提交对象之间比较，那么还需要实现从一棵树的结构转换到另一棵树的所有文件的改动。这涉及到了 <code>Git</code> 的 <code>tree</code> 对象。</p></li><li><p>格式化打印：最后，需要对比较的结果进行合适的格式化打印，让用户容易阅读，并且能够容易跟踪改动。</p></li></ul></details><h3 id="❓存一个通讯录-包括增删改查-用什么数据结构" tabindex="-1"><a class="header-anchor" href="#❓存一个通讯录-包括增删改查-用什么数据结构" aria-hidden="true">#</a> ❓存一个通讯录，包括增删改查，用什么数据结构</h3><details class="hint-container details"><summary>💡</summary><p>最适合的数据结构是哈希表（<code>Hash Table</code>）。增删改查的时间复杂度都是 <code>O(1)</code></p><p>可以设计一个 <code>HashMap</code>，其中 <code>Key</code> 是联系人的名字，<code>Value</code> 是联系人的电话号码。这样，在通讯录中查找一个联系人时，就可以使用他的名字在 <code>HashMap</code> 中进行检索，而无需将通讯录所有内容遍历一遍。</p></details><h3 id="❓设计一个线程池-画出你的架构图" tabindex="-1"><a class="header-anchor" href="#❓设计一个线程池-画出你的架构图" aria-hidden="true">#</a> ❓设计一个线程池，画出你的架构图</h3><details class="hint-container details"><summary>💡</summary><p>简单的架构图：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>                                 --------------------
              ------------     --&gt;| Worker Thread    |
             | Add Task |------&gt; |                  |
              ------------     --&gt;|    ...           | 
                                  --------------------
              ------------       --------------------
             |  Scheduler  | --&gt;| Worker Thread    |
              ------------     |                  |
                              --&gt;|    ...           |
           --------------------  --------------------
          | ThreadPool Manager |
           --------------------
              ------------
             | Remove Task|
              ------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池的设计：</p><ul><li><p>线程池管理器（<code>ThreadPool Manager</code>）：用于创建、启动、暂停、停止和维护工作线程的数量。在添加任务时，会调度闲置的工作线程。</p></li><li><p>工作队列（<code>Work Queue</code>）：用于存储待执行的任务。线程池管理器会从工作队列中取出任务并分配给工作线程。</p></li><li><p>工作线程（<code>Worker Thread</code>）：线程池中的线程。这些线程会等待来自线程池管理器的任务，执行任务，然后等待下一个任务的分配。这是一个循环的过程。</p></li></ul><p>还需完善的功能：如更复杂的调度策略、工作线程的生命周期管理、错误处理机制、线程池状态的监视与调试等等。</p></details><hr><h2 id="接口设计" tabindex="-1"><a class="header-anchor" href="#接口设计" aria-hidden="true">#</a> 接口设计</h2><h3 id="❓restful-架构" tabindex="-1"><a class="header-anchor" href="#❓restful-架构" aria-hidden="true">#</a> ❓<code>RESTful</code> 架构</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>REST</code>（<code>Representational State Transfer</code>，表现层状态转换）是一种基于 <code>HTTP/HTTPS</code> 协议的软件架构风格，它提供了一种用于构建分布式系统的架构设计原则。使用 <code>REST</code> 架构设计的 <code>Web</code> 服务称为<code> RESTful API</code>。</p></blockquote><p><code>RESTful</code> 架构原则：</p><ul><li><p>资源导向：<code>REST</code> 架构将所有东西视为资源。每个资源都有其唯一的 <code>URI</code>（统一资源标识符），资源之间互相独立，可以通过 <code>HTTP</code> 方法进行 <code>CURD</code>（创建、更新、读取、删除）操作。</p></li><li><p>无状态：<code>RESTful</code> 架构是无状态的，这意味着每个请求都必须包含所有的信息，服务器不存储请求之间的任何相关信息，这有利于系统的可伸缩性。</p></li><li><p><code>Cacheable</code>：<code>RESTful</code> 架构的请求可以被缓存，通过在服务器响应请求时发送一些 <code>HTTP</code> 头部信息，可以告知客户端该响应是可以被缓存的。</p></li><li><p>统一接口：<code>RESTful</code> 架构应保持统一的接口，使得 <code>API</code> 更易于使用和管理。</p></li><li><p><code>Client-Server</code>：<code>RESTful</code> 架构是客户端-服务器架构，客户端负责用户界面和用户的交互，服务器负责处理业务逻辑和数据存储。</p></li><li><p><code>Layered System</code>：<code>RESTful</code> 系统通常是分层结构的，每一层负责特定的功能。客户端不需要知道服务器背后是否有其他的中间层。</p></li></ul><p>🌰 用户接口</p><ul><li><code>GET</code> <code>/users</code>：获取所有用户列表</li><li><code>POST</code> <code>/users</code>：创建一个新用户</li><li><code>GET</code> <code>/users/123</code>：获取 <code>ID</code> 为 123 的用户信息</li><li><code>PUT</code> <code>/users/123</code>：更新 <code>ID</code> 为 123 的用户信息</li><li><code>DELETE</code> <code>/users/123</code>：删除 <code>ID</code> 为 123 的用户。</li></ul></details><h3 id="❓接口幂等如何解决" tabindex="-1"><a class="header-anchor" href="#❓接口幂等如何解决" aria-hidden="true">#</a> ❓接口幂等如何解决</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>接口幂等性是指一次和多次请求某一个资源应该具有同样的副作用。无论进行多少次操作，结果都是相同的。</p></blockquote><p>常见方案：</p><ul><li><p>在服务器端使用&quot;唯一请求编号&quot;来防止重复处理。每次客户端请求时，附带一个唯一请求编号，服务器需要记录已经处理过的编号。当接收到重复的请求时，直接返回之前的结果，不进行处理。</p></li><li><p>使用数据库的原子操作，比如 <code>INCR</code>，<code>DECR</code> 来保证操作的原子性。</p></li><li><p><code>Token</code> 机制：在需要保证幂等性的操作前，先向服务端获取一个唯一的 <code>Token</code>，然后在执行操作时携带该 <code>Token</code>，服务端验证 <code>Token</code> 有效性并执行操作。每个 <code>Token</code> 只能使用一次。</p></li><li><p>乐观锁：在数据更新时，验证版本号，如果在此期间有其他请求修改过数据，则拒绝本次请求。</p></li><li><p>分布式锁：对需要保证幂等性的业务操作进行加锁处理，在分布式系统中，可以使用分布式锁。</p></li><li><p><code>MVCC</code>（多版本并发控制）：每个读操作会创建一个快照，写操作则创建一个新的版本。</p></li></ul></details><hr><h2 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计" aria-hidden="true">#</a> 系统设计</h2><h3 id="❓如何设计一个高可用的系统" tabindex="-1"><a class="header-anchor" href="#❓如何设计一个高可用的系统" aria-hidden="true">#</a> ❓如何设计一个高可用的系统，</h3><details class="hint-container details"><summary>💡</summary><p>高可用的系统设计：</p><ul><li><p>冗余：减少单一点故障，例如备份关键组件，将数据复制到多个地点，使用多个实例分布在不同的服务器、数据中心或地理位置。</p></li><li><p>负载均衡：将进来的流量均匀分散到多个服务实例或者服务器上，防止单一服务或服务器过载。</p></li><li><p>故障监控和恢复：实现自动故障检测和恢复，比如系统出现故障，可以自动启动备用系统或切换到故障恢复模式，减少系统停机时间。</p></li><li><p>垂直和水平扩展：垂直扩展指增加单一服务器的能力（如CPU、RAM），水平扩展指增加服务器数量。请根据具体应用和负载情况选择最适合的方法。</p></li><li><p>微服务架构：将应用程序分解为一组小型、独立的服务，这些服务可以独立进行扩展和部署。</p></li><li><p>分布式系统设计：使用分布式数据库系统，使用分布式缓存系统，使用分布式计算系统等。</p></li></ul></details><blockquote><p>❓流量快到阈值了怎么处理</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><p>提前预测和监控：监控系统的关键性能指标，如CPU使用率、内存使用率和网络流量等，当指标接近阈值时，发出预警。</p></li><li><p>自动扩展：云计算平台如AWS、阿里云都支持根据系统负载自动扩展系统资源，如自动增加服务器实例。</p></li><li><p>限流：当流量超过阈值时，可以开始拒绝部分请求，或者将超出的流量引导到备用系统。</p></li><li><p>优化系统：进行性能优化，如优化代码，减少不必要的数据库查询，添加缓存等以提高系统处理能力。</p></li><li><p>灰度发布：当发布新版本时，先只给部分用户使用，慢慢扩大范围，这样既可以测试新版本的性能，又不会对全部用户产生影响。</p></li></ul></details><h3 id="❓介绍一下限流算法" tabindex="-1"><a class="header-anchor" href="#❓介绍一下限流算法" aria-hidden="true">#</a> ❓介绍一下限流算法</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>限流是为了保护系统和服务，避免因为流量过大、并发过高而导致的系统崩溃。</p></blockquote><p>常见的限流算法：</p><ul><li><p>令牌桶（<code>Token Bucket</code>）：系统有一个固定大小的桶，系统会以恒定的速度往桶里填充令牌，处理请求时需要从桶内消耗令牌，如果桶中无令牌，则需要等待或者直接拒绝请求。</p><blockquote><p>这种方法使得在流量突增时，能够将多余的流量先&quot;存储&quot;起来，处理能力回升时再慢慢处理，从而能够应对短时间的流量突增。</p></blockquote></li><li><p>漏桶（<code>Leaky Bucket</code>）：系统有一个固定大小的桶，系统以恒定速度处理桶创的请求，多余的请求会直接被丢弃。</p><blockquote><p>这种方法保证了处理流程的稳定性，但是在流量突增时直接丢弃多余的请求，可能会导致突发的大量请求无法处理。</p></blockquote></li><li><p>计数器类型：统计在某个窗口时间内的请求量，如果超过则拒绝请求。</p><blockquote><p>这种方法对应用领域的要求最简单，但是在窗口切换时会出现“突刹”现象。</p></blockquote></li><li><p>滑动窗口：对计数器类型的改进版，将时间窗口分成多个格子，计算滑动窗口内的请求总数，超过阈值则拒绝处理。</p><blockquote><p>这种方法避免了“突刹”现象。</p></blockquote></li><li><p>分布式限流：用于对全局流量进行限制的一类方法，涉及到多个节点的协作和同步问题，可以利用 <code>redis</code> 等分布式工具。</p></li></ul></details><h3 id="❓密码哈希处理-如果暴力破解怎么办" tabindex="-1"><a class="header-anchor" href="#❓密码哈希处理-如果暴力破解怎么办" aria-hidden="true">#</a> ❓密码哈希处理，如果暴力破解怎么办</h3><details class="hint-container details"><summary>💡</summary><p>密码以哈希形式存储在数据库中，目的就是即使数据库被暴力破解，攻击者也只能获取到无法直接用来登录的哈希值。然而，如果哈希函数被选定，攻击者可以尝试用常见的密码生成哈希值，看是否与破解的哈希值相符，这种方法被称为<strong>暴力攻击</strong>或者<strong>穷举攻击</strong>。</p><p>防止暴力破解常见策略：</p><ul><li><p>密码复杂度规则：通过设置密码复杂度规则（必须包含大写、小写、数字、特殊字符等），以增加暴力破解的难度。</p></li><li><p>使用加盐哈希（<code>Salted Hash</code>）：在哈希密码前，先添加一段随机的字符串（盐）。即使两个用户使用同样的密码，由于“盐”是随机的，他们的哈希值也会是不同的。这大大增加了暴力破解的复杂度。</p></li><li><p>密码哈希函数的迭代次数：通过增加密码哈希函数的迭代次数，增加单次尝试的计算量，从而大大延长暴力破解所需的时间。</p></li><li><p>使用现代密码哈希函数，比如 <code>Argon2</code>, <code>bcrypt</code>, <code>scrypt</code> 或者 <code>PBKDF2</code>。这些函数设计了内置的盐并能调整散列所需的资源和时间，使得计算哈希变得更加昂贵，减慢攻击速度。</p></li><li><p>限制登录失败次数：通过限制用户在短时间内登录失败的次数来防止暴力破解。</p></li><li><p>二次验证：使用手机短信、邮件、第二密码等二次验证方式，增加破解的难度。</p></li></ul><p>策略的目的：都是增加暴力破解的难度，使得其所消耗的时间、资源和成本超过其所能获得的收益。</p></details><hr><h2 id="持续集成" tabindex="-1"><a class="header-anchor" href="#持续集成" aria-hidden="true">#</a> 持续集成</h2><h3 id="❓持续集成方案" tabindex="-1"><a class="header-anchor" href="#❓持续集成方案" aria-hidden="true">#</a> ❓持续集成方案</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>持续集成（<code>CI</code>，<code>Continuous Integration</code>）是一种编程实践，通过该实践，团队可以更频繁地将代码集成到主分支。每次集成都通过自动化的构建（包括编译、发布、自动化测试）来验证，以便尽早地发现集成错误。</p></blockquote><p>方案：</p><ul><li><p>版本控制系统：开发人员可以频繁的提交代码到版本控制系统中。</p><blockquote><p>例如：<code>Git</code></p></blockquote></li><li><p>持续集成服务器：当代码被推送到主分支，持续集成服务器会自动开始构建流程。</p><blockquote><p>例如：<code>Jenkins</code>，<code>Travis CI</code>，<code>CircleCI</code></p></blockquote></li><li><p>自动构建：持续集成服务器自动执行构建任务，包括代码拉取、编译、发布等流程。</p></li><li><p>自动化测试：在自动构建后，进行自动化测试，这包括单元测试、集成测试和功能测试。</p></li><li><p>构建结果反馈：如果构建或者测试失败，持续集成服务器会立即反馈给开发人员，及时修复问题。</p></li><li><p>自动部署：如果所有测试都通过了，那么新代码可以自动被部署到开发或者生产环境。</p></li></ul></details><h3 id="❓git-工作流" tabindex="-1"><a class="header-anchor" href="#❓git-工作流" aria-hidden="true">#</a> ❓<code>Git</code> 工作流</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Git</code>: 最流行的版本控制系统之一。</p></blockquote><ul><li><p>中央式工作流：这是最简单的工作流模型。中央式工作流使用一个中央仓库，所有开发者直接与中央仓库进行交互。所有的变更都直接提交到这个中央仓库的主分支上。</p></li><li><p>功能分支工作流：在这个模型中，每个新的功能都拥有自己的分支。这样可以将功能开发与主代码库隔离开，使得开发者可以在自己的功能分支上独立工作。</p></li><li><p><code>Gitflow</code> 工作流：一种复杂但结构化的工作流模型，定义了一个围绕项目发布的严格分支模型。除了需要维护 <code>feature</code>、<code>develop</code>、<code>master</code> 等不同的分支外，还需要有专门用于准备、维护、修复发布版本的 <code>release</code>、<code>hotfix</code> 等分支。</p></li><li><p><code>Forking</code> 工作流：开源项目中常见的工作流模型。每个开发者都会派生（<code>fork</code>）出自己的公开仓库，然后在这个派生仓库中工作，完成后发起拉取请求（<code>pull request</code>）合并回主仓库。</p></li><li><p><code>Pull Request</code> 工作流：类似 <code>Forking</code> 工作流，但是每个开发者直接在原始仓库创建新的分支进行开发，开发后发起 <code>Pull Request</code> 待其他开发者审核后，才能被合并到主分支。</p></li></ul></details>`,50);function v(f,q){const i=s("ExternalLinkIcon");return c(),d("div",null,[n(" more "),r,e("ul",null,[e("li",null,[u,e("a",h,[l("2022-10-01 《软件研发效能提升之美》书评"),a(i)])]),e("li",null,[m,e("a",k,[l("2022-10-12 《卓有成效的工程师》书评"),a(i)])])]),b])}const x=o(t,[["render",v],["__file","0x12.architecture.html.vue"]]);export{x as default};

import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e,f as o}from"./app-_jE41G-y.js";const c="/docs/assets/objc-class-diagram-0JRmvx1z.jpg",t={},i=o(`<h2 id="oc-设计理念" tabindex="-1"><a class="header-anchor" href="#oc-设计理念" aria-hidden="true">#</a> <code>OC</code> 设计理念</h2><p><code>OC</code> 底层是使用 <code>C/C++</code> 实现。定一个继承 <code>NSObject</code> 的类，这个类底层使用 <code>C</code> 语言中的 <code>struct</code> 结构体来实现的。</p><h3 id="❓oc-的动态性" tabindex="-1"><a class="header-anchor" href="#❓oc-的动态性" aria-hidden="true">#</a> ❓<code>OC</code> 的动态性</h3><details class="hint-container details"><summary>💡</summary><p>首先理解两个“动态语言与静态语言”</p><p><code>OC</code> 的 <code>runtime</code> 文档中介绍中就详细写明了，<code>runtime</code> 的设计是为了将 <code>OC</code> 中的更多的处理延迟到编译后。</p><ul><li>动态类型 (Dynamic typing) : 编译时并不确定对象类型，在运行时才判断对象的类型。<code>OC</code> 中一切对象都可以用 <code>id</code> 指针指向。</li><li>动态绑定 (Dynamic binding) : 方法的调用也是运行时才决定，而并非编译时。</li><li>动态加载 (Dynamic loading) : 运行时可以动态加载其它模块或框架</li></ul></details><h3 id="❓类结构体的组成-isa-指针指向了什么" tabindex="-1"><a class="header-anchor" href="#❓类结构体的组成-isa-指针指向了什么" aria-hidden="true">#</a> ❓类结构体的组成，<code>isa</code> 指针指向了什么？</h3><details class="hint-container details"><summary>💡</summary><p>先给出答案 <code>isa</code> 指针是指向类对象，每一个对象都包含 <code>isa</code> 指针，通过这个指针可以找到类对象。</p><p>当一个对象调用某个方法时(消息发送)，运行时先在当前方法列表中查找，如果不存在，通过 <code>isa</code> 指针查找类对象中是否存在方法，如果还不存在会通过父类指针进一步往上查找，最后还是找不到就会抛出未找到异常。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// id 就是 objc_object</span>
<span class="token keyword">struct</span> objc_object <span class="token punctuation">{</span>
  Class _Nonnull isa<span class="token punctuation">;</span>         <span class="token comment">// 指向对象所属的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Class 就是 objc_class</span>
<span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
  Class _Nonnull isa<span class="token punctuation">;</span>         <span class="token comment">// 指向元类</span>
  Class _Nullable superclass<span class="token punctuation">;</span> <span class="token comment">// 指向父类</span>
  cache_t cache<span class="token punctuation">;</span>              <span class="token comment">// 方法缓存</span>
  class_data_bits_t bits<span class="token punctuation">;</span>     <span class="token comment">// 包含方法列表和其他信息</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓oc-底层方法列表的数据结构是什么" tabindex="-1"><a class="header-anchor" href="#❓oc-底层方法列表的数据结构是什么" aria-hidden="true">#</a> ❓<code>OC</code> 底层方法列表的数据结构是什么？</h3><details class="hint-container details"><summary>💡</summary><p>底层是通过结构体来实现了，结构里面的通过数组来存储方法列表</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 方法列表结构体</span>
<span class="token keyword">struct</span> method_list_t <span class="token punctuation">{</span>
  uint32_t entsize<span class="token punctuation">;</span>        <span class="token comment">// 结构体的大小</span>
  uint32_t method_count<span class="token punctuation">;</span>   <span class="token comment">// 方法的数量</span>
  method_t method_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 方法列表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 方法结构体</span>
<span class="token keyword">struct</span> method_t <span class="token punctuation">{</span>
  SEL sel<span class="token punctuation">;</span>                <span class="token comment">// 方法的名称</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>types<span class="token punctuation">;</span>      <span class="token comment">// 方法的类型</span>
  IMP imp<span class="token punctuation">;</span>                <span class="token comment">// 对应的实现（函数指针）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓id、nil、null-区别" tabindex="-1"><a class="header-anchor" href="#❓id、nil、null-区别" aria-hidden="true">#</a> ❓<code>id</code>、<code>nil</code>、<code>NULL</code> 区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><code>id</code> : 可以指向任意的 <code>OC</code> 对象</li><li><code>nil</code> : 一种特殊的指针，指向为空的 <code>OC</code> 对象</li><li><code>NULL</code> : 也是表示空指针，一般代表 <code>C</code> 指针为空</li></ul></details><h3 id="❓-load-与-initialize-区别" tabindex="-1"><a class="header-anchor" href="#❓-load-与-initialize-区别" aria-hidden="true">#</a> ❓<code>+load</code> 与 <code>+initialize</code> 区别</h3><details class="hint-container details"><summary>💡</summary><p>这两个都是类方法，可以从下面几个方面去对比两者的区别</p><ul><li><p>调用时机</p><ul><li><code>+load</code> : 这是在运行时加载时，进行触发调用。</li><li><code>+initialize</code> : 会在类第一次使用时，进行触发调用。</li></ul></li><li><p>调用次数</p><ul><li><code>+load</code> : 只会在运行时加载时，调用一次。</li><li><code>+initialize</code> : 第一次调用时，调用一次。</li></ul></li><li><p>调用父类</p><ul><li><code>+load</code> : 不会调用父类的 <code>+load</code></li><li><code>+initialize</code> : 如果当前类没有</li></ul></li><li><p>手动调用</p><ul><li><code>+load</code> : 不能手动调用，运行时进行调用的。手动调用会触发异常。</li><li><code>+initialize</code> : 可以手动调用。</li></ul></li></ul></details><blockquote><p>❓<code>+load</code> 的调用顺序</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><code>+load</code> 方法调用顺序与编译连接顺序有关。</li><li>不同类之间的<code>+load</code>方法的调用顺序不能确定，取决于编译连接顺序。</li><li>如果父类、子类和分类都实现了 <code>+load</code> 方法，<code>+load</code> 方法的调用顺序是：先调用父类的<code>+load</code>，再调用子类的<code>+load</code>，最后调用分类的<code>+load</code>。</li></ul></details><h3 id="❓-property-本质是什么" tabindex="-1"><a class="header-anchor" href="#❓-property-本质是什么" aria-hidden="true">#</a> ❓<code>@Property</code> 本质是什么？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@property</code> 是 <code>Objective-C</code> 中的一个关键字，用于声明一个属性。主要作用是为类的实例变量（属性）生成对应的访问器方法，即 <code>getter</code> 方法和 <code>setter</code> 方法。</p></blockquote><p><code>@property</code> 访问器</p><ul><li>原子性 : <code>atomic</code>、<code>nonatomic</code></li><li>读写性 : <code>readwrite</code>、<code>readonly</code></li><li>内存管理 : <code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code></li></ul><p><code>@property</code> 优点</p><ul><li>隔离性：可以封装实例变量的直接访问，将类的内部实现与外部接口隔离，提高数据的安全性。</li><li>可维护性：可以在 <code>getter</code> 和 <code>setter</code> 中添加特定的逻辑如设置新值时进行验证，获取值时返回一个计算后的值等，提高代码的可维护性。</li></ul><blockquote><p><code>@property</code> 底层实现</p></blockquote><p>声明 <code>@property</code> 后，编译器会根据属性的特性在 <code>class_rw_t</code> 结构中的 <code>methods</code> 和 <code>properties</code> 中生成 <code>getter</code> 和 <code>setter</code> 方法以及相应的属性。然后在运行时，这些 <code>getter</code> 和 <code>setter</code> 方法以及属性被引入到<code>objc_class</code>的结构中。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
    Class isa<span class="token punctuation">;</span>              <span class="token comment">// metaclass 的指针</span>
    Class super_class<span class="token punctuation">;</span>      <span class="token comment">// 父类</span>
    cache_t cache<span class="token punctuation">;</span>          <span class="token comment">// 缓存</span>
    class_data_bits_t bits<span class="token punctuation">;</span> <span class="token comment">// 类的相关信息，包含了一个指向 class_rw_t 数据结构的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 可读写结构，存储运行时添加的类信息</span>
<span class="token keyword">struct</span> class_rw_t <span class="token punctuation">{</span>
    uint32_t flags<span class="token punctuation">;</span>
    uint32_t version<span class="token punctuation">;</span>
    <span class="token keyword">const</span> class_ro_t <span class="token operator">*</span>ro<span class="token punctuation">;</span>           <span class="token comment">// 只读结构体，保存编译时确定的类信息</span>
    method_array_t methods<span class="token punctuation">;</span>         <span class="token comment">// 方法列表</span>
    property_array_t properties<span class="token punctuation">;</span>    <span class="token comment">// 属性列表</span>
    protocol_array_t protocols<span class="token punctuation">;</span>     <span class="token comment">// 协议列表</span>
    Class firstSubclass<span class="token punctuation">;</span>
    Class nextSiblingClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><blockquote><p>❓<code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code> 区别？</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><p><code>assign</code>：是赋值特性，简单设置变量，不更改引用计数。</p><blockquote><p>主要用在基本的数据类型（如 int、float）或 C 数据类型（如 结构体、C 数组）而不是对象。</p></blockquote></li><li><p><code>strong</code>（类似于：retain）：是所有权（owning）特性。</p><blockquote><p>采用 <code>ARC</code>（自动引用计数）环境下，编译器会自动在设置方法中插入 <code>retain</code> 调用，使对象的引用计数增加，从而表示当前对象拥有数据值。</p></blockquote></li><li><p><code>weak</code>：是非拥有关系（non-owning）特性，即弱引用。</p><blockquote><p>当用 <code>weak</code> 修饰对象时，被指向的对象引用计数不会增加，更重要的是，当对象被释放时，被 <code>weak</code> 修饰的变量会自动被置为 <code>nil</code>，防止野指针的出现。<code>weak</code> 修饰的属性适合在已经存在对对象的<code>strong</code>引用，或者对象之间存在相互循环引用的情况下使用。</p></blockquote></li><li><p><code>copy</code>：是拷贝特性。</p><blockquote><p>适合 <code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code> 等不可变对象。最重要的一点是：使用 <code>copy</code> 保持封装性，对象在内部可能需要一个数据的完整副本，并且把这个副本给外界使用，防止作为接口提供的对象的初始数据被改变。</p></blockquote></li></ul><p>选择哪种属性修饰符要视情况而定，如果数据是不可变的，那么选择 <code>assign</code> 或 <code>copy</code> 较好；如果数据是可变的，可以选择 <code>strong</code> 或 <code>weak</code>。</p></details><h3 id="❓oc-中的三种字符串" tabindex="-1"><a class="header-anchor" href="#❓oc-中的三种字符串" aria-hidden="true">#</a> ❓<code>OC</code> 中的三种字符串？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>__NSCFConstantString</code> ：在编译时被创建的常量字符串对象，如<code>NSString *str = @&quot;Hello, World!&quot;</code>。这些对象会在编译时就被创建，并且在程序的整个生命周期中都不会被销毁。</p></li><li><p><code>__NSTaggedPointerString</code> ：使用 <code>Tagged Pointer</code> 技术来提高内存使用效率，通常用于存储较小的字符串数据。</p></li><li><p><code>__NSCFString</code> ：本质上是一个 <code>Core Foundation</code> 字符串的引用（<code>CFStringRef</code>），这种类型的字符串通常会在运行时程序动态创建的对象字符串。</p></li></ul></details><blockquote><p><code>Tagged Pointer</code> 了解吗？</p></blockquote><details class="hint-container details"><summary>💡</summary><blockquote><p><code>iOS 7</code> 之后 Apple 为了优化引入的一项技术。从字面意思上来看<code>Tagged Pointer</code>就是带有标签的指针。</p></blockquote><p>一般来说，在 64-bit 架构下，一个指针的值需要占用 8 byte 的内存空间；然而对于一些非常小的数据，比如 NSNumber、NSDate、NSString 等，使用 8 byte 存储对象指针就显得非常浪费。为了解决这个问题，苹果引入了 <code>Tagged Pointer</code> 技术，通过标签直接将小的数据对象嵌入到指针中，这样对于小的数据对象，就无需额外的内存来存储了，能够显著提高内存的利用率。需要注意，一个对象是否使用 <code>Tagged Pointer</code> 是由系统决定的，不能人为控制。</p><p>具体到 <code>NSString</code> 这种场景中，如果字符串的内容非常短，那么它的实现方式可能就是 <code>Tagged Pointer</code>，直接将字符串内容存在指针中，提高了内存利用率。</p></details><h3 id="❓nsdictionary-大致实现原理" tabindex="-1"><a class="header-anchor" href="#❓nsdictionary-大致实现原理" aria-hidden="true">#</a> ❓<code>NSDictionary</code> 大致实现原理</h3><details class="hint-container details"><summary>💡</summary><p><code>NSDictionary</code> 在内部实现上采用了哈希表的数据结构</p></details><h2 id="block" tabindex="-1"><a class="header-anchor" href="#block" aria-hidden="true">#</a> <code>block</code></h2><h3 id="❓block-与-函数指针" tabindex="-1"><a class="header-anchor" href="#❓block-与-函数指针" aria-hidden="true">#</a> ❓<code>block</code> 与 函数指针</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>block</code>：一种特殊的数据类型，可以存储一段代码，并且这段代码可以在任何时候被执行。可以访问在声明他的那个作用域中定义的变量，这被称为“变量捕获”。</p></li><li><p>函数指针：函数指针是存储着函数地址的指针变量，本质上是一个地址值，也就是函数在内存中的起始地址。函数指针不能像 <code>block</code> 那样访问变量，只能通过传参的方式去使用外部的数据。</p></li></ul></details><h3 id="❓block-底层实现" tabindex="-1"><a class="header-anchor" href="#❓block-底层实现" aria-hidden="true">#</a> ❓<code>block</code> 底层实现？</h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 底层是使用结构体实现的。</p><p>根据内存分区不同，分为三种 <code>block</code></p><ul><li><code>__NSGlobalBlock__</code> : 全局 <code>block</code>，类似全局静态变量，存放在静态区</li><li><code>__NSStackBlock__</code> : 栈区 <code>block</code>，保存在栈区</li><li><code>__NSMallocBlock__</code> : 堆区 <code>block</code>，保存在堆区</li></ul></details><h2 id="category" tabindex="-1"><a class="header-anchor" href="#category" aria-hidden="true">#</a> <code>Category</code></h2><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Category</code>(类别)：<code>Objective-C</code> 的一个特性，提供了一种给已存在类添加方法的机制.</p></blockquote><ul><li><code>Category</code> : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。</li><li><code>Extension</code> : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。</li></ul></details><h3 id="❓如果分类中添加与类相同的方法签名会发生什么" tabindex="-1"><a class="header-anchor" href="#❓如果分类中添加与类相同的方法签名会发生什么" aria-hidden="true">#</a> ❓如果分类中添加与类相同的方法签名会发生什么？</h3><details class="hint-container details"><summary>💡</summary><p>分类中的方法是运行时添加到方法列表中，并且是添加中已有方法的前面。所以当分类与原类中的方法相同时，分类中的方法会优先调用，覆盖掉原类中的方法。</p></details><h3 id="❓分类是如何实现的-它为什么会覆盖掉原来的方法" tabindex="-1"><a class="header-anchor" href="#❓分类是如何实现的-它为什么会覆盖掉原来的方法" aria-hidden="true">#</a> ❓分类是如何实现的？它为什么会覆盖掉原来的方法？</h3><details class="hint-container details"><summary>💡</summary><p>底层实现：是一个 <code>objc_category</code> 结构体，它包含了类名(name)、类(cls)、类别中所有方法的列表(method_list)、类别的协议列表(protocol_list)、类别中所有的属性列表(property_list)。</p><p>加载过程：在程序运行时的 <code>load</code> 阶段进行的，所有类和分类的 <code>+load</code> 方法（如果有）被调用。在调用 <code>+load</code> 方法之前，<code>runtime</code> 会先将分类的方法、协议、属性合并到类的数据结构中。这个过程中，分类的方法被放在了原来类方法列表的前面，所以在类和分类中有相同方法名的方法的时候，分类的方法会被优先调用，原类的方法被覆盖。</p></details><h3 id="❓分类中如何添加属性" tabindex="-1"><a class="header-anchor" href="#❓分类中如何添加属性" aria-hidden="true">#</a> ❓分类中如何添加属性？</h3><details class="hint-container details"><summary>💡</summary><p>可以使用关联对象（<code>Associated Objects</code>）让分类拥有“伪属性”。</p><p>在Objective-C中，分类（Category）的定义中并不支持直接添加属性（instance variable）。但我们可以通过 Objective-C 的关联对象（Associative References）机制实现给分类添加属性。</p><p>以下是一个例子，演示如何给一个分类添加一个属性：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;NSObject+Property.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>objc<span class="token operator">/</span>runtime<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>MyKey <span class="token operator">=</span> <span class="token operator">&amp;</span>MyKey<span class="token punctuation">;</span>

<span class="token keyword">@implementation</span> <span class="token function">NSObject</span> <span class="token punctuation">(</span>Property<span class="token punctuation">)</span>
<span class="token comment">// getter</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>myProperty <span class="token punctuation">{</span>
  <span class="token comment">// \`objc_getAssociatedObject\` 用于取关联对象。</span>
  <span class="token comment">//  - 首个参数是要存取的对象</span>
  <span class="token comment">//  - 第二个参数是键，我们用一个静态常量 \`MyKey\` 作为键（每个关联到对象的键必须全局唯一）</span>
  <span class="token keyword">return</span> <span class="token function">objc_getAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> MyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// setter</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setMyProperty<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>myProperty <span class="token punctuation">{</span>
  <span class="token comment">// \`objc_setAssociatedObject\` 第三个参数是存储的值，第四个参数是关联策略</span>
  <span class="token comment">// \`OBJC_ASSOCIATION_COPY_NONATOMIC\`，表示这是一个 copy ，非原子操作的特性</span>
  <span class="token function">objc_setAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> MyKey<span class="token punctuation">,</span> myProperty<span class="token punctuation">,</span> OBJC_ASSOCIATION_COPY_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们定义了一个 <code>NSObject</code> 的分类并为它添加了一个 <code>myProperty</code> 属性。</p><p>。对于 ，例如在这里我们将它设为了 。</p><p>通过关联对象可以间接实现在分类中&quot;添加&quot;属性，这也是 <code>Objective-C</code> 动态的特性之一。</p></details><h2 id="runtime" tabindex="-1"><a class="header-anchor" href="#runtime" aria-hidden="true">#</a> <code>runtime</code></h2><h3 id="❓oc-对象模型" tabindex="-1"><a class="header-anchor" href="#❓oc-对象模型" aria-hidden="true">#</a> ❓<code>OC</code> 对象模型</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>Objective-C 类图</p></blockquote><figure><img src="`+c+`" alt="objc-class-diagram" tabindex="0" loading="lazy"><figcaption>objc-class-diagram</figcaption></figure></details><h3 id="❓isa-是什么" tabindex="-1"><a class="header-anchor" href="#❓isa-是什么" aria-hidden="true">#</a> ❓<code>isa</code> 是什么？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>isa</code>： <code>OC</code> 对象的一个指针，它是每个 <code>OC</code> 对象的第一个成员变量，用于指向该对象的类对象。</p></blockquote><p><code>Objective-C</code> 的对象模型中，对象分为实例对象、类对象、元类对象，这三种对象都含有 <code>isa</code> 指针。</p><ul><li><p>实例对象: 实例对象的<code>isa</code>指向它的类对象；实例对象主要存储实例变量的值。</p></li><li><p>类对象: 类对象的<code>isa</code>指向元类对象；类对象主要存储实例方法、属性、以及遵守的协议等信息。</p></li><li><p>元类对象: 元类对象的<code>isa</code>指向自身；元类对象主要存储类方法等信息。</p></li></ul><p>当发送消息给一个对象时，<code>runtime</code> 通过这个对象的 <code>isa</code> 指针找到它的类对象，然后在类对象的方法列表中查找对应的方法进行调用。</p></details><h3 id="❓runtime-如何通过-selector-找到对应的-imp-地址" tabindex="-1"><a class="header-anchor" href="#❓runtime-如何通过-selector-找到对应的-imp-地址" aria-hidden="true">#</a> ❓<code>runtime</code> 如何通过 <code>selector</code> 找到对应的 <code>IMP</code> 地址</h3><details class="hint-container details"><summary>💡</summary><ul><li>消息的接受者（receiver）会在自己的类和超类（superclasses）的方法列表中查找与消息匹配的 <code>selector</code>。</li><li>如果找到了匹配的 <code>selector</code>，那么会从方法列表中取出对应的函数指针（IMP），并且调用这个函数。</li><li>如果没有找到匹配的 <code>selector</code>，那么会进入消息转发（forwarding）流程。</li></ul></details><h3 id="❓super-是什么" tabindex="-1"><a class="header-anchor" href="#❓super-是什么" aria-hidden="true">#</a> ❓<code>super</code> 是什么？</h3><details class="hint-container details"><summary>💡</summary><p><code>super</code> 并不是一个指针，在 <code>OC</code> 进行消息调用时，其实是有两个隐藏参数的，一个是接收者(receiver)，一个是方法选择器(selector)。</p><p>常见的 <code>self</code> 表示的是接收者。而 <code>super</code> 其实是一个编译器标示符，当发送给 <code>super</code> 一个消息时，调用者仍然是 <code>self</code> ，但是运行时会从当前类的父类开始查找方法。</p><blockquote><p>以下代码输出？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@interface</span> Dog <span class="token punctuation">:</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Dog
<span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>init <span class="token punctuation">{</span>
  <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">super</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说 <code>super</code> 并不会改变消息的接收者，所以当我们调用 <code>[super class]</code> 时，虽然是从父类开始查找 <code>class</code> 方法，但是方法的接收者依然是 <code>self</code> 本身，其类别自然是当前类本身。这也是为什么我们再调用 <code>[super class]</code> 时还会返回 <code>Dog</code> 类的原因。</p></details><blockquote><p><code>super</code> 的底层实现？</p></blockquote><details class="hint-container details"><summary>💡</summary><p><code>OC</code> 中 <code>super</code> 的实现是通过 <code>runtime</code> 的 <code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code> 两个函数来完成的。具体来说，当编译器遇到 <code>[super method]</code> 这种形式的调用时，会转化为 <code>objc_msgSendSuper(super_cls, sel)</code> 的形式。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// super 结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">objc_super</span> <span class="token punctuation">{</span>
  __unsafe_unretained id receiver<span class="token punctuation">;</span>        <span class="token comment">// 消息的接收者</span>
  __unsafe_unretained Class super_class<span class="token punctuation">;</span>  <span class="token comment">// 父类(开始查找的类)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// objc_msgSendSuper</span>
<span class="token keyword">void</span> <span class="token function">objc_msgSendSuper</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">objc_super</span> <span class="token operator">*</span>super<span class="token punctuation">,</span> SEL op<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>###, 消息转发, 弱引用表</p><h2 id="runloop" tabindex="-1"><a class="header-anchor" href="#runloop" aria-hidden="true">#</a> <code>RunLoop</code></h2><h3 id="❓runloop-有几种事件源-有几种模式" tabindex="-1"><a class="header-anchor" href="#❓runloop-有几种事件源-有几种模式" aria-hidden="true">#</a> ❓<code>RunLoop</code> 有几种事件源？有几种模式？</h3><details class="hint-container details"><summary>💡</summary><p><code>RunLoop</code>是用来管理事件和处理 <code>IO</code> 的基本架构</p><p>三种事件源</p><ul><li><code>Timer</code>：定时器事件 <blockquote><p><code>RunLoop</code> 按照设定的时间区间接收定时器事件。</p></blockquote></li><li><code>Source</code>：输入源事件 <blockquote><p>包括两种类型：source0 &amp; source1</p></blockquote><ul><li>source0 : 自定义的输入源，需要程序员自己生成和管理。</li><li>source1 ： 基于 <code>Port</code> 的输入源，接收来自其他线程或进程的消息，然后在当前线程上调用指定的处理方法。</li></ul></li><li><code>Observer</code>：观察者事件 <blockquote><p>可以设置在 <code>RunLoop</code> 各个运行阶段接收的事件。</p></blockquote></li></ul><p>运行模式</p><ul><li><code>NSDefaultRunLoopMode</code>（kCFRunLoopDefaultMode）：默认模式 <blockquote><p>如果不手动指定模式，<code>RunLoop</code> 就在这个模式下运行。</p></blockquote></li><li><code>UITrackingRunLoopMode</code>：界面跟踪模式 <blockquote><p>用于 <code>ScrollView</code> 滚动时。</p></blockquote></li><li><code>UIInitializationRunLoopMode</code>：启动 App 时第进入的模式 <blockquote><p>启动完成后就不再使用。</p></blockquote></li><li><code>NSRunLoopCommonModes</code>（kCFRunLoopCommonModes）：这是一个占位模式，不是一种真正的 Mode。 <blockquote><p>可以将事件源（<code>Timer/Observer/Source</code>）添加到 <code>CommonModes</code> 中，<code>RunLoop</code> 运行在哪种 Mode 时，只要这种 Mode 被标记为 Common 的属性，则 <code>RunLoop</code> 就会处理相应的事件。</p></blockquote></li></ul></details><h3 id="❓runloop-内部实现逻辑" tabindex="-1"><a class="header-anchor" href="#❓runloop-内部实现逻辑" aria-hidden="true">#</a> ❓<code>Runloop</code> 内部实现逻辑？</h3><details class="hint-container details"><summary>💡</summary><p><code>RunLoop</code> 的内部实现可以简单地概括为一个 <code>while</code> 循环，在这个循环中处理各种输入源的事件。<code>RunLoop</code> 在开启后会一直在这个循环中执行，直到接收到停止 <code>RunLoop</code> 的消息。</p><ul><li><p><code>RunLoop</code> 在启动时会从预设的 <code>Mode</code> 中选择一个，然后进入 <code>RunLoop</code> 的循环。</p></li><li><p>进入循环周期</p><ul><li>首先，处理所有到期的定时器事件。</li><li>然后，处理所有的输入源事件。输入源的事件包括来自 <code>Port</code> 的消息，以及用户定义的其他事件。</li><li>然后，如果有观察者的话，<code>RunLoop</code> 会通知观察者当前 <code>RunLoop</code> 的状态。</li><li>最后，如果在处理事件的过程中没有任何源需要处理，那么 <code>RunLoop</code> 会进入休眠等待被唤醒。</li></ul></li><li><p>继续下一次循环，直到接收到结束 <code>RunLoop</code> 的消息。</p></li></ul></details><h3 id="❓以下代码输出是什么" tabindex="-1"><a class="header-anchor" href="#❓以下代码输出是什么" aria-hidden="true">#</a> ❓以下代码输出是什么？</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
  <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil afterDelay<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test <span class="token punctuation">{</span>
  <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><blockquote><p>打印顺序 : 1, 4, 2, 3</p></blockquote><p>&quot;1&quot;和&quot;4&quot;是普通的直接执行代码，因此会按照顺序输出。</p><p>&quot;2&quot;和&quot;3&quot;位于异步并发队列中，会在新线程中执行，所以会在&quot;1&quot;和&quot;4&quot;之后开始执行。</p><p>&quot;5&quot;不会输出。原因是<code>[self performSelector:@selector(test) withObject:nil afterDelay:10];</code>这一行代码被放在异步并发队列中，并且是在子线程中执行，但是这种执行方式是依赖 <code>RunLoop</code> 的，而新创建的线程默认是没有启动 <code>RunLoop</code> 的，所以<code>performSelector:afterDelay:</code>方法会失效。</p><blockquote><p>如果想要使 &quot;5&quot; 能够打印，应该怎么处理？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 方案一 : 放入主线程 RunLoop</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> performSelectorOnMainThread<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil waitUntilDone<span class="token punctuation">:</span>NO<span class="token punctuation">]</span><span class="token punctuation">;</span>
  
<span class="token comment">// 方案二 : 在子线程中手动启动 RunLoop</span>
NSRunLoop <span class="token operator">*</span>runLoop <span class="token operator">=</span> <span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil afterDelay<span class="token punctuation">:</span><span class="token number">5.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>runLoop run<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,57);function p(l,d){return s(),a("div",null,[e(" more "),i])}const k=n(t,[["render",p],["__file","objective-c.html.vue"]]);export{k as default};

import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as o,a as c,f as i}from"./app-4qjgWOI3.js";const l={},t=i('<h2 id="❓flutter-列表优化方案" tabindex="-1"><a class="header-anchor" href="#❓flutter-列表优化方案" aria-hidden="true">#</a> ❓<code>Flutter</code> 列表优化方案</h2><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ListView.builder</code>: 使用 <code>ListView.builder</code> 可以实现列表的懒加载。它仅在列表项滚动到屏幕内时创建对应的 <code>Widget</code>，因此对于大量的列表项，它可以大大节省创建和渲染列表项所需的时间和内存。</p></li><li><p>使用 <code>const Widget</code>: 在定义静态列表项时，可以使用 <code>const</code> 关键字创建不可变的 <code>Widget</code>。这样可以避免在每次构建时都重新创建新的 <code>Widget</code>。</p></li><li><p>使用 <code>Key</code>: 如果列表数据中的项可能会在不同的位置移动，那么使用 <code>UniqueKey</code> 或 <code>ValueKey</code> 可以帮助 <code>Flutter</code> 框架识别出哪些 <code>Widget</code> 是“一样的”，哪些是需要更新的。这样可以避免无效的 <code>Widget</code> 重建。</p></li><li><p>防止列表项更新: 如果列表项的更新不频繁，使用 <code>AutomaticKeepAliveClientMixin</code> 可以保持列表项状态不被销毁，减少不必要的构建。</p></li><li><p><code>ListView.separated</code>: 可以方便地在列表项之间添加分隔线，而无需在每个列表项中添加分隔线元素，这可以减少 <code>Widget</code> 树的深度，提高性能。</p></li><li><p><code>shrink-wrap</code>: 有些情况下，使用 <code>ListView</code> 会导致列表项无法在列表之外进行布局。此时可以 使用 <code>shrinkWrap</code> 属性来让列表适应其内容的大小。</p></li></ul></details><h2 id="❓flutter-渲染优化方案" tabindex="-1"><a class="header-anchor" href="#❓flutter-渲染优化方案" aria-hidden="true">#</a> ❓<code>Flutter</code> 渲染优化方案</h2><details class="hint-container details"><summary>💡</summary><p>按照渲染时机分类：</p><blockquote><p>渲染优化来说主要涉及两个方面，其一是首次加载的渲染，其二是 <code>StatefulWidget</code> 状态改变时页面的重建渲染。</p></blockquote><ul><li><p>首次渲染方面: 构建 <code>Widget</code> 时应该合理搭建，减少复杂度；能使用 <code>const</code> 的地方尽量使用</p></li><li><p>重建渲染方面: 尽量减少状态改变引起重建区域；减少 <code>saveLayer()</code>的触发</p><blockquote><p>触发 <code>saveLayer()</code></p></blockquote><ul><li><code>ShaderMask</code></li><li><code>ColorFilter</code></li><li><code>Chip</code> &amp; <code>disabledColorAlpha != 0xff</code></li><li><code>Text</code> &amp; <code>overflowShader</code></li></ul></li></ul><p>按照渲染类型分类：</p><ul><li><p>图片优化：</p><ul><li>使用合适大小的图片，避免加载过大的图片。</li><li>使用 <code>Flutter</code> 中的 <code>cacheHeight</code> 和 <code>cacheWidth</code> 对图片进行缩放。</li><li>避免在一个界面显示大量图片，可以使用懒加载的方式，如 <code>ListView.builder</code>。</li><li>使用 <code>FadeInImage</code> 控件实现图片的平滑切换。</li></ul></li><li><p>布局优化：</p><ul><li>减少无关层级的嵌套，尽量避免深层次的布局嵌套。</li><li>使用 <code>const</code> 关键字，避免不必要的重绘。</li><li>避免频繁使用 <code>Opacity</code>，<code>ClipRRect</code> 等比较消耗性能的组件。</li><li>当不需要布局关联时，使用 <code>RepaintBoundary</code> 将部分布局剥离出来，可以有效地分割渲染树。</li></ul></li><li><p>代码优化：</p><ul><li>使用 <code>shouldRebuild</code> 避免不必要的 <code>Widget</code> 重建。</li><li>尽量使用轻量级组件，尽量避免将大型组件当作 <code>child</code> 传入其他组件。</li><li><code>ListView</code>、<code>GridView</code> 等长列表类的组件尽量使用 <code>ListView.builder</code> 或 <code>GridView.builder</code>，这种模式下，列表子项只在需要时创建，可以极大提升性能。</li></ul></li><li><p>动画优化：</p><ul><li>使用 <code>Flare</code> 代替传统的 <code>Controller</code> 完成复杂的动画。</li><li>动画开启时，使用 <code>timeDilation</code> 延长动画时间，方便调试。</li><li>将动画部分剥离出 <code>RepaintBoundary</code>，避免整个列表频繁重绘。</li></ul></li></ul></details><h2 id="❓flutter-包体积优化方案" tabindex="-1"><a class="header-anchor" href="#❓flutter-包体积优化方案" aria-hidden="true">#</a> ❓<code>Flutter</code> 包体积优化方案</h2><details class="hint-container details"><summary>💡</summary><p>包体积的优化说到底就是包里面所含有资源的优化，主要包含两类文件一类是资源文件，另一个类是二进制文件。</p><ul><li><p>资源文件的优化</p><ul><li>无用资源的移除：检查项目中的所有资源文件，删除没有被使用到的图片、视频等大型资源文件。</li><li>压缩图片和音频文件：这些文件往往体积较大，使用一些工具进行压缩可以节省空间。</li><li>使用 <code>App Bundle</code>（仅对 <code>Android</code>）：发布到 <code>Google Play Store</code> 时，考虑用 <code>Android App Bundle</code>（<code>.aab</code> 文件）替代 <code>APK</code>。<code>App Bundle</code> 将你的应用拆分成多个 <code>APK</code>，分别对应不同的硬件配置，用户下载时只需要下载对应自身设备的 <code>APK</code>。</li><li>资源的动态下发。</li></ul></li><li><p>二进制文件优化</p><ul><li>无用代码的移除：确保 <code>pubspec.yaml</code> 文件没有包含任何不需要的行，例如无用的依赖和 <code>_asset_</code>。</li><li>使用仅包含所需功能的包和插件：只添加需要的功能包，避免使用过大的库，尤其是当你只需要库的一部分功能时。</li><li>缩小 <code>Native</code> 代码：如应用包含 <code>Native</code> (<code>Kotlin/Java/Swift/Objective-C</code>) 的代码，那么可以通过一些 <code>Native</code> 工具来减小它们的体积。例如，<code>Android</code> 可以使用 <code>ProGuard/R8</code> 来进行代码混淆和优化。</li><li><code>tree-shaking</code>: <code>Flutter</code> 的编译工具会自动删除“死代码”。保证在项目中无未使用的代码可以让 <code>tree-shaking</code> 更加有效。</li><li>运行 <code>flutter build</code> 命令时，开启 <code>--split-debug-info</code> 选项可以将符号信息（<code>Dart</code>的堆栈追踪信息）和程序信息分别保存，以此降低程序本身的体积。</li></ul></li></ul></details>',6);function a(r,u){return d(),o("div",null,[c(" more "),t])}const n=e(l,[["render",a],["__file","0x06.optimization.html.vue"]]);export{n as default};

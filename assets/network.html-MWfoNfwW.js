import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as o,a as t,f as c}from"./app-MGW3UszY.js";const i={},l=c('<h2 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> Concept</h2><table><thead><tr><th>abbr</th><th>full</th><th>description</th></tr></thead><tbody><tr><td><code>OSI</code></td><td>Open System Interconnection</td><td>开放式系统互联通信参考模型</td></tr><tr><td><code>CA</code></td><td>Certificate Authority</td><td>证书颁发机构</td></tr><tr><td><code>IP</code></td><td>Internet Protocol</td><td>网络传输协议</td></tr><tr><td><code>TCP</code></td><td>Transmission Control Protocol</td><td>传输控制协议</td></tr><tr><td><code>UDP</code></td><td>User Datagram Protocol</td><td>用户数据报协议</td></tr><tr><td><code>HTTP</code></td><td>Hyper Text Transfer Protocol</td><td>超文本传输协议</td></tr><tr><td><code>HTTPS</code></td><td>Hyper Text Transfer Protocol Secure</td><td>超文本安全传输协议</td></tr><tr><td><code>QUIC</code></td><td>Quick UDP Internet Connections</td><td>快速 <code>UDP</code> 网络连接协议</td></tr></tbody></table><h2 id="tcp-ip-五层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip-五层模型" aria-hidden="true">#</a> <code>TCP/IP</code> 五层模型</h2><ol><li>应用层 : <code>DNS</code>、<code>HTTP</code>、<code>HTTPS</code>、<code>RPC</code>、<code>P2P</code> (<code>DHCP</code>、<code>RTMP</code>、<code>GTP</code>) <blockquote><p><code>OSI</code> 七层模型中，将应用层细分为(应用层、表示层、会话层)</p></blockquote><ul><li>表示层 :</li><li>会话层 :</li></ul></li><li>传输层 : <code>TCP</code>、<code>UDP</code>、<code>QUIC</code></li><li>网络层 : (IP 层) <code>IP</code> (<code>ICMP</code>、<code>OSPF</code>、<code>BGP</code>、<code>IPSec</code>、<code>GRE</code>)</li><li>链路层 : (MAC 层) <code>ARP</code>、<code>VLAN</code>、<code>STP</code></li><li>物理层 : 网络跳线</li></ol><h2 id="tcp-vs-udp" tabindex="-1"><a class="header-anchor" href="#tcp-vs-udp" aria-hidden="true">#</a> <code>TCP</code> vs <code>UDP</code></h2><blockquote><p><code>TCP</code> 特点</p></blockquote><ul><li>可靠性 : 通过确认应答、超时重传等机制保证数据的可靠传输。</li><li>有序性 : 通过数据序号来保证数据有序，传输完成后通过排序来保证数据的正确性。</li><li>双全工 : 通信双方(服务端和客户端)都具备发送和接受数据的能力。(三次握手来保证)</li></ul><blockquote><p><code>UDP</code> 特点</p></blockquote><ul><li>不可靠 : 通信通信双方不需要建立连接，不能保证数据准确送达。</li><li>无序性 : 每次发送的数据包相互独立，没有特定的顺序。</li><li>速度快 : 由于数据包结构简单，保证的 <code>UDP</code> 传输速度优于 <code>TCP</code></li></ul><p>一些游戏、直播和需要低延迟实时性要求较高的应用，会使用 <code>UDP</code>。</p><blockquote><p><code>TCP</code> 的 <code>keepalive</code> 机制</p></blockquote><p><code>keepalive</code> 顾名思义是否还活着，是一种心跳检测机制。用于判断连接方是否还处于活动状态，以便断开已经失活连接释放资源。发送探测包后，如果处于活动状态，接收方会发送确认信号；如果处于失活状态，则会再连续再发送几次探测包如果均无响应则证明对方已断开连接，可以释放资源。</p><p>需要注意的一点是，这个 <code>keepalive</code> 机制的时长一般默认为 2 小时。所以，不能使用使用该机制来确认实时性较高的保活探测。</p><h2 id="http-vs-https" tabindex="-1"><a class="header-anchor" href="#http-vs-https" aria-hidden="true">#</a> <code>HTTP</code> vs <code>HTTPS</code></h2><p><code>HTTP</code>: 是基于 <code>TCP/IP</code> 通信协议的一种数据传输协议。 <code>HTTPS</code> : <code>= HTTP + SSL</code>，在 <code>HTTP</code> 协议的基础加上了加密处理。</p><blockquote><p><code>HTTP</code> 常见报文</p></blockquote><table><thead><tr><th>abbr</th><th>full</th><th>description</th></tr></thead><tbody><tr><td><code>SYN</code></td><td>synchronize</td><td>同步报文，用于建立连接</td></tr><tr><td><code>ACK</code></td><td>acknowledge</td><td>确认报文，用于确认已接收</td></tr><tr><td><code>FIN</code></td><td>finish</td><td>传输完成报文，用于结束连接</td></tr><tr><td><code>RST</code></td><td>reset</td><td>重置报文，用于重置连接</td></tr><tr><td><code>PSH</code></td><td>push</td><td>推送报文，用于直接将数据推送给接收端，而不是先放在缓存区</td></tr><tr><td><code>URG</code></td><td>urgent</td><td>紧急报文，用于传输紧急数据，接收端会优先处理该数据</td></tr></tbody></table><blockquote><p>“三次握手” - 创建连接</p></blockquote><ul><li>客户端发给服务端 SYN 报文 =&gt; (服务端: 客户端的发送功能正常)</li><li>服务端接受 SYN 报文之后，给客户端发送 SYN+ACK 报文 =&gt; (客户端: 服务端接受、发送功能正常)</li><li>客户端收到 SYN+ACK 报文之后，给服务度发送 ACK 报文 =&gt; (服务单: 客户端接受功能正常)</li></ul><p>三次握手的核心点 : 开始数据通信前，确认双方发送和接受功能是否都正常。</p><blockquote><p>“四次挥手” - 断开连接</p></blockquote><ul><li>一方完成数据发送发给另一方 FIN 报文 (一方: 数据传输完成)</li><li>另一方接受 FIN 报文之后，给对方发送 ACK 报文 (另一方: 确认对方数据传输完成，并已关闭)</li><li>另一方进行数据确认已完成，则也给对方发送 FIN 报文 (另一方: 如果有数据还未传输，传输完，保证数据传输完成。)</li><li>对方收到 FIN 报文之后，回复 ACK 报文 (一方: 确认对方数据传输完成)</li></ul><p>四次挥手的核心点 : 断开连接前，确认双方数据均发送完毕。</p><blockquote><p><code>HTTPS</code> 的加密过程原理</p></blockquote><p>首先需要了解两种加密模式，对称加密和非对称加密。</p><ul><li>对称加密：通信双方使用同一个密钥进行数据的加密和解密。</li><li>非对称加密：有两个秘钥(私钥和公钥)，公钥用来加密数据，私钥用来解密。对称加密比非对称加密来说，因为使用单一秘钥计算量小，没有复杂的数学计算，所以效率上高于非对称加密。</li></ul><p><code>HTTPS</code> 的连接过程也是三次握手。相对于 <code>HTTP</code> 的区别在于，第二次时服务器除了发送 <code>ACK</code> 之外，还会将加密的使用的公钥发送给客户端。第三次时客户端接受到公钥后，会校验公钥的合法性，并生产一个对称加密的秘钥。客户端回复服务端 <code>ACK</code> 的同时，也会将生成的秘钥通过公钥加密之后发送给服务端。之后双方就可以使用秘钥进行数据加密通信了。</p><p><code>HTTPS</code> 中的中间人攻击，是指中间人先伪装成服务器接受客户端发送过来的请求，发送伪装的公钥给客户端。然后伪装成客户端将拦截的请求发送服务器，得到服务器的公钥。这样客户端以后发送请求都会请过中间人，中间人可以在篡改真实的请求。</p><p>而为了解决中间人攻击这个问题，就引入了 <code>CA</code> 机构，用于给服务器签发数字证书。数字证书是包含服务器标识(如：域名)以及服务器公钥等信息。客户端可以通过这些信息来确认是否连接上正确的服务器，来避免中间人攻击。</p><h2 id="http-各个版本的区别" tabindex="-1"><a class="header-anchor" href="#http-各个版本的区别" aria-hidden="true">#</a> <code>HTTP</code> 各个版本的区别</h2><ul><li><code>HTTP</code> 1.0 : 最早期版本，每次请求都会重新创建 <code>TCP</code> 的连接的创建和释放，造成极大的资源消耗。属于“非持续性连接”。</li><li><code>HTTP</code> 1.1 : 改善了 1.0 版本的问题，修正为“持续性连接”。一次 <code>TCP</code> 连接可以发送多个请求和回复。引入 <code>pipeline</code> (管道)机制，可以同时发送多个请求，但是响应会按照请求队列的先后顺序进行，被称为“队头阻塞”问题。</li><li><code>HTTP</code> 2.0 : 优化了传输数据格式(1.x 文本 -&gt; 二进制)，减少了解析复杂度和提升传输速度。通过多路复用机制，解决了 1.0 “队头阻塞” 的问题，一次连接可以同时进行多个请求和响应。头信息压缩处理，减少数据体积。添加了服务器推送功能。</li><li><code>HTTP</code> 3.0 : 开发中... <code>TCP</code> -&gt; <code>QUIC</code></li></ul><h2 id="http-中-get、post-区别" tabindex="-1"><a class="header-anchor" href="#http-中-get、post-区别" aria-hidden="true">#</a> <code>HTTP</code> 中 <code>GET</code>、<code>POST</code> 区别</h2><h2 id="cookie-vs-session" tabindex="-1"><a class="header-anchor" href="#cookie-vs-session" aria-hidden="true">#</a> <code>Cookie</code> vs <code>Session</code></h2><h2 id="socket" tabindex="-1"><a class="header-anchor" href="#socket" aria-hidden="true">#</a> <code>Socket</code></h2>',34);function r(a,h){return d(),o("div",null,[t(" more "),l])}const s=e(i,[["render",r],["__file","network.html.vue"]]);export{s as default};

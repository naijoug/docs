import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as r,a as d,f as i}from"./app-SDsRO-JA.js";const h={},c=i('<h2 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程" aria-hidden="true">#</a> 进程与线程</h2><p>进程 : 程序的一次运行活动，各个进程之间相互资源独立。操作系统分配资源的基本单位，具有唯一的 PID 和 port 号。 线程 : 线程是进程的最小执行单位，同一个进程内的多个线程共享进程内的资源。</p><h2 id="进程间如何通信" tabindex="-1"><a class="header-anchor" href="#进程间如何通信" aria-hidden="true">#</a> 进程间如何通信</h2><h2 id="最多能开辟多少个进程和线程" tabindex="-1"><a class="header-anchor" href="#最多能开辟多少个进程和线程" aria-hidden="true">#</a> 最多能开辟多少个进程和线程？</h2><h2 id="解决线程安全的方案" tabindex="-1"><a class="header-anchor" href="#解决线程安全的方案" aria-hidden="true">#</a> 解决线程安全的方案</h2><p><code>CAS</code>(Compare And Swap) : 比较并交换，是一种实现原子的机制，可以保证一个变量在读、写时的原子性。 基本原理是比较三个操作数，V (内存位置值)、A (原值)、B (新值)，比较 V 与 A，如果相等则将更新内存位置值交换为 B，如果不相等则不做交换操作。最后无论是否进行交换操作，都返回该位置的值。线程1 读取值后，在进行写时，将读取的值与要写入内存位置的值进行比较，这样如果线程2 在线程1 写之前修改了数据，那么比较的时候就会不相等，也就不能写入保证了原子性。</p><p><code>CAS</code> 会存在 <code>ABA</code> 问题。也就是说线程2 先将 A 修改为了 B，又将 B 修改为了 A，这样线程1 再进行比较时还是相等，但是其实数据已经是修改过了的。而解决 <code>ABA</code> 问题最常见的方案就是版本号，也就是每次修改数据时，都会加上一个版本号。原始版本号为 1，而线程1 读取数据时版本号为 1，当线程2 进行 <code>ABA</code> 数据修改后，版本号增长为了 3，则线程1 再进行比较时，就会知道 A 是修改后的了，也就不能写入。</p><h2 id="协程与线程" tabindex="-1"><a class="header-anchor" href="#协程与线程" aria-hidden="true">#</a> 协程与线程</h2><p>协程(Coroutine) : 也被称为“微线程”。运行在用户态，相比于线程具有极高的执行效率和极低的切换成本。</p><h2 id="线程锁有哪些" tabindex="-1"><a class="header-anchor" href="#线程锁有哪些" aria-hidden="true">#</a> 线程锁有哪些</h2><ul><li><p>读写锁(read/write-lock)</p></li><li><p>互斥锁(mutex-lock)</p></li><li><p>自旋锁(spin-lock)</p></li><li><p>递归锁(recursive-lock)</p></li><li><p>悲观锁</p></li><li><p>乐观锁</p></li></ul><h2 id="线程锁的底层实现" tabindex="-1"><a class="header-anchor" href="#线程锁的底层实现" aria-hidden="true">#</a> 线程锁的底层实现?</h2><h2 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> <code>async/await</code></h2><h2 id="并行-vs-串行" tabindex="-1"><a class="header-anchor" href="#并行-vs-串行" aria-hidden="true">#</a> 并行 vs 串行</h2><p>并行 (Concurrency) : 多个任务会同时执行。如果是多核 CPU 会是真正意义上并行，多个任务会在不同 CPU 上同时运行；如果是单核 CPU 是一种伪并行，是同一时间间隔上运行多个任务，CPU 在多个任务上切换运行，其实某一时刻上其实只有一个任务执行，由于 CPU 运行速度比较快，用户角度观察呈现并发状态。</p>',15);function o(n,t){return a(),r("div",null,[d(" more "),c])}const p=e(h,[["render",o],["__file","thread.html.vue"]]);export{p as default};

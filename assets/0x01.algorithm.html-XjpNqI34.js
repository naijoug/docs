import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r,o as n,c as t,a as s,b as a,e,d as o,f as p}from"./app-j-heE4gB.js";const d={},h=a("h2",{id:"reference",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),e(" reference")],-1),c=a("a",{href:""},null,-1),u={href:"https://halfrost.com/lru_lfu_interview",target:"_blank",rel:"noopener noreferrer"},m=p('<hr><h2 id="概念知识" tabindex="-1"><a class="header-anchor" href="#概念知识" aria-hidden="true">#</a> 概念知识</h2><h3 id="❓时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#❓时间复杂度分析" aria-hidden="true">#</a> ❓时间复杂度分析</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>最好时间复杂度</p></li><li><p>最坏时间复杂度</p></li><li><p>平均时间复杂度</p></li><li><p>摊还分析法 : 均摊时间复杂度，一种特殊的平均时间复杂度</p></li></ul></details><h3 id="❓知道贪心算法吗-它的具体步骤是什么样子的" tabindex="-1"><a class="header-anchor" href="#❓知道贪心算法吗-它的具体步骤是什么样子的" aria-hidden="true">#</a> ❓知道贪心算法吗？它的具体步骤是什么样子的？</h3><details class="hint-container details"><summary>💡</summary><p>贪心算法，也称贪婪算法，是指在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上考虑做出选择，而是采取一种局部最优的选择策略。</p><p>贪心算法的主要步骤是:</p><ol><li><p>建立数学模型来描述问题。</p></li><li><p>把问题分解为若干个子问题。</p></li><li><p>对每一子问题求解，得到子问题的局部最优解。</p></li><li><p>把子问题的解局部最优解合成原问题的一个解。</p></li></ol><p>贪心算法能解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码等。然而对于最优解问题，贪心算法一般不能得到我们所要求的答案。一旦一个具体问题通过贪心算法策略做出了一次选择，那么这个选择通常是无法再改变的。所以说，贪心算法适用的问题一定具有这个特性，即局部最优解能导向全局最优解。</p></details><hr><h2 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法" aria-hidden="true">#</a> 排序算法</h2><h3 id="几种排序算法的思想和复杂度" tabindex="-1"><a class="header-anchor" href="#几种排序算法的思想和复杂度" aria-hidden="true">#</a> 几种排序算法的思想和复杂度</h3><details class="hint-container details"><summary>💡</summary><p>以下是几种常见排序算法的思想及其复杂度：</p><ol><li><p>冒泡排序： 比较相邻的元素，如果前一个比后一个大，就把它们两个交换位置。重复此步骤，直到没有需要交换的元素。时间复杂度O(n^2)。</p></li><li><p>选择排序： 在未排序序列中找到最小（或最大）元素，存放到排序序列的首端。然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。时间复杂度O(n^2)。</p></li><li><p>插入排序：从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，并在已经排序的元素序列中从后向前扫描；如果该元素小于前面的元素，那么就把前面的元素向后移动一位；重复此步骤，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后。重复该步骤。时间复杂度O(n^2)。</p></li><li><p>快速排序：选择一个基准元素，将比它小的元素交换到它左边，比它大的元素交换到它右边。然后再对两边的子序列进行排序。时间复杂度O(n log n)。</p></li><li><p>归并排序：将待排序序列分为两半，分别对他们进行排序，然后合并。这是一种典型的分治算法。时间复杂度O(n log n)。</p></li><li><p>堆排序： 利用堆这种数据结构所设计的一种排序算法，将数组构造成最大堆或最小堆，然后将堆顶元素与最后一个元素交换，然后将剩下元素重新构造成堆。时间复杂度O(n log n)。</p></li><li><p>希尔排序： 思想是使数组中任意间隔h的元素都是有序的，这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立的有序数组编织在一起的一个数组。 时间复杂度根据步长的序列不同而不同，最优的时间复杂度可以达到O(n log n)。</p></li><li><p>基数排序： 将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。时间复杂度O(n*k)，其中k为数列中的数的最大的位数。这是用空间换时间的明显例子。</p></li></ol><p>注意：这里说的时间复杂度是指每个算法最坏的情况下的时间复杂度。</p></details><blockquote><p>❓<code>log(n)</code> 的复杂度是怎么算出来的</p></blockquote><details class="hint-container details"><summary>💡</summary><p>在计算机科学中，很多算法的运行时间都是与其输入长度的某种方关系的。这关系通常是线性的（线性时间复杂度），二次的（二次时间复杂度），或对数的（对数时间复杂度）。其中，O(log n) 的复杂度通常用于描述那些将问题规模减半的算法。</p><p>O(log n) 的时间复杂度最经典的例子是二分查找算法。二分查找算法在查找一个有序列表中的元素时，每一步都将剩余的查找区间减半，直到找到所需元素或区间缩小为 0。由于每一步都将问题的大小减半，所以在最坏的情况下，需要进行 log2(n) 步操作，因此其时间复杂度为 O(log n)。</p><p>还有一些其它算法，如归并排序和快速排序在某些情况下，其时间复杂度也可以达到O(n log n) 。其中 log n 的部分来源于多级分解步骤——每一级都将问题的规模减半（或者接近减半），比如二分法、归并等。</p><p>但并不是所有的问题的规模减半的算法的时间复杂度都是O(log n)，还需要看单次操作的时间复杂度。如果单次操作的时间复杂度已经达到或者超过O(n)，那么总的时间复杂度就不再是O(log n)，而是比这个大。所以进行复杂度分析的时候，要看整体的复杂度，不能只看某一部分。</p><p>请注意，这里的 log 指的是以 2 为底的对数。在大 O 符号的表示法中，所有的对数底数都是可忽略的，因为他们只会通过常系数来改变运行时间，而在大 O 符号中，常系数是被忽略的。</p></details><h3 id="❓哪些排序算法是稳定的-哪些是不稳定的" tabindex="-1"><a class="header-anchor" href="#❓哪些排序算法是稳定的-哪些是不稳定的" aria-hidden="true">#</a> ❓哪些排序算法是稳定的，哪些是不稳定的</h3><details class="hint-container details"><summary>💡</summary><p>排序算法的稳定性是指如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序是否保持。</p><p>以下是一些常见排序算法的稳定性：</p><p>稳定的排序算法：</p><ul><li>冒泡排序：稳定</li><li>插入排序：稳定</li><li>归并排序：稳定</li><li>基数排序：稳定</li><li>计数排序：稳定</li><li>桶排序：稳定</li></ul><p>不稳定的排序算法：</p><ul><li>选择排序：不稳定</li><li>堆排序：不稳定</li><li>快速排序：不稳定</li><li>希尔排序：不稳定</li></ul><p>特别要注意的是，以上列出的排序算法的稳定性即是他们最基本、原始形式下的稳定性。为了提高某些排序算法的性能，有些实现版本可能对这些算法进行了修改，这可能会影响他们的稳定性。比如，很多对快速排序所做的优化都使其变得不稳定。</p></details><h3 id="❓冒泡排序和插入排序的时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#❓冒泡排序和插入排序的时间复杂度是多少" aria-hidden="true">#</a> ❓冒泡排序和插入排序的时间复杂度是多少</h3><details class="hint-container details"><summary>💡</summary><p>两者的时间复杂度相同 <code>O(n²)</code></p><p>插入排序是稳定的排序，对于相同的元素排序前后的相对位置不会发生变化。</p></details><h3 id="❓为什么实际开发中会更多选择插入排序" tabindex="-1"><a class="header-anchor" href="#❓为什么实际开发中会更多选择插入排序" aria-hidden="true">#</a> ❓为什么实际开发中会更多选择插入排序</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>输入规模小</strong>：插入排序对小规模输入的处理非常高效，因为小规模情况下，插入排序的操作过程减少，效率相对较高。</p></li><li><p><strong>输入序列接近有序</strong>：插入排序对于近乎有序的序列，其性能特别好。在这种情况下，插入排序可以达到线性时间复杂度。</p></li><li><p><strong>稳定排序算法</strong>：稳定性是排序算法的一个重要特性，它保证了等值的元素在排序后保持相对顺序不变。插入排序是稳定的排序算法，这能满足一些特定的需求。</p></li><li><p><strong>原地排序算法</strong>：插入排序是原地排序算法，只需 <code>O(1)</code> 的额外内存空间，对于内存空间有限的场景非常有利。</p></li><li><p><strong>在线算法</strong>：插入排序是在线算法，在读取输入信息的时候就可以开始进行排序操作，无需获取全部输入信息。</p></li></ul><p>注意：插入排序的最坏时间复杂度（当输入序列完全逆序时）是 <code>O(n^2)</code>，因此它不适合处理大规模和随机输入的情况，此时快速排序、归并排序等高级排序算法更为适用。</p></details><h3 id="❓为什么快速排序是不稳定排序-而归并排序是稳定排序" tabindex="-1"><a class="header-anchor" href="#❓为什么快速排序是不稳定排序-而归并排序是稳定排序" aria-hidden="true">#</a> ❓为什么快速排序是不稳定排序，而归并排序是稳定排序</h3><details class="hint-container details"><summary>💡</summary><p>排序的稳定性：</p><ul><li>稳定排序算法：可以保证排序前后，两个相等的数相对位置不变。</li><li>不稳定的排序算法：不能保证排序前后，相等元素的相对顺序不变。</li></ul><blockquote><p>快速排序是不稳定的排序：</p></blockquote><p>快速排序的基本思想：使用一个关键值（通常将序列的第一个元素作为关键值，即基准元素）对序列进行划分，将待排序序列划分为两部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再依次对这两部分数据分别进行快速排序，整个过程是递归进行的。在这个过程中，有可能会改变相同元素的相对位置，因此快速排序是不稳定的。</p><blockquote><p>归并排序是稳定的排序：</p></blockquote><p>归并排序的基本思想：先找出待排序序列中的相邻数据对进行排序，然后合并，再对每对有序序列进行同样的操作，如此进行下去，直至整个序列有序。在这个过程中，相等的元素的前后位置是不会发生改变的，因此归并排序是稳定的排序。</p></details><hr><h2 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h2><h3 id="❓二分查找在升序数组中找出绝对值最小的那个数" tabindex="-1"><a class="header-anchor" href="#❓二分查找在升序数组中找出绝对值最小的那个数" aria-hidden="true">#</a> ❓二分查找在升序数组中找出绝对值最小的那个数</h3><details class="hint-container details"><summary>💡</summary><p>二分查找是一种在排序数组中查找特定元素的搜索算法。通过每次减半搜索区间，二分查找可以快速定位到目标元素。下面是在升序数组中找出绝对值最小的那个数的过程：</p><ul><li><p>确定数组的中间元素。如果这个元素的绝对值比当前最小的绝对值小，那么将它设为当前最小的绝对值。</p></li><li><p>根据数组是升序的性质，如果中间元素大于零，那么在它左边的元素都比它小，因此，下一步在左半部分数组中寻找。</p></li><li><p>反之，如果中间元素小于零，那么在它右边的元素都比它大，因此，下一步在右半部分数组中寻找。</p></li><li><p>重复以上搜索过程，直到搜索范围为空。最后得到的当前最小的绝对值就是我们要找的结果。</p></li></ul><p>注意，这种方法对升序或者降序数组都是有效的，只是搜索的方向不同而已。</p><p>这就是如何通过二分查找在升序数组中寻找绝对值最小的数。</p></details><hr><h2 id="随机数" tabindex="-1"><a class="header-anchor" href="#随机数" aria-hidden="true">#</a> 随机数</h2><h3 id="❓随机数生成-真随机数和伪随机数" tabindex="-1"><a class="header-anchor" href="#❓随机数生成-真随机数和伪随机数" aria-hidden="true">#</a> ❓随机数生成，真随机数和伪随机数</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>真随机数：从某种随机物理过程或现象产生的数，这些过程或现象完全是随机的。</p><blockquote><p>如放射性元素的衰变、电子噪声、大气噪声等。实际上，任何有着不确定行为的系统都有可能作为随机源。因为这种方式产生的随机数是基于物理现象，所以在理论上它是完全无法预测的。然而，真随机数生成器在实践中的使用有许多挑战，包括需要特殊的硬件、生成速度慢、难以进行测试和验证等。</p></blockquote></li><li><p>伪随机数：使用确定性算法生成的看起来“像随机”的数。</p><blockquote><p>这些算法通常是数学公式或模型，以便在给定的初始值(称为种子)下可以生成所需的随机数。伪随机数看起来像是随机的，因为没有明显的模式或顺序，但在现实中，如果知道用于生成它们的确切算法和种子值，就可以预测它们。但是，伪随机数生成器通常非常快速，而且可以产生几乎无限数量的随机数，这使得它们在许多应用中非常有用。</p></blockquote></li></ul><p>两者主要区别：在于预测性。真随机数的生成是由物理过程决定的，是不可预测的，而伪随机数是由算法生成的，在理论上是可以预测的。</p></details>',28);function f(g,_){const i=r("ExternalLinkIcon");return n(),t("div",null,[s(" more "),h,a("ul",null,[a("li",null,[c,a("a",u,[e("2020-06-30 面试中 LRU / LFU 的青铜与王者"),o(i)])])]),m])}const y=l(d,[["render",f],["__file","0x01.algorithm.html.vue"]]);export{y as default};

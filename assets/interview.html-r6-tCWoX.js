import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as o}from"./app-8at8Ga89.js";const e={},t=o(`<h1 id="ios-面试题" tabindex="-1"><a class="header-anchor" href="#ios-面试题" aria-hidden="true">#</a> <code>iOS</code> “面试题”</h1><h2 id="oc-swift" tabindex="-1"><a class="header-anchor" href="#oc-swift" aria-hidden="true">#</a> OC &amp; swift</h2><blockquote><p><code>block</code> 底层实现？</p></blockquote><p><code>block</code> 底层是使用结构体实现的。</p><p>根据内存分区不同，分为三种 <code>block</code></p><ul><li><code>__NSGlobalBlock__</code> : 全局 <code>block</code>，类似全局静态变量，存放在静态区</li><li><code>__NSStackBlock__</code> : 栈区 <code>block</code>，保存在栈区</li><li><code>__NSMallocBlock__</code> : 堆区 <code>block</code>，保存在堆区</li></ul><blockquote><p><code>KVO</code> 失效了怎么办？</p></blockquote><blockquote><p><code>Codable</code> 实现原理</p></blockquote><h2 id="xcode" tabindex="-1"><a class="header-anchor" href="#xcode" aria-hidden="true">#</a> Xcode</h2><blockquote><p><code>Xcode</code> 证书校验流程</p></blockquote><blockquote><p><code>Xcode</code> 打包流程</p></blockquote><h2 id="event-dispatch-事件分发" tabindex="-1"><a class="header-anchor" href="#event-dispatch-事件分发" aria-hidden="true">#</a> event dispatch - “事件分发”</h2><blockquote><p>用户点击屏幕上按钮，整个过程讲一下？</p></blockquote><h2 id="method-dispatch-方法派发" tabindex="-1"><a class="header-anchor" href="#method-dispatch-方法派发" aria-hidden="true">#</a> method dispatch - “方法派发”</h2><blockquote><p>以下代码输出？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Animail
<span class="token keyword">@end</span>
<span class="token keyword">@interface</span> Dog <span class="token punctuation">:</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Dog
<span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>init <span class="token punctuation">{</span>
    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">super</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="network-网络" tabindex="-1"><a class="header-anchor" href="#network-网络" aria-hidden="true">#</a> network - “网络”</h2><blockquote><p>如何解决两个网络请求之间的依赖?</p></blockquote><blockquote><p>如何优化网络？</p></blockquote><h2 id="memory-内存" tabindex="-1"><a class="header-anchor" href="#memory-内存" aria-hidden="true">#</a> memory - “内存”</h2><blockquote><p><code>OC</code> 中一个 <code>NSObject</code> 对象，占几个字节？</p></blockquote><p>一个 <code>NSObject</code> 对象应该就是存放这个对象的指针地址。一个指针的大小应该是占用 16 个直接。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Todo<span class="token punctuation">:</span> NSObject 
<span class="token punctuation">{</span>
   <span class="token keyword">int</span><span class="token punctuation">:</span> _no<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _title<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _detail<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>OC 中的 <code>Tagged Pointer</code> 了解吗？</p></blockquote><blockquote><p>如何使用 <code>UIImageView</code> 显示一个超大图片，并且支持缩放功能？</p></blockquote><p>由于 <code>UIImageView</code> 通过 <code>UIImage</code> 加载图片，是一次性将图片加载到内存，超大图片会引发内存不足的的问题。所以这个时候不能一次全部加载，需要使用分治思想，将图片像素点分块加载，只加载可视区域像素点。使用 <code>Tile Rendering</code> 的解决方案，类似家庭装修贴地砖的方式，先将图片像素按照一定的大小分割成 <code>Tile</code>，然后根据图片显示区域渲染。<code>CATiledLayer</code> 是一种适用于处理大量数据的渲染的 layer，适合处理这种情况。 缩放功能可以通过将 <code>UIImageView</code> 嵌套在 <code>UIScrollView</code> 里面，根据缩放的代理回调，进行 <code>Tile</code> 的重新绘制。</p><blockquote><p><code>C++</code> 中 <code>placement new</code> 特性，在 <code>OC</code> 中可以使用吗？</p></blockquote><p><code>placement new</code> : 是一种可以已分配内存的位置直接构造对象的特性，而这个已分配内存可以栈区也可以是堆区。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 栈内存</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 堆内存</span>
<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>OC</code> 是不具备这个特性，但是可以借助 <code>C</code> 语言分配内存。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// OC 常规方案</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Foo alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 C 分配内存</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>foo init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以下代码存在什么问题？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> INT_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Test alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>申请对象时，在 <code>ARC</code> 编译期间，会添加 <code>autorelease</code>，将申请的对象加入到自动释放池中。如果在一个自动释放池申请大量对象，那么对象的释放都需要等到这个这个自动释放所在的 <code>RunLoop</code> 休眠或结束时才能释放，申请大量对象时会造成内存泄漏。这种情况下，需要将 <code>@autoreleasepool</code> 加入到 <code>for</code> 循环里面。</p><blockquote><p>^ 如果将 <code>for</code> 循环改为 <code>enumerateObjectsUsingBlock</code> 会不会有问题？</p></blockquote><p>不会有问题，这是因为枚举器方法实现时，已经将 <code>block</code> 嵌套在 <code>@autoreleasepool</code> 中。</p><h2 id="thread-线程" tabindex="-1"><a class="header-anchor" href="#thread-线程" aria-hidden="true">#</a> thread - “线程”</h2><blockquote><p><code>atomic</code> 线程安全吗？</p></blockquote><blockquote><p>NSMutableArray 的线程安全性？</p></blockquote><blockquote><p>以下代码输出是什么？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil afterDelay<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test
<span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>iOS</code> 中如何创建一个常驻线程？</p></blockquote><h2 id="data-数据" tabindex="-1"><a class="header-anchor" href="#data-数据" aria-hidden="true">#</a> data - “数据”</h2><blockquote><p><code>FMDB</code> vs <code>CoreData</code> vs <code>SwiftData</code></p></blockquote><blockquote><p><code>CoreData</code> 的底层实现</p></blockquote><blockquote><p><code>SwiftData</code> 的底层实现</p></blockquote><h2 id="media-音视频" tabindex="-1"><a class="header-anchor" href="#media-音视频" aria-hidden="true">#</a> media - “音视频”</h2><blockquote><p>如何使用 <code>AVFoundation</code> 给视频添加水印？</p></blockquote><h2 id="optimization-优化" tabindex="-1"><a class="header-anchor" href="#optimization-优化" aria-hidden="true">#</a> optimization - “优化”</h2><blockquote><p><code>UITableView</code> 优化方案?</p></blockquote><ul><li>最核心的优化其实苹果已经帮我们做了，Cell 的复用机制，这个是标配。</li><li>对于不等高 Cell，缓存 Cell 高度应该基本操作，还可以配合高度预先计算一起使用。</li><li>Cell 内部的优化，就是比较通用的视图优化，图片圆角处理等。</li><li>滚动过程中，如果涉及 Cell 中数据刷新，比如图片下载，或者定时器刷新数据等。需要根据是否出现在屏幕中，进行网络请求的暂停，定时器的暂停等。</li></ul><blockquote><p>iOS 启动优化方案？</p></blockquote><blockquote><p>iOS 如何检测卡顿？</p></blockquote><blockquote><p>iOS 界面卡顿优化方案？</p></blockquote><h2 id="architecture-架构" tabindex="-1"><a class="header-anchor" href="#architecture-架构" aria-hidden="true">#</a> architecture - “架构”</h2><blockquote><p>组件化设计思路？</p></blockquote><p>组件化：有时也称为“模块化”。将一个大的业务功能，按照不同的功能模块进行拆分。</p><p>拆分原则：类似 <code>SOLID</code> 原则。 * 单一职责原则 : 拆分的功能模块应该尽量做到功能单一。 * 接口隔离原则 : 功能模块尽量做到对外暴露接口的最小化。</p><p>分层原则：网上有一个借用经典四象限法则来划分(以 <strong>业务相关</strong>、<strong><code>UI</code> 相关</strong> 作为两个轴线，来进行组件化分层) * 业务功能层 : 业务有关 &amp; <code>UI</code> 有关。用户看到的主要功能页面。 * 业务逻辑层 : 业务有关 &amp; <code>UI</code> 无关。在用户使用业务功能时，背后的处理逻辑。 * <code>UI</code> 层 : 业务无关 &amp; <code>UI</code> 有关。通用的 <code>UI</code> 页面，不关联具体的业务逻辑。 * 基础层 : 业务无关 &amp; <code>UI</code> 无关。通用的基础功能。</p><p>单向依赖原则：组件之间的依赖关系，应该做到上层依赖下层，下层不要依赖上层。</p><blockquote><p>下层组件需要调用上层组件怎样处理？</p></blockquote><p>方案一：依赖注入方式。下层组件定义好钩子函数，注册时，将上层组件注入下层组件定义好的钩子函数。</p><p>方案二：间接访问。通过底层的路由组件，将上层组件注册到路由表中，这样下层组件就可以通过路由间接访问到上层组件。</p>`,63),c=[t];function p(l,i){return a(),s("div",null,c)}const k=n(e,[["render",p],["__file","interview.html.vue"]]);export{k as default};

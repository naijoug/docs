import{_ as d}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as l,c as i,a as o,b as e,e as s,d as n,f as t}from"./app-RWDK11N-.js";const p={},r=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),s(" reference")],-1),u=e("a",{href:""},null,-1),k={href:"https://draveness.me/whys-the-design-mysql-b-plus-tree",target:"_blank",rel:"noopener noreferrer"},h=e("a",{href:""},null,-1),m={href:"https://draveness.me/whys-the-design-redis-bgsave-fork",target:"_blank",rel:"noopener noreferrer"},b=e("a",{href:""},null,-1),v={href:"https://draveness.me/whys-the-design-redis-single-thread",target:"_blank",rel:"noopener noreferrer"},y=t(`<hr><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h2><h3 id="❓数据库的三大范式" tabindex="-1"><a class="header-anchor" href="#❓数据库的三大范式" aria-hidden="true">#</a> ❓数据库的三大范式</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>数据库的三大范式，是数据库设计的基础理论，主要是为了解决数据冗余以及提高数据一致性和完整性。</p></blockquote><ul><li><p>第一范式(<code>1NF</code>)：具有原子性。要求数据库表的每一列都是不可分割的原子数据项，也就是说一个字段只能保存一种数据，不能像 <code>Excel</code> 那样在一个单元格里保存多个数据。</p></li><li><p>第二范式(<code>2NF</code>)：满足完全函数依赖。首先必须满足第一范式。其次，如果数据库表中有组合主键，要求非主键列必须完全依赖于全部主键，而不是部分主键。</p></li><li><p>第三范式(<code>3NF</code>)：消除传递依赖。首先必须满足第二范式。其次，非主属性必须直接依赖于主关键字，即如果诸如 <code>X -&gt; Y, Y -&gt; Z</code> 的关系，说明 <code>Z</code> 依赖于 <code>X</code>，那么在 <code>3NF</code> 中，<code>Z</code> 只能直接依赖于 <code>X</code>，而不能通过 <code>Y</code> 传递依赖。</p></li></ul><p>注：这三种范式是设计关系数据库表结构的基础理论，但是在实际工程设计中，为了追求更高的查询性能，通常会适当降低范式标准，引入一定的数据冗余。</p></details><h3 id="❓事务的四个特性" tabindex="-1"><a class="header-anchor" href="#❓事务的四个特性" aria-hidden="true">#</a> ❓事务的四个特性</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>在数据库中，事务（<code>Transaction</code>）具有四个基本的特性，常被称为 <code>ACID</code> 特性。</p></blockquote><ul><li><p>原子性（<code>Atomicity</code>）：事务是一个不可分割的工作单元，事务中包含的操作要么全做，要么全都不做。不可能做到一半，如果事务执行过程中出现错误，所有的修改都将被回滚，数据库状态将回到事务开始时的状态。</p></li><li><p>一致性（<code>Consistency</code>）：事务必须使数据库从一个一致性状态转换到另一个一致性状态。一致性状态指的是数据库在事务执行前后都满足一系列的约束条件。</p></li><li><p>隔离性（<code>Isolation</code>）：在并发环境下，一个事务的执行不会被其他事务干扰，即一个事务内部的操作及数据对并发的其他事务是隔离的，不会互相影响。</p></li><li><p>持久性（<code>Durability</code>）：一旦事务提交，它所做的修改将会永久保存到数据库中。即使系统出现崩溃，使用了持久化技术（常见的如写入磁盘、数据备份等）的系统，也能保证事务的持久性。</p></li></ul></details><h3 id="❓隔离性的四个实现级别" tabindex="-1"><a class="header-anchor" href="#❓隔离性的四个实现级别" aria-hidden="true">#</a> ❓隔离性的四个实现级别</h3><details class="hint-container details"><summary>💡</summary><p>四个级别从低到高分别是：</p><ul><li><p>读未提交（<code>Read Uncommitted</code>）：最低的隔离级别，事务中的修改，即使没有提交，其他事务也能看见，容易产生脏读、幻读和不可重复读。</p></li><li><p>读已提交（<code>Read Committed</code>）：较低的隔离级别，一个事务开始只能看见已提交事务所做的修改。这种隔离级别仍可能出现幻读和不可重复读。</p></li><li><p>可重复读（<code>Repeatable Read</code>）：中等的隔离级别，这种情况下，物理上并发事务的读操作不会读到本事务后续的写入。只有事务结束后，其他事务的写入才能被当前事务需读取到。但是可能出现幻读，因为幻读是针对一定范围的记录的。</p></li><li><p>串行化（<code>Serializable</code>）：最高的隔离级别，它要求事务串行执行，用排他锁来解决幻读问题（也解决了脏读和不可重复读的问题）。但串行处理性能差，这个级别一般不使用。</p></li></ul></details><hr><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="❓数据库建表的时候索引有什么用" tabindex="-1"><a class="header-anchor" href="#❓数据库建表的时候索引有什么用" aria-hidden="true">#</a> ❓数据库建表的时候索引有什么用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>索引是数据库中用于加速数据查询的数据结构。</p></blockquote><ul><li><p>提升查询性能：通过创建索引，数据库可以高效地查找、排序和连接表中的行。当对表进行查询时，如果没有索引，数据库需要遍历整个表（全表扫描）才能找到需要的数据，这将消耗大量的处理器和磁盘资源。但是如果有了索引，数据库在查找数据的时候就像在字典中查找单词那样快速，极大地提高了查询效率。</p></li><li><p>加速排序和分组操作：索引对于加快排序和行分组操作也很有用，因为在索引中的数据已经按照一定的顺序进行了排序，所以数据库可以利用这一特性加速这些操作。</p></li><li><p>保证数据的唯一性：通过在字段上创建唯一索引，可以确保整个表或某一列的数据的唯一性。</p></li><li><p>帮助服务器避免排序和临时表：在存在合适索引的情况下，<code>MySQL</code> 可以使用索引来找到数据，而无需进行排序和临时表的操作。</p></li><li><p>将随机 <code>IO</code> 变为顺序 <code>IO</code>：索引通常以 <code>B-Tree</code>（平衡多路查找树）或相关数据结构存储，这使得数据读取更趋近于顺序，而顺序 <code>IO</code> 相比随机 <code>IO</code> 拥有更好的性能。</p></li></ul><p>注意：虽然索引可以大大提高查询性能，但创建和维护索引也需要时间和存储空间，且过多不必要的索引会影响数据的插入、删除和更新操作的性能。因此，开发者需要根据实际的数据库使用情况设计和选择合适的索引。</p></details><h3 id="❓数据库索引的优缺点" tabindex="-1"><a class="header-anchor" href="#❓数据库索引的优缺点" aria-hidden="true">#</a> ❓数据库索引的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>索引的作用:</p><ul><li><p>提高查询效率: 索引的第一个并且是最重要的作用就是可以极大的提高数据的查询效率，这也是索引最初被设计出来的主要目的。</p></li><li><p>加速排序分组操作: <code>SQL</code> 语句在进行排序（<code>ORDER BY</code>）和分组（<code>GROUP BY</code>）等操作时，如果对应的字段建立了索引，那么效率会快很多。</p></li><li><p>提高表连接速度: 对于多表查询（<code>join</code>）语句，如果没有索引，那么每个表都会被执行一次全表扫描，所以数据量大的时候查询效率非常低。但如果建立了足够的索引，查询效果就会有明显提高。</p></li><li><p>强制数据的唯一性和完整性: 创建唯一性索引，可以保证数据库表中每一行数据的唯一性。也可以作为主键约束的一部分，确保主键的唯一性和完整性。</p></li></ul><p>索引的优点:</p><ul><li><p>所有的索引，包括与之相对的表，保持在物理上的有序，可以提升查询速度。</p></li><li><p>通过索引，我们可以在查询时使用优化隐藏器，借此改变数据读取的次数，获得更好的读取性能。</p></li><li><p>索引在任何时候都保持着与之相对的表同步。</p></li></ul><p>索引的缺点:</p><ul><li><p>索引需要占物理和数据存储空间，除了数据表空间，索引也需要占用一定的物理存储空间。如果数据表中需要建立的索引过多，索引文件可能会占用更多的存储空间。</p></li><li><p>索引不仅需要存储空间，还会影响数据库的性能。在插入和修改数据时，索引需要动态维护，这会消耗大量的系统资源，如 <code>CPU</code> 和 <code>IO</code>，并会对数据库的性能产生影响。而且，太多的索引也会使数据库在进行索引选择时消耗更多的时间。</p></li><li><p>虽然索引大大提高了查询速度，同时也降低了更新表的速度，如对表进行<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>。因为更新表时， <code>MySQL</code> 不仅要保存数据，还要保存一下索引文件。</p></li><li><p>索引可能导致数据重复，如果在一个大的表中创建了许多索引，这将需要更多的磁盘空间，并且可能产生大量的重复数据。</p></li></ul></details><h3 id="❓索引的底层结构" tabindex="-1"><a class="header-anchor" href="#❓索引的底层结构" aria-hidden="true">#</a> ❓索引的底层结构</h3><details class="hint-container details"><summary>💡</summary><p>在数据库系统中，索引的底层的几种数据结构：</p><ul><li><p><code>B树</code>（<code>Balance Tree</code>）：<code>B树</code> 是一种多路搜索树，可以有多个子节点。数据库系统中的索引大多使用 <code>B树</code>。<code>B树</code> 的路径平衡，查询效率稳定，大大提高了磁盘 <code>I/O</code> 性能。</p></li><li><p><code>B+树</code>：<code>B+树</code> 是 <code>B树</code> 的变种，所有数据记录都存储在叶子节点，同时叶子节点还按顺序链接，这样可以提供更高效的范围查询性能。<code>B+树</code> 是大多数关系型数据库使用的索引数据结构。</p></li><li><p>哈希表：哈希表是一种查找非常快速的数据结构，它通过一个哈希函数将数据映射到一个点上，实现了快速查找。但是哈希表不适合范围查询和排序查询。</p></li><li><p><code>Bitmap</code>（位图）：位图索引是一种特殊类型的索引，它通过位串来表示某一列中某一特定的值，对那些具有唯一值少的列效果更好。</p></li><li><p><code>LSM</code> 树（<code>Log-Structured Merge Tree</code>）：<code>LSM</code> 树是一种非常高效的写相关操作的数据结构，主要应用在 <code>KV</code> 数据库，如 <code>LevelDB</code>、<code>RocksDB</code> 等。</p></li></ul><p>注：常见的关系型数据库，如 <code>MySQL</code>、<code>Oracle</code> 和 <code>SQL Server</code>，主要采用 <code>B+树</code> 作为底层的索引结构。而非关系型数据库，如 <code>MongoDB</code>、<code>LevelDB</code> 等在一些场景下会选择使用 <code>LSM树</code> 等其他数据结构。</p></details><hr><h2 id="联表查询" tabindex="-1"><a class="header-anchor" href="#联表查询" aria-hidden="true">#</a> 联表查询</h2><h3 id="❓sql-中-join-常见用法" tabindex="-1"><a class="header-anchor" href="#❓sql-中-join-常见用法" aria-hidden="true">#</a> ❓<code>SQL</code> 中 <code>join</code> 常见用法</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>在 <code>SQL</code> 中，<code>JOIN</code> 子句用于将一个或多个表的记录组合在一起。</p></blockquote><ul><li><p><code>INNER JOIN</code>：返回两个表中具有匹配值的记录。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName 
<span class="token keyword">FROM</span> Orders
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Customers <span class="token keyword">ON</span> Orders<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>LEFT JOIN</code>（或 <code>LEFT OUTER JOIN</code>）：返回左表中的所有记录，以及右表中的匹配记录。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>RIGHT JOIN</code>（或 <code>RIGHT OUTER JOIN</code>）：返回右表中的所有记录，以及左表中的匹配记录。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName 
<span class="token keyword">FROM</span> Orders
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Customers <span class="token keyword">ON</span> Orders<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>FULL JOIN</code>（或 <code>FULL OUTER JOIN</code>）：返回左表和右表中的所有记录。如果有匹配的值，则返回匹配的值。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>CROSS JOIN</code>: 完全依赖采用笛卡尔积算法来返回列的所有可能组合。 即每一个左表中的记录与右表中的每一个记录都相结合。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Products<span class="token punctuation">.</span>ProductName 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> Products<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>SELF JOIN</code>: 用于将一个表与自身联接。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>CustomerName <span class="token keyword">AS</span> CustomerName1<span class="token punctuation">,</span> B<span class="token punctuation">.</span>CustomerName <span class="token keyword">AS</span> CustomerName2
<span class="token keyword">FROM</span> Customers A<span class="token punctuation">,</span> Customers B
<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span>CustomerID <span class="token operator">&lt;&gt;</span> B<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓sql-中的连表查询-left-join-与-right-join-的区别" tabindex="-1"><a class="header-anchor" href="#❓sql-中的连表查询-left-join-与-right-join-的区别" aria-hidden="true">#</a> ❓<code>SQL</code> 中的连表查询 <code>left join</code> 与 <code>right join</code> 的区别</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 是 SQL 中的两种连接（join）类型，它们都用于合并表中的行。</p></blockquote><p>主要区别：在于合并后结果集中包含哪些行。</p><ul><li><p><code>LEFT JOIN</code>：返回左表中的所有行，以及右表中与左表匹配的行。如果左表中的某行在右表中没有匹配行，则结果集中这一行的右表部分将包含 <code>NULL</code>。</p></li><li><p><code>RIGHT JOIN</code>：返回右表中的所有行，以及左表中与右表匹配的行。如果右表中的某行在左表中没有匹配行，则结果集中这一行的左表部分将包含 <code>NULL</code>。</p></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>? <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> : 左连
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span>

? <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> : 右连
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><h3 id="❓redis-雪崩-击穿-穿透分别是什么-如何避免" tabindex="-1"><a class="header-anchor" href="#❓redis-雪崩-击穿-穿透分别是什么-如何避免" aria-hidden="true">#</a> ❓<code>Redis</code> 雪崩，击穿，穿透分别是什么，如何避免</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>缓存雪崩：指缓存中大量的数据同时过期，导致大量的请求直接打到存储层，存储层的数据库呈现瞬间高并发并且处理超慢，引发一系列问题。</p><blockquote><p>解决方法：可以在缓存失效后，通过互斥锁或者队列来控制读数据库写缓存的线程数量。还可以把每个对象的过期时间都设置为随机，这样可以防止所有缓存同时更新，造成雪崩。</p></blockquote></li><li><p>缓存穿透：指查询一个一定不存在的数据，由于缓存不命中，而导致每次都会去请求数据库，就如同在缓存中穿出了一个洞。</p><blockquote><p>解决方法：首先将不存在的查询结果也进行缓存，但是设置一个很短的过期时间，最长不超过五分钟。其次，使用布隆过滤器，只允许已知存在的数据穿过去查询。</p></blockquote></li><li><p>缓存击穿：指一个存在的 <code>key</code>，在缓存过期的一刹那，同时有大量的请求，这些请求都会击穿到数据库。</p><blockquote><p>解决方法：设置热点数据永不过期。或者在进入缓存之前，设置互斥锁，防止多用户同时去查询数据库。</p></blockquote></li></ul></details><hr><h2 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h2><h3 id="❓sqlite-中的读写是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#❓sqlite-中的读写是线程安全的吗" aria-hidden="true">#</a> ❓<code>sqlite</code> 中的读写是线程安全的吗</h3><details class="hint-container details"><summary>💡</summary><p><code>SQLite</code> 本身支持多线程访问，但是线程安全性取决于在编译 <code>SQLite</code> 库时的设置。</p><p>配置选项：</p><ul><li><p><code>SQLITE_THREADSAFE=0</code> : 在非线程安全模式时，它不允许多线程访问，某些线程安全的假设就无法保证了。</p></li><li><p><code>SQLITE_THREADSAFE=1</code> : 在多线程模式下，可以被多个线程同时安全访问，但是每个线程都需要使用一个不同的数据库连接。</p></li><li><p><code>SQLITE_THREADSAFE=2</code> : 在序列化模式下，可以被多个线程同时使用，并且一个数据库连接也能在多个线程之间共享。</p></li></ul></details><hr><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2><h3 id="❓大量数据表的优化方案" tabindex="-1"><a class="header-anchor" href="#❓大量数据表的优化方案" aria-hidden="true">#</a> ❓大量数据表的优化方案</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>合理的表设计：清晰合理的表设计是高效数据库的基础。这包括合理的使用数据类型，避免过多列，规范化数据库等。</p></li><li><p>创建和使用索引：为常用查询列和 <code>join</code> 操作列创建索引可以大大提高数据库查询效率。在创建索引时要平衡查询效率和更新维护成本，避免过度索引。</p></li><li><p>数据分区：数据分区是一种将表的一部分行存储到独立的硬盘上的方式。通过数据分区，可以提高查询性能和管理便利性。</p></li><li><p>数据归档和清理：对于老旧和罕用的数据可以定期归档并从主数据库中删除，这样可以节省大量存储空间并提高整体性能。</p></li><li><p>使用缓存：使用缓存可以大大提高数据读取效率。对于查询结果集不常变动但访问频繁的数据可以缓存在内存中。</p></li><li><p><code>SQL</code> 查询优化：写出高效的 <code>SQL</code> 语句也很重要，尽量减少全表扫描，利用好索引等。</p></li><li><p>使用读写分离：在大数据量的情况下，一个数据库服务器可能无法同时处理大量的读和写请求。读写分离可以将读和写请求分散到不同的服务器，提高处理能力。</p></li><li><p>数据库表水平拆分：当单表数据量过大时，通过水平拆分可以将数据分散到多个物理表里，提高数据读写效率。</p></li></ul></details><hr><h2 id="情景题" tabindex="-1"><a class="header-anchor" href="#情景题" aria-hidden="true">#</a> 情景题</h2><h3 id="❓如果数据库的内容发生了改变-如何实现数据的迁移" tabindex="-1"><a class="header-anchor" href="#❓如果数据库的内容发生了改变-如何实现数据的迁移" aria-hidden="true">#</a> ❓如果数据库的内容发生了改变，如何实现数据的迁移</h3><details class="hint-container details"><summary>💡</summary><p>数据库的迁移通常是一个相对复杂的过程，要考虑到数据完整性，迁移过程中的服务可用性等多方面的问题。以下是一种常见的数据库迁移的步骤：</p><ol><li><p>备份当前数据库：首先，我们需要备份当前的数据库。在进行任何可能对数据产生影响的操作之前，都应当有备份的操作。</p></li><li><p>对新数据库进行初始化设置：新的数据库初次使用时需要进行一些初始化设置，例如设置适当的参数，建立合适的索引，等等。</p></li><li><p>导出数据：从原始数据库中导出需要迁移的数据。这一步可以使用数据库自带的导出工具或者使用一些第三方的工具。这步生成的文件通常为SQL数据脚本文件，可以用于在新的数据库中重建数据。</p></li><li><p>导入数据：将导出的数据导入到新的数据库中。这一步通常可以通过执行数据脚本文件来完成，具体操作视数据库的类型而定。</p></li><li><p>测试数据的一致性：在新数据库中运行一些查询或进行其他方式的测试，以确保新数据库中的数据和原数据库中的数据是一致的。</p></li><li><p>切换数据库：在确认新数据库工作良好后，可以将数据库切换到新的数据库。在实际操作中，可能需要停机维护一段时间，或者需要使用一些策略来减少服务中断的时间。</p></li><li><p>优化和监视：在迁移之后，我们可能需要进一步优化新的数据库，以使其性能达到最佳。此外，我们也需要监视新的数据库，确保其运行正常。</p></li></ol><p>整个迁移过程需要谨慎操作，确保每一步都没有问题，尤其是在生产环境中更是要确保每步操作的正确性，以免造成数据的丢失或者系统的中断。在进行迁移前，最好能在测试环境中完整地演练一遍，当无误后再进行生产环境的迁移。</p></details><h3 id="❓有两个数据库-每个数据库中又一张表-如何对这两张进行连表查询" tabindex="-1"><a class="header-anchor" href="#❓有两个数据库-每个数据库中又一张表-如何对这两张进行连表查询" aria-hidden="true">#</a> ❓有两个数据库，每个数据库中又一张表，如何对这两张进行连表查询</h3><details class="hint-container details"><summary>💡</summary><p>在SQL中，如果想要跨数据库进行联表查询，可以在指定表名的时候同时指定数据库名。以下是一个简单的示例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> database1<span class="token punctuation">.</span>table1 t1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> database2<span class="token punctuation">.</span>table2 t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个示例中<code>database1</code>是第一个数据库的名称，<code>table1</code>是该数据库中的表；<code>database2</code>是第二个数据库的名称，<code>table2</code>是在第二个数据库中的表。这个查询将这两个表进行了联接，联接的条件是这两个表中的<code>id</code>字段相等。</p><p>这只是一个简单的例子，实际的SQL查询可能会根据你的实际需求更复杂。同时，你必须确保在执行这个查询的数据库用户拥有对所有涉及的数据库和表的相应权限，否则这个查询可能会失败。</p></details><h3 id="❓两台服务器上的两个数据库-每个数据库中又一张表-如何对这两张进行连表查询" tabindex="-1"><a class="header-anchor" href="#❓两台服务器上的两个数据库-每个数据库中又一张表-如何对这两张进行连表查询" aria-hidden="true">#</a> ❓两台服务器上的两个数据库，每个数据库中又一张表，如何对这两张进行连表查询</h3><details class="hint-container details"><summary>💡</summary><p>在这个情况下，由于两个数据库位于不同的服务器上，这个过程将会有些复杂。并不是所有的数据库系统都支持跨服务器的查询。对于支持的数据库系统，你需要在服务器之间建立链接或者是设置分布式系统。</p><p>以SQL Server为例，你需要使用链接服务器（linked server）。一旦服务器链接成功，则可以跨服务器进行查询。例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Server1<span class="token punctuation">.</span>database1<span class="token punctuation">.</span>dbo<span class="token punctuation">.</span>table1 t1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Server2<span class="token punctuation">.</span>database2<span class="token punctuation">.</span>dbo<span class="token punctuation">.</span>table2 t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个查询语句的前提是<code>Server1</code>和<code>Server2</code>两台服务器已经链接成功。</p><p>对于MySql，你可能需要通过联邦存储引擎（FEDERATED Storage Engine）来实现。这个引擎可以让你在一个MySQL数据库中查询另一个MySQL服务器上的数据。</p><p>另外的方式是使用应用程序或者脚本来连接这两个服务器，然后分别查询每个服务器中数据库的数据，然后在应用程序中对查询结果进行组合。例如，在Python中，你可以使用<code>pandas</code>库来处理查询结果，进行数据合并。</p><p>需要注意的是，跨服务器查询数据可能会有性能问题，网络延迟，权限问题等等，因此，这种做法通常并不建议，在大多数情况下，最好避免让你的数据库跨越多个服务器。</p></details><h3 id="❓设计一套数据库方案-实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息-并展示对应数量-聊天记录的数据量较大" tabindex="-1"><a class="header-anchor" href="#❓设计一套数据库方案-实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息-并展示对应数量-聊天记录的数据量较大" aria-hidden="true">#</a> ❓设计一套数据库方案，实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息，并展示对应数量（聊天记录的数据量较大）</h3><details class="hint-container details"><summary>💡</summary><p>考虑到微信的聊天记录是较大的数据量，设计数据库方案时，我们需要将搜索效率和存储空间两方面都考虑进去。</p><p>首先，对于聊天记录的存储，我们无法避免要在某种程度上存储原始的聊天记录。我们可以设计一个<code>Message</code>表，其中包含<code>ID</code>（唯一标识每条记录）、<code>ChatID</code>（唯一标识每一个聊天会话）、<code>UserID</code>（发信人）、<code>Time</code>（发送时间）、<code>Content</code>（发送的内容）等字段。</p><p>然后，为了实现快速搜索，我们可以采用全文搜索（Full-Text Search）或者倒排索引（Inverted Index）的方式对Content字段建立索引。</p><ol><li><p>全文搜索：可以考虑使用数据库系统（如MySQL）自带的全文索引功能，或者第三方的全文搜索引擎（比如Elasticsearch）进行搜索。全文搜索会对Content字段的内容进行分词，并对分出来的词语建立索引，从而实现关键词的快速搜索。</p></li><li><p>倒排索引：自己为 <code>Content</code> 字段建立一个倒排索引系统。简单来说，就是将所有聊天记录中的每一个词语都拉出来，然后记录下每一个词语都在哪些聊天记录中出现过，这样搜索的时候只需要查找倒排索引表，就可以快速找到包含关键词的聊天记录。</p></li></ol><p>另外，如果需要支持模糊匹配，我们还可以考虑使用Trie树等数据结构实现。</p><p>至于展示对应数量，当我们利用索引快速找出包含某关键词的所有聊天记录后，只需要对返回结果进行计数即可。</p><p>最后，考虑到微信的规模，我们还需要合理分库分表，以满足大并发、海量数据的处理需求。另外，还要适时进行数据库的优化，保证数据库查询的性能。</p></details>`,44);function O(I,L){const a=c("ExternalLinkIcon");return l(),i("div",null,[o(" more "),r,e("ul",null,[e("li",null,[u,e("a",k,[s("2019-12-11 为什么 MySQL 使用 B+ 树"),n(a)])])]),o(" Redis "),e("ul",null,[e("li",null,[h,e("a",m,[s("2019-12-17 为什么 Redis 快照使用子进程"),n(a)])]),e("li",null,[b,e("a",v,[s("2019-10-18 为什么 Redis 选择单线程模型"),n(a)])])]),y])}const w=d(p,[["render",O],["__file","0x06.database.html.vue"]]);export{w as default};

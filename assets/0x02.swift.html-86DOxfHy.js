import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as p,c,a as l,b as n,e as s,d as e,f as i}from"./app-p8TZSqN4.js";const u="/docs/assets/swift-method-dispatch-TlCrGbQF.jpeg",d={},r=n("h2",{id:"reference",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),s(" reference")],-1),k=n("a",{href:"%E2%9C%85"},null,-1),m={href:"https://juejin.cn/post/6844904128188006413",target:"_blank",rel:"noopener noreferrer"},v=n("a",{href:"%E2%9C%85"},null,-1),b={href:"https://juejin.cn/post/6844904152951193608",target:"_blank",rel:"noopener noreferrer"},w=n("a",{href:""},null,-1),f={href:"https://swift.gg/2018/12/03/pop-vs-oop/",target:"_blank",rel:"noopener noreferrer"},h=n("a",{href:""},null,-1),y={href:"https://mp.weixin.qq.com/s/U95QmOOjeXkk-yC23cuZCQ",target:"_blank",rel:"noopener noreferrer"},g=n("a",{href:""},null,-1),q={href:"https://www.jianshu.com/p/c93d7a7d6771",target:"_blank",rel:"noopener noreferrer"},S=n("a",{href:""},null,-1),x={href:"https://juejin.cn/post/6844903459863412750?from=search-suggest#heading-5",target:"_blank",rel:"noopener noreferrer"},C=n("a",{href:""},null,-1),P={href:"https://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/",target:"_blank",rel:"noopener noreferrer"},I=i(`<hr><h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><h3 id="❓swift-为什么是-面向协议-的语言" tabindex="-1"><a class="header-anchor" href="#❓swift-为什么是-面向协议-的语言" aria-hidden="true">#</a> ❓<code>Swift</code> 为什么是“面向协议”的语言</h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓swift-中的-pop-与-oop-的区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-pop-与-oop-的区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>POP</code> 与 <code>OOP</code> 的区别</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>OOP</code>（面向对象编程）和 <code>POP</code>（面向协议编程）是两种不同的编程范式。</p></blockquote><p>主要区别：</p><ul><li><p>继承：</p><ul><li><code>OOP</code> 中，类（<code>Class</code>）是一种主要的构造，一个类可以继承另一个类的属性和方法。然而，继承可能引导进入“继承地狱”，即过度使用继承而导致的设计复杂性和代码冗余。</li><li><code>POP</code> 中，通过协议（<code>Protocol</code>）定义一组行为，类型可以遵守协议并实现协议所规定的行为。协议可以被任何类型（如类、结构体、枚举等）遵守，可以使用协议来代替类的继承。</li></ul></li><li><p>多态：</p><ul><li><code>OOP</code> 中，多态是通过继承和方法重写实现的。</li><li><code>POP</code> 中，多态是通过协议和扩展实现的。任何类型只要遵守同一个协议，就可以被视为同一种类型。通过协议扩展，可以提供默认实现或者添加新的功能。</li></ul></li><li><p>组合：</p><ul><li><code>OOP</code> 中，为了代码复用，可能需要设计复杂的类层次结构，而且 <code>Swift</code> 类不支持多继承，所以当功能跨多个类时可能会变得很麻烦。</li><li><code>POP</code> 中，类型可以遵守多个协议，每个协议可以代表一种功能或者特性，这使得类型的组合更为灵活。</li></ul></li></ul><p>注：在 <code>Swift</code> 中 <code>POP</code> 被广泛使用。比如 <code>Swift</code> 标准库的许多功能，如集合类型(<code>Array</code>, <code>Dictionary</code> 等)、数值类型（<code>Int</code>, <code>Double</code> 等）、<code>Comparable</code>、<code>Equatable</code> 等都是通过 <code>POP</code> 设计的。</p></details><h3 id="❓swift-对比-oc-的优点在哪里" tabindex="-1"><a class="header-anchor" href="#❓swift-对比-oc-的优点在哪里" aria-hidden="true">#</a> ❓<code>Swift</code> 对比 <code>OC</code> 的优点在哪里</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>简化的语法和语义：<code>Swift</code> 的语法更接近现代编程语言。</p><blockquote><p>比如使用 <code>let</code>声明常量，<code>var</code> 声明变量，可以省去 <code>;</code> 分号，同时它引入了元组和可选型概念，使代码更易读易写。</p></blockquote></li><li><p>安全性：<code>Swift</code> 有很多用于增加代码的稳定性和可读性的特性。</p><blockquote><p>例如，它的可选型系统可以清楚地处理 <code>nil</code> 值或者缺失值。</p></blockquote></li><li><p>易于维护：由于此语言淘汰了 <code>C</code> 语言的遗风，<code>Swift</code> 代码更易于理解和维护。另外，<code>Swift</code> 还取消了头文件的概念，代码更加紧凑。</p></li><li><p>提高性能：<code>Swift</code> 在某些性能上，比如 <code>GEMM</code> 算法，快速傅里叶变换等，已经可以达到 <code>C++</code> 的水平，这点在 <code>Objective-C</code> 上是难以想象的。</p></li><li><p>内存管理：<code>Swift</code> 使用 <code>ARC</code>，自动管理应用程序的内存，相对于 <code>OC</code> 更加便捷。</p></li><li><p>具有函数式编程的特性：<code>Swift</code> 不仅可以像 <code>Objective-C</code> 那样进行面向对象式编程，而且它还混入了函数式编程的一些概念，例如 <code>map</code> 和 <code>filter</code> 这样的函数。</p></li><li><p>交互性和可玩性：<code>Playgrounds</code> 是 <code>Swift</code> 的一项重要特性，它使得学习 <code>Swift</code> 更加有趣。</p></li><li><p>未来发展：<code>Swift</code> 是 <code>Apple</code> 官方推出和主导的编程语言，未来将会获得更好的支持和发展。</p></li></ul><p>总结：<code>Swift</code> 相比于 <code>Objective-C</code> 在语法的简洁性、代码的可读性、安全性、性能及未来的发展等多方面具有更大的优势。</p></details><hr><h2 id="结构体与类" tabindex="-1"><a class="header-anchor" href="#结构体与类" aria-hidden="true">#</a> 结构体与类</h2><h3 id="❓swift-结构体与类的区别" tabindex="-1"><a class="header-anchor" href="#❓swift-结构体与类的区别" aria-hidden="true">#</a> ❓<code>Swift</code> 结构体与类的区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>值类型和引用类型：结构体是值类型；类是引用类型。</p><p>一个结构体实例被赋值给一个新的变量或者作为一个函数的参数传递时，这个实例的拷贝会被创建出来，所以改变新变量中的值不会影响原来的实例。 一个类实例赋值实际上是传递了一个引用，所以修改赋值后的实例也会影响到原来的实例。</p></li><li><p>继承：结构体不能继承其他的结构体或者类；类可以继承其他的类。</p></li><li><p>类型转化：结构体不能；类可以被强制类型转换，可以使用 <code>is</code> 和 <code>as</code> 操作符在运行时检查实例的类型。</p></li><li><p>析构函数：结构体没有；类有析构函数，用来在类实例被销毁前执行特定的操作。</p></li><li><p>引用计数：结构体没有；类通过引用计数进行内存管理。</p></li><li><p>协议：类和结构体都可以实现协议，但是类可以利用某些特定的协议提供的运行时特性。</p></li></ul></details><h3 id="结构体" tabindex="-1"><a class="header-anchor" href="#结构体" aria-hidden="true">#</a> 结构体</h3><h4 id="❓swift-中-array、dictionary、set-为什么设计成值类型" tabindex="-1"><a class="header-anchor" href="#❓swift-中-array、dictionary、set-为什么设计成值类型" aria-hidden="true">#</a> ❓<code>Swift</code> 中 <code>Array</code>、<code>Dictionary</code>、<code>Set</code> 为什么设计成值类型</h4><details class="hint-container details"><summary>💡</summary><ul><li><p>语义清晰</p><blockquote><p>可以使赋值的语义更加清晰。当你把一个数组（或字典、集合）赋值给新的变量时，<code>Swift</code> 实际上会复制一份这个数组，这意味着新变量和旧变量之间不存在任何关联，对其中一个的改动不会影响到另一个。</p></blockquote></li><li><p>线程安全</p><blockquote><p>在涉及多线程操作的环境中，无需担心对数组（或字典、集合）的修改会潜在地影响到其他线程。有利于减少由竞态条件（race condition）导致的问题，并使得代码更加安全。</p></blockquote></li><li><p>性能优化</p><blockquote><p>虽然值类型在赋值时需要复制其数据，但 <code>Swift</code> 采用了一种被称为“写时复制”（copy-on-write）的优化策略。只有当数据真正需要被改动时，<code>Swift</code> 才会复制一份数据，避免了不必要的复制操作。</p></blockquote></li></ul></details><h4 id="❓cow-设计说一下" tabindex="-1"><a class="header-anchor" href="#❓cow-设计说一下" aria-hidden="true">#</a> ❓<code>cow</code> 设计说一下</h4><details class="hint-container details"><summary>💡</summary><p><code>cow</code> (Copy on Write) : <code>Swift</code> 的写时拷贝，也就是说数据只有等到赋值修改时才进行拷贝，主要应用在系统设计的值类型(<code>String</code>、<code>Array</code>、<code>Dictionary</code>)</p></details><h4 id="❓isknownuniquelyreferenced-实现自定义结构体-cow" tabindex="-1"><a class="header-anchor" href="#❓isknownuniquelyreferenced-实现自定义结构体-cow" aria-hidden="true">#</a> ❓<code>isKnownUniquelyReferenced</code> 实现自定义结构体 <code>cow</code></h4><details class="hint-container details"><summary>💡</summary><p><code>isKnownUniquelyReferenced</code> 函数可以用来检测是被被多个变量引用</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 数据包装类</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> wrapper<span class="token punctuation">:</span> <span class="token class-name">A</span>
  <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">self</span><span class="token punctuation">.</span>wrapper <span class="token operator">=</span> value 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">MyArray</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> storage<span class="token punctuation">:</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
  <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      storage <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/// 添加数据</span>
  <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">append</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为唯一的引用，如果不是，先创建副本对象，在进行添加修改</span>
      <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isKnownUniquelyReferenced</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          storage <span class="token operator">=</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span>wrapper<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      storage<span class="token punctuation">.</span>wapper<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h3><h4 id="❓swift-中的初始化方法" tabindex="-1"><a class="header-anchor" href="#❓swift-中的初始化方法" aria-hidden="true">#</a> ❓<code>Swift</code> 中的初始化方法</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>初始化方法是用来确保类型实例中的所有存储属性都被赋予初始值的特殊方法。</p></blockquote><p><code>Swift</code> 的初始化过程中有两个阶段：</p><ul><li>第一阶段是为每个存储型属性设置初始值。当每个存储型属性的初始值被确定后</li><li>第二阶段开始，它允许人们可以自定义他们的存储型属性。</li></ul><p><code>Swift</code> 的构造器分为两种：指定构造器和便利构造器。</p><ul><li>指定构造器：类中最主要的构造器，一个类必须拥有至少一个指定构造器。</li><li>便利构造器：类中比较次要的，辅助型的构造器。它通常在为某个特定使用场景或者特定输入值提供构造方便。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>

    <span class="token comment">// 指定构造器</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 便利构造器</span>
    <span class="token keyword">convenience</span> <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;[Unnamed]&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h4 id="❓static-和-class-的区别" tabindex="-1"><a class="header-anchor" href="#❓static-和-class-的区别" aria-hidden="true">#</a> ❓<code>static</code> 和 <code>class</code> 的区别</h4><details class="hint-container details"><summary>💡</summary><p><code>static</code> 和 <code>class</code> 都可以用来声明类型级别的方法或属性。</p><ul><li><p><code>static</code> 可以用于类、结构体和枚举，声明静态方法和静态属性。对于静态方法和属性，无论是在类还是在类的实例中，都是共享同一个存储空间。对于使用 <code>static</code> 声明的计算属性或方法，无法在子类中进行重写。这是因为 <code>static</code> 声明的属性和方法被绑定到了它们被声明的类型上。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">var</span> myStaticProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>class</code> 关键字只能用于类，用于声明类方法和类属性。使用 <code>class</code> 关键字标记的计算属性或者方法可以在子类中进行重写。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">MySuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token keyword">var</span> myClassProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MySubClass</span><span class="token punctuation">:</span> <span class="token class-name">MySuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">class</span> <span class="token keyword">var</span> myClassProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓swift-中的-final-作用" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-final-作用" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>final</code> 作用</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>final</code> 关键字用于防止一个类被继承，或者防止一个方法、属性或下标方法被一个子类重写。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 1&gt; 防止类被继承</span>
<span class="token comment">// 如果一个类为 final，那么该类中所有的方法、属性以及下标方法都将被自动标记为 final。</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token comment">// class definition here</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2&gt; 防止方法被子类重写</span>
    <span class="token keyword">final</span> <span class="token keyword">func</span> <span class="token function-definition function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// method body here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>final</code> 的主要目的：一是提高性能（编译器可以优化 <code>final</code> 方法或类的调用），二是表达设计意图（不希望、也不需要子类去重写或者继承）。</p></details><h4 id="❓super-在-oc-和-swift-的区别" tabindex="-1"><a class="header-anchor" href="#❓super-在-oc-和-swift-的区别" aria-hidden="true">#</a> ❓<code>super</code> 在 <code>OC</code> 和 <code>Swift</code> 的区别</h4><details class="hint-container details"><summary>💡</summary></details><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h3><h4 id="❓存储属性与计算属性区别" tabindex="-1"><a class="header-anchor" href="#❓存储属性与计算属性区别" aria-hidden="true">#</a> ❓存储属性与计算属性区别</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>存储属性</strong>：顾名思义，存储属性是某个特定类或结构体实例所存储的一个值，如 <code>Int、String、Double</code> 类型的常量或变量。这个值可能是定义时直接赋值的，也可能是在初始化时赋值。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// Point 结构体有两个存储属性 x 和 y。</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0.0</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">0.0</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">5.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">5.0</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>计算属性</strong>：计算属性并不直接存储值，而是提供一个 <code>getter</code> 和一个可选的 <code>setter</code> 来间接获取和设置其他属性或者变量的值。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> width <span class="token operator">=</span> <span class="token number">0.0</span>
    <span class="token keyword">var</span> height <span class="token operator">=</span> <span class="token number">0.0</span>

    <span class="token comment">// Rectangle 结构体有一个计算属性 area</span>
    <span class="token keyword">var</span> area<span class="token punctuation">:</span> <span class="token class-name">Double</span> <span class="token punctuation">{</span>
        <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token comment">// 通过 width 和 height 计算得来</span>
            <span class="token keyword">return</span> width <span class="token operator">*</span> height
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span> <span class="token punctuation">{</span> <span class="token comment">// 可以通过设置 area 的值间接修改 width 和 height 的值</span>
            width <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
            height <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><blockquote><p>总结：存储属性是存储在特定类或结构体实例中的一个常量或变量；计算属性则是通过计算得到的一个值。</p></blockquote></details><h4 id="❓swift-中的属性修饰符" tabindex="-1"><a class="header-anchor" href="#❓swift-中的属性修饰符" aria-hidden="true">#</a> ❓<code>Swift</code> 中的属性修饰符</h4><details class="hint-container details"><summary>💡</summary><ul><li><p>访问权限修饰符：</p><ul><li><code>private</code>：私有属性，只能在属性所在的类或结构体中访问。</li><li><code>fileprivate</code>：文件私有属性，只能在该属性所在的文件范围内访问。</li><li><code>internal</code>：内部属性，可以在整个模块（例如一个 <code>App</code> 或者一个 <code>Framework</code>）内访问，这是默认的访问级别。</li><li><code>public</code>：公开属性，可以被任何人访问，但在别的模块中不能被 <code>override</code> 和继承。</li><li><code>open</code>：开放属性，可以被任何人使用，也可以在别的模块中被 <code>override</code> 和继承。</li></ul></li><li><p>内存管理修饰符</p><ul><li><code>weak</code>：用于解决循环引用的问题，被修饰的属性在引用的对象被销毁后将自动被设为 <code>nil</code>。</li><li><code>unowned</code>：和 <code>weak</code> 类似，也用于解决循环引用的问题，但被修饰的属性在引用的对象被销毁后不会被设为 <code>nil</code>，因此在使用时需要确保该对象仍然存在，否则会出现运行时错误。</li></ul></li><li><p>功能修饰符</p><ul><li><code>lazy</code>：延迟加载的属性，它的值将在第一次访问时才被计算并存储。</li><li><code>dynamic</code>：可以让该属性在运行时动态查找，主要用于 <code>Objective-C</code> 和 <code>Swift</code> 的互操作。</li></ul></li><li><p>特性修饰符</p><ul><li><code>@IBOutlet</code>：用于 <code>Interface Builder</code> 中的属性的连接。</li><li><code>@propertyWrapper</code>：用于自定义属性包装器，通过包装器可以定义属性值的存储方式和逻辑。</li><li><code>@Published</code>：用于自动为属性生成将会发送属性最新值的 <code>publisher</code>。</li></ul></li></ul></details><h4 id="❓延迟存储属性" tabindex="-1"><a class="header-anchor" href="#❓延迟存储属性" aria-hidden="true">#</a> ❓延迟存储属性</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>延迟存储属性（<code>Lazy Stored Properties</code>）是指当属性首次被调用时才计算其初始值的属性。在属性声明前添加 <code>lazy</code> 关键字来表示一个延迟存储属性。</p></blockquote><p>使用场景：</p><ul><li>属性初始化消耗大，但又可能不会被用到。</li><li>属性的值依赖于实例的其他属性，但是又需要在实例完全初始化以后才能获取。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">DataImporter</span> <span class="token punctuation">{</span>
    
    <span class="token comment">/*
    DataImporter 是一个负责将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */</span>
    <span class="token keyword">var</span> fileName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;data.txt&quot;</span></span>
    <span class="token comment">// 导入数据的代码......</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DataManager</span> <span class="token punctuation">{</span>
    <span class="token keyword">lazy</span> <span class="token keyword">var</span> importer <span class="token operator">=</span> <span class="token class-name">DataImporter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 其他数据管理代码......</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> manager <span class="token operator">=</span> <span class="token class-name">DataManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
manager<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Some data&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// &#39;importer&#39; 属性尚未被创建</span>
<span class="token function">print</span><span class="token punctuation">(</span>manager<span class="token punctuation">.</span>importer<span class="token punctuation">.</span>fileName<span class="token punctuation">)</span>
<span class="token comment">// &#39;importer&#39; 属性现在被创建了</span>
<span class="token comment">// 输出 &quot;data.txt”</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h2><h3 id="❓swift-中的-string-的设计理念" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-string-的设计理念" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>String</code> 的设计理念</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>设计理念：安全、简洁、现代、易用。</p></blockquote><ul><li><p>安全性：字符串被设计为值类型；无法通过下标索引来访问字符，需要使用 <code>String.Index</code> 类型的索引进行字符串的访问和操作。</p></li><li><p>简洁性：主要体现在内置的字符串相关 <code>API</code> 上，简化了 <code>OC</code> 遗留的接口名称冗长的问题。</p></li><li><p>现地化：支持 <code>Unicode</code>，可以处理多样化的文本内容。这是因为在 <code>Swift</code> 中 <code>String</code> 类型以 <code>UTF-16</code> 的形式存储。</p></li><li><p>易用性：可以跟一般的基本类型值一样，直接进行“+”、“+=”运算符的操作，还有各种内置的处理字符串的 <code>API</code>，如：大小写转化，去除前后空格等。</p></li></ul></details><h3 id="❓为什么-swift-将-string-设计为不能通过索引访问" tabindex="-1"><a class="header-anchor" href="#❓为什么-swift-将-string-设计为不能通过索引访问" aria-hidden="true">#</a> ❓为什么 <code>Swift</code> 将 <code>String</code> 设计为不能通过索引访问</h3><details class="hint-container details"><summary>💡</summary><p>因为 <code>Swift</code> 中的 <code>String</code> 兼容 <code>Unicode</code> 字符串的。</p><p>在 <code>Unicode</code> 中，字符的长度可能是不一致的（例如，某些 <code>emoji</code> 表情字符由多个 <code>Unicode</code> 组成），所以采用整数索引可能会将字符串截断，导致字符不完整，甚至导致崩溃。</p></details><h3 id="❓如何评价-string-的索引设计" tabindex="-1"><a class="header-anchor" href="#❓如何评价-string-的索引设计" aria-hidden="true">#</a> ❓如何评价 <code>String</code> 的索引设计</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Swift</code> 中 <code>String</code> 的索引设计是为了处理 <code>Unicode</code> 字符串的复杂性。</p><p>字符串是由 <code>Unicode</code> 字符组成的，而 <code>Unicode</code> 字符的长度是不固定的。有的 <code>Unicode</code> 字符可能由一个 <code>Unicode</code> 标量（scalar）构成，而有的 <code>Unicode</code> 字符可能由多个 <code>Unicode</code> 标量构成。还有一种情况是，一个可视字符可能由多个 <code>Unicode</code> 字符构成，例如带重音的字母。</p><p>因此在 <code>Swift</code> 中，<code>String</code> 的索引不能简单地用整数表示。如果用整数表示，会导致取字符的操作成为一个 <code>O(n)</code> 时间复杂度的操作，因为必须从头开始遍历字符串获得指定索引的字符。此外，由于 <code>Unicode</code> 字符长度的不固定性，如果用整数做索引还可能会造成索引越界的错误。</p><p>为了解决这些问题，<code>Swift</code> 设计了 <code>String.Index</code> 来作为字符串的索引。<code>String.Index</code> 封装了对底层字符串存储的访问，可以高效且安全地进行字符的访问。只能通过特定的方法(比如<code>index(after:)</code>或者<code>index(before:)</code>等)来操作索引，这有助于保证字符串的访问安全性。</p><p>虽然这种设计使得处理字符串的索引变得稍微有些繁琐，但是却能有效地处理 <code>Unicode</code> 字符串的复杂性，保证字符串操作的安全性和效率，避免了诸多常见的错误。所以，可以说 <code>String</code> 的索引设计是非常优秀和切实可行的。</p></details><hr><h2 id="枚举" tabindex="-1"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h2><h3 id="❓swift-中的枚举和其它编程语言的区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的枚举和其它编程语言的区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的枚举和其它编程语言的区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>关联值：枚举成员可以与任意类型的值进行关联存储，叫做关联值（<code>Associated Values</code>）；每个枚举成员的关联值类型可以是不同的。</p></li><li><p>方法：与结构体和类一样，枚举也可以定义方法，在枚举值实例上调用的方法功能；</p></li><li><p>构造函数：可以提供构造函数，用以提供一个带有默认枚举值的实例。</p></li><li><p>递归枚举：如果枚举的一种 <code>case</code> 持有该枚举类型的关联值，那么这个枚举就是递归枚举。</p></li><li><p>模式匹配：枚举值和 <code>switch</code> 语句一起使用时，可以进行模式匹配，包括获取枚举值关联值，或者多个 <code>case</code> 值一起匹配。</p></li></ul></details><h3 id="❓swift-中的-switch-和其它编程语言有什么区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-switch-和其它编程语言有什么区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>switch</code> 和其它编程语言有什么区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>模式匹配：可以进行复杂的模式匹配，包括元组、范围匹配以及关联枚举值等。</p></li><li><p>无需 <code>break</code>：其他编程语言中，如<code>C</code>语言每个 <code>case</code> 后面都需要添加 <code>break</code> 关键字以退出 <code>switch</code> 否则将会发生贯穿现象。在 <code>Swift</code> 中每个 <code>case</code> 后面不需要添加 <code>break</code>，当遇到符合的 <code>case</code> 后程序会直接退出 <code>switch</code> 语句。</p></li><li><p>绑定常量和变量：在一个 <code>case</code> 的语句中，可以用 <code>let</code> 或者 <code>var</code> 来绑定匹配到的值到临时的常量或变量中。</p></li></ul></details><h3 id="❓模式匹配深入说一下" tabindex="-1"><a class="header-anchor" href="#❓模式匹配深入说一下" aria-hidden="true">#</a> ❓模式匹配深入说一下</h3><details class="hint-container details"><summary>💡</summary><p><code>Swift</code> 的模式匹配非常灵活且强大，它不仅可以使用在 <code>switch</code> 语句中，还可用在 <code>if、while、guard</code> 语句中，以及 <code>for-in</code> 循环和类型转换。</p><ul><li><p><strong>通配符模式（Wildcard Pattern）</strong>： 使用 <code>_</code> 表示，匹配任何值，但不绑定该值。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token omit keyword">_</span> <span class="token operator">=</span> someValue <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;This will always be true!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>标识符模式（Identifier Pattern）</strong> 匹配任何值并赋值给一个常量或者变量。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token operator">=</span> someValue <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;Value is 42&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>值绑定模式（Value-Binding Pattern）：</strong> 将匹配的值绑定给一个变量或常量。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> point <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> point <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The point is at (</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">x</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">y</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;The point is at (3, 2)&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>元组模式（Tuple Pattern）：</strong> 用来匹配元组。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">in</span> points <span class="token keyword">where</span> x <span class="token operator">==</span> y <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Matched point (</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">x</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">y</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;Matched point (0, 0)&quot;, &quot;Matched point (1, 1)&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>枚举用例模式（Enumeration Case Pattern）：</strong> 匹配枚举的某个 <code>case</code>。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">enum</span> <span class="token class-name">Direction</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> north<span class="token punctuation">,</span> south<span class="token punctuation">,</span> east<span class="token punctuation">,</span> west
<span class="token punctuation">}</span>

<span class="token keyword">let</span> heading<span class="token punctuation">:</span> <span class="token class-name">Direction</span> <span class="token operator">=</span> <span class="token punctuation">.</span>north
<span class="token keyword">if</span> <span class="token punctuation">.</span>north <span class="token operator">=</span> heading <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;We&#39;re heading north!&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;We&#39;re heading north!&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>类型转换模式：</strong> 检查一个值是否为某个类型，如果是的话绑定为那个类型的常量或变量。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token keyword">as</span> <span class="token class-name">Int</span> <span class="token operator">=</span> someValue <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value as an integer is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;Value as an integer is 42&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>可选模式（Optional Pattern）：</strong> 用来匹配可选值。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> someOptional<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token keyword">some</span><span class="token punctuation">(</span><span class="token keyword">let</span> value<span class="token punctuation">)</span> <span class="token operator">=</span> someOptional <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;Value is 42&quot;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用语法糖</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token operator">=</span> someOptional <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>  <span class="token comment">// &quot;Value is 42&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓fallthrough-的作用" tabindex="-1"><a class="header-anchor" href="#❓fallthrough-的作用" aria-hidden="true">#</a> ❓<code>fallthrough</code> 的作用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>fallthrough</code> 在 <code>Swift</code> 中用于显式地允许在 <code>switch</code> 语句的一个 <code>case</code> 分支执行完毕后，直接连续地执行下一个 <code>case</code> 分支，而不管下一个 <code>case</code> 是否满足匹配条件。使用 <code>fallthrough</code> 就像破坏 <code>case</code> 的边界，使得代码的控制流能够“穿透”到下一个 <code>case</code> 中去。</p></blockquote><p>一般情况下，当 Swift 的 <code>switch</code> 语句匹配到某个 <code>case</code> 后，就会执行该 <code>case</code> 中的语句并退出 <code>switch</code> 语句。如果你希望在一个 <code>case</code> 执行完毕后还能继续执行下一个 <code>case</code>，可以使用 <code>fallthrough</code> 关键字。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> integerToDescribe <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">var</span> description <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;The number </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">integerToDescribe</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> is&quot;</span></span>

<span class="token keyword">switch</span> integerToDescribe <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">:</span>
    description <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">&quot; a prime number, and also&quot;</span></span>
    <span class="token keyword">fallthrough</span>
<span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token comment">// fallthrough 使得控制流连续地执行了 default 分支</span>
    description <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">&quot; an integer.&quot;</span></span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span>description<span class="token punctuation">)</span>
<span class="token comment">// 输出 &quot;The number 5 is a prime number, and also an integer.&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="可选类型" tabindex="-1"><a class="header-anchor" href="#可选类型" aria-hidden="true">#</a> 可选类型</h2><h3 id="❓swift-可选类型-optional-了解吗" tabindex="-1"><a class="header-anchor" href="#❓swift-可选类型-optional-了解吗" aria-hidden="true">#</a> ❓<code>Swift</code> 可选类型 <code>Optional</code> 了解吗</h3><details class="hint-container details"><summary>💡</summary><p><code>Optional</code> 是一个非常重要的特性，它指的是变量或常量可能完全没有值，或者说变量或常量的值可能为空。</p><p><code>Swift</code> 使用 <code>Optional</code> 来处理值可能为 <code>nil</code> 的情况。这与 <code>Objective-C</code> 不同，因为 <code>Objective-C</code> 中任何对象类型都可以被设定为 <code>nil</code>，而基本类型则不能。在 <code>Swift</code> 中，可选类型可以用于所有类型，包括基本类型和自定义类型。</p><p>声明一个 <code>Optional</code> 类型的语法是在类型后面加上一个问号 <code>?</code>。</p><p>解包有两种方式：</p><ul><li>强制解包，使用感叹号 <code>!</code></li><li>可选型绑定，使用 <code>if let</code> 或者 <code>guard let</code>。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 声明可选字符串</span>
<span class="token keyword">var</span> myString<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Hello, Swift!&quot;</span></span>

<span class="token keyword">if</span> <span class="token keyword">let</span> actualString <span class="token operator">=</span> myString <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The string has - </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">actualString</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The string does not have a value&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>使用 <code>Optional</code> 类型时，需要注意安全地解包，以避免出现 <code>nil</code> 值导致的运行时错误。而这恰恰是 <code>Swift</code> 使用 <code>Optional</code> 的一个关键理念，就是让潜在的 <code>nil</code> 更明显，从而提升程序的安全性。</p></blockquote></details><h3 id="❓为什么-swift-中要引入一个可选类型" tabindex="-1"><a class="header-anchor" href="#❓为什么-swift-中要引入一个可选类型" aria-hidden="true">#</a> ❓为什么 <code>Swift</code> 中要引入一个可选类型</h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓optional-可选类型的底层实现" tabindex="-1"><a class="header-anchor" href="#❓optional-可选类型的底层实现" aria-hidden="true">#</a> ❓<code>Optional</code> 可选类型的底层实现</h3><details class="hint-container details"><summary>💡</summary><p>与 <code>Objective-C</code> 中的 <code>nil</code> 略有不同，因为 <code>Swift</code> 中的 <code>nil</code> 不是一个指针，而是一个表示没有值的状态。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">Wrapped</span><span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByNilLiteral</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token keyword">none</span>           <span class="token comment">// 表示没有值 nil</span>
  <span class="token keyword">case</span> <span class="token keyword">some</span><span class="token punctuation">(</span><span class="token class-name">Wrapped</span><span class="token punctuation">)</span>  <span class="token comment">// 表示有值</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓swift-统一类型的变量可选值与非可选值内存有什么区别" tabindex="-1"><a class="header-anchor" href="#❓swift-统一类型的变量可选值与非可选值内存有什么区别" aria-hidden="true">#</a> ❓<code>Swift</code> 统一类型的变量可选值与非可选值内存有什么区别</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Swift</code> 中，可选值（<code>Optional</code>）实际上是一个枚举类型</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">enum</span> <span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">Wrapped</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token keyword">none</span>           <span class="token comment">// 表示没有值</span>
    <span class="token keyword">case</span> <span class="token keyword">some</span><span class="token punctuation">(</span><span class="token class-name">Wrapped</span><span class="token punctuation">)</span>  <span class="token comment">// 表示有值</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：可选值在内存上比非可选值多了一层枚举的信息，一般情况下，多出的这一层需要一些额外的内存来存储枚举的状态（<code>none</code>或<code>some</code>）。具体多出多少内存，取决于特定的枚举类型和编译器的优化。在可选值为 <code>none</code> 的状态下，也就是 <code>nil</code> 的情况下，可选值因为没有需要存储的值，所以在内存中一般只需要存储枚举的状态。</p></details><hr><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><h3 id="❓swift-中的闭包" tabindex="-1"><a class="header-anchor" href="#❓swift-中的闭包" aria-hidden="true">#</a> ❓<code>Swift</code> 中的闭包</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>非逃逸闭包</p><blockquote><p>闭包作为函数参数，在函数返回之前，这个闭包已经执行，则为非逃逸闭包。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithNonescapingClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>逃逸闭包</p><blockquote><p>闭包作为函数参数传入函数，如果这个闭包在函数返回之后再执行，则为逃逸闭包，闭包参数需要使用 <code>@escaping</code> 修饰。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> completionHandlers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithEscapingClosure</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    completionHandlers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>尾随闭包</p><blockquote><p>将闭包作为函数的最后一个参数，函数调用时，闭包参数就是一个写在尾随函数调用后面的一个闭包表达式。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数体部分</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以下是不使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 闭包主体部分</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 以下是使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尾随闭包主体部分</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>自动闭包</p><blockquote><p>需要一个不接受参数的闭包作为函数参数，使用 <code>@autoclosure</code> 修饰。用作闭包表达式的延迟加载，只有当闭包表达式真正调用时才执行。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> customersInLine <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Chris&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Alex&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;John&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Jessie&quot;</span></span><span class="token punctuation">]</span>
<span class="token keyword">let</span> customerProvider <span class="token operator">=</span> <span class="token punctuation">{</span> customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Now serving </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token function">customerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓-escaping-vs-autoclosure" tabindex="-1"><a class="header-anchor" href="#❓-escaping-vs-autoclosure" aria-hidden="true">#</a> ❓<code>@escaping</code> vs <code>@autoclosure</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>@escaping</code>：用于指示一个闭包参数可以“逃逸”出函数。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> completionHandlers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  
<span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithEscapingClosure</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有被标记为 @escaping，将无法将其存储在函数外部。</span>
    completionHandlers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>@autoclosure</code>：用于自动创建一个闭包来封装传入的表达式。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">logIfTrue</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> predicate<span class="token punctuation">:</span> <span class="token attribute atrule">@autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token function">predicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;True&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 可以把一个表达式当作闭包来调用</span>
<span class="token function">logIfTrue</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 打印 &quot;True&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><hr><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><h3 id="❓swift-函数派发机制" tabindex="-1"><a class="header-anchor" href="#❓swift-函数派发机制" aria-hidden="true">#</a> ❓<code>Swift</code> 函数派发机制</h3><details class="hint-container details"><summary>💡</summary><p>派发方式 :</p><ul><li>静态派发</li><li>动态派发 <ul><li>函数表派发 : 基于 <code>VTable</code> (Virtual Method Table)</li><li>消息派发 : 基于 <code>OC</code> 运行时机制</li></ul></li></ul><p>派发效率 : <code>静态派发</code> &gt; <code>函数表派发</code> &gt; <code>消息派发</code></p><ul><li><p>静态派发 : <code>swift</code> 中大多数类型被设计为值类型(<code>struct</code>、<code>enum</code>)，值类型的方法都是静态派发。如果是 <code>final</code> 修饰引用类型也是静态派发。<code>extension</code> 中的方法也是静态派发。</p><blockquote><p>通过 <code>function_ref</code> 指令调用方法。</p></blockquote></li><li><p>函数表派发 : 属于动态派发，对于引用类型，不是 <code>extension</code> 中的方法是通过 <code>VTable</code>(Virtual Method Table) 虚方法表进行派发。还存在一中 <code>WTable</code>(Witness Table) 见证者表，用于保存引用类型实现的协议方法。</p><blockquote><p>通过 <code>class_method</code> 指令调用方法。</p></blockquote></li><li><p>消息转发 : 属于动态派发，使用 <code>@objc</code> 和 <code>dynamic</code> 修饰的方法通过消息转发。仅通过 <code>@objc</code> 修饰的方法，不会改变派发方式，仅生成一个可供 <code>OC</code> 使用的方法。</p><blockquote><p>通过 <code>objc_method</code> 指令调用方法。</p></blockquote></li></ul><p>| 类型 | 直接派发 | 函数表派发 | 消息派发 | --- | --- | <code>struct</code> | 所有方法 | 无 | 无 | <code>class</code> | 扩展方法 | 初始化定义方法 | 无 | <code>protocol</code> | 扩展方法 | 初始化定义方法 | <code>@objc</code></p><figure><img src="`+u+`" alt="swift-method-dispatch" tabindex="0" loading="lazy"><figcaption>swift-method-dispatch</figcaption></figure></details><h3 id="❓inout-关键字做了什么" tabindex="-1"><a class="header-anchor" href="#❓inout-关键字做了什么" aria-hidden="true">#</a> ❓<code>inout</code> 关键字做了什么</h3><details class="hint-container details"><summary>💡</summary><p><code>inout</code> 可以让函数、方法或者运算符可以改变传入参数的值。</p><p>在 <code>Swift</code> 中，标量类型（如<code>Int</code>，<code>Double</code>，<code>Bool</code>，<code>String</code>等）和结构体，枚举都是值类型（value type）, 也就是在函数内部改变这些参数并不会影响到函数外部的值，因为传递的是值的拷贝。</p><p><code>inout</code> 关键字允许函数修改外部变量的值。本质上，它将值传递给函数，并将函数返回后的值复制回原始变量。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">+=</span> <span class="token number">1</span>
  <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token comment">// 1</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓mutating-关键字的作用" tabindex="-1"><a class="header-anchor" href="#❓mutating-关键字的作用" aria-hidden="true">#</a> ❓<code>mutating</code> 关键字的作用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>mutating</code> 是 <code>Swift</code> 中的一个关键字，只能用在结构体和枚举的方法中。它的作用是允许该方法修改结构体或枚举的 <code>variables</code> 或 <code>properties</code>。默认情况下，值类型的属性不能在其实例方法中被修改（因为值类型在传递和赋值时会被复制）。当在方法前面加了 <code>mutating</code> 关键字，那么就能在这个方法中修改它的属性，且这个改动会在方法结束后保持。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 结构体使用 mutating</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment">// 移动点到另一个坐标</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">moveBy</span><span class="token punctuation">(</span>x deltaX<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y deltaY<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">+=</span> deltaX
        y <span class="token operator">+=</span> deltaY
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span>
point<span class="token punctuation">.</span><span class="token function">moveBy</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span> <span class="token comment">// Point(x: 3, y: 4)</span>

<span class="token comment">// 枚举中使用 mutating</span>
<span class="token keyword">enum</span> <span class="token class-name">TrafficLight</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> red<span class="token punctuation">,</span> yellow<span class="token punctuation">,</span> green
    
    <span class="token comment">// 下一个红绿灯</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span>red<span class="token punctuation">:</span>
            <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>green
        <span class="token keyword">case</span> <span class="token punctuation">.</span>green<span class="token punctuation">:</span>
            <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>yellow
        <span class="token keyword">case</span> <span class="token punctuation">.</span>yellow<span class="token punctuation">:</span>
            <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>red
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> light <span class="token operator">=</span> <span class="token class-name">TrafficLight</span><span class="token punctuation">.</span>red
light<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// light 现在是 .green</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓infix-operator-了解吗" tabindex="-1"><a class="header-anchor" href="#❓infix-operator-了解吗" aria-hidden="true">#</a> ❓<code>infix operator</code> 了解吗</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>infix operator</code>: 中缀运算符，是一种特殊类型的运算符，它位于两个操作数之间，如 <code>+, -, *, /</code> 等。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 自定义的中缀运算符 %%</span>
<span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">%%</span>
<span class="token keyword">func</span> <span class="token operator">%%</span><span class="token punctuation">(</span><span class="token keyword">left</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> <span class="token keyword">right</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">left</span> <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">%%</span> <span class="token number">3</span>  <span class="token comment">// 结果为16</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>可以在定义中缀运算符时添加优先级</p><blockquote><p>预定义的优先级组(<code>precedence</code>): <code>AdditionPrecedence</code>、<code>MultiplicationPrecedence</code>、<code>BitwiseShiftPrecedence</code> 等。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 可以在定义中缀运算符时添加优先级和结合性</span>
<span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">%%</span><span class="token punctuation">:</span> <span class="token class-name">AdditionPrecedence</span> <span class="token comment">// + 优先级</span>
<span class="token keyword">func</span> <span class="token operator">%%</span><span class="token punctuation">(</span><span class="token keyword">left</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> <span class="token keyword">right</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">left</span> <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">%%</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span>  <span class="token comment">// 结果为18，而不是36，因为&quot;%%&quot;的优先级与&quot;+&quot;相同</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>可以在定义中缀运算符时指定结合性(<code>associativity</code>): <code>left</code>(左结合)、<code>right</code>(右结合) 或 <code>none</code>(不结合)。</p><blockquote><p>例如，&quot;+&quot; 和 &quot;*&quot; 运算符是 <code>left-associative</code>，即它们从左向右结合。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">^</span> <span class="token punctuation">:</span> <span class="token class-name">PowerPrecedence</span>
<span class="token keyword">precedencegroup</span> <span class="token class-name">PowerPrecedence</span> <span class="token punctuation">{</span>
    <span class="token keyword">higherThan</span><span class="token punctuation">:</span> <span class="token class-name">MultiplicationPrecedence</span>
    <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token operator">^</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Double</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">2.0</span> <span class="token operator">^</span> <span class="token number">2.0</span> <span class="token operator">^</span> <span class="token number">3.0</span>  <span class="token comment">// 结果为64.0，因为操作符是左结合，所以首先计算2的平方，然后用4的立方计算结果。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓swift-中的-pwt、vwt" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-pwt、vwt" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>pwt</code>、<code>vwt</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>pwt</code> 和 <code>vwt</code> 是 <code>Swift</code> 的底层实现上文中的概念，分别是 <code>PropertyWitnessTable</code> 和 <code>ValueWitnessTable</code> 的简写。</p></blockquote><ul><li><p><code>pwt</code>（<code>Property Witness Table</code>）：属性见证表</p><blockquote><p>属性见证表包含了属性的一些基础信息和操作函数，如 <code>destroy</code>、<code>initialize</code>、<code>get</code>等。<code>pwt</code> 在 <code>Swift</code> 中为协议扩展以及泛型编程提供了可能。</p></blockquote></li><li><p><code>vwt</code>（<code>Value Witness Table</code>）：值见证表</p><blockquote><p>值见证表是一个结构体的元信息的集合。它包含了描述对象如何复制、销毁的函数指针，以及对象的大小和对齐方式等信息。每个 <code>Swift</code> 可取值类型，比如 <code>struct，enum，tuple</code> 等，都有对应的值见证表。当需要进行一些内存操作时，如复制、销毁、移动内存等，便会调用它们对应的 <code>Value Witness Table</code> 中的函数来进行操作。</p></blockquote></li></ul><p>总结：这些表在编译时就会生成，并附着在每个类型的元数据上。在运行时，当类型需要对自身的属性或者值进行操作时，就会调用这些表中的函数。它们是 <code>Swift</code> 在泛型和协议上面做到类型安全和抽象的关键所在。</p></details><h3 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程" aria-hidden="true">#</a> 函数式编程</h3><h4 id="❓-swift-中函数是第一等公民-这句话怎么理解" tabindex="-1"><a class="header-anchor" href="#❓-swift-中函数是第一等公民-这句话怎么理解" aria-hidden="true">#</a> ❓“<code>Swift</code> 中函数是第一等公民” 这句话怎么理解</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>一等公民：同其它基础数据类型一样。</p></blockquote><ul><li>可以作为参数传递给其他函数(高阶函数)。</li><li>可以作为其他函数的返回值。</li><li>可以赋值给变量。</li><li>可以存储在数据结构中。</li></ul></details><h4 id="❓map、filter、reduce" tabindex="-1"><a class="header-anchor" href="#❓map、filter、reduce" aria-hidden="true">#</a> ❓<code>map</code>、<code>filter</code>、<code>reduce</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>map</code>、<code>filter</code>、<code>reduce</code> 是 <code>Swift</code> 中常用的三个高阶函数，主要用于对数组进行操作。</p></blockquote><ul><li><p><code>map</code>：获取一个闭包表达式作为其唯一参数。数组中的每个元素调用一次该闭包函数，并返回一个包含有所有新值的数组。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> doubled <span class="token operator">=</span> numbers<span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span>   <span class="token comment">// 返回新的数组：[2, 4, 6, 8, 10]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>filter</code>：用于过滤数组，同样需要传入一个闭包表达式作为参数， 这个闭包函数需要返回一个布尔值用来确定是否过滤掉某一个元素。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> evens <span class="token operator">=</span> numbers<span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token comment">// 返回新的数组：[2, 4]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>reduce</code>：将所有元素组合成一个值。它需要两个参数，第一个参数是初始值，第二个参数是一个闭包函数。闭包函数会被数组中的元素依此调用，并将结果连续组合起来。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">+</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment">// 返回的结果是：15</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span> <span class="token comment">// 简化版本</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓flatmap、-compactmap" tabindex="-1"><a class="header-anchor" href="#❓flatmap、-compactmap" aria-hidden="true">#</a> ❓<code>flatMap</code>、 <code>compactMap</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>flatMap</code> 在 <code>Swift 4.1</code> 之前，用来处理嵌套的集合以及可选值的情况。但由于这种使用方式存在引发混淆的情况，因此从 <code>Swift 4.1</code> 开始，处理可选值的 <code>flatMap</code> 方法被重命名为 <code>compactMap</code>，而 <code>flatMap</code> 只用来处理嵌套集合。</p></blockquote><ul><li><p><code>flatMap</code>: 用来 &quot;摊平&quot; 嵌套集合</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> arrays <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment">// 将二维数组合并成一个新的一维数组</span>
<span class="token keyword">let</span> flatArray <span class="token operator">=</span> arrays<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>flatArray<span class="token punctuation">)</span>  <span class="token comment">// 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>compactMap</code>: 用来过滤掉 <code>nil</code></p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;1&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;2&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;three&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;4&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;5&quot;</span></span><span class="token punctuation">]</span>
<span class="token comment">// Int($0) 将字符串转化为 Int，可能返回 nil，compactMap 将过滤掉 nil 的元素</span>
<span class="token keyword">let</span> integers <span class="token operator">=</span> numbers<span class="token punctuation">.</span>compactMap <span class="token punctuation">{</span> <span class="token class-name">Int</span><span class="token punctuation">(</span><span class="token short-argument">$0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span>  <span class="token comment">// 输出：[1, 2, 4, 5]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓swift-函数式编程-函子、单子" tabindex="-1"><a class="header-anchor" href="#❓swift-函数式编程-函子、单子" aria-hidden="true">#</a> ❓<code>Swift</code> 函数式编程 (函子、单子)</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>函数式编程是一种编程范式，函子（<code>functor</code>）和单子（<code>monad</code>）是函数式编程中的术语。</p></blockquote><ul><li><p>函子 : 是一种可以将所有的输入操作映射到输出操作的对象。在 <code>Swift</code> 中，最常见的函子就是 <code>Array</code>, <code>map</code> 方法就是一个典型的函子操作。</p></li><li><p>单子 : 是函子的一个特例，满足一些额外条件。具体来说，它需要实现两个方法：一个是用来创建单子的方法，另一个是用来连接两个单子的方法。在 <code>Swift</code> 中，对于 <code>Array</code> 来说，创建单子的方法是初始化方法，连接两个单子的方法同样是 <code>flatMap</code>。</p></li></ul></details><h4 id="❓swift-函数中的-currying" tabindex="-1"><a class="header-anchor" href="#❓swift-函数中的-currying" aria-hidden="true">#</a> ❓<code>Swift</code> 函数中的 <code>Currying</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Currying</code>（柯里化）是一种将具有多个参数的函数转换成一系列使用一个参数的函数的技术。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 接受两个参数的函数</span>
<span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 返回 5</span>

<span class="token comment">// 柯里化为一个接受一个参数并返回一个函数的函数，返回的函数同样接受一个参数并返回加法结果</span>
<span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> b <span class="token keyword">in</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> addThree <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">// 返回一个新的函数</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">addThree</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 返回 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过柯里化，可以方便地创建具有特定行为的新函数，这在函数式编程中很常见。当我们需要生成大量类似的函数时，这种技术会非常有用。</p></details><hr><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h2><h3 id="❓swift-中的协议与-oc-中协议的特点和区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的协议与-oc-中协议的特点和区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的协议与 <code>OC</code> 中协议的特点和区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>相同点 : 协议在 <code>Swift</code> 和 <code>Objective-C</code> 中都是定义一组特定的方法、属性或者其它要求的工具。其他类、结构体或者枚举都可以遵守这些协议，并提供这些要求的具体实现。</p></li><li><p>不同点</p><ul><li><code>Objective-C</code> 中，协议往往用于实现“委托”模式，尤其是在 <code>UI</code> 编程中经常使用。协议中只能包含方法的声明。</li><li><code>Swift</code> 中的协议更加强大。</li></ul></li></ul><blockquote><p><code>Swift</code> 协议：</p></blockquote><ul><li>要求遵循协议的类型提供特定名称和类型的实例属性或者类型属性</li><li>要求遵循协议的类型提供特定名称和类型的方法、初始化方法、下标操作符</li><li>要求遵循协议的类型提供特定的操作符方法</li><li>为遵循协议的类型提供默认的方法或者属性的实现</li><li>可以定义类型别名</li><li>可以继承其它协议</li><li>可以在协议中使用关联类型等</li></ul></details><h3 id="❓-面向协议编程-说说你的理解" tabindex="-1"><a class="header-anchor" href="#❓-面向协议编程-说说你的理解" aria-hidden="true">#</a> ❓“面向协议编程” 说说你的理解</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>核心思想 : 先定义出需要的行为和特性，然后再根据这些要求来编写具体的实现，而不是先写具体的类型然后再去考虑它们之间的关系。</p></li><li><p>优点：使得我们的代码更加灵活和可复用。由于协议的默认实现和多协议继承等特性，能够轻松地定义出行为复杂的类型，并且能够通过协议的组合来实现更为强大的功能。也使得代码解耦性更强，更容易进行单元测试。</p></li></ul></details><h3 id="非透明类型" tabindex="-1"><a class="header-anchor" href="#非透明类型" aria-hidden="true">#</a> 非透明类型</h3><h4 id="❓some-的作用" tabindex="-1"><a class="header-anchor" href="#❓some-的作用" aria-hidden="true">#</a> ❓<code>some</code> 的作用</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>在 <code>Swift 5.1</code> 中引入了 <code>some</code> 关键字来支持 <code>Opaque Types</code>（不透明类型）的特性。这个特性允许函数或方法隐藏具体的返回类型，只暴露它遵循的协议，从而增强代码的封装性和灵活性。它在某些场景下解决了使用协议作为类型带来的问题。</p></blockquote><p><code>Opaque Type</code>（不透明类型）就意味着这是一种特定的类型，尽管具体的类型被隐藏了。换句话说，就是使用 <code>some</code> 关键字声明一个返回值的类型，而不具体说明是什么样的类型，只懈说明它遵守了哪个协议。只有返回的类型是统一的，你无法使用 <code>some</code> 声明的函数同时返回不同的类型。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">func</span> <span class="token function-definition function">makeNoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Dog</span><span class="token punctuation">:</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">func</span> <span class="token function-definition function">makeNoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;Woof!&quot;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">func</span> <span class="token function-definition function">makeNoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;Meow!&quot;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这个函数返回了 some Animal，意思就是返回了一个遵守 Animal 协议的类型，具体是什么类型，调用者无法知道</span>
<span class="token keyword">func</span> <span class="token function-definition function">getPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>pet<span class="token punctuation">.</span><span class="token function">makeNoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 输出 &quot;Woof!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="标准库协议" tabindex="-1"><a class="header-anchor" href="#标准库协议" aria-hidden="true">#</a> 标准库协议</h3><h4 id="❓customstringconvertible-customdebugstringconvertible" tabindex="-1"><a class="header-anchor" href="#❓customstringconvertible-customdebugstringconvertible" aria-hidden="true">#</a> ❓<code>CustomStringConvertible</code> &amp; <code>CustomDebugStringConvertible</code></h4><details class="hint-container details"><summary>💡</summary><ul><li><p><code>CustomStringConvertible</code> 是一个协议，如果自定义的类型实现了 <code>CustomStringConvertible</code> 协议，那么能够自定义表示实例的字符串。</p><blockquote><p><code>Swift</code> 的许多基础类型都实现了这个协议，包括 <code>String, Int, Double</code> 等。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Point</span><span class="token punctuation">:</span> <span class="token class-name">CustomStringConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token class-name">Int</span>

    <span class="token comment">// 实现 CustomStringConvertible 提供一个 description 属性</span>
    <span class="token keyword">var</span> description<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;(</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">x</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">y</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment">// Prints &quot;(5, 5)&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>CustomDebugStringConvertible</code> 是 <code>Swift</code> 标准库中的一个协议，它提供了自定义类型在调试打印时的描述。</p><blockquote><p>当使用 <code>debugPrint</code> 函数或 <code>po</code> 命令（在调试器中）打印对象时，<code>debugDescription</code> 属性的字符串将被使用。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>
<span class="token comment">// 遵循 CustomDebugStringConvertible 并且实现 debugDescription 属性</span>
<span class="token keyword">extension</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">CustomDebugStringConvertible</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> debugDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;Person(name: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, age: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">age</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
<span class="token comment">// 输出：Person(name: Alice, age: 30)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>注：通常 <code>debugDescription</code> 提供的信息比默认的 <code>description</code> 更详细，以帮助我们更好地理解对象的状态。</p></details><h4 id="❓equatable-comparable-hashable" tabindex="-1"><a class="header-anchor" href="#❓equatable-comparable-hashable" aria-hidden="true">#</a> ❓<code>Equatable</code> &amp; <code>Comparable</code> &amp; <code>Hashable</code></h4><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Equatable</code> 是 <code>Swift</code> 标准库中的一个协议，它定义了一种方式来检查两个实例是否相等。</p><blockquote><p>对于遵循该协议的类型，可以使用 <code>==</code> 或 <code>!=</code> 运算符来比较它们的实例。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>

<span class="token comment">// 遵循 Equatable 协议，并实现 == 运算符</span>
<span class="token keyword">extension</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>name <span class="token operator">==</span> rhs<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 可以直接比较这些类型的实例</span>
<span class="token keyword">let</span> alice <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> anotherAlice <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>alice <span class="token operator">==</span> anotherAlice<span class="token punctuation">)</span>  <span class="token comment">// 打印 &quot;true&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Comparable</code> 是 <code>Swift</code> 的一个协议，继承于 <code>Equatable</code> 协议。</p><blockquote><p>遵循该协议的类型可以进行比较操作。这意味着可以使用 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&gt;</code> 这样的比较运算符来比较这些类型的实例。</p></blockquote><ul><li>该类型与自身的比较运算符（如 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&gt;</code>）必须进行实现。</li><li>必须实现等于 <code>==</code> 操作符，因为 <code>Comparable</code> 协议继承自 <code>Equatable</code>。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    
    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>name <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>name <span class="token operator">==</span> rhs<span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对实例进行比较</span>
<span class="token keyword">let</span> alice <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">)</span>
<span class="token keyword">let</span> bob <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Bob&quot;</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>alice <span class="token operator">&lt;</span> bob<span class="token punctuation">)</span>  <span class="token comment">// 打印 &quot;true&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Hashable</code> 是 <code>Swift</code> 的一个协议，继承于 <code>Equatable</code> 协议。</p><blockquote><p>用于定义那些可以将它们的实例转化为一个可以代表它们的唯一整数值（即散列值）的类型，这使得它们能够诸如存储在 <code>Set</code> 中或作为 <code>Dictionary</code> 的键等操作。</p></blockquote><ul><li>实现 <code>hash(into:)</code> 函数来提供一个散列值。</li><li>必须实现等于 <code>==</code> 操作符，因为 <code>Hashable</code> 协议继承自 <code>Equatable</code>。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// Hashable 协议定义</span>
<span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">Hashable</span> <span class="token punctuation">:</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 散列值</span>
    <span class="token keyword">var</span> hashValue<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token comment">// 哈希函数</span>
    <span class="token keyword">func</span> <span class="token function-definition function">hash</span><span class="token punctuation">(</span>into hasher<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">Hasher</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>

    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>name <span class="token operator">==</span> rhs<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age
    <span class="token punctuation">}</span>
    <span class="token comment">// 散列函数</span>
    <span class="token keyword">func</span> <span class="token function-definition function">hash</span><span class="token punctuation">(</span>into hasher<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">Hasher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        hasher<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
        hasher<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> alice <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> bob <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Bob&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">21</span><span class="token punctuation">)</span>
<span class="token comment">// 存入 Set 中的数据，需要知道如何检查其中的元素是否重复</span>
<span class="token keyword">let</span> people<span class="token punctuation">:</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Person</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span>alice<span class="token punctuation">,</span> bob<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓sequence-collection-rangereplaceablecollection" tabindex="-1"><a class="header-anchor" href="#❓sequence-collection-rangereplaceablecollection" aria-hidden="true">#</a> ❓<code>Sequence</code> &amp; <code>Collection</code> &amp; <code>RangeReplaceableCollection</code></h4><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Sequence</code> 是 <code>Swift</code> 标准库中的一个基础协议。它表示一个元素有顺序并可遍历的组合。</p><ul><li>遵循 <code>Sequence</code> 协议的类型（如数组 <code>Array</code>、字典 <code>Dictionary</code> 或者集合 <code>Set</code> 等）需要实现一个 <code>makeIterator()</code> 方法。</li><li>作为 <code>Sequence</code> 也可以使用几种函数来操作和查询你的序列，比如 <code>map()</code>、<code>filter()</code>、<code>dropFirst()</code>、<code>prefix()</code> 等。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// Sequence 协议定义</span>
<span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">Sequence</span> <span class="token punctuation">{</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Element</span> <span class="token keyword">where</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Element</span> <span class="token operator">==</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Iterator</span><span class="token punctuation">.</span><span class="token class-name">Element</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Iterator</span> <span class="token punctuation">:</span> <span class="token class-name">IteratorProtocol</span>
    <span class="token comment">// 返回一个 \`Iterator\` 类型的实例，通过该实例可以遍历序列(\`for-in\`)的元素。</span>
    <span class="token keyword">func</span> <span class="token function-definition function">makeIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Iterator</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// numbers 就是一个 Sequence</span>
<span class="token comment">// 使用 for-in 来遍历数组</span>
<span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 map 函数来将数组中的每一个元素乘以 2</span>
<span class="token keyword">let</span> doubled <span class="token operator">=</span> numbers<span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>doubled<span class="token punctuation">)</span>  <span class="token comment">// 打印 [2, 4, 6, 8, 10]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Collection</code> 是 <code>Swift</code> 中的一个协议，继承自 <code>Sequence</code> 协议。</p><blockquote><p>表示可以遍历且元素有顺序的数据类型，比如数组、字典和集合等，并提供了一些额外的功能，比如可以通过索引访问元素。</p></blockquote><ul><li><code>startIndex</code> 和 <code>endIndex</code> 属性，表示集合的开始和结束索引。</li><li><code>index(after:)</code> 方法，表示获取给定索引的下一个索引。</li><li>使用下标访问元素的能力。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// Collection 协议定义</span>
<span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">Collection</span> <span class="token punctuation">:</span> <span class="token class-name">Sequence</span> <span class="token punctuation">{</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Index</span> <span class="token punctuation">:</span> <span class="token class-name">Comparable</span> <span class="token keyword">where</span> <span class="token operator">...</span>
    <span class="token comment">// 集合开始索引</span>
    <span class="token keyword">var</span> startIndex<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token comment">// 集合结束索引</span>
    <span class="token keyword">var</span> endIndex<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// 下标访问元素</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>position<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Element</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>bounds<span class="token punctuation">:</span> <span class="token class-name">Range</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">SubSequence</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">var</span> count<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">index</span><span class="token punctuation">(</span>after i<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">.</span>indices <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>RangeReplaceableCollection</code> 是 <code>Swift</code> 的一个集合协议，继承于了 <code>Collection</code> 协议。</p><blockquote><p>它为能对集合的一个范围进行插入和删除操作的类型声明了一组方法。如 <code>removeSubrange(_:)</code> 等。</p></blockquote><ul><li><code>init()</code>，用于创建一个新的空集合。</li><li><code>replaceSubrange(_:with:)</code>，用于替换集合中的一段范围为一组新的元素。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">RangeReplaceableCollection</span> <span class="token punctuation">:</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">SubSequence</span> <span class="token punctuation">:</span> <span class="token class-name">RangeReplaceableCollection</span> <span class="token punctuation">{</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">SubSequence</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 替换集合中指定范围元素</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">replaceSubrange</span><span class="token operator">&lt;</span><span class="token class-name">C</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> subrange<span class="token punctuation">:</span> <span class="token class-name">Range</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Index</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> with newElements<span class="token punctuation">:</span> <span class="token class-name">C</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">C</span> <span class="token punctuation">:</span> <span class="token class-name">Collection</span><span class="token punctuation">,</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Element</span> <span class="token operator">==</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token class-name">Element</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span>
numbers<span class="token punctuation">.</span><span class="token function">removeSubrange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">...</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token comment">// 输出 [10, 50]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓-expressiblebystringliteral-expressiblebyarrayliteral-expressiblebydictionaryliteral" tabindex="-1"><a class="header-anchor" href="#❓-expressiblebystringliteral-expressiblebyarrayliteral-expressiblebydictionaryliteral" aria-hidden="true">#</a> ❓ <code>ExpressibleByStringLiteral</code> &amp; <code>ExpressibleByArrayLiteral</code> &amp; <code>ExpressibleByDictionaryLiteral</code></h4><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ExpressibleByStringLiteral</code> 是 <code>Swift</code> 中的一个协议，它表示一个类型可以通过字符串字面量进行初始化。</p><blockquote><p>要遵循该协议，类型需要实现 <code>init(stringLiteral value: StringLiteralType)</code> 初始化方法。在初始化方法中，将字符串字面量转化为该类型的一个实例。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">HTMLComponent</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByStringLiteral</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> html<span class="token punctuation">:</span> <span class="token class-name">String</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>stringLiteral value<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        html <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&lt;p&gt;</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&lt;/p&gt;&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 将字符串自动包装为 HTML 段落标签</span>
<span class="token keyword">let</span> component<span class="token punctuation">:</span> <span class="token class-name">HTMLComponent</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Hello, world!&quot;</span></span>
<span class="token function">print</span><span class="token punctuation">(</span>component<span class="token punctuation">.</span>html<span class="token punctuation">)</span>  <span class="token comment">// 输出 &quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ExpressibleByArrayLiteral</code> 是 <code>Swift</code> 中的一个协议，允许使用数组字面量来初始化遵循此协议的类型。</p><blockquote><p>要使得类型遵循 <code>ExpressibleByArrayLiteral</code>，需要提供一个 <code>init(arrayLiteral elements:)</code> 的初始化方法。这个方法接收一个或多个同一类型的值，这些值与数组字面量中的元素一一对应。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Vector</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByArrayLiteral</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token class-name">Double</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>arrayLiteral elements<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>elements<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>
        x <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        y <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        z <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> vector<span class="token punctuation">:</span> <span class="token class-name">Vector</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span>x<span class="token punctuation">,</span> vector<span class="token punctuation">.</span>y<span class="token punctuation">,</span> vector<span class="token punctuation">.</span>z<span class="token punctuation">)</span>  <span class="token comment">// 打印 &quot;1.0 2.0 3.0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ExpressibleByDictionaryLiteral</code> 是 <code>Swift</code> 的一个协议。遵循此协议的类型可以使用字典字面量进行初始化。这意味着可以直接使用 <code>{key: value, ...}</code> 的格式来创建这种类型的实例。</p><blockquote><p>为了遵循 <code>ExpressibleByDictionaryLiteral</code> 协议你需要定义一个 <code>init(dictionaryLiteral elements: (Key, Value)...)</code> 初始化方法。<code>Key</code> 和 <code>Value</code> 是你需要的字典的键和值的类型。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">MyDictionary</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByDictionaryLiteral</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span> <span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">]</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>dictionaryLiteral elements<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Int</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token class-name">Dictionary</span><span class="token punctuation">(</span>uniqueKeysWithValues<span class="token punctuation">:</span> elements<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用字典字面量来创建一个 MyDictionary 实例</span>
<span class="token keyword">let</span> myDict<span class="token punctuation">:</span> <span class="token class-name">MyDictionary</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;one&quot;</span></span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;two&quot;</span></span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;three&quot;</span></span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>myDict<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment">// Prints:  [&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><blockquote><p><code>Swift</code> 中的字面量协议</p></blockquote><ul><li><code>ExpressibleByNilLiteral</code> : <code>nil</code> 字面量协议</li><li><code>ExpressibleByBooleanLiteral</code> : 布尔值字面量协议</li><li><code>ExpressibleByIntegerLiteral</code> : 整数字面量协议</li><li><code>ExpressibleByFloatLiteral</code> : 浮点数字面量协议</li><li><code>ExpressibleByStringLiteral</code> : 字符串字面量协议</li><li><code>ExpressibleByArrayLiteral</code> : 数组字面量协议</li><li><code>ExpressibleByDictionaryLiteral</code> : 字典字面量协议</li></ul></details><h3 id="codable" tabindex="-1"><a class="header-anchor" href="#codable" aria-hidden="true">#</a> Codable</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Codable</code> 是 <code>Swift</code> 标准库中的一个类型别名，表示可以编码和解码的数据类型。它是 <code>Encodable</code> 和 <code>Decodable</code> 两个协议的组合。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">Codable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">)</span>

<span class="token comment">// 转为 JSON 数据</span>
<span class="token keyword">let</span> encoder <span class="token operator">=</span> <span class="token class-name">JSONEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 转回 Person 实例</span>
    <span class="token keyword">let</span> decoder <span class="token operator">=</span> <span class="token class-name">JSONDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> decodedPerson <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> decoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">,</span> from<span class="token punctuation">:</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>decodedPerson<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment">// 打印 &quot;Alice&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h4 id="❓codable-如何实现-key-映射" tabindex="-1"><a class="header-anchor" href="#❓codable-如何实现-key-映射" aria-hidden="true">#</a> ❓<code>Codable</code> 如何实现 <code>key</code> 映射</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Codable</code> 是 <code>Swift</code> 中处理数据序列化和反序列化的协议。当 <code>JSON</code> 字段名称和模型属性名称不一致时，可以使用这个协议中的一个关键特性 —— 键映射 (key mapping)。在模型中定义一个枚举，遵守 <code>CodingKey</code> 协议，用于映射 <code>JSON</code> 字段和模型属性。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">User</span><span class="token punctuation">:</span> <span class="token class-name">Codable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> id<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> registrationDate<span class="token punctuation">:</span> <span class="token class-name">Date</span>

    <span class="token comment">// 定义键映射的枚举</span>
    <span class="token keyword">enum</span> <span class="token class-name">CodingKeys</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">CodingKey</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> id
        <span class="token keyword">case</span> name
        <span class="token keyword">case</span> registrationDate <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;registration_date&quot;</span></span>  <span class="token comment">// 进行键映射</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：如果型类型中所有的键都和 <code>JSON</code> 的键一一对应，那么不需要手动提供 <code>CodingKeys</code>。<code>Swift</code> 的编译器会自动提供一个<code>String</code>类型的，名为<code>CodingKeys</code>的枚举，里面包含了每个属性对应的键。但一旦在模型中自定义了 <code>CodingKeys</code>，那么编译器就会停止自动合成，需要为模型中的每个属性都提供对应的键。</p></details><h4 id="❓codable-实现原理" tabindex="-1"><a class="header-anchor" href="#❓codable-实现原理" aria-hidden="true">#</a> ❓<code>Codable</code> 实现原理</h4><details class="hint-container details"><summary>💡</summary><p>在标准库中，定义了一个 <code>Decoder</code> 协议，一般解码器（比如 <code>JSONDecoder</code>）都会遵循这个协议。相应地，还有一个 <code>Encoder</code> 协议，编码器（如 <code>JSONEncoder</code>）会遵循这个协议。</p><p>对于每个数据类型，只要它遵循了 <code>Decodable</code> 协议，就可以解码；遵循了 <code>Encodable</code> 协议，就可以编码。通过协议默认实现编码解码任务。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 解码方法</span>
<span class="token keyword">init</span><span class="token punctuation">(</span>from decoder<span class="token punctuation">:</span> <span class="token class-name">Decoder</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>
<span class="token comment">// 编码方法</span>
<span class="token keyword">func</span> <span class="token function-definition function">encode</span><span class="token punctuation">(</span>to encoder<span class="token punctuation">:</span> <span class="token class-name">Encoder</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><h3 id="❓关联类型" tabindex="-1"><a class="header-anchor" href="#❓关联类型" aria-hidden="true">#</a> ❓关联类型</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Swift</code> 中，关联类型是用在协议中的一种类型。关联类型提供了一种方式来使协议中的方法、属性或下标脚本的类型保持灵活性。它给协议添加了一个需要在实现协议的时候才确定的类型占位符。</p><p>关联类型是通过 <code>associatedtype</code> 关键字声明的。一旦一个协议拥有了关联类型，它就不能被当做一个独立的类型使用。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 容器协议</span>
<span class="token keyword">protocol</span> <span class="token class-name">Container</span> <span class="token punctuation">{</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Item</span> <span class="token comment">// 关联类型</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">append</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">Item</span><span class="token punctuation">)</span>  <span class="token comment">// 添加元素</span>
    <span class="token keyword">var</span> count<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>              <span class="token comment">// 获取元素数量</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>   <span class="token comment">// 通过索引获取元素</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">IntArray</span><span class="token punctuation">:</span> <span class="token class-name">Container</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 Int 类型的容器协议</span>
    <span class="token keyword">var</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">typealias</span> <span class="token class-name">Item</span> <span class="token operator">=</span> <span class="token class-name">Int</span>

    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">append</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        items<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> count<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> items<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span>

    <span class="token keyword">subscript</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓any-与-anyobject-区别" tabindex="-1"><a class="header-anchor" href="#❓any-与-anyobject-区别" aria-hidden="true">#</a> ❓<code>Any</code> 与 <code>AnyObject</code> 区别</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Any</code> 和 <code>AnyObject</code> 是 <code>Swift</code> 中两种特殊的类型，它们都可以表示 &quot;任何类型&quot;。</p></blockquote><p>区别：</p><ul><li><p><code>AnyObject</code> 可以表示任何类类型的实例，也就是说，非类类型（比如结构体、枚举）的实例不能赋值给 <code>AnyObject</code>。这与 <code>Objective-C</code> 中的 <code>id</code> 类型比较相似。<code>AnyObject</code> 一般在 <code>Swift</code> 与 <code>Objective-C</code> 交互的时候使用。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> myClass<span class="token punctuation">:</span> <span class="token class-name">AnyObject</span> <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> myStruct<span class="token punctuation">:</span> <span class="token class-name">AnyObject</span> <span class="token operator">=</span> <span class="token class-name">MyStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 编译错误，结构体不能被赋值给 AnyObject</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Any</code> 则可以表示 <code>Swift</code> 中的任何类型的实例，包括类、结构体、枚举、基本数据类型、函数、数组、字典等等，甚至还包括可选类型。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> myClass<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> myStruct<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token class-name">MyStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 编译通过，结构体可以被赋值给 Any</span>
<span class="token keyword">let</span> myInt<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token number">123</span>
<span class="token keyword">let</span> myArray<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> myOptional<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token keyword">none</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓泛型-t-与-any-有什么区别" tabindex="-1"><a class="header-anchor" href="#❓泛型-t-与-any-有什么区别" aria-hidden="true">#</a> ❓泛型 <code>T</code> 与 <code>Any</code> 有什么区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>泛型 <code>T</code> 是在编译时就确定的具体类型。在函数或类型定义中，<code>T</code> 只是一个占位符，代表任意类型。然而，当函数被调用或类型被实例化时，<code>T</code> 将被具体的类型替换。因此，使用泛型可以确保类型的一致性和安全性。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 交换两个元素值的函数</span>
<span class="token keyword">func</span> <span class="token function-definition function">swapTwoValues</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">T</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temporaryA <span class="token operator">=</span> a
    a <span class="token operator">=</span> b
    b <span class="token operator">=</span> temporaryA
<span class="token punctuation">}</span>

<span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">200</span>
<span class="token comment">// T 在函数调用时被确定为 Int 类型</span>
<span class="token function">swapTwoValues</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token operator">&amp;</span>num1<span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token operator">&amp;</span>num2<span class="token punctuation">)</span>
<span class="token comment">// 现在 num1 是 200, num2 是 100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Any</code> 是一个可以表示 <code>Swift</code> 中任何类型的特殊类型，包括类、结构体、枚举、函数类型等等。可以把 <code>Any</code> 看作是一个 “类型的黑箱”，可以将任何类型的实例赋值给 <code>Any</code>，但使用这个值时，需要将其转换回原来的类型。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> items<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
items<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
items<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello World&quot;</span></span><span class="token punctuation">)</span>
items<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3.14159</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Pi&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓anyiterator-了解吗" tabindex="-1"><a class="header-anchor" href="#❓anyiterator-了解吗" aria-hidden="true">#</a> ❓<code>AnyIterator</code> 了解吗</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>AnyIterator</code> 是一种类型擦除的迭代器，它提供了一种方法来创建符合 <code>IteratorProtocol</code> 的类型，而不需要创建新的，自定义的类型。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// 创建一个迭代器来迭代这个序列</span>
<span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token class-name">AnyIterator</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token keyword">in</span>
    <span class="token keyword">let</span> nextNum <span class="token operator">=</span> num
    num <span class="token operator">*=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> nextNum
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..&lt;</span><span class="token number">10</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓泛型类型擦除如何实现" tabindex="-1"><a class="header-anchor" href="#❓泛型类型擦除如何实现" aria-hidden="true">#</a> ❓泛型类型擦除如何实现</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>泛型类型擦除 : 将具有特定泛型类型约束的对象转化为一个不再具有特定泛型类型的对象，但仍然保持相似的行为。</p></blockquote><p>泛型类型擦除处理，一般是通过将泛型类型或函数包装在一个非泛型类型中来达成的。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 协议</span>
<span class="token keyword">protocol</span> <span class="token class-name">MyProtocol</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 实现 MyProtocol 的泛型类</span>
<span class="token keyword">class</span> <span class="token class-name">MyGenericClass</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">MyProtocol</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 将泛型类 MyGenericClass 进行类型擦除，同事具备 MyProtocol 的行为</span>
<span class="token keyword">class</span> <span class="token class-name">AnyMyGenericClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> _myClass<span class="token punctuation">:</span> <span class="token class-name">AnyObject</span>
    <span class="token keyword">init</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">MyProtocol</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> myClass<span class="token punctuation">:</span> <span class="token class-name">MyGenericClass</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _myClass <span class="token operator">=</span> myClass
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程" aria-hidden="true">#</a> 异步编程</h2><h3 id="❓swift-如何实现自己的-promise" tabindex="-1"><a class="header-anchor" href="#❓swift-如何实现自己的-promise" aria-hidden="true">#</a> ❓<code>Swift</code> 如何实现自己的 <code>Promise</code></h3><details class="hint-container details"><summary>💡</summary><p>实现自己的 <code>Promise</code> 实质上是要创建一个可以包装异步操作，并能够在之后获取其结果的对象。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 一种简单的 Promise 实现</span>
<span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token operator">?</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token operator">?</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token class-name">Error</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">func</span> <span class="token function-definition function">fulfill</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function-definition function">reject</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>error <span class="token operator">=</span> error
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// then 方法被调用来添加一个将在 Promise 解决时调用的回调</span>
    <span class="token keyword">func</span> <span class="token function-definition function">then</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> callback<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token class-name">Error</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        callbacks<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 一旦 Promise 被解决(fulfilled 或 rejected)，它就会执行所有回调函数，并清空回调队列</span>
    <span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function-definition function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token operator">=</span> value <span class="token punctuation">{</span>
            callbacks<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
            callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token punctuation">{</span>
            callbacks<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
            callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 Promise</span>
<span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span>then <span class="token punctuation">{</span> result <span class="token keyword">in</span>
    <span class="token keyword">switch</span> result <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">let</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span><span class="token keyword">let</span> error<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Error: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">error</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在全局队列上模拟一个异步操作，2秒后，\`fulfill\` 方法将 \`Promise\` 状态更改为已解决，并打印“Value: 5”。</span>
<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// simulate async operation</span>
    promise<span class="token punctuation">.</span><span class="token function">fulfill</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓async-await" tabindex="-1"><a class="header-anchor" href="#❓async-await" aria-hidden="true">#</a> ❓<code>async/await</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.5</code> 新引入的两个关键字，主要用于简化、美化 <code>Swift</code> 中的异步任务的编码和阅读。</p></blockquote><p><code>async/await</code> 带来了更清晰、更简洁的异步编程模型。解决了过去处理多异步任务回调地狱的问题，可以和同步代码一样顺序编写，大大提高了代码的可读性和可维护性。</p><ul><li><p><code>async</code>：表示一个函数为异步函数。异步函数是一个可以在后台进程运行而不会阻塞当前的运行进程。</p></li><li><p><code>await</code>：通常在异步函数中调用另一个异步函数时使用，以表示等待这个异步函数的执行结果。</p></li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">fetchDataFromServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">-&gt;</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function-definition function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchDataFromServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="sendable" tabindex="-1"><a class="header-anchor" href="#sendable" aria-hidden="true">#</a> Sendable</h3><h4 id="❓sendable" tabindex="-1"><a class="header-anchor" href="#❓sendable" aria-hidden="true">#</a> ❓<code>Sendable</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.5</code> 中与并发相关的新特性之一，是一个标记性的协议。用于表示遵循该协议的类型是能安全地发送到和接收自别的并发上下文（例如，异步任务、actor）。</p></blockquote><p>类型可以标记 <code>Sendable</code> 协议的两个条件：</p><ul><li>值类型（例如，枚举、结构体）</li><li>所有的存储属性（包括递归地）都是 <code>Sendable</code></li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 直接遵循 Sendable 协议</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span><span class="token punctuation">:</span> <span class="token class-name">Sendable</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">Double</span>
  <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token class-name">Double</span>
<span class="token punctuation">}</span>

<span class="token comment">// 扩展遵循 Sendable 协议</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token class-name">Double</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token class-name">Double</span>
<span class="token punctuation">}</span>
<span class="token keyword">extension</span> <span class="token class-name">Point</span><span class="token punctuation">:</span> <span class="token class-name">Sendable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h4 id="❓class-类型可以标记为-sendable-吗" tabindex="-1"><a class="header-anchor" href="#❓class-类型可以标记为-sendable-吗" aria-hidden="true">#</a> ❓<code>class</code> 类型可以标记为 <code>Sendable</code> 吗</h4><details class="hint-container details"><summary>💡</summary><p><code>class</code> 并不是值类型，因此不能直接让 <code>class</code> 遵从 <code>Sendable</code> 协议。但是可以通过 <code>@unchecked Sendable</code> 属性强制表明 <code>class</code> 是 <code>Sendable</code>。必须保证这个类型是 <code>class</code>，在传递这个类的实例时仍旧能保证线程安全。</p><p><code>class</code>遵从 <code>Sendable</code> 协议时必须小心，因为 <code>Sendable</code> 要求遵循该协议的类型是线程安全的。如果不能保证线程安全，使用 <code>@unchecked Sendable</code> 可能引发难以调试的线程问题。</p></details><hr><h2 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h2><h3 id="❓rethrows-和-throws-的区别" tabindex="-1"><a class="header-anchor" href="#❓rethrows-和-throws-的区别" aria-hidden="true">#</a> ❓<code>rethrows</code> 和 <code>throws</code> 的区别</h3><details class="hint-container details"><summary>💡</summary><p>在 Swift 中，<code>throws</code> 和 <code>rethrows</code> 都与错误处理有关。</p><ul><li><p><code>throws</code> 关键字用于标识一个函数或方法可能会抛出错误。这意味着在调用这个函数或方法时，必须处理可能抛出的错误。</p><blockquote><p>例如，使用 <code>do-catch</code> 语句，或者让包含此调用的函数同样标记为 <code>throws</code>。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">performOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在函数体中，可能会抛出一个错误</span>
    <span class="token keyword">throw</span> <span class="token class-name">MyError</span><span class="token punctuation">.</span>someError <span class="token comment">// 抛出一个错误</span>
<span class="token punctuation">}</span>

<span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token function">performOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理错误</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>rethrows</code> 关键字用于标识一个函数或方法接受一个可能抛出错误的函数作为参数，并且它将可能抛出此类函数可能抛出的错误。如果传入的函数不抛出错误，那么调用 <code>rethrows</code> 函数的代码不需要进行错误处理。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">performClosureOperation</span><span class="token punctuation">(</span>on operation<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这个函数体将转发从 operation 参数中抛出的任何错误</span>
    <span class="token keyword">try</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用一个不抛出错误的闭包调用函数</span>
<span class="token function">performClosureOperation</span><span class="token punctuation">(</span>on<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">/* 这里没有错误抛出，所以我们不需要处理错误 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用一个可能抛出错误的闭包调用函数</span>
    <span class="token keyword">try</span> <span class="token function">performClosureOperation</span><span class="token punctuation">(</span>on<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token class-name">MyError</span><span class="token punctuation">.</span>someError <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 必须处理错误</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理错误</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>总结：<code>rethrows</code> 表示函数或方法将转发作为参数传入的函数可能抛出的错误，而 <code>throws</code> 则表示函数或方法本身可能抛出错误。</p></details><hr><h2 id="混编" tabindex="-1"><a class="header-anchor" href="#混编" aria-hidden="true">#</a> 混编</h2><h3 id="❓swift-与-oc-混编相互调用" tabindex="-1"><a class="header-anchor" href="#❓swift-与-oc-混编相互调用" aria-hidden="true">#</a> ❓<code>Swift</code> 与 <code>OC</code> 混编相互调用</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Swift</code> 调用 <code>Objective-C</code>：</p><blockquote><p>在为 <code>Swift</code> 工程导入 <code>OC</code> 类后，<code>Xcode</code> 会自动生成一个名为 <code>项目名称-Swift.h</code> 的头文件，只需要在需要使用 <code>OC</code> 中对象的 <code>Swift</code> 文件中，导入这个文件即可实现 <code>OC</code> 的类、方法的调用。（注意是在 <code>OC</code> 文件中引入）。</p></blockquote></li><li><p><code>Objective-C</code> 调用 <code>Swift</code>：</p><blockquote><p>项目需添加桥接头文件（即创建一个 <code>Swift</code> 文件时系统自动生成的 <code>项目名称-Bridging-Header.h</code> 文件），然后在该头文件中，引入要用到的 <code>OC</code> 类的头文件，这样就可以在 <code>Swift</code> 中正常使用 <code>OC</code> 类和方法。在 <code>Swift</code> 代码实现后，<code>OC</code> 就可以通过在 <code>OC</code> 中引入 <code>TargetName-Swift.h</code> 文件来调用 <code>Swift</code> 代码了。</p></blockquote></li></ul></details><h3 id="❓dynamic-在-swift-与-oc-中的作用" tabindex="-1"><a class="header-anchor" href="#❓dynamic-在-swift-与-oc-中的作用" aria-hidden="true">#</a> ❓<code>dynamic</code> 在 <code>Swift</code> 与 <code>OC</code> 中的作用</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>在 <code>Objective-C</code> 中，<code>dynamic</code> 关键字用于告知编译器，方法的实现将在运行时动态绑定，即不在编译时进行绑定。这允许在运行时替换、添加或者修改方法实现。</p><blockquote><p>通常会在定义了属性的 <code>getter</code> 和 <code>setter</code> 方法后，使用 <code>@dynamic</code> 关键字来避免编译器自动生成方法实现，然后在运行时手动提供这些方法的实现。</p></blockquote></li><li><p>在 <code>Swift</code> 中，<code>dynamic</code> 关键字用于在类或者类的成员前，表示该类或者类的成员可以被 <code>Objective-C</code> 动态调度。也就是说，被<code>dynamic</code>修饰的成员方法、属性或下标脚本的调用会变成一个 <code>Objective-C</code> 的消息发送。</p><blockquote><p><code>Swift</code> 中的 <code>dynamic</code> 不仅仅告诉编译器在运行时查找方法实现，而且还确保了被修饰的元素可以被 <code>Objective-C</code> 访问，因此它们可以被 <code>Objective-C</code> 的运行时特性（如 <code>Key-Value Observing</code>、<code>Key-Value Coding</code>）使用。</p></blockquote></li></ul><p>注意：在 <code>Swift</code> 中，<code>dynamic</code> 只能用于修饰类的实例成员，不能用于修饰静态成员或者全局函数。同时，只有继承自 <code>NSObject</code> 的类可以使用 <code>dynamic</code> 修饰方法或者属性。</p></details><h3 id="swift-指针了解吗" tabindex="-1"><a class="header-anchor" href="#swift-指针了解吗" aria-hidden="true">#</a> <code>Swift</code> 指针了解吗</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift</code> 中的指针相对于 <code>C/C++</code> 提供的原始指针类型进行了封装和规范，以提供更安全的使用方式。主要使用 <code>UnsafePointer&lt;T&gt;</code> 和 <code>UnsafeMutablePointer&lt;T&gt;</code> 类型来表示不可变和可变的指针。</p></blockquote><p>在使用时对原始内存进行了引用，而非直接操作内存。当完成所有的读、写或者想要释放某个内存片段时，使用 <code>deinitialize</code> 和 <code>deallocate</code> 方法来完成。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">usePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为 Int 创建不可变和可变指针</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span>
    <span class="token keyword">let</span> numPointer<span class="token punctuation">:</span> <span class="token class-name">UnsafePointer</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">UnsafePointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>numPointer<span class="token punctuation">.</span>pointee<span class="token punctuation">)</span> <span class="token comment">// 10</span>
    <span class="token keyword">let</span> nums <span class="token operator">=</span> <span class="token class-name">UnsafeMutablePointer</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>capacity<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span>
    nums<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>pointee<span class="token punctuation">)</span> <span class="token comment">// 20</span>
    <span class="token operator">...</span>
    nums<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用完毕后记得释放</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h2><h3 id="❓-available-inlinable" tabindex="-1"><a class="header-anchor" href="#❓-available-inlinable" aria-hidden="true">#</a> ❓<code>@available</code> &amp; <code>@inlinable</code></h3><h3 id="❓-discardableresult" tabindex="-1"><a class="header-anchor" href="#❓-discardableresult" aria-hidden="true">#</a> ❓<code>@discardableResult</code> &amp;</h3><h3 id="❓-objc-objcmembers" tabindex="-1"><a class="header-anchor" href="#❓-objc-objcmembers" aria-hidden="true">#</a> ❓<code>@objc</code> &amp; <code>@objcMembers</code></h3><h3 id="❓-testable" tabindex="-1"><a class="header-anchor" href="#❓-testable" aria-hidden="true">#</a> ❓<code>@testable</code></h3><h3 id="propertywrapper" tabindex="-1"><a class="header-anchor" href="#propertywrapper" aria-hidden="true">#</a> @propertyWrapper</h3><h4 id="❓-propertywrapper-是什么" tabindex="-1"><a class="header-anchor" href="#❓-propertywrapper-是什么" aria-hidden="true">#</a> ❓<code>@propertyWrapper</code> 是什么</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.1</code> 引入了一项新特性：属性包装器（property wrappers）。属性包装器提供了一种将特性添加到属性上的新方法，例如线程安全，懒加载，键值观察，存储在数据库中等，从而使这些属性更易于复用。简单来说，属性包装器就是一个定义了特殊访问策略的结构或类，我们可以将这个访问策略附加到属性上，而不是重新实现相同的访问策略。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 定义属性包装器</span>
<span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">struct</span> <span class="token class-name">HundredOrLess</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> score <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> score <span class="token punctuation">}</span>
        <span class="token keyword">set</span> <span class="token punctuation">{</span> score <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用属性包装器</span>
<span class="token keyword">struct</span> <span class="token class-name">Grade</span> <span class="token punctuation">{</span>
    <span class="token comment">/// 数学成绩</span>
    <span class="token attribute atrule">@HundredOrLess</span> <span class="token keyword">var</span> math<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token comment">/// 体育成绩</span>
    <span class="token attribute atrule">@HundredOrLess</span> <span class="token keyword">var</span> gym<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h4 id="❓-propertywrapper-的常见用法" tabindex="-1"><a class="header-anchor" href="#❓-propertywrapper-的常见用法" aria-hidden="true">#</a> ❓<code>@propertyWrapper</code> 的常见用法</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@propertyWrapper</code> 使得定义可复用的属性行为成为可能，使得任务像添加线程安全性、字符清理、内部值转换等转化为一个简易操作。</p></blockquote><p>常见用法：</p><ul><li><p>存储属性的转换。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">struct</span> <span class="token class-name">Capitalized</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">didSet</span> <span class="token punctuation">{</span> <span class="token keyword">self</span><span class="token punctuation">.</span>wrappedValue <span class="token operator">=</span> wrappedValue<span class="token punctuation">.</span>capitalized <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>wrappedValue<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>wrappedValue <span class="token operator">=</span> wrappedValue<span class="token punctuation">.</span>capitalized
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用了 @Capitalized 修饰符，使得这两个属性的值自动被转换为首字母大写。</span>
    <span class="token attribute atrule">@Capitalized</span> <span class="token keyword">var</span> firstName<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token attribute atrule">@Capitalized</span> <span class="token keyword">var</span> lastName<span class="token punctuation">:</span> <span class="token class-name">String</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>线程安全。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">class</span> <span class="token class-name">Atomic</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 串行队列</span>
    <span class="token keyword">private</span> <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token class-name">DispatchQueue</span><span class="token punctuation">(</span>label<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Atomic serial queue&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> _value<span class="token punctuation">:</span> <span class="token class-name">Value</span>

    <span class="token comment">// 使用一个串行队列保护，确保读取和写入操作的原子性。</span>
    <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">Value</span> <span class="token punctuation">{</span>
      <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> queue<span class="token punctuation">.</span>sync <span class="token punctuation">{</span> _value <span class="token punctuation">}</span> <span class="token punctuation">}</span>
      <span class="token keyword">set</span> <span class="token punctuation">{</span> queue<span class="token punctuation">.</span>sync <span class="token punctuation">{</span> _value <span class="token operator">=</span> newValue <span class="token punctuation">}</span> <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">init</span><span class="token punctuation">(</span>wrappedValue value<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     _value <span class="token operator">=</span> value
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">AtomicCounter</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@Atomic</span> <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>用户默认值。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">struct</span> <span class="token class-name">UserDefault</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// UserDefaults 存储键</span>
    <span class="token keyword">let</span> key<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token comment">/// 默认值</span>
    <span class="token keyword">let</span> defaultValue<span class="token punctuation">:</span> <span class="token class-name">T</span>

    <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 UserDefaults 存储和检索值。</span>
        <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token class-name">UserDefaults</span><span class="token punctuation">.</span>standard<span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> key<span class="token punctuation">)</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">T</span> <span class="token operator">??</span> defaultValue <span class="token punctuation">}</span>
        <span class="token keyword">set</span> <span class="token punctuation">{</span> <span class="token class-name">UserDefaults</span><span class="token punctuation">.</span>standard<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> key<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Settings</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@UserDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;ShowOnboarding&quot;</span></span><span class="token punctuation">,</span> defaultValue<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">var</span> showOnboarding<span class="token punctuation">:</span> <span class="token class-name">Bool</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓-dynamicmemberlookup-dynamiccallable" tabindex="-1"><a class="header-anchor" href="#❓-dynamicmemberlookup-dynamiccallable" aria-hidden="true">#</a> ❓<code>@dynamicMemberLookup</code> &amp; <code>@dynamicCallable</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>@dynamicMemberLookup</code>: 动态成员查找，<code>Swift 4.2</code> 引入的新特性。</p><blockquote><p>允许创建被动态调用的类型，它的属性和方法在编译时是未知的，只有在运行时才会确定。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@dynamicMemberLookup</span>
<span class="token keyword">struct</span> <span class="token class-name">DynamicMember</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dictionary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;dynamicMember&quot;</span></span><span class="token punctuation">:</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;otherMember&quot;</span></span><span class="token punctuation">:</span> <span class="token number">119</span><span class="token punctuation">]</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>dynamicMember member<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> dictionary<span class="token punctuation">[</span>member<span class="token punctuation">]</span> <span class="token operator">??</span> <span class="token number">114</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> member <span class="token operator">=</span> <span class="token class-name">DynamicMember</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>member<span class="token punctuation">.</span>dynamicMember<span class="token punctuation">)</span> <span class="token comment">// 110</span>
<span class="token function">print</span><span class="token punctuation">(</span>member<span class="token punctuation">.</span>otherMember<span class="token punctuation">)</span>   <span class="token comment">// 119</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>@dynamicCallable</code>: 动态调用，<code>Swift 5</code> 提供的一个新特性。</p><blockquote><p>允许实现自定义的“可调用”行为。实质上，它是为了 <code>Swift</code> 能更好地与其他的动态语言交互而设计的，比如 <code>Python</code>。</p></blockquote><p><code>@dynamicCallable</code> 类型必须实现以下方法之一（或两个都实现）：</p><ul><li><code>func dynamicallyCall(withArguments args: [T]) -&gt; U</code> : 接受一个未命名参数数组</li><li><code>func dynamicallyCall(withKeywordArguments args: KeyValuePairs&lt;N, T&gt;) -&gt; U</code> : 接受一个键-值对数组作为参数（也即标签和值的数组）</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@dynamicCallable</span>
<span class="token keyword">struct</span> <span class="token class-name">Repeater</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">dynamicallyCall</span><span class="token punctuation">(</span>withKeywordArguments arguments<span class="token punctuation">:</span> <span class="token class-name">KeyValuePairs</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Int</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> arguments<span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">.</span>value <span class="token operator">??</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> repeatTask <span class="token operator">=</span> <span class="token class-name">Repeater</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 实例可以像函数一样被调用</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">repeatTask</span><span class="token punctuation">(</span>count<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// HelloHelloHelloHelloHello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>注：这些特性在调用 <code>Python</code>、<code>JavaScript</code>、<code>Ruby</code> 和其他一些动态脚本语言的 <code>API</code> 时非常有用，因为它能让你写出更加直观和更加接近这些语言的 <code>Swift</code> 代码。</p></details><h3 id="私有" tabindex="-1"><a class="header-anchor" href="#私有" aria-hidden="true">#</a> 私有</h3><h4 id="❓-specialize" tabindex="-1"><a class="header-anchor" href="#❓-specialize" aria-hidden="true">#</a> ❓<code>@_specialize</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@_specialize</code> 是 <code>Swift</code> 中的一个私有特性，在正式的 <code>Swift</code> 版本中不推荐使用，因为它可能在未来的版本中被移除或者修改。</p></blockquote><p><code>@_specialize</code> 属性用来告诉 <code>Swift</code> 的编译器，尽可能地为特定的类型参数生成专门的代码。这意味着当一个使用特定类型参数的函数被调用时，编译器不再使用通用版本，而是使用为这些特定类型生成的专门代码。</p><p>优点：性能优化，因为不再需要类型检查和解包，也不再需要动态派发。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 比较两个 Comparable 的元素并返回最小的一个</span>
<span class="token keyword">func</span> <span class="token function-definition function">min</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> y <span class="token operator">&lt;</span> x <span class="token operator">?</span> y <span class="token punctuation">:</span> x
<span class="token punctuation">}</span>

<span class="token comment">// @_specialize 优化，生成一个专门处理 Int 的版本</span>
<span class="token attribute atrule">@_specialize</span><span class="token punctuation">(</span><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token operator">==</span> <span class="token class-name">Int</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function-definition function">min</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> y <span class="token operator">&lt;</span> x <span class="token operator">?</span> y <span class="token punctuation">:</span> x
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h4 id="❓-functionbuilder" tabindex="-1"><a class="header-anchor" href="#❓-functionbuilder" aria-hidden="true">#</a> ❓<code>@_functionBuilder</code></h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.1</code> 引入了函数建构器特性，目前还处于私有阶段，故以 <code>_</code> 开头。函数建构器功能主要用于简化大量样板代码。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// SwiftUI </span>
<span class="token class-name">VStack</span><span class="token punctuation">(</span>content<span class="token punctuation">:</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> <span class="token class-name">Group</span> <span class="token punctuation">{</span> 
        <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">)</span> 
        <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">)</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// @_functionBuilder 可以简化为如下写法</span>
<span class="token class-name">VStack</span> <span class="token punctuation">{</span> 
    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">)</span> 
    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,169);function O(_,A){const a=o("ExternalLinkIcon");return p(),c("div",null,[l(" more "),r,n("ul",null,[n("li",null,[k,n("a",m,[s("2020-04-15 一文鉴定是 Swift 的王者，还是青铜"),e(a)]),n("blockquote",null,[n("p",null,[v,n("a",b,[s("Answer - Swift 进阶黄金之路"),e(a)])])])]),n("li",null,[w,n("a",f,[s("2018-12-03 Swift 中的面向协议编程：是否优于面向对象编程？"),e(a)])]),n("li",null,[h,n("a",y,[s("2018-11-01 深入剖析 Swift 性能优化"),e(a)])]),n("li",null,[g,n("a",q,[s("2018-10-08 Swift 的 Witness Table"),e(a)])]),n("li",null,[S,n("a",x,[s("2017-01-10 深入理解 Swift 派发机制"),e(a)])]),n("li",null,[C,n("a",P,[s("2016-02-27 Swift 烧脑体操"),e(a)])])]),I])}const D=t(d,[["render",O],["__file","0x02.swift.html.vue"]]);export{D as default};

import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,a as i,f as t}from"./app-4qjgWOI3.js";const s={},n=t('<h3 id="❓时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#❓时间复杂度分析" aria-hidden="true">#</a> ❓时间复杂度分析</h3><details class="hint-container details"><summary>💡</summary><ul><li>最好时间复杂度</li><li>最坏时间复杂度</li><li>平均时间复杂度</li><li>摊还分析法 : 均摊时间复杂度，一种特殊的平均时间复杂度</li></ul></details><h3 id="❓冒泡排序和插入排序的时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#❓冒泡排序和插入排序的时间复杂度是多少" aria-hidden="true">#</a> ❓冒泡排序和插入排序的时间复杂度是多少</h3><details class="hint-container details"><summary>💡</summary><p>两者的时间复杂度相同 O(n²)</p><p>插入排序是稳定的排序，对于相同的元素排序前后的相对位置不会发生变化。</p></details><h3 id="❓为什么实际开发中会更多选择插入排序" tabindex="-1"><a class="header-anchor" href="#❓为什么实际开发中会更多选择插入排序" aria-hidden="true">#</a> ❓为什么实际开发中会更多选择插入排序</h3><details class="hint-container details"><summary>💡</summary><p>插入排序在某些情况下在实际开发中更受欢迎，主要有以下原因：</p><ol><li><p><strong>输入规模小</strong>：插入排序对小规模输入的处理非常高效，因为小规模情况下，插入排序的操作过程减少，效率相对较高。</p></li><li><p><strong>输入序列接近有序</strong>：插入排序对于近乎有序的序列，其性能特别好。在这种情况下，插入排序可以达到线性时间复杂度。</p></li><li><p><strong>稳定排序算法</strong>：稳定性是排序算法的一个重要特性，它保证了等值的元素在排序后保持相对顺序不变。插入排序是稳定的排序算法，这能满足一些特定的需求。</p></li><li><p><strong>原地排序算法</strong>：插入排序是原地排序算法，只需O(1)的额外内存空间，对于内存空间有限的场景非常有利。</p></li><li><p><strong>在线算法</strong>：插入排序是在线算法，在读取输入信息的时候就可以开始进行排序操作，无需获取全部输入信息。</p></li></ol><p>但需要注意的是：插入排序的最坏时间复杂度（当输入序列完全逆序时）是O(n^2)，因此它不适合处理大规模和随机输入的情况，此时快速排序、归并排序等高级排序算法更为适用。</p></details><h3 id="为什么快速排序是不稳定排序-而归并排序是稳定排序" tabindex="-1"><a class="header-anchor" href="#为什么快速排序是不稳定排序-而归并排序是稳定排序" aria-hidden="true">#</a> 为什么快速排序是不稳定排序，而归并排序是稳定排序</h3><h3 id="❓随机数生成-真随机数和伪随机数" tabindex="-1"><a class="header-anchor" href="#❓随机数生成-真随机数和伪随机数" aria-hidden="true">#</a> ❓随机数生成，真随机数和伪随机数</h3><details class="hint-container details"><summary>💡</summary><p>随机数生成是计算机科学中的一个重要主题。在许多应用程序中，比如加密和仿真，都需要使用随机数。随机数可分为两类，真随机数和伪随机数。</p><p><strong>真随机数</strong>：</p><p>真随机数是从某种随机物理过程或现象产生的数，这些过程或现象完全是随机的，如放射性元素的衰变、电子噪声、大气噪声等。实际上，任何有着不确定行为的系统都有可能作为随机源。因为这种方式产生的随机数是基于物理现象，所以在理论上它是完全无法预测的。然而，真随机数生成器在实践中的使用有许多挑战，包括需要特殊的硬件、生成速度慢、难以进行测试和验证等。</p><p><strong>伪随机数</strong>：</p><p>伪随机数是使用确定性算法生成的看起来“像随机”的数。 这些算法通常是数学公式或模型，以便在给定的初始值(称为种子)下可以生成所需的随机数。伪随机数看起来像是随机的，因为他们没有明显的模式或顺序，但在现实中，如果你知道用于生成它们的确切算法和种子值，你就可以预测它们。但是，伪随机数生成器通常非常快速，而且可以产生几乎无限数量的随机数，这使得它们在许多应用中非常有用。</p><p>总而言之，真随机数和伪随机数之间的主要区别在于预测性：真随机数的生成是由物理过程决定的，因此是不可预测的，而伪随机数是由算法生成的，因此在理论上是可以预测的。</p></details>',9);function l(o,d){return e(),r("div",null,[i(" more "),n])}const p=a(s,[["render",l],["__file","0x01.algorithm.html.vue"]]);export{p as default};

import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e,f as o}from"./app-SX6jYwBY.js";const c={},t=o(`<h2 id="kvc" tabindex="-1"><a class="header-anchor" href="#kvc" aria-hidden="true">#</a> KVC</h2><blockquote><p><code>KVC (Key Value Coding)</code> : 是 <code>OC</code> 的特性，可以直接通过键名访问属性和属性赋值。通过 <code>NSObject</code> 的扩展(<code>NSKeyValueCoding</code>)来实现，所有继承 <code>NSObject</code> 的类型都可以使用 <code>KVC</code> 特性。</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 通过 key 读取值</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>nullable id<span class="token punctuation">)</span>valueForKey<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>key<span class="token punctuation">;</span>                          
<span class="token comment">//通过 key 来赋值</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setValue<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable id<span class="token punctuation">)</span>value forKey<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>key<span class="token punctuation">;</span>          
<span class="token comment">// keyPath 读取值</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>nullable id<span class="token punctuation">)</span>valueForKeyPath<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>keyPath<span class="token punctuation">;</span>                  
<span class="token comment">// keyPath 来赋值</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setValue<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable id<span class="token punctuation">)</span>value forKeyPath<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>keyPath<span class="token punctuation">;</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="❓kvc-机制是如何通过-key-找到-value" tabindex="-1"><a class="header-anchor" href="#❓kvc-机制是如何通过-key-找到-value" aria-hidden="true">#</a> ❓<code>KVC</code> 机制是如何通过 <code>key</code> 找到 <code>value</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>KVC</code>，即 <code>Key-Value Coding</code>，是一种通过字符串（key）来获取或者设置对象的属性（value）的机制。当通过 <code>valueForKey:</code> 方法获取值或者 <code>setValue:forKey:</code> 来设值时，<code>KVC</code> 会按照一定的搜索规则来寻找对应的 key。</p></blockquote><ul><li><p><code>valueForKey:</code></p><ul><li><p>查找 <code>getter</code> 方法</p><blockquote><p>首先 <code>KVC</code> 会检查当前对象是否存在名为 key 的 <code>getter</code> 方法或者名为 <code>get&lt;Key&gt;</code> 的 <code>getter</code> 方法。如果存在，就直接调用该方法来获取值。</p></blockquote></li><li><p>直接访问实例变量</p><blockquote><p>如果没有找到 <code>getter</code> 方法，<code>KVC</code> 会查找是否存在名为 key 的实例变量或者名为 <code>_key</code>、<code>_isKey</code>、<code>isKey</code>的实例变量。如果找到，就直接返回实例变量的值。</p></blockquote></li><li><p><code>valueForUndefinedKey:</code> 方法</p><blockquote><p>如果还是没有找到，<code>KVC</code> 会寻找是否实现了 <code>valueForUndefinedKey:</code> 方法，如果实现，就返回该方法的值。</p></blockquote></li><li><p>抛出异常</p><blockquote><p>如果 <code>valueForUndefinedKey:</code> 方法也不存在，<code>KVC</code> 抛出 <code>NSUnknownKeyException</code>异常。</p></blockquote></li></ul></li><li><p><code>setValue:forKey:</code></p><ul><li><p>查找 <code>setter</code> 方法</p><blockquote><p>首先 <code>KVC</code> 会检查对象是否存在名为 <code>set&lt;Key&gt;:</code> 的 <code>setter</code> 方法，如果存在，则调用该方法设置值。</p></blockquote></li><li><p>直接设置实例变量</p><blockquote><p>如果没有 <code>setter</code> 方法，<code>KVC</code> 会查找是否存在名为 key 或者 _key 的实例变量，如果存在，就直接设置实例变量的值。</p></blockquote></li><li><p><code>setValue:forUndefinedKey:</code> 方法</p><blockquote><p>如果没有找到对应的实例变量，<code>KVC</code> 会检查是否实现了 <code>setValue:forUndefinedKey:</code> 方法，如果实现，那么会调用该方法。</p></blockquote></li><li><p>抛出异常</p><blockquote><p>如果 <code>setValue:forUndefinedKey:</code> 方法也不存在，<code>KVC</code> 抛出 <code>NSUnknownKeyException</code> 异常。</p></blockquote></li></ul></li></ul></details><h3 id="❓若一个类有实例变量-nsstring-foo-调用-setvalue-forkey-时-是以-foo-还是-foo-作为-key" tabindex="-1"><a class="header-anchor" href="#❓若一个类有实例变量-nsstring-foo-调用-setvalue-forkey-时-是以-foo-还是-foo-作为-key" aria-hidden="true">#</a> ❓若一个类有实例变量 <code>NSString *_foo</code>，调用 <code>setValue:forKey:</code> 时，是以 <code>foo</code> 还是 <code>_foo</code> 作为 <code>key</code></h3><details class="hint-container details"><summary>💡</summary><p><code>setValue:forKey:</code> 方法在寻找对应的实例变量时，对于名为 <code>foo</code> 的 key，系统会首先寻找 setter 方法 <code>setFoo:</code>；如果 <code>setFoo:</code> 方法不存在，就会寻找名为<code>_foo</code>的实例变量。所以在这种情况下，你应该以 <code>foo</code> 作为 <code>key</code>。这也是 <code>Apple</code> 官方 <code>KVC</code> 编程指南的建议，用属性名不带下划线 <code>_</code> 的格式作为 key。</p><p>底层会优先寻找 <code>foo, _foo, _isFoo, isFoo</code> 这些形式的实例变量，这体现了 <code>KVC</code> 强大的容错处理能力。</p><p>注意，直接操作实例变量可能会绕过一些属性的约束或行为（比如属性的内存管理策略，<code>KVO</code> 通知等），所以除非有特殊的需求或考虑，通常还是推荐通过属性进行访问的。</p></details><h3 id="❓kvc-的-keypath-中的集合运算符如何使用" tabindex="-1"><a class="header-anchor" href="#❓kvc-的-keypath-中的集合运算符如何使用" aria-hidden="true">#</a> ❓<code>KVC</code> 的 <code>keyPath</code> 中的集合运算符如何使用</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>KVC</code> 中，可以使用一些特殊的操作符来对值进行集合操作。这些操作符包括 <code>@avg、@count、@max、@min、@sum</code> 以及集合操作符 <code>@distinctUnionOfObjects、@unionOfObjects</code>。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">self</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> peopleArray <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;John&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Alice&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Bob&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>

<span class="token comment">// 计算平均年龄</span>
<span class="token comment">// ⚠️ 需要使用 NSArray 而不是 Swift 的 Array(不支持 KVC)</span>
<span class="token keyword">let</span> totalAge <span class="token operator">=</span> <span class="token punctuation">(</span>peopleArray <span class="token keyword">as</span> <span class="token class-name">NSArray</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKeyPath<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;@avg.age&quot;</span></span><span class="token punctuation">)</span>

<span class="token comment">// 获取名字数组</span>
<span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">(</span>peopleArray <span class="token keyword">as</span> <span class="token class-name">NSArray</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKeyPath<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;@distinctUnionOfObjects.name&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓kvc-有哪些实际应用" tabindex="-1"><a class="header-anchor" href="#❓kvc-有哪些实际应用" aria-hidden="true">#</a> ❓<code>KVC</code> 有哪些实际应用</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>数据模型转换</p><blockquote><p>在处理网络请求返回的 <code>JSON</code> 数据时，可以使用 <code>KVC</code> 将字典转换为自定义的模型。通过遍历字典，使用 <code>KVC</code> 的 <code>setValue:forKey:</code> 方法，可以将字典的值设置到对应的模型属性上。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">for</span> key <span class="token keyword">in</span> dictionary<span class="token punctuation">.</span>keys <span class="token punctuation">{</span>
    model<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>查询和操作集合</p><blockquote><p>可以使用 <code>KVC</code> 进行集合运算，比如求平均值（@avg）、总和（@sum）、最大值（@max）、最小值（@min）等，减少了编写求和、过滤等代码的工作量。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> totalAge <span class="token operator">=</span> peopleArray<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKeyPath<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;@sum.age&quot;</span></span><span class="token punctuation">)</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token class-name">NSNumber</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>动态属性访问和设置</p><blockquote><p>在某些需要动态改变属性或动态访问的场景，比如写一些通用的 <code>UI</code> 设置代码，可以根据外部传入的属性名字符串，动态设置对象的属性，增强了代码的通用性和灵活性。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">configure</span><span class="token punctuation">(</span>object<span class="token punctuation">:</span> <span class="token class-name">NSObject</span><span class="token punctuation">,</span> property<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    object<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> property<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓kvc-的底层实现" tabindex="-1"><a class="header-anchor" href="#❓kvc-的底层实现" aria-hidden="true">#</a> ❓<code>KVC</code> 的底层实现</h3><details class="hint-container details"><summary>💡</summary><p><code>KVC</code> 的底层实现主要是通过几个步骤寻找对应的键值，并直接访问实例变量。</p><ul><li><p>检查是否存在与给定键名匹配的 <code>setter</code> 或 <code>getter</code> 方法。如果存在，它们将被优先调用。 对于 <code>setValue:forKey:</code>，会查找 <code>set&lt;Key&gt;:</code> 格式的方法；对于 <code>valueForKey:</code>，会查找 <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 或 <code>get&lt;Key&gt;</code>格式的方法。</p></li><li><p>如果不存在相应的 <code>setter</code> 或 <code>getter</code> 方法，那么会查看 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 这个类方法是否返回<code>YES</code>。如果这个方法返回 <code>NO</code>，那么将会调用 <code>setValue:forUndefinedKey:</code> 或者 <code>valueForUndefinedKey:</code>。</p></li><li><p>如果返回 <code>YES</code>，那么将会按照 <code>_key</code>, <code>_isKey</code>, <code>key</code>, <code>isKey</code>的顺序查找实例变量。如果找到相应的实例变量，那么将直接对这个实例变量进行赋值或者取值。对于 <code>setValue:forKey:</code>，如果设置的值为 <code>nil</code>，那么将会调用 <code>setNilValueForKey:</code>。</p></li><li><p>如果没有找到匹配的实例变量，那么再次会调用 <code>setValue:forUndefinedKey:</code> 或者 <code>valueForUndefinedKey:</code>。这两个方法默认的实现是抛出一个异常，但可以根据需求来重写它们。</p></li></ul></details><hr><h2 id="kvo" tabindex="-1"><a class="header-anchor" href="#kvo" aria-hidden="true">#</a> KVO</h2><blockquote><p><code>KVO (Key Value Observer)</code> : 是一种观察者模式的实现。</p></blockquote><h3 id="❓addobserver-forkeypath-options-context-各个参数的作用是什么" tabindex="-1"><a class="header-anchor" href="#❓addobserver-forkeypath-options-context-各个参数的作用是什么" aria-hidden="true">#</a> ❓<code>addObserver:forKeyPath:options:context:</code> 各个参数的作用是什么</h3><details class="hint-container details"><summary>💡</summary><p><code>addObserver:forKeyPath:options:context:</code> 方法用于注册一个观察者来监听一个属性的变化。</p><ul><li><p><code>observer</code>: 注册的观察者对象，这个对象必须实现一个 <code>observeValueForKeyPath:ofObject:change:context:</code> 的方法，来处理对应的属性变化。</p></li><li><p><code>forKeyPath</code>: 要监听的属性字符串。</p></li><li><p><code>options</code>: 用于设置观察的选项，它是一个标志位。</p><p>*<code>NSKeyValueObservingOptionNew</code>：观察属性新值。</p><ul><li><code>NSKeyValueObservingOptionOld</code>：观察属性的旧值。</li><li><code>NSKeyValueObservingOptionInitial</code>：在注册观察者时立即发送一次通知。</li><li><code>NSKeyValueObservingOptionPrior</code>：在改变前后都发送通知。</li></ul></li><li><p><code>context</code>: 上下文信息，主要用于在回调方法中区分观察的属性。当有多个属性使用同样的 <code>keyPath</code> 注册观察者时，可以通过这个参数区分它们。</p></li></ul></details><blockquote><p><code>observer</code> 中需要实现哪个方法才能获得 <code>KVO</code> 回调</p></blockquote><details class="hint-container details"><summary>💡</summary><p>需要实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来处理属性变化。</p><ul><li><code>keyPath</code>：被观察的属性名。</li><li><code>object</code>：被观察的对象。</li><li><code>change</code>：一个字典，包含了旧值和新值，具体内容由注册观察者时的选项决定。</li><li><code>context</code>：注册观察者时传入的上下文。</li></ul><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>observeValueForKeyPath<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>keyPath ofObject<span class="token punctuation">:</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>object change<span class="token punctuation">:</span><span class="token punctuation">(</span>NSDictionary<span class="token operator">&lt;</span>NSKeyValueChangeKey<span class="token punctuation">,</span>id<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span>change context<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>context <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>keyPath isEqualToString<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//handle property change</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓kvo-的优缺点" tabindex="-1"><a class="header-anchor" href="#❓kvo-的优缺点" aria-hidden="true">#</a> ❓<code>KVO</code> 的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>优点：</p><ul><li><p><code>KVO</code> 提供了一种简单的方式来观察和响应对象属性的变化。</p></li><li><p><code>KVO</code> 是基于 <code>Objective-C</code> 的动态性，不需要提前设定哪些属性是可观察的。</p></li><li><p><code>KVO</code> 可以观察私有变量，这在一些特殊场合非常有用。</p></li></ul><p>缺点：</p><ul><li><p><code>KVO</code> 的使用方式比较复杂，需要添加和移除观察者，观察者过多时可能容易出错。</p></li><li><p><code>KVO</code> 的使用破坏了封装性，引入了不必要的依赖。如果一个类的内部实现改变了，那么使用 <code>KVO</code> 观察该类属性的代码可能会出错。</p></li><li><p><code>KVO</code> 在处理异常时并不友好，例如如果观察了一个并不存在的属性，<code>KVO</code> 会在运行时崩溃。</p></li><li><p><code>KVO</code> 的底层实现依赖于 <code>Objective-C</code> 的 <code>runtime</code>, 而 <code>runtime</code> 的复杂性导致 <code>KVO</code> 的性能并不是特别好。</p></li><li><p><code>KVO</code> 的代码阅读性和维护性比较差，因为所有的键都是字符串形式，一旦键名拼写错误，编译器并不能检查出来。</p></li></ul></details><h3 id="❓如何手动触发一个-value-的-kvo" tabindex="-1"><a class="header-anchor" href="#❓如何手动触发一个-value-的-kvo" aria-hidden="true">#</a> ❓如何手动触发一个 <code>value</code> 的 <code>KVO</code></h3><details class="hint-container details"><summary>💡</summary><p>使用让 <code>KVO</code> 派发通知的方法 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code>。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 手动触发 KVO，即使属性值并没发生真正的变化</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> willChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;value&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 直接修改实例变量</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> didChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;value&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个方法除了可以用于手动触发 <code>KVO</code> 外，也常常在自定义的 <code>setter</code> 方法中使用以支持 <code>KVO</code>。</p></details><h3 id="❓如何取消系统默认的-kvo-并手动触发" tabindex="-1"><a class="header-anchor" href="#❓如何取消系统默认的-kvo-并手动触发" aria-hidden="true">#</a> ❓如何取消系统默认的 <code>KVO</code> 并手动触发</h3><details class="hint-container details"><summary>💡</summary><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>automaticallyNotifiesObserversForKey<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>key <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>key isEqualToString<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> NO<span class="token punctuation">;</span> <span class="token comment">// 取消自动生成 KVO 通知</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">super</span> automaticallyNotifiesObserversForKey<span class="token punctuation">:</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setProperty<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>property <span class="token punctuation">{</span>
    <span class="token comment">// 手动触发 KVO</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> willChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    _property <span class="token operator">=</span> property<span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> didChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓如何给-kvo-的触发设定条件" tabindex="-1"><a class="header-anchor" href="#❓如何给-kvo-的触发设定条件" aria-hidden="true">#</a> ❓如何给 <code>KVO</code> 的触发设定条件</h3><blockquote><p>例如：改变的值符合某个条件时再触发 <code>KVO</code></p></blockquote><details class="hint-container details"><summary>💡</summary><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>automaticallyNotifiesObserversForKey<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>key <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>key isEqualToString<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> NO<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">super</span> automaticallyNotifiesObserversForKey<span class="token punctuation">:</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setProperty<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>property <span class="token punctuation">{</span>
    <span class="token comment">// 这是自定义的条件，当 property 的长度大于 5 时，才触发 KVO</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>property length<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token keyword">self</span> willChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        _property <span class="token operator">=</span> property<span class="token punctuation">;</span>
        <span class="token punctuation">[</span><span class="token keyword">self</span> didChangeValueForKey<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        _property <span class="token operator">=</span> property<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓kvo-失效了怎么办" tabindex="-1"><a class="header-anchor" href="#❓kvo-失效了怎么办" aria-hidden="true">#</a> ❓<code>KVO</code> 失效了怎么办</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>检查你是否正确注册了观察者</strong></p><blockquote><p>确认是否调用了对象的 <code>addObserver:forKeyPath:options:context:</code> 方法将观察者注册到正确的键路径（key path）。键路径必须是可观察对象的属性。如果键路径写错，<code>KVO</code> 是不会工作的。</p></blockquote></li><li><p><strong>检查你是否正确实现了观察响应方法</strong></p><blockquote><p>加入观察者后，需要实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来响应属性值的改变。如果没有正确实现这个方法，也会导致 <code>KVO</code> 失效。</p></blockquote></li><li><p><strong>检查你是否正确删除了观察者</strong></p><blockquote><p>在观察者不再需要观察属性时，需要调用 <code>removeObserver:forKeyPath:</code> 或 <code>removeObserver:forKeyPath:context:</code> 方法。如果观察者被错误地删除了，或者删除次数多于添加次数，会导致 <code>KVO</code> 失效。</p></blockquote></li><li><p><strong>检查属性是否通过 setter 方法改变</strong></p><blockquote><p><code>KVO</code> 依赖于属性的 <code>setter</code> 方法来工作。如果直接改变了实例变量的值，<code>KVO</code> 会不起作用。如果要改变属性值，一定要使用 <code>self.property = newValue</code> 这样的方式。</p></blockquote></li></ul></details><h3 id="❓kvo-的底层实现" tabindex="-1"><a class="header-anchor" href="#❓kvo-的底层实现" aria-hidden="true">#</a> ❓<code>KVO</code> 的底层实现</h3><details class="hint-container details"><summary>💡</summary><p>对一个对象添加 <code>KVO</code> 观察者的时候，底层会将这个对象的 <code>isa 指针</code> 指向一个中间类 - 这个类是原类的子类，并且重写了被观察属性的 <code>setter</code> 方法。在新的 <code>setter</code> 方法中，会调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code>，用来通知观察者属性值的改变。</p><p>这个新的子类会被动态生成，类名通常是 “NSKVONotifying_原类名” 的形式。可以通过打印对象的 <code>class</code> 和 <code>object_getClass()</code> 来查看这个动态生成的类。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token punctuation">[</span><span class="token keyword">self</span> addObserver<span class="token punctuation">:</span><span class="token keyword">self</span> forKeyPath<span class="token punctuation">:</span><span class="token string">@&quot;property&quot;</span> options<span class="token punctuation">:</span>NSKeyValueObservingOptionNew context<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 输出原类名</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 输出动态生成的子类名</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">object_getClass</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓kvo-为什么要创建一个子类来实现" tabindex="-1"><a class="header-anchor" href="#❓kvo-为什么要创建一个子类来实现" aria-hidden="true">#</a> ❓<code>KVO</code> 为什么要创建一个子类来实现</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>非侵入式：对象的具体类不需要实现任何 <code>KVO</code> 相关的代码，所有工作都是由运行时系统自动完成，对原有代码无侵入性。</p></li><li><p>一般化和自动化：<code>KVO</code> 机制可以使用在所有遵循 <code>KVC</code>（Key Value Coding）的对象上，而不局限于某个具体的类，观察者可以监听任何属性的改变，所有逻辑都被自动化地处理。</p></li></ul><p>这种实现方式也有一些缺点，比如性能开销（频繁观察和移除观察者会导致大量动态类的创建和销毁），难以追踪调试（由于运行时动态创建的类不在源代码中，出错时难以定位），需要处理一些隐式规则（必须在 <code>dealloc</code> 方法中移除观察者，否则可能导致崩溃等）。</p></details><h3 id="❓kvo-崩溃会是什么情况下发生-如何避免" tabindex="-1"><a class="header-anchor" href="#❓kvo-崩溃会是什么情况下发生-如何避免" aria-hidden="true">#</a> ❓<code>KVO</code> 崩溃会是什么情况下发生，如何避免</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>观察者没有正确地移除监听</p><blockquote><p>当被观察对象销毁的时候，如果任何观察者没有停止观察，那么下一次属性值变化就会试图给已经不存在的观察者发送通知，导致崩溃。为了防止此类崩溃，应当确保在观察者或者被观察的对象销毁的时候正确地移除观察者。具体来说，在观察者的 <code>dealloc</code> 方法（或者在 <code>Swift</code> 的 <code>deinit</code> 方法）中移除所有的监听非常重要。</p></blockquote></li><li><p>观察者重复添加监听</p><blockquote><p>如果对同一个属性添加了重复的监听，这本身不会导致崩溃。但是，如果只移除监听一次，还有一个监听将保留在那里，如果观察者销毁了，就可能会引发崩溃。因此，要避免添加重复的观察者，或者确保对每次添加观察者的属性进行相应次数的移除操作。</p></blockquote></li><li><p>添加或删除观察者在多线程环境下没有正确同步</p><blockquote><p>如果在一个线程中添加观察者，然后在另一线程中几乎同时删除观察者，也可能会导致问题。为此，可以使用锁或者其他同步机制来确保线程安全。</p></blockquote></li><li><p>错误的 <code>key</code> 路径或者不存在的 <code>key</code> 路径</p><blockquote><p>要观察的 <code>key</code> 必须是被观察对象的一个 <code>KVC-compliant key</code>。否则，当尝试添加观察者时，程序就会崩溃。因此，应尽量避免硬编码字符串，而应使用能够进行编译器检查的方式，例如，<code>NSStringFromSelector()</code> 或 <code>@keypath</code>。</p></blockquote></li></ul></details><h2 id="kvc-kvo" tabindex="-1"><a class="header-anchor" href="#kvc-kvo" aria-hidden="true">#</a> KVC &amp; KVO</h2><h3 id="❓kvc-和-kvo-的-keypath-一定是属性吗" tabindex="-1"><a class="header-anchor" href="#❓kvc-和-kvo-的-keypath-一定是属性吗" aria-hidden="true">#</a> ❓<code>KVC</code> 和 <code>KVO</code> 的 <code>keyPath</code> 一定是属性吗</h3><details class="hint-container details"><summary>💡</summary><p>是的，对于 <code>KVC</code>（Key-Value Coding）和 <code>KVO</code>（Key-Value Observing），<code>keyPath</code> 通常是对象的属性（property）。</p><p>比如有一个 <code>Person</code> 类有一个叫<code>age</code>的属性，就可以用 <code>age</code> 作为 <code>keyPath</code> 来获取或设置它的值。也可以用更复杂的 <code>keyPath</code> 来访问对象的关联对象的属性。比如 <code>Person</code> 类有一个 <code>address</code> 属性是 <code>Address</code> 类的实例，<code>Address</code> 类又有一个 <code>city</code> 的属性，可以使用 <code>address.city</code> 这样的 <code>keyPath</code> 来获取或设置人的地址的城市。</p><p>如果 <code>keyPath</code> 不是属性，且没有提供自定义的访问器（accessor）方法，使用 <code>KVC</code> 来访问这个 <code>keyPath</code> 会抛出异常。</p><p>在使用 <code>KVO</code> 时，观察的属性必须支持 <code>KVO</code>，也就是说必须是动态性质（dynamic property），这通常涉及到属性的内存管理和 <code>objc</code> 运行时系统。</p></details><h3 id="❓kvc-成员变量会不会触发-kvo" tabindex="-1"><a class="header-anchor" href="#❓kvc-成员变量会不会触发-kvo" aria-hidden="true">#</a> ❓<code>KVC</code> 成员变量会不会触发 <code>KVO</code></h3><details class="hint-container details"><summary>💡</summary><p>使用 <code>KVC</code>(<code>Key-Value Coding</code>) 赋值时</p><ul><li>如果找到了相应的 <code>setter</code> 方法，会默认调用这个 <code>setter</code> 方法，进而触发 <code>KVO</code>(<code>Key-Value Observing</code>)。</li><li>如果不存在相应的 <code>setter</code> 方法，<code>KVC</code> 会直接修改实例变量的值，这个过程不会触发 <code>KVO</code>。</li></ul><p>使用 <code>KVC</code> 触发 <code>KVO</code></p><ul><li>确保存在一个相应的 <code>setter</code> 方法。</li><li>在修改值之前和之后手动调用 <code>willChangeValue(forKey:)</code> 和 <code>didChangeValue(forKey:)</code> 以通知 <code>Key-Value Observing</code> 系统。</li></ul></details><h3 id="❓通过-kvc-修改属性会触发-kvo-吗" tabindex="-1"><a class="header-anchor" href="#❓通过-kvc-修改属性会触发-kvo-吗" aria-hidden="true">#</a> ❓通过 <code>KVC</code> 修改属性会触发 <code>KVO</code> 吗</h3><details class="hint-container details"><summary>💡</summary><p>是的，通过 <code>KVC</code> 修改属性会触发 <code>KVO</code>。</p><p><code>KVC</code>（Key-Value Coding）和<code>KVO</code>（Key-Value Observing）都是基于 <code>Objective-C</code> 的动态性质的特性。当使用 <code>KVC</code> 的 <code>setValue:forKey:</code> 方法设置属性值时，<code>KVO</code> 将会自动通知所有注册为这个属性观察者的对象。这是因为 <code>KVC</code> 在实现时，会尽量调用 <code>setter</code> 方法，而 <code>KVO</code> 就是通过监听是否调用了 <code>setter</code> 方法来触发的。</p><p>如果直接改变一个实例变量的值（绕过<code>setter</code>和<code>getter</code>），那么 <code>KVO</code> 将不会被触发。因为 <code>KVO</code> 的事件触发是依赖于 <code>setter</code> 的调用的。如果想直接改变实例变量同时又想触发 <code>KVO</code> ，需要手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 。</p></details>`,44);function p(l,i){return s(),a("div",null,[e(" more "),t])}const r=n(c,[["render",p],["__file","0x04.kvc-kvo.html.vue"]]);export{r as default};

import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as t,c,a as i,b as n,e as a,d as p,f as d}from"./app-aW0fSETx.js";const u={},l=n("h2",{id:"reference",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),a(" reference")],-1),r={href:"https://juejin.cn/post/6844904082516213768",target:"_blank",rel:"noopener noreferrer"},m=d(`<hr><h2 id="notificationcenter" tabindex="-1"><a class="header-anchor" href="#notificationcenter" aria-hidden="true">#</a> NotificationCenter</h2><h3 id="❓nsnotification-实现原理" tabindex="-1"><a class="header-anchor" href="#❓nsnotification-实现原理" aria-hidden="true">#</a> ❓<code>NSNotification</code> 实现原理</h3><details class="hint-container details"><summary>💡</summary><p><code>NSNotification</code>的实现原理在于“观察者模式”：</p><ul><li><p>注册观察者：对象（观察者）向 <code>NSNotificationCenter</code>（通知中心）注册自己，表示希望接收某一种通知。此时，需要提供一个选择器，这个选择器是在通知发生后调用的一个方法，也会提供一个可选的名称和/或发送者，以便筛选需要接收的通知。</p></li><li><p>发送通知：某个对象（通知源）创建了一个 <code>NSNotification</code> 实例，包含了通知的名称和有关通知所代表事件的信息，然后将这个实例传递给 <code>NSNotificationCenter</code>，要求它将通知发送给所有的观察者。</p></li><li><p>接收和处理通知：<code>NSNotificationCenter</code> 找到注册听这种通知的所有观察者，然后调用它们提供的选择器，把通知实例作为参数传入。观察者在方法内部可以获取并使用其中的信息。</p></li><li><p>移除观察者：当观察者不再需要监听通知时（比如在对象被销毁前），需要手动告诉 <code>NSNotificationCenter</code> 移除自己，以防止在观察者不存在时尝试调用观察者的方法引发错误。</p></li></ul></details><h3 id="❓页面销毁时不移除通知会崩溃吗" tabindex="-1"><a class="header-anchor" href="#❓页面销毁时不移除通知会崩溃吗" aria-hidden="true">#</a> ❓页面销毁时不移除通知会崩溃吗</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>在 <code>iOS9</code> 之前，如果不在页面销毁时移除通知，可能会导致崩溃。这是因为，当监听对象（通常是 <code>UIViewController</code> 实例）被销毁时，其关联的通知并没有被自动移除。如果此时有新的通知发送过来，系统仍然会尝试调用监听对象的通知处理方法，但由于监听对象已经被销毁，这时候就会抛出一个异常，导致应用崩溃。</p></li><li><p>从 <code>iOS9</code> 和 <code>OS X 10.11</code> 开始，如果监听对象被销毁，<code>NSNotificationCenter</code> 将会自动移除与其相关的所有通知，因此不需要手动移除。但注意，这个特性仅适用于 <code>NSNotificationCenter</code>，不适用于其他的通知中心，如 <code>NSDistributedNotificationCenter</code> 或者 <code>NSWorkspace.shared.notificationCenter</code>。</p></li></ul></details><h3 id="❓多次添加同一个通知会是什么结果" tabindex="-1"><a class="header-anchor" href="#❓多次添加同一个通知会是什么结果" aria-hidden="true">#</a> ❓多次添加同一个通知会是什么结果</h3><details class="hint-container details"><summary>💡</summary><p>多次添加同一个通知会导致通知被多次执行。</p><p>因为在添加通知的时候，<code>NotificationCenter</code> 会为每个添加的通知注册一个观察者。当有一个通知被发布的时候，<code>NotificationCenter</code> 会查找所有注册了该通知名的观察者并执行对应的选择器（方法）。所以，如果多次注册了同一个通知和同一个选择器，当该通知被发布的时候，对应的选择器就会被执行多次。</p></details><blockquote><p>多次移除通知呢</p></blockquote><details class="hint-container details"><summary>💡</summary><p>多次移除同一个通知，系统不会报错，移除操作也不会对性能有影响。</p><p>系统在移除时会找到对应的观察者并取消其注册，如果没有找到则不会有任何操作。所以多次移除同一个通知是没有问题的，但还是建议按照需要来添加或移除通知，以保持代码干净整洁。如果确定某个通知已经被移除，那么就没有必要再次移除。</p></details><h3 id="❓下面代码可以接受通知吗" tabindex="-1"><a class="header-anchor" href="#❓下面代码可以接受通知吗" aria-hidden="true">#</a> ❓下面代码可以接受通知吗</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSNotificationCenter <span class="token operator">*</span>center <span class="token operator">=</span> <span class="token punctuation">[</span>NSNotificationCenter defaultCenter<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 发送通知</span>
<span class="token punctuation">[</span>center addObserver<span class="token punctuation">:</span><span class="token keyword">self</span> selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>handleNotification<span class="token punctuation">:</span><span class="token punctuation">)</span> name<span class="token punctuation">:</span><span class="token string">@&quot;One&quot;</span> object<span class="token punctuation">:</span><span class="token operator">@</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 接收通知</span>
<span class="token punctuation">[</span>center postNotificationName<span class="token punctuation">:</span><span class="token string">@&quot;One&quot;</span> object<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>无法接收到通知。</p><p>原因在于：在添加观察者 <code>addObserver:selector:name:object:</code> 时，为 <code>object</code> 参数传入了 <code>@1</code>，这意味着观察者只处理那些 <code>object</code> 为 <code>@1</code> 的通知。在发送通知 <code>postNotificationName:object:</code> 时，<code>object</code> 参数设置为 <code>nil</code>，这意味着通知并没有携带任何对象。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 解决方案</span>
<span class="token comment">//   - 方案一：发送通知时将 object 设置为 @1</span>
<span class="token punctuation">[</span>center postNotificationName<span class="token punctuation">:</span><span class="token string">@&quot;One&quot;</span> object<span class="token punctuation">:</span><span class="token operator">@</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//   - 方案二：添加观察者时将 object 参数设置为 nil</span>
<span class="token punctuation">[</span>center addObserver<span class="token punctuation">:</span><span class="token keyword">self</span> selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>handleNotification<span class="token punctuation">:</span><span class="token punctuation">)</span> name<span class="token punctuation">:</span><span class="token string">@&quot;One&quot;</span> object<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="notificationqueue" tabindex="-1"><a class="header-anchor" href="#notificationqueue" aria-hidden="true">#</a> NotificationQueue</h2><h3 id="❓nsnotificationqueue-是异步还是同步发送-在哪个线程响应" tabindex="-1"><a class="header-anchor" href="#❓nsnotificationqueue-是异步还是同步发送-在哪个线程响应" aria-hidden="true">#</a> ❓<code>NSNotificationQueue</code> 是异步还是同步发送，在哪个线程响应</h3><details class="hint-container details"><summary>💡</summary><p><code>NSNotificationQueue</code> 是 <code>NSNotificationCenter</code> 的扩展，它可以实现异步发送通知以及合并发送相同通知。</p><p><code>NSNotificationQueue</code> 的 <code>- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle</code> 方法发送通知时，这是一个异步过程。通知会被加入一个基于 <code>RunLoop</code> 的队列中，只有当 <code>RunLoop</code> 启动时才会发送通知。</p><p>通知响应的线程一般依赖于添加通知的线程。当在主线程添加通知，那么会在主线程响应这个通知。但需要注意的是，由于 <code>NSNotificationQueue</code> 是基于 <code>RunLoop</code> 的，因此在后台线程中由于默认情况下没有 <code>RunLoop</code>，所以无法在后台线程响应通过 <code>NSNotificationQueue</code> 发送的通知。如果希望在后台线程响应，那么需要创建并启动 <code>RunLoop</code>。</p><p><code>NSNotificationQueue</code> 还提供了一种机制，即合并通知。当连续发送多个相同的通知时，<code>NSNotificationQueue</code> 会将它们合并为一个通知进行发送，这样可以避免发送大量相同的通知造成的性能问题。</p></details><h3 id="❓nsnotificationqueue-和-runloop的关系" tabindex="-1"><a class="header-anchor" href="#❓nsnotificationqueue-和-runloop的关系" aria-hidden="true">#</a> ❓<code>NSNotificationQueue</code> 和 <code>runloop</code>的关系</h3><details class="hint-container details"><summary>💡</summary><p><code>NSNotificationQueue</code>的工作是基于<code>RunLoop</code>的。将一个通知加入到 <code>NSNotificationQueue</code> 时，通知不会立刻被发送出去，而是会被加到当前 <code>RunLoop</code> 的事件队列中，在下一个 <code>RunLoop</code> 迭代时才会被处理和发送。</p><p>如果将多个相同的通知加入到队列中，<code>NSNotificationQueue</code> 会进行合并，等到 <code>RunLoop</code> 迭代时只发送一个通知，这样可以有效防止大量重复通知导致的性能问题。</p></details><hr><h2 id="通知与线程" tabindex="-1"><a class="header-anchor" href="#通知与线程" aria-hidden="true">#</a> 通知与线程</h2><h3 id="❓如何保证通知接收的线程在主线程" tabindex="-1"><a class="header-anchor" href="#❓如何保证通知接收的线程在主线程" aria-hidden="true">#</a> ❓如何保证通知接收的线程在主线程</h3><details class="hint-container details"><summary>💡</summary><p>通常使用<code>Grand Central Dispatch</code> (<code>GCD</code>) 来确保通知的响应是在主线程上执行的。在通知接收到之后，在主线程队列上异步执行一个块来处理通知事件。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// Notification callback method</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>handleNotification<span class="token punctuation">:</span><span class="token punctuation">(</span>NSNotification <span class="token operator">*</span><span class="token punctuation">)</span>notification <span class="token punctuation">{</span>
    <span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token comment">// Handle notification in the main thread here.</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓通知的发送时同步还是异步" tabindex="-1"><a class="header-anchor" href="#❓通知的发送时同步还是异步" aria-hidden="true">#</a> ❓通知的发送时同步还是异步</h3><details class="hint-container details"><summary>💡</summary><p><code>NSNotification</code> 的发送是同步的，也就是说当一个通知被发出，<code>NSNotificationCenter</code> 会立刻逐个遍历所有的观察者，执行对应的处理方法，直到所有观察者都处理完通知，才会继续执行发送通知后的代码。</p><p>在执行观察者的处理代码时，是在发送通知的线程内执行的。这意味着如果在主线程发送通知，通知的处理也将在主线程执行。如果在后台线程发送通知，通知的处理也将在后台线程执行。</p><p><code>NSNotificationCenter</code> 同时也提供了异步发送通知的方法：<code>postNotification:object:userInfo:deliverImmediately:</code>。这个方法会把通知添加到当前 <code>runloop</code> 的队列中，然后立即返回，通知的处理会在 <code>runloop</code> 下次循环时执行。这个方法在 <code>iOS</code> 中并未公开，只在 <code>macOS</code> 中可以使用。</p></details><h3 id="❓通知的发送和接受是在同一个线程里吗-如何异步发送消息" tabindex="-1"><a class="header-anchor" href="#❓通知的发送和接受是在同一个线程里吗-如何异步发送消息" aria-hidden="true">#</a> ❓通知的发送和接受是在同一个线程里吗，如何异步发送消息</h3><details class="hint-container details"><summary>💡</summary><p><code>NSNotification</code>的发送和接收默认情况下是在同一个线程中进行的。简单来说，如果在主线程中发布通知，那么处理通知的方法也会在主线程中运行。同样，如果在后台线程中发布通知，那么接收到的通知也会在后台线程中处理。</p><p>对于如何异步发送通知，<code>Cocoa</code> 并没有提供直接的 <code>API</code>，但可以通过 <code>dispatch_async</code> 函数将发送通知的操作放到想要的队列（主队列或者其他自定义的并发队列）中进行。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 在主队列中异步发送通知</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">[</span>NSNotificationCenter defaultCenter<span class="token punctuation">]</span> postNotificationName<span class="token punctuation">:</span><span class="token string">@&quot;NotificationName&quot;</span> object<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,27);function h(k,f){const e=o("ExternalLinkIcon");return t(),c("div",null,[i(" more "),l,n("ul",null,[n("li",null,[n("a",r,[a("2020-03-05 一文全解 iOS 通知机制"),p(e)])])]),m])}const v=s(u,[["render",h],["__file","0x05.notification.html.vue"]]);export{v as default};

import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,a,f as o}from"./app-b_rSVNxV.js";const c={},i=o(`<h2 id="oc-设计理念" tabindex="-1"><a class="header-anchor" href="#oc-设计理念" aria-hidden="true">#</a> <code>OC</code> 设计理念</h2><p><code>OC</code> 底层是使用 <code>C/C++</code> 实现。定一个继承 <code>NSObject</code> 的类，这个类底层使用 <code>C</code> 语言中的 <code>struct</code> 结构体来实现的。</p><h3 id="❓oc-的动态性" tabindex="-1"><a class="header-anchor" href="#❓oc-的动态性" aria-hidden="true">#</a> ❓<code>OC</code> 的动态性</h3><details class="hint-container details"><summary>💡</summary><p>首先理解两个“动态语言与静态语言”</p><p><code>OC</code> 的 <code>runtime</code> 文档中介绍中就详细写明了，<code>runtime</code> 的设计是为了将 <code>OC</code> 中的更多的处理延迟到编译后。</p><ul><li>动态类型 (Dynamic typing) : 编译时并不确定对象类型，在运行时才判断对象的类型。<code>OC</code> 中一切对象都可以用 <code>id</code> 指针指向。</li><li>动态绑定 (Dynamic binding) : 方法的调用也是运行时才决定，而并非编译时。</li><li>动态加载 (Dynamic loading) : 运行时可以动态加载其它模块或框架</li></ul></details><h3 id="❓类结构体的组成-isa-指针指向了什么" tabindex="-1"><a class="header-anchor" href="#❓类结构体的组成-isa-指针指向了什么" aria-hidden="true">#</a> ❓类结构体的组成，<code>isa</code> 指针指向了什么？</h3><details class="hint-container details"><summary>💡</summary><p>先给出答案 <code>isa</code> 指针是指向类对象，每一个对象都包含 <code>isa</code> 指针，通过这个指针可以找到类对象。</p><p>当一个对象调用某个方法时(消息发送)，运行时先在当前方法列表中查找，如果不存在，通过 <code>isa</code> 指针查找类对象中是否存在方法，如果还不存在会通过父类指针进一步往上查找，最后还是找不到就会抛出未找到异常。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// id 就是 objc_object</span>
<span class="token keyword">struct</span> objc_object <span class="token punctuation">{</span>
  Class _Nonnull isa<span class="token punctuation">;</span>         <span class="token comment">// 指向对象所属的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Class 就是 objc_class</span>
<span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
  Class _Nonnull isa<span class="token punctuation">;</span>         <span class="token comment">// 指向元类</span>
  Class _Nullable superclass<span class="token punctuation">;</span> <span class="token comment">// 指向父类</span>
  cache_t cache<span class="token punctuation">;</span>              <span class="token comment">// 方法缓存</span>
  class_data_bits_t bits<span class="token punctuation">;</span>     <span class="token comment">// 包含方法列表和其他信息</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓oc-底层方法列表的数据结构是什么" tabindex="-1"><a class="header-anchor" href="#❓oc-底层方法列表的数据结构是什么" aria-hidden="true">#</a> ❓<code>OC</code> 底层方法列表的数据结构是什么？</h3><details class="hint-container details"><summary>💡</summary><p>底层是通过结构体来实现了，结构里面的通过数组来存储方法列表</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 方法列表结构体</span>
<span class="token keyword">struct</span> method_list_t <span class="token punctuation">{</span>
  uint32_t entsize<span class="token punctuation">;</span>        <span class="token comment">// 结构体的大小</span>
  uint32_t method_count<span class="token punctuation">;</span>   <span class="token comment">// 方法的数量</span>
  method_t method_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 方法列表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 方法结构体</span>
<span class="token keyword">struct</span> method_t <span class="token punctuation">{</span>
  SEL sel<span class="token punctuation">;</span>                <span class="token comment">// 方法的名称</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>types<span class="token punctuation">;</span>      <span class="token comment">// 方法的类型</span>
  IMP imp<span class="token punctuation">;</span>                <span class="token comment">// 对应的实现（函数指针）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓id、nil、null-区别" tabindex="-1"><a class="header-anchor" href="#❓id、nil、null-区别" aria-hidden="true">#</a> ❓<code>id</code>、<code>nil</code>、<code>NULL</code> 区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><code>id</code> : 可以指向任意的 <code>OC</code> 对象</li><li><code>nil</code> : 一种特殊的指针，指向为空的 <code>OC</code> 对象</li><li><code>NULL</code> : 也是表示空指针，一般代表 <code>C</code> 指针为空</li></ul></details><h3 id="❓-load-与-initialize-区别" tabindex="-1"><a class="header-anchor" href="#❓-load-与-initialize-区别" aria-hidden="true">#</a> ❓<code>+load</code> 与 <code>+initialize</code> 区别</h3><details class="hint-container details"><summary>💡</summary><p>这两个都是类方法，可以从下面几个方面去对比两者的区别</p><ul><li><p>调用时机</p><ul><li><code>+load</code> : 这是在运行时加载时，进行触发调用。</li><li><code>+initialize</code> : 会在类第一次使用时，进行触发调用。</li></ul></li><li><p>调用次数</p><ul><li><code>+load</code> : 只会在运行时加载时，调用一次。</li><li><code>+initialize</code> : 第一次调用时，调用一次。</li></ul></li><li><p>调用父类</p><ul><li><code>+load</code> : 不会调用父类的 <code>+load</code></li><li><code>+initialize</code> : 如果当前类没有</li></ul></li><li><p>手动调用</p><ul><li><code>+load</code> : 不能手动调用，运行时进行调用的。手动调用会触发异常。</li><li><code>+initialize</code> : 可以手动调用。</li></ul></li></ul></details><blockquote><p>❓<code>+load</code> 的调用顺序</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><code>+load</code> 方法调用顺序与编译连接顺序有关。</li><li>不同类之间的<code>+load</code>方法的调用顺序不能确定，取决于编译连接顺序。</li><li>如果父类、子类和分类都实现了 <code>+load</code> 方法，<code>+load</code> 方法的调用顺序是：先调用父类的<code>+load</code>，再调用子类的<code>+load</code>，最后调用分类的<code>+load</code>。</li></ul></details><h3 id="❓-property-本质是什么" tabindex="-1"><a class="header-anchor" href="#❓-property-本质是什么" aria-hidden="true">#</a> ❓<code>@Property</code> 本质是什么？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>@property</code> 是 Objective-C 中的一个关键字，用于声明一个属性。</p></li><li><p><code>@property</code> 的主要作用是为类的实例变量（属性）生成对应的访问器方法，即 <code>getter</code> 方法和 <code>setter</code> 方法。</p></li><li><p><code>@property</code> 还可以自定义访问器方法的名字</p><ul><li>原子性 : atomic、nonatomic</li><li>读写性 : readwrite、readonly</li><li>内存管理 : assign、strong、weak、copy</li></ul></li><li><p><code>@property</code>，可以封装实例变量的直接访问，将类的内部实现与外部接口隔离，提高数据的安全性；同时可以在 getter 和 setter 中添加特定的逻辑如设置新值时进行验证，获取值时返回一个计算后的值等，提高代码的可维护性。</p></li><li><p>声明 <code>@property</code> 后，编译器会根据属性的特性在 <code>class_rw_t</code> 结构中的 <code>methods</code> 和 <code>properties</code> 中生成 getter 和 setter 方法以及相应的属性。然后在运行时，这些 getter 和 setter 方法以及属性被引入到<code>objc_class</code>的结构中。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
    Class isa<span class="token punctuation">;</span>              <span class="token comment">// metaclass 的指针</span>
    Class super_class<span class="token punctuation">;</span>      <span class="token comment">// 父类</span>
    cache_t cache<span class="token punctuation">;</span>          <span class="token comment">// 缓存</span>
    class_data_bits_t bits<span class="token punctuation">;</span> <span class="token comment">// 类的相关信息，包含了一个指向 class_rw_t 数据结构的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 可读写结构，存储运行时添加的类信息</span>
<span class="token keyword">struct</span> class_rw_t <span class="token punctuation">{</span>
    uint32_t flags<span class="token punctuation">;</span>
    uint32_t version<span class="token punctuation">;</span>
    <span class="token keyword">const</span> class_ro_t <span class="token operator">*</span>ro<span class="token punctuation">;</span>           <span class="token comment">// 只读结构体，保存编译时确定的类信息</span>
    method_array_t methods<span class="token punctuation">;</span>         <span class="token comment">// 方法列表</span>
    property_array_t properties<span class="token punctuation">;</span>    <span class="token comment">// 属性列表</span>
    protocol_array_t protocols<span class="token punctuation">;</span>     <span class="token comment">// 协议列表</span>
    Class firstSubclass<span class="token punctuation">;</span>
    Class nextSiblingClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><blockquote><p>❓<code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code> 区别？</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><p><code>assign</code>：是赋值特性，简单设置变量，不更改引用计数。主要用在基本的数据类型（如 int、float）或 C 数据类型（如 结构体、C 数组）而不是对象。</p></li><li><p><code>strong</code>（类似于：retain）：是所有权（owning）特性。采用 ARC（自动引用计数）环境下，编译器会自动在设置方法中插入 <code>retain</code> 调用，使对象的引用计数增加，从而表示当前对象拥有数据值。</p></li><li><p><code>weak</code>：是非拥有关系（non-owning）特性，即弱引用。当用 weak 修饰对象时，被指向的对象引用计数不会增加，更重要的是，当对象被释放时，被 <code>weak</code> 修饰的变量会自动被置为 nil，防止野指针的出现。weak 修饰的属性适合在已经存在对对象的<code>strong</code>引用，或者对象之间存在相互循环引用的情况下使用。</p></li><li><p><code>copy</code>：是拷贝特性，适合 NSString、NSArray、NSDictionary 等不可变对象。最重要的一点是：使用 <code>copy</code> 保持封装性，对象在内部可能需要一个数据的完整副本，并且把这个副本给外界使用，防止作为接口提供的对象的初始数据被改变。</p><p>选择哪种属性修饰符要视情况而定，如果数据是不可变的，那么选择 <code>assign</code> 或 <code>copy</code> 较好；如果数据是可变的，可以选择 <code>strong</code> 或 <code>weak</code>。</p></li></ul></details><h3 id="❓oc-中的三种字符串" tabindex="-1"><a class="header-anchor" href="#❓oc-中的三种字符串" aria-hidden="true">#</a> ❓<code>OC</code> 中的三种字符串？</h3><details class="hint-container details"><summary>💡</summary><ul><li><code>__NSCFConstantString</code> ：在编译时被创建的常量字符串对象，如<code>NSString *str = @&quot;Hello, World!&quot;</code>。这些对象会在编译时就被创建，并且在程序的整个生命周期中都不会被销毁。</li><li><code>__NSTaggedPointerString</code> ：使用 <code>Tagged Pointer</code> 技术来提高内存使用效率，通常用于存储较小的字符串数据。</li><li><code>__NSCFString</code> ：本质上是一个 Core Foundation 字符串的引用（CFStringRef），这种类型的字符串通常会在运行时程序动态创建的对象字符串。</li></ul></details><blockquote><p><code>Tagged Pointer</code> 了解吗？</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li>iOS7 之后 Apple 为了优化引入的一项技术。从字面意思上来看<code>Tagged Pointer</code>就是带有标签的指针。</li><li>一般来说，在 64-bit 架构下，一个指针的值需要占用 8 byte 的内存空间；然而对于一些非常小的数据，比如 NSNumber、NSDate、NSString 等，使用 8 byte 存储对象指针就显得非常浪费。为了解决这个问题，苹果引入了 <code>Tagged Pointer</code> 技术，通过标签直接将小的数据对象嵌入到指针中，这样对于小的数据对象，就无需额外的内存来存储了，能够显著提高内存的利用率。需要注意，一个对象是否使用 <code>Tagged Pointer</code> 是由系统决定的，不能人为控制。</li><li>具体到 <code>NSString</code> 这种场景中，如果字符串的内容非常短，那么它的实现方式可能就是 <code>Tagged Pointer</code>，直接将字符串内容存在指针中，提高了内存利用率。</li></ul></details><h3 id="❓nsdictionary-大致实现原理" tabindex="-1"><a class="header-anchor" href="#❓nsdictionary-大致实现原理" aria-hidden="true">#</a> ❓<code>NSDictionary</code> 大致实现原理</h3><details class="hint-container details"><summary>💡</summary><p><code>NSDictionary</code> 在内部实现上采用了哈希表的数据结构</p></details><h2 id="block" tabindex="-1"><a class="header-anchor" href="#block" aria-hidden="true">#</a> <code>block</code></h2><h3 id="❓block-与-函数指针" tabindex="-1"><a class="header-anchor" href="#❓block-与-函数指针" aria-hidden="true">#</a> ❓<code>block</code> 与 函数指针</h3><details class="hint-container details"><summary>💡</summary><ul><li>block 是一种特殊的数据类型，可以存储一段代码，并且这段代码可以在任何时候被执行。可以访问在声明他的那个作用域中定义的变量，这被称为“变量捕获”。</li><li>函数指针：函数指针是存储着函数地址的指针变量，本质上是一个地址值，也就是函数在内存中的起始地址。函数指针不能像 <code>block</code> 那样访问变量，只能通过传参的方式去使用外部的数据。</li></ul></details><h3 id="❓block-底层实现" tabindex="-1"><a class="header-anchor" href="#❓block-底层实现" aria-hidden="true">#</a> ❓<code>block</code> 底层实现？</h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 底层是使用结构体实现的。</p><p>根据内存分区不同，分为三种 <code>block</code></p><ul><li><code>__NSGlobalBlock__</code> : 全局 <code>block</code>，类似全局静态变量，存放在静态区</li><li><code>__NSStackBlock__</code> : 栈区 <code>block</code>，保存在栈区</li><li><code>__NSMallocBlock__</code> : 堆区 <code>block</code>，保存在堆区</li></ul></details><h2 id="category" tabindex="-1"><a class="header-anchor" href="#category" aria-hidden="true">#</a> <code>Category</code></h2><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Category</code>(类别) 提供了一种给已存在类添加方法的机制.</p></blockquote><ul><li><code>Category</code> : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。</li><li><code>Extension</code> : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。</li></ul></details><h3 id="❓如果分类中添加与类相同的方法签名会发生什么" tabindex="-1"><a class="header-anchor" href="#❓如果分类中添加与类相同的方法签名会发生什么" aria-hidden="true">#</a> ❓如果分类中添加与类相同的方法签名会发生什么？</h3><details class="hint-container details"><summary>💡</summary><p>分类中的方法是运行时添加到方法列表中，并且是添加中已有方法的前面。所以当分类与原类中的方法相同时，分类中的方法会优先调用，覆盖掉原类中的方法。</p></details><h3 id="❓分类是如何实现的-它为什么会覆盖掉原来的方法" tabindex="-1"><a class="header-anchor" href="#❓分类是如何实现的-它为什么会覆盖掉原来的方法" aria-hidden="true">#</a> ❓分类是如何实现的？它为什么会覆盖掉原来的方法？</h3><h3 id="❓分类中如何添加属性" tabindex="-1"><a class="header-anchor" href="#❓分类中如何添加属性" aria-hidden="true">#</a> ❓分类中如何添加属性？</h3><details class="hint-container details"><summary>💡</summary><p>可以使用关联对象（<code>Associated Objects</code>）让分类拥有“伪属性”。</p></details><h2 id="runtime" tabindex="-1"><a class="header-anchor" href="#runtime" aria-hidden="true">#</a> <code>runtime</code></h2><h3 id="❓runtime-如何通过-selector-找到对应的-imp-地址" tabindex="-1"><a class="header-anchor" href="#❓runtime-如何通过-selector-找到对应的-imp-地址" aria-hidden="true">#</a> ❓<code>runtime</code> 如何通过 <code>selector</code> 找到对应的 <code>IMP</code> 地址</h3><details class="hint-container details"><summary>💡</summary><ul><li>消息的接受者（receiver）会在自己的类和超类（superclasses）的方法列表中查找与消息匹配的 <code>selector</code>。</li><li>如果找到了匹配的 <code>selector</code>，那么会从方法列表中取出对应的函数指针（IMP），并且调用这个函数。</li><li>如果没有找到匹配的 <code>selector</code>，那么会进入消息转发（forwarding）流程。</li></ul></details><h3 id="❓super-是什么" tabindex="-1"><a class="header-anchor" href="#❓super-是什么" aria-hidden="true">#</a> ❓<code>super</code> 是什么？</h3><details class="hint-container details"><summary>💡</summary><p><code>super</code> 并不是一个指针，在 <code>OC</code> 进行消息调用时，其实是有两个隐藏参数的，一个是接收者(receiver)，一个是方法选择器(selector)。</p><p>常见的 <code>self</code> 表示的是接收者。而 <code>super</code> 其实是一个编译器标示符，当发送给 <code>super</code> 一个消息时，调用者仍然是 <code>self</code> ，但是运行时会从当前类的父类开始查找方法。</p><blockquote><p>以下代码输出？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@interface</span> Dog <span class="token punctuation">:</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Dog
<span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>init <span class="token punctuation">{</span>
  <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">super</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说 <code>super</code> 并不会改变消息的接收者，所以当我们调用 <code>[super class]</code> 时，虽然是从父类开始查找 <code>class</code> 方法，但是方法的接收者依然是 <code>self</code> 本身，其类别自然是当前类本身。这也是为什么我们再调用 <code>[super class]</code> 时还会返回 <code>Dog</code> 类的原因。</p></details><blockquote><p><code>super</code> 的底层实现？</p></blockquote><details class="hint-container details"><summary>💡</summary><p><code>OC</code> 中 <code>super</code> 的实现是通过 <code>runtime</code> 的 <code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code> 两个函数来完成的。具体来说，当编译器遇到 <code>[super method]</code> 这种形式的调用时，会转化为 <code>objc_msgSendSuper(super_cls, sel)</code> 的形式。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// super 结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">objc_super</span> <span class="token punctuation">{</span>
  __unsafe_unretained id receiver<span class="token punctuation">;</span>        <span class="token comment">// 消息的接收者</span>
  __unsafe_unretained Class super_class<span class="token punctuation">;</span>  <span class="token comment">// 父类(开始查找的类)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// objc_msgSendSuper</span>
<span class="token keyword">void</span> <span class="token function">objc_msgSendSuper</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">objc_super</span> <span class="token operator">*</span>super<span class="token punctuation">,</span> SEL op<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="isa-消息转发-弱引用表" tabindex="-1"><a class="header-anchor" href="#isa-消息转发-弱引用表" aria-hidden="true">#</a> isa, 消息转发, 弱引用表</h3><h2 id="runloop" tabindex="-1"><a class="header-anchor" href="#runloop" aria-hidden="true">#</a> <code>RunLoop</code></h2><h3 id="❓runloop-有几种事件源-有几种模式" tabindex="-1"><a class="header-anchor" href="#❓runloop-有几种事件源-有几种模式" aria-hidden="true">#</a> ❓<code>RunLoop</code> 有几种事件源？有几种模式？</h3><details class="hint-container details"><summary>💡</summary><p><code>RunLoop</code>是用来管理事件和处理IO的基本架构</p><p>三种事件源</p><ul><li><code>Timer Source</code>：定时器事件。<code>RunLoop</code> 按照设定的时间区间接收定时器事件。</li><li><code>Input Source</code>：输入源事件。包括两种类型，一种是基于 <code>Port</code> 的输入源，接收来自其他线程或进程的消息，然后在当前线程上调用指定的处理方法。另一种是自定义的输入源，需要程序员自己生成和管理。</li><li><code>Observer Source</code>：观察者事件。可以设置在 <code>RunLoop</code> 各个运行阶段接收的事件。</li></ul><p>运行模式</p><ul><li><code>NSDefaultRunLoopMode</code>（kCFRunLoopDefaultMode）：默认模式，如果不手动指定模式，RunLoop 就在这个模式下运行。</li><li><code>UITrackingRunLoopMode</code>：界面跟踪模式，用于 <code>ScrollView</code> 滚动时。</li><li><code>UIInitializationRunLoopMode</code>：启动 App 时第进入的模式，启动完成后就不再使用。</li><li><code>NSRunLoopCommonModes</code>（kCFRunLoopCommonModes）：这是一个占位用的 Mode，不是一种真正的 Mode。可以将事件源（Timer/Observer/Source）添加到 CommonModes 中，RunLoop 运行在哪种 Mode 时，只要这种 Mode 被标记为 Common 的属性，则 RunLoop 就会处理相应的事件。</li></ul></details><h3 id="❓runloop-内部实现逻辑" tabindex="-1"><a class="header-anchor" href="#❓runloop-内部实现逻辑" aria-hidden="true">#</a> ❓<code>Runloop</code> 内部实现逻辑？</h3><details class="hint-container details"><summary>💡</summary><p><code>RunLoop</code> 的内部实现可以简单地概括为一个 <code>while</code> 循环，在这个循环中处理各种输入源的事件。<code>RunLoop</code> 在开启后会一直在这个循环中执行，直到接收到停止 <code>RunLoop</code> 的消息。</p><ul><li><code>RunLoop</code> 在启动时会从预设的 Mode 中选择一个，然后进入RunLoop的循环。</li><li>在循环的每一个周期内，<code>RunLoop</code> 会首先处理所有到期的定时器事件。</li><li>然后，<code>RunLoop</code> 会处理所有的输入源事件。输入源的事件包括来自 <code>Port</code> 的消息，以及用户定义的其他事件。</li><li>然后，如果有观察者的话，<code>RunLoop</code> 会通知观察者当前 <code>RunLoop</code> 的状态。</li><li>其次，如果在处理事件的过程中没有任何源需要处理，那么 <code>RunLoop</code> 会进入休眠等待被唤醒。</li><li>这个循环会一直持续下去，直到接收到结束RunLoop的消息。</li></ul></details>`,49);function d(t,l){return n(),s("div",null,[a(" more "),i])}const u=e(c,[["render",d],["__file","objective-c.html.vue"]]);export{u as default};

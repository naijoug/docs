import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,f as t}from"./app-8at8Ga89.js";const d={},i=t('<h1 id="objective-c" tabindex="-1"><a class="header-anchor" href="#objective-c" aria-hidden="true">#</a> Objective-C</h1><p><code>OC</code> 底层是使用 <code>C/C++</code> 实现。定一个继承 <code>NSObject</code> 的类，这个类底层使用 <code>C</code> 语言中的 <code>struct</code> 结构体来实现的。</p><blockquote><p><code>OC</code> 的动态性</p></blockquote><blockquote><p>``id<code>、</code>nil<code>、</code>NULL`</p></blockquote><blockquote><p><code>+load</code> 与 <code>+initialize</code> 的区别</p></blockquote><p><code>+load</code> : <code>+initialize</code> :</p><blockquote><p><code>block</code> 的本质</p></blockquote><blockquote><p><code>OC</code> 中的 Category 分类</p></blockquote><ul><li><p>Category : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。</p></li><li><p>Extension : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。</p><p>如果分类中添加与类相同的方法签名会发生什么？</p><p>分类中的方法是运行时添加到方法列表中，并且是添加中已有方法的前面。所以当分类与原类中的方法相同时，分类中的方法会优先调用，覆盖掉原类中的方法。</p></li></ul>',9),l=[i];function p(a,r){return o(),c("div",null,l)}const b=e(d,[["render",p],["__file","objective-c.html.vue"]]);export{b as default};

import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e,f as t}from"./app-TyFLvDt8.js";const o={},p=t(`<hr><h2 id="objective-c" tabindex="-1"><a class="header-anchor" href="#objective-c" aria-hidden="true">#</a> Objective-C</h2><h3 id="❓下面代码输出结果" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@property</span> <span class="token punctuation">(</span>atomic<span class="token punctuation">)</span> NSInteger i<span class="token punctuation">;</span>
<span class="token comment">// 线程中</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>在这种情况下，属性 <code>i</code> 并不能保证以线程安全的方式递增。虽然 <code>atomic</code> 属性确实提供了一定的线程安全性，但是它的操作并不是完全原子性的（atomic）。具体来说， <code>atomic</code> 只能保证属性的 <code>getter</code> 和 <code>setter</code> 方法在被调用时不会被其他线程打断，并不能保证像 <code>self.i++</code> 这样的复合操作是线程安全的。</p><p><code>self.i++</code> 实际上包含了三个操作：获取 <code>i</code> 的值，将获取到的值加一，然后将新值赋值给 <code>i</code>。这三个操作是分开进行的，并不是原子操作，所以多个线程可能同时在获取和设置 <code>i</code> 的值，这会导致数据的混乱。</p><p>所以这段代码的结果是不可预测的，它将取决于线程调度和运行时的具体情况。如果你希望在多线程环境中更新共享变量，那么你需要使用锁或者其他同步机制来确保线程安全。</p></details><h3 id="❓下面代码输出结果-1" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-1" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> <span class="token function">NSObject</span> <span class="token punctuation">(</span>Test<span class="token punctuation">)</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> <span class="token function">NSObject</span> <span class="token punctuation">(</span>Test<span class="token punctuation">)</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>NSObject test<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObject new<span class="token punctuation">]</span> test<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><blockquote><p>在 <code>Objective-C</code> 对象模型中，所有类的元类(<code>meta-class</code>)形成了一个单向链表，链表的末端是根类（如<code>NSObject</code>）的元类，<code>NSObject</code> 的元类的方法列表中包含了其所有子类的类方法。因此，当一个子类的类方法在其自身的元类中找不到实现时，会在这条单向链表中继续寻找，最终会找到根元类 <code>NSObject</code> 的方法列表，所以 <code>[NSObject test]</code>会调用到定义在分类中的实例方法。</p></blockquote><p>输出为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Test
Test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓下面代码输出结果-2" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-2" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> DogTest <span class="token punctuation">:</span> NSObject
 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test<span class="token punctuation">;</span>
 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test<span class="token punctuation">;</span>
 <span class="token keyword">@end</span>

 <span class="token keyword">@implementation</span> DogTest
 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;TEST&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">@end</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token punctuation">[</span>DogTest new<span class="token punctuation">]</span> test<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">[</span>DogTest test<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>输出一个 “TEST” 之后崩溃。</p><p>一个类方法在它们自己的类中没有找到，<code>Objective-C</code> 运行时将尝试在它的超类中查找。但是自定义的类 <code>DogTest</code>（子类）并不包含元类方法 <code>+test</code>，并且它的超类 <code>NSObject</code> 也没有这个方法，因此 <code>[DogTest test];</code> 将引发 <code>unrecognized selector sent to class</code> 异常，导致程序崩溃。</p></details><h3 id="❓下面代码输出结果-3" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-3" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@interface</span> Dog <span class="token punctuation">:</span> Animal
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Dog
    <span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>init <span class="token punctuation">{</span>
        <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromClass</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">super</span> class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>输出：</p><pre><code>    Dog 
    Dog
</code></pre><p><code>super</code> 并不会改变消息的接收者，所以当调用 <code>[super class]</code> 时，虽然是从父类开始查找 <code>class</code> 方法，但是方法的接收者依然是 <code>self</code> 本身，其类别自然是当前类本身。这也是为什么调用 <code>[super class]</code> 时还会返回 <code>Dog</code> 类的原因。</p></details><h3 id="❓下面代码能正常运行吗-如果能-输出是什么" tabindex="-1"><a class="header-anchor" href="#❓下面代码能正常运行吗-如果能-输出是什么" aria-hidden="true">#</a> ❓下面代码能正常运行吗(如果能，输出是什么)</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Person <span class="token punctuation">:</span> NSObject 
<span class="token keyword">@property</span><span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span>copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span> 
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Person
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>speak <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;My name is:%@&quot;</span><span class="token punctuation">,</span><span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> ViewController
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    id cls <span class="token operator">=</span> <span class="token punctuation">[</span>Person class<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token operator">&amp;</span>cls<span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span>__bridge id<span class="token punctuation">)</span>obj speak<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>这段代码可以正常运行，其输出将是 <code>My name is:(null)</code>。</p><p>在这段代码中 <code>id cls = [Person class];</code>这行代码是获取 <code>Person</code> 类。然后 <code>void *obj = &amp;cls;</code> 这行代码是获取了指向 <code>cls</code> 的指针，所以 <code>obj</code> 指向的是一个 <code>Person</code> 类的对象，而不是 <code>Person</code> 类的实例。然后 <code>[(__bridge id)obj speak];</code> 这行代码就是发送一个消息给 <code>obj</code>，所以最终调用的是 <code>Person</code> 类的 <code>speak</code> 方法。</p><p>注意：并没有给 <code>name</code> 属性赋值，所以当打印 <code>name</code> 属性的时候，它的值是 <code>nil</code>，也就是 <code>(null)</code>。</p></details><hr><h2 id="swift" tabindex="-1"><a class="header-anchor" href="#swift" aria-hidden="true">#</a> Swift</h2><h4 id="❓下面代码输出是什么" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出是什么" aria-hidden="true">#</a> ❓下面代码输出是什么？</h4><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">struct</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">T</span>

	<span class="token keyword">var</span> projectedValue<span class="token punctuation">:</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">self</span> <span class="token punctuation">}</span>

	<span class="token keyword">func</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Foo&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">HasWrapper</span> <span class="token punctuation">{</span>
	<span class="token attribute atrule">@Wrapper</span> <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span>
    
	<span class="token keyword">func</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// \`wrappedValue\`</span>
	    <span class="token function">print</span><span class="token punctuation">(</span>_x<span class="token punctuation">)</span> <span class="token comment">// wrapper type itself</span>
	    <span class="token function">print</span><span class="token punctuation">(</span>$x<span class="token punctuation">)</span> <span class="token comment">// \`projectedValue\`</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><ul><li><code>x</code> 是通过 <code>@Wrapper</code> 修饰符被包装的属性。 当直接访问 <code>x</code> 时，将获取 <code>wrappedValue</code> 的实际值。</li><li><code>_x</code> 则访问到 <code>Wrapper</code> 的实例本身。</li><li><code>$x</code> 用于访问 <code>projectedValue</code>，返回的是 <code>Wrapper</code> 的实例(由于 <code>Wrapper</code> 结构体没有定义 <code>CustomStringConvertible</code> 协议，因此它会使用默认的描述符，也就是其内部存储的字符串描述。)。</li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment">// 0</span>
<span class="token function">print</span><span class="token punctuation">(</span>_x<span class="token punctuation">)</span>   <span class="token comment">// Wrapper(wrappedValue: 0)</span>
<span class="token function">print</span><span class="token punctuation">(</span>$x<span class="token punctuation">)</span>   <span class="token comment">// Wrapper(wrappedValue: 0)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="uikit" tabindex="-1"><a class="header-anchor" href="#uikit" aria-hidden="true">#</a> UIKit</h2><h3 id="❓寻找最近的公共-view" tabindex="-1"><a class="header-anchor" href="#❓寻找最近的公共-view" aria-hidden="true">#</a> ❓寻找最近的公共 <code>View</code></h3><details class="hint-container details"><summary>💡</summary><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 寻找两个子视图最近的公共父视图</span>
<span class="token keyword">func</span> <span class="token function-definition function">findNearestCommonAncestor</span><span class="token punctuation">(</span>view1<span class="token punctuation">:</span> <span class="token class-name">UIView</span><span class="token punctuation">,</span> view2<span class="token punctuation">:</span> <span class="token class-name">UIView</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">UIView</span><span class="token operator">?</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> currentView<span class="token punctuation">:</span> <span class="token class-name">UIView</span><span class="token operator">?</span> <span class="token operator">=</span> view1
    <span class="token keyword">while</span> <span class="token keyword">let</span> view <span class="token operator">=</span> currentView <span class="token punctuation">{</span> <span class="token comment">// 递归视图的父视图</span>
        <span class="token comment">// 判断 view2 是否为当前遍历父视图的后代视图，如果是就是公共父视图</span>
        <span class="token keyword">if</span> view2<span class="token punctuation">.</span><span class="token function">isDescendant</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> view<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token keyword">return</span> view
        <span class="token punctuation">}</span>
        currentView <span class="token operator">=</span> view<span class="token punctuation">.</span>superview
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token nil constant">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓打印一个-view-的所有子-view-要求分层打印" tabindex="-1"><a class="header-anchor" href="#❓打印一个-view-的所有子-view-要求分层打印" aria-hidden="true">#</a> ❓打印一个 <code>View</code> 的所有子 <code>View</code>，要求分层打印</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>树的层序遍历问题</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 队列(Queue)来实现树的层次遍历</span>
<span class="token keyword">func</span> <span class="token function-definition function">printSubviewsInLevelOrder</span><span class="token punctuation">(</span><span class="token keyword">for</span> view<span class="token punctuation">:</span> <span class="token class-name">UIView</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">UIView</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    queue<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token operator">!</span>queue<span class="token punctuation">.</span>isEmpty <span class="token punctuation">{</span>
        <span class="token keyword">var</span> count <span class="token operator">=</span> queue<span class="token punctuation">.</span>count <span class="token comment">// 当前层数量</span>
        <span class="token keyword">var</span> levelViews <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">UIView</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前层视图</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> levelView <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            levelViews<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>levelView<span class="token punctuation">)</span>
            count <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token comment">// 将当前层视图子视图继续加入队列</span>
            <span class="token keyword">for</span> subview <span class="token keyword">in</span> levelView<span class="token punctuation">.</span>subviews <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>subview<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">print</span><span class="token punctuation">(</span>levelViews<span class="token punctuation">)</span> <span class="token comment">// 打印当前层视图   </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> 多线程</h2><h3 id="❓下面代码输出结果-4" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-4" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><ul><li><p>如果这段代码在<strong>主线程</strong>中执行，那么会导致死锁。</p><blockquote><p>因为 <code>dispatch_sync</code> 函数是一个同步执行的函数，它会阻塞当前线程，并等待 <code>dispatch_sync</code> 内部的任务执行完成后再继续执行。然而此处的 <code>dispatch_sync</code> 内部任务被派发到了主队列，所以这个任务需要在主线程上执行。但是主线程此时被上述的 <code>dispatch_sync</code> 阻塞了，所以 <code>dispatch_sync</code> 内部的任务无法执行。这就造成了死锁，上述代码会在输出 &quot;1&quot; 后停止。</p></blockquote></li><li><p>如果这段代码在一个<strong>非主线程</strong>执行，那么它会先阻塞该线程，再在主线程上同步执行任务，输出 &quot;2&quot;，然后取消阻塞，接着输出 &quot;3&quot;，所以结果是 &quot;1&quot;，&quot;2&quot;，&quot;3&quot;。</p></li></ul></details><blockquote><p>❓改为 <code>global queue</code> 呢</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span><span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>这段代码无论在主线程还是在子线程中执行，最终的输出结果都是 &quot;1&quot;, &quot;2&quot;, &quot;3&quot;。</p><p>首先输出 &quot;1&quot;，然后 <code>dispatch_sync</code> 会将 <code>block</code> 中的任务同步地添加到全局队列，并阻塞当前线程直到 <code>block</code> 中的任务执行完毕。由于这里使用的是全局队列，这个队列是并发队列，且和当前线程（无论主线程或子线程）不是同一个队列，所以不会造成死锁。<code>block</code> 中的任务执行后，输出 &quot;2&quot;，然后 <code>dispatch_sync</code> 返回，当前线程继续执行，输出 &quot;3&quot;。所以最终的输出结果就是 &quot;1&quot;, &quot;2&quot;, &quot;3&quot;。</p></details><h3 id="❓下面代码输出结果-5" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-5" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
BOOL isEqual <span class="token operator">=</span> <span class="token punctuation">[</span>queue isKindOfClass<span class="token punctuation">:</span><span class="token punctuation">[</span>NSObject class<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;isEqual=%d&quot;</span><span class="token punctuation">,</span> isEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>输出结果是 <code>isEqual=1</code>。</p><p>虽然 <code>Objective-C </code>的 <code>GCD</code> 队列是基于 <code>C</code> 语言的 <code>dispatch_queue_t</code> 类型实现的，但它仍然是 <code>NSObject</code> 的子类。尽管 <code>GCD</code> 的 <code>API</code> 都是用纯 <code>C</code> 来实现的，但实际上 <code>GCD</code> 对象在 <code>Objective-C</code> 的运行时环境中是被当作 <code>Objective-C</code> 对象来处理的。所以这里的 <code>queue</code> 是可以被当作 <code>NSObject</code> 的实例来处理的，所以 <code>[queue isKindOfClass:[NSObject class]]</code> 的结果是 <code>YES</code>，即 <code>isEqual=1</code>。</p><p>然而，不能直接对 <code>dispatch_queue_t</code> 类型的对象发送 <code>Objective-C</code> 消息，例如 <code>respondsToSelector:</code>、<code>performSelector:</code> 等，这样做可能会引发异常或者崩溃。因为 <code>dispatch_queue_t</code> 以及其他的 <code>GCD</code> 对象类型并没有实现这些方法。</p></details><h3 id="❓下面代码输出结果-6" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-6" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>sync <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;1&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>这段代码会造成主线程的死锁。</p><p>函数<code>test()</code> 是在主线程中被调用的，然后在 <code>test()</code> 函数中，又使用了<code>DispatchQueue.main.sync</code>尝试再次在主线程中执行一段任务。</p><p>由于 <code>sync</code> 是同步执行，也就是说 <code>sync</code>后面的任务会立刻执行，执行完后才会继续执行后面的代码。但是 <code>sync</code> 后面的代码块又是在主线程中执行的，这个时候主线程已经被前面的 <code>test()</code> 函数占用，所以<code>sync</code>后面的代码块就会等待主线程空闲，但是主线程在等待 <code>sync</code> 后的代码块执行完毕，导致互相等待，产生死锁。+</p></details><h3 id="❓下面代码输出结果-7" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-7" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;1&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>label<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;thread&quot;</span></span><span class="token punctuation">)</span>
    queue<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;2&quot;</span></span><span class="token punctuation">)</span>
        <span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>sync <span class="token punctuation">{</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;3&quot;</span></span><span class="token punctuation">)</span>
            queue<span class="token punctuation">.</span>sync <span class="token punctuation">{</span>
                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;4&quot;</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;5&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;6&quot;</span></span><span class="token punctuation">)</span>
    queue<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;7&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;8&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>根据这段代码的执行流程，代码中打印的消息的顺序应该是：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1
6
8
2
3
5
7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是这段代码的一些解释：</p><ul><li>这段代码首先在主线程中调用 <code>print(&quot;1&quot;)</code>，接着创建一个自定义的并发队列 <code>queue</code>。</li><li>然后在 <code>queue</code> 中异步执行一个 block，但执行这个 block 并不会阻塞当前线程（即主线程）。所以，<code>print(&quot;1&quot;)</code>，<code>print(&quot;6&quot;)</code> 和 <code>print(&quot;8&quot;)</code> 几乎是立即执行的，只是因为 CPU 的调度问题，可能存在轻微的延迟。</li><li>之后，回到 <code>queue</code> 中异步执行的那个 block。在这个 block 的执行过程中，会首先执行 <code>print(&quot;2&quot;)</code>。接着，在主线程中同步执行一个 block。这个 block 的执行会阻塞 <code>queue</code>，直到这个 block 执行完毕。 在这个 block 中，又在 <code>queue</code> 中执行了一个 block，但是由于这是同步执行的，所以要等待这个 block 执行完毕后才能继续执行主线程的 block。但是，这个 block 并不会被执行，因为他是在 <code>queue</code> 中同步执行的，<code>queue</code> 在这个时候还在等待主线程中的 block 执行完毕。这就产生了死锁。</li><li>最后，<code>queue</code> 中的另一个 block 并不会被执行，因为在执行这个 block 的时候，<code>queue</code> 已经被上面的死锁阻塞了。</li></ul><p>因此，这段代码的实际输出应该只有 <code>print(&quot;1&quot;)</code>， <code>print(&quot;6&quot;)</code> 和 <code>print(&quot;8&quot;)</code>的输出，并且程序会在 <code>queue.sync { print(&quot;4&quot;) }</code> 这行产生死锁。</p><p>注意：Swift 中，每一个线程都有一个与之相关联的 DispatchQueue（分派队列），这个 DispatchQueue 用来管理和调度这个线程上的任务。<code>DispatchQueue.main.sync</code> 表示将一个任务添加到主线程相关联的 DispatchQueue 中，并立即等待这个任务执行完毕。<code>queue.async</code> 表示将一个任务异步地添加到 <code>queue</code> 中，这个任务会在 <code>queue</code> 有空闲的时候执行，并且添加任务后的代码不会等待这个任务执行完毕就会继续执行。</p></details><h3 id="❓下面代码输出结果-8" tabindex="-1"><a class="header-anchor" href="#❓下面代码输出结果-8" aria-hidden="true">#</a> ❓下面代码输出结果</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil afterDelay<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>test <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><blockquote><p>打印顺序 : 1, 4, 2, 3</p></blockquote><p>&quot;1&quot;和&quot;4&quot;是普通的直接执行代码，因此会按照顺序输出。</p><p>&quot;2&quot;和&quot;3&quot;位于异步并发队列中，会在新线程中执行，所以会在&quot;1&quot;和&quot;4&quot;之后开始执行。</p><p>&quot;5&quot;不会输出。原因是<code>[self performSelector:@selector(test) withObject:nil afterDelay:10];</code>这一行代码被放在异步并发队列中，并且是在子线程中执行，但是这种执行方式是依赖 <code>RunLoop</code> 的，而新创建的线程默认是没有启动 <code>RunLoop</code> 的，所以<code>performSelector:afterDelay:</code>方法会失效。</p></details><blockquote><p>❓如果想要使 &quot;5&quot; 能够打印，应该怎么处理</p></blockquote><details class="hint-container details"><summary>💡</summary><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 方案一 : 放入主线程 RunLoop</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> performSelectorOnMainThread<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil waitUntilDone<span class="token punctuation">:</span>NO<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
<span class="token comment">// 方案二 : 在子线程中手动启动 RunLoop</span>
NSRunLoop <span class="token operator">*</span>runLoop <span class="token operator">=</span> <span class="token punctuation">[</span>NSRunLoop currentRunLoop<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>nil afterDelay<span class="token punctuation">:</span><span class="token number">5.0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>runLoop run<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓下面代码会发生什么" tabindex="-1"><a class="header-anchor" href="#❓下面代码会发生什么" aria-hidden="true">#</a> ❓下面代码会发生什么</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> NSString <span class="token operator">*</span>target<span class="token punctuation">;</span>
<span class="token comment">//....</span>

dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">&quot;parallel&quot;</span><span class="token punctuation">,</span> DISPATCH_QUEUE_CONCURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">dispatch_async</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>
     	<span class="token keyword">self</span><span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithFormat<span class="token punctuation">:</span><span class="token string">@&quot;ksddkjalkjd%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>这段代码在一个并发队列 (&quot;parallel&quot;) 上异步地多次执行一个 BLOCK。每次 BLOCK 执行时,会把 self.target 的值设置为一个新的字符串。因为这是在并发队列上执行的，所以这些设置 self.target 的操作可能同时执行。</p><p>这会引起线程安全的问题——数据竞争 (data race)。由于 setter 本质上是读取+写入两个操作，如果多个线程同时进行这两个操作，可能会造成数据不一致。这就是所谓的线程安全问题。</p><p>同时，不确定的并发操作可能会导致内存暴涨。dispatch_async的block，会被dispatch_retain，然后被存储起来等待执行。如果并行队列中block剧增，未执行的block可能会积压，导致大量内存消耗。</p><p>因此对于涉及多线程访问和修改的属性，应该引入线程同步机制，如使用 <code>@synchronized(self)</code>、<code>dispatch_semaphore_t</code>（信号量）等来防止数据竞争。当然，考虑到性能问题，在多线程环境下我们应该尽量避免大量读写同一个共享资源。</p></details>`,53);function c(i,l){return s(),a("div",null,[e(" more "),p])}const r=n(o,[["render",c],["__file","0x18.code.html.vue"]]);export{r as default};

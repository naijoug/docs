import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as a,a as e,f as t}from"./app-nOqLU-Iw.js";const c={},o=t(`<h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><h3 id="❓swift-类和结构体的区别" tabindex="-1"><a class="header-anchor" href="#❓swift-类和结构体的区别" aria-hidden="true">#</a> ❓<code>Swift</code> 类和结构体的区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>值类型和引用类型：结构体是值类型；类是引用类型。</p><p>一个结构体实例被赋值给一个新的变量或者作为一个函数的参数传递时，这个实例的拷贝会被创建出来，所以改变新变量中的值不会影响原来的实例。 一个类实例赋值实际上是传递了一个引用，所以修改赋值后的实例也会影响到原来的实例。</p></li><li><p>继承：结构体不能继承其他的结构体或者类；类可以继承其他的类。</p></li><li><p>类型转化：结构体不能；类可以被强制类型转换，可以使用 <code>is</code> 和 <code>as</code> 操作符在运行时检查实例的类型。</p></li><li><p>析构函数：结构体没有；类有析构函数，用来在类实例被销毁前执行特定的操作。</p></li><li><p>引用计数：结构体没有；类通过引用计数进行内存管理。</p></li><li><p>协议：类和结构体都可以实现协议，但是类可以利用某些特定的协议提供的运行时特性。</p></li></ul></details><h3 id="❓swift-中的枚举和其它编程语言的区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的枚举和其它编程语言的区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的枚举和其它编程语言的区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>关联值：枚举成员可以与任意类型的值进行关联存储，叫做关联值（<code>Associated Values</code>）；每个枚举成员的关联值类型可以是不同的。</p></li><li><p>方法：与结构体和类一样，枚举也可以定义方法，在枚举值实例上调用的方法功能；</p></li><li><p>构造函数：可以提供构造函数，用以提供一个带有默认枚举值的实例。</p></li><li><p>递归枚举：如果枚举的一种 <code>case</code> 持有该枚举类型的关联值，那么这个枚举就是递归枚举。</p></li><li><p>模式匹配：枚举值和 <code>switch</code> 语句一起使用时，可以进行模式匹配，包括获取枚举值关联值，或者多个 <code>case</code> 值一起匹配。</p></li></ul></details><blockquote><p>❓<code>Swift</code> 中的 <code>switch</code> 和其它编程语言有什么区别？</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><p>模式匹配：可以进行复杂的模式匹配，包括元组、范围匹配以及关联枚举值等。</p></li><li><p>无需 <code>break</code>：其他编程语言中，如<code>C</code>语言每个 <code>case</code> 后面都需要添加 <code>break</code> 关键字以退出 <code>switch</code> 否则将会发生贯穿现象。在 <code>Swift</code> 中每个 <code>case</code> 后面不需要添加 <code>break</code>，当遇到符合的 <code>case</code> 后程序会直接退出 <code>switch</code> 语句。</p></li><li><p>绑定常量和变量：在一个 <code>case</code> 的语句中，可以用 <code>let</code> 或者 <code>var</code> 来绑定匹配到的值到临时的常量或变量中。</p></li></ul></details><blockquote><p>❓匹配模式深入说一下？</p></blockquote><h3 id="❓swift-中的-string-的设计理念" tabindex="-1"><a class="header-anchor" href="#❓swift-中的-string-的设计理念" aria-hidden="true">#</a> ❓<code>Swift</code> 中的 <code>String</code> 的设计理念</h3><details class="hint-container details"><summary>💡</summary><p><code>Swift</code> 字符串 <code>String</code> 的设计理念：是安全、简洁、现代、以及易用。</p><ul><li><p>安全性：字符串被设计为值类型；无法通过下标索引来访问字符，需要使用 <code>String.Index</code> 类型的索引进行字符串的访问和操作。</p></li><li><p>简洁性：主要体现在内置的字符串相关 API 上，简化了 <code>OC</code> 遗留的接口名称冗长的问题。</p></li><li><p>现地化：支持 <code>Unicode</code>，可以处理多样化的文本内容。这是因为在 <code>Swift</code> 中 <code>String</code> 类型以 <code>UTF-16</code> 的形式存储。</p></li><li><p>易用性：可以跟一般的基本类型值一样，直接进行“+”、“+=”运算符的操作，还有各种内置的处理字符串的 API，如：大小写转化，去除前后空格等。</p></li></ul></details><h3 id="❓为什么-swift-将-string-设计为不能通过索引访问" tabindex="-1"><a class="header-anchor" href="#❓为什么-swift-将-string-设计为不能通过索引访问" aria-hidden="true">#</a> ❓为什么 <code>Swift</code> 将 <code>String</code> 设计为不能通过索引访问？</h3><details class="hint-container details"><summary>💡</summary><p>因为 <code>Swift</code> 中的 <code>String</code> 兼容 <code>Unicode</code> 字符串的。</p><p>在 <code>Unicode</code> 中，字符的长度可能是不一致的（例如，某些 <code>emoji</code> 表情字符由多个 <code>Unicode</code> 组成），所以采用整数索引可能会将字符串截断，导致字符不完整，甚至导致崩溃。</p></details><h3 id="❓swift-中-array、dictionary、set-为什么设计成值类型" tabindex="-1"><a class="header-anchor" href="#❓swift-中-array、dictionary、set-为什么设计成值类型" aria-hidden="true">#</a> ❓<code>Swift</code> 中 <code>Array</code>、<code>Dictionary</code>、<code>Set</code> 为什么设计成值类型？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>语义清晰</p><p>可以使赋值的语义更加清晰。当你把一个数组（或字典、集合）赋值给新的变量时，<code>Swift</code> 实际上会复制一份这个数组，这意味着新变量和旧变量之间不存在任何关联，对其中一个的改动不会影响到另一个。</p></li><li><p>线程安全</p><p>在涉及多线程操作的环境中，无需担心对数组（或字典、集合）的修改会潜在地影响到其他线程。有利于减少由竞态条件（race condition）导致的问题，并使得代码更加安全。</p></li><li><p>性能优化</p><p>虽然值类型在赋值时需要复制其数据，但 <code>Swift</code> 采用了一种被称为“写时复制”（copy-on-write）的优化策略。只有当数据真正需要被改动时，<code>Swift</code> 才会复制一份数据，避免了不必要的复制操作。</p></li></ul></details><h3 id="❓cow-设计说一下" tabindex="-1"><a class="header-anchor" href="#❓cow-设计说一下" aria-hidden="true">#</a> ❓<code>cow</code> 设计说一下？</h3><details class="hint-container details"><summary>💡</summary><p><code>cow</code> (Copy on Write) : Swift 的写时拷贝，也就是说数据只有等到赋值修改时才进行拷贝，主要应用在系统设计的值类型(<code>String</code>、<code>Array</code>、<code>Dictionary</code>)</p></details><blockquote><p><code>isKnownUniquelyReferenced</code> 实现自定义结构体 <code>Cow</code></p></blockquote><details class="hint-container details"><summary>💡</summary><p><code>isKnownUniquelyReferenced</code> 函数可以用来检测是被被多个变量引用</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 数据包装类</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> wrapper<span class="token punctuation">:</span> <span class="token class-name">A</span>
  <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">self</span><span class="token punctuation">.</span>wrapper <span class="token operator">=</span> value 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">MyArray</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> storage<span class="token punctuation">:</span> <span class="token class-name">Wrapper</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
  <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      storage <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/// 添加数据</span>
  <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">append</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否为唯一的引用，如果不是，先创建副本对象，在进行添加修改</span>
      <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isKnownUniquelyReferenced</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          storage <span class="token operator">=</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span>wrapper<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      storage<span class="token punctuation">.</span>wapper<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓swift-中的闭包" tabindex="-1"><a class="header-anchor" href="#❓swift-中的闭包" aria-hidden="true">#</a> ❓<code>Swift</code> 中的闭包</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>逃逸闭包</p><blockquote><p>闭包作为函数参数传入函数，如果这个闭包在函数返回之后再执行，则为逃逸闭包，闭包参数需要使用 <code>@escaping</code> 修饰。</p></blockquote></li><li><p>非逃逸闭包</p><blockquote><p>闭包作为函数参数，在函数返回之前，这个闭包已经执行，则为非逃逸闭包。</p></blockquote></li><li><p>尾随闭包</p><blockquote><p>将闭包作为函数的最后一个参数，函数调用时，闭包参数就是一个写在尾随函数调用后面的一个闭包表达式。</p></blockquote></li><li><p>自动闭包</p><blockquote><p>需要一个不接受参数的闭包作为函数参数，使用 <code>@autoclosure</code> 修饰。用作闭包表达式的延迟加载，只有当闭包表达式真正调用时才执行。</p></blockquote></li></ul></details><h3 id="❓swift-可选类型-optional-说一下理解" tabindex="-1"><a class="header-anchor" href="#❓swift-可选类型-optional-说一下理解" aria-hidden="true">#</a> ❓<code>Swift</code> 可选类型 <code>Optional</code> 说一下理解？</h3><blockquote><p>❓<code>Optional</code> 可选类型的底层实现</p></blockquote><details class="hint-container details"><summary>💡</summary><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">Wrapped</span><span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByNilLiteral</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token keyword">none</span>           <span class="token comment">// 表示没有值 nil</span>
  <span class="token keyword">case</span> <span class="token keyword">some</span><span class="token punctuation">(</span><span class="token class-name">Wrapped</span><span class="token punctuation">)</span>  <span class="token comment">// 表示有值</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓swift-once-是用在什么地方的" tabindex="-1"><a class="header-anchor" href="#❓swift-once-是用在什么地方的" aria-hidden="true">#</a> ❓<code>swift_once</code> 是用在什么地方的？</h3><details class="hint-container details"><summary>💡</summary><p><code>swift_once</code>是Swift的一个内部函数，它提供了一种线程安全的方式来执行一次初始化或者配置代码。与 <code>Objective-C</code> 中 <code>dispatch_once()</code> 实现类似的功能。</p><p>在 <code>Swift</code> 的底层实现层面，像类型元数据的初始化、静态变量和全局变量的初始化、静态属性和懒惰属性的初始化等，都是使用<code>swift_once</code>来确保它们的初始化代码只会被执行一次。</p></details><h3 id="❓-dynamicmemberlookup" tabindex="-1"><a class="header-anchor" href="#❓-dynamicmemberlookup" aria-hidden="true">#</a> ❓<code>@dynamicMemberLookup</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 4.2</code> 引入的 <code>@dynamicMemberLookup</code> 特性。这种新特性允许我们创建被动态调用的类型，它的属性和方法在编译时是未知的，只有在运行时才会确定。这对于利用 <code>Swift</code> 来调用 <code>Python</code>，<code>JavaScript</code>，<code>Ruby</code> 和其他动态语言的代码非常有用。这样可以使得 <code>Swift</code> 具有一定的动态性，同时又不失类型安全。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token attribute atrule">@dynamicMemberLookup</span>
<span class="token keyword">struct</span> <span class="token class-name">DynamicMember</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> dictionary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;dynamicMember&quot;</span></span><span class="token punctuation">:</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;otherMember&quot;</span></span><span class="token punctuation">:</span> <span class="token number">119</span><span class="token punctuation">]</span>
  <span class="token keyword">subscript</span><span class="token punctuation">(</span>dynamicMember member<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> dictionary<span class="token punctuation">[</span>member<span class="token punctuation">]</span> <span class="token operator">??</span> <span class="token number">114</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> member <span class="token operator">=</span> <span class="token class-name">DynamicMember</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>member<span class="token punctuation">.</span>dynamicMember<span class="token punctuation">)</span> <span class="token comment">// 110</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓-propertywrapper" tabindex="-1"><a class="header-anchor" href="#❓-propertywrapper" aria-hidden="true">#</a> ❓<code>@propertyWrapper</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.1</code> 引入了一项新特性：属性包装器（property wrappers）。属性包装器提供了一种将特性添加到属性上的新方法，例如线程安全，懒加载，键值观察，存储在数据库中等，从而使这些属性更易于复用。简单来说，属性包装器就是一个定义了特殊访问策略的结构或类，我们可以将这个访问策略附加到属性上，而不是重新实现相同的访问策略。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 定义属性包装器</span>
<span class="token attribute atrule">@propertyWrapper</span>
<span class="token keyword">struct</span> <span class="token class-name">HundredOrLess</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> score <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
      <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> score <span class="token punctuation">}</span>
      <span class="token keyword">set</span> <span class="token punctuation">{</span> score <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用属性包装器</span>
<span class="token keyword">struct</span> <span class="token class-name">Grade</span> <span class="token punctuation">{</span>
  <span class="token comment">/// 数学成绩</span>
  <span class="token attribute atrule">@HundredOrLess</span> <span class="token keyword">var</span> math<span class="token punctuation">:</span> <span class="token class-name">Int</span>
  <span class="token comment">/// 体育成绩</span>
  <span class="token attribute atrule">@HundredOrLess</span> <span class="token keyword">var</span> gym<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><h3 id="❓inout-关键字做了什么" tabindex="-1"><a class="header-anchor" href="#❓inout-关键字做了什么" aria-hidden="true">#</a> ❓<code>inout</code> 关键字做了什么？</h3><details class="hint-container details"><summary>💡</summary><p><code>inout</code> 可以让函数、方法或者运算符可以改变传入参数的值。</p><p>在 <code>Swift</code> 中，标量类型（如<code>Int</code>，<code>Double</code>，<code>Bool</code>，<code>String</code>等）和结构体，枚举都是值类型（value type）, 也就是在函数内部改变这些参数并不会影响到函数外部的值，因为传递的是值的拷贝。</p><p><code>inout</code> 关键字允许函数修改外部变量的值。本质上，它将值传递给函数，并将函数返回后的值复制回原始变量。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">+=</span> <span class="token number">1</span>
  <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token comment">// 1</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓swift-函数派发机制" tabindex="-1"><a class="header-anchor" href="#❓swift-函数派发机制" aria-hidden="true">#</a> ❓<code>Swift</code> 函数派发机制</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><strong>直接派发（Direct Dispatch）</strong>：直接派发发生在值类型（枚举、结构体）和 <code>final</code> 类上的方法、属性和下标。这些操作的派发是在编译时期决定的，不存在动态派发的过程，不能被覆盖，执行效率也是最高的。</p></li><li><p><strong>虚表派发（Virtual Table Dispatch）</strong>：虚表派发发生在普通类（非 <code>final</code>）上的方法、属性和下标。这些操作的派发方式由 <code>Swift</code> 编译器在运行时通过虚表（<code>vtable</code>）来查找。虚表是一种在编译时期生成的用于动态派发函数的数据结构，存储了类型的动态类型信息。</p></li><li><p><strong>见证表派发（Witness Table Dispatch）</strong>：见证表派发发生在协议方法、属性和下标的操作。这些操作的派发方式由 <code>Swift</code> 编译器在运行时通过一种名为见证表的类似于虚表的机制，查找并调用相应的实现。见证表包含了协议的动态类型信息和协议方法的实现。对于带有 <code>where</code> 子句的协议扩展提供的默认实现，会为符合不同条件的类型生成不同的见证表。</p></li></ul><table><thead><tr><th>类型</th><th>派发机制</th></tr></thead><tbody><tr><td><code>struct</code></td><td></td></tr><tr><td><code>class</code></td><td></td></tr><tr><td><code>protocol</code></td><td></td></tr><tr><td><code>extension</code></td><td></td></tr></tbody></table></details><h3 id="❓-swift-中函数是第一等公民-这句话你是怎么理解的" tabindex="-1"><a class="header-anchor" href="#❓-swift-中函数是第一等公民-这句话你是怎么理解的" aria-hidden="true">#</a> ❓“<code>Swift</code> 中函数是第一等公民”这句话你是怎么理解的？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>一等公民：同其它基础数据类型一样。</p></blockquote><ul><li>可以作为参数传递给其他函数(高阶函数)。</li><li>可以作为其他函数的返回值。</li><li>可以赋值给变量。</li><li>可以存储在数据结构中。</li></ul></details><h3 id="❓swift-函数式编程-函子、单子" tabindex="-1"><a class="header-anchor" href="#❓swift-函数式编程-函子、单子" aria-hidden="true">#</a> ❓<code>Swift</code> 函数式编程 (函子、单子)</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>函数式编程是一种编程范式，函子（<code>functor</code>）和单子（<code>monad</code>）是函数式编程中的术语。</p></blockquote><ul><li><p>函子 : 是一种可以将所有的输入操作映射到输出操作的对象。在 <code>Swift</code> 中，最常见的函子就是 <code>Array</code>, <code>map</code> 方法就是一个典型的函子操作。</p></li><li><p>单子 : 是函子的一个特例，满足一些额外条件。具体来说，它需要实现两个方法：一个是用来创建单子的方法，另一个是用来连接两个单子的方法。在 <code>Swift</code> 中，对于 <code>Array</code> 来说，创建单子的方法是初始化方法，连接两个单子的方法同样是 <code>flatMap</code>。</p></li></ul></details><h3 id="map、filter、reduce" tabindex="-1"><a class="header-anchor" href="#map、filter、reduce" aria-hidden="true">#</a> <code>map</code>、<code>filter</code>、<code>reduce</code></h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓-functionbuilder" tabindex="-1"><a class="header-anchor" href="#❓-functionbuilder" aria-hidden="true">#</a> ❓<code>@_functionBuilder</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.1</code> 引入了函数建构器特性，目前还处于私有阶段，故以 _ 开头。函数建构器功能主要用于简化大量样板代码。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// SwiftUI </span>
<span class="token class-name">VStack</span><span class="token punctuation">(</span>content<span class="token punctuation">:</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token class-name">Group</span> <span class="token punctuation">{</span> 
    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">)</span> 
    <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">)</span> 
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// @_functionBuilder 可以简化为如下写法</span>
<span class="token class-name">VStack</span> <span class="token punctuation">{</span> 
  <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">)</span> 
  <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h2><h3 id="❓swift-中的协议与-oc-中协议的特点和区别" tabindex="-1"><a class="header-anchor" href="#❓swift-中的协议与-oc-中协议的特点和区别" aria-hidden="true">#</a> ❓<code>Swift</code> 中的协议与 <code>OC</code> 中协议的特点和区别？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>相同点 : 协议在 <code>Swift</code> 和 <code>Objective-C</code> 中都是定义一组特定的方法、属性或者其它要求的工具。其他类、结构体或者枚举都可以遵守这些协议，并提供这些要求的具体实现。</p></li><li><p>不同点</p><ul><li><code>Objective-C</code> 中，协议往往用于实现“委托”模式，尤其是在 UI 编程中经常使用。协议中只能包含方法的声明。</li><li><code>Swift</code> 中的协议更加强大。</li></ul></li></ul><p><code>Swift</code> 协议：</p><ul><li>要求遵循协议的类型提供特定名称和类型的实例属性或者类型属性</li><li>要求遵循协议的类型提供特定名称和类型的方法、初始化方法、下标操作符</li><li>要求遵循协议的类型提供特定的操作符方法</li><li>为遵循协议的类型提供默认的方法或者属性的实现</li><li>可以定义类型别名</li><li>可以继承其它协议</li><li>可以在协议中使用关联类型等</li></ul></details><h3 id="❓-面向协议编程-说说你的理解" tabindex="-1"><a class="header-anchor" href="#❓-面向协议编程-说说你的理解" aria-hidden="true">#</a> ❓“面向协议编程” 说说你的理解？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>核心思想 : 先定义出我们需要的行为和特性，然后再根据这些要求来编写具体的实现，而不是先写具体的类型然后再去考虑它们之间的关系。</p></li><li><p>优点：使得我们的代码更加灵活和可复用。由于协议的默认实现和多协议继承等特性，我们能够轻松地定义出行为复杂的类型，并且能够通过协议的组合来实现更为强大的功能。也使得我们的代码解耦性更强，更容易进行单元测试。</p></li></ul></details><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><h3 id="关联类型" tabindex="-1"><a class="header-anchor" href="#关联类型" aria-hidden="true">#</a> 关联类型？</h3><h3 id="❓-specialize-泛型语法特性" tabindex="-1"><a class="header-anchor" href="#❓-specialize-泛型语法特性" aria-hidden="true">#</a> ❓<code>@_specialize</code> - 泛型语法特性</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift</code> 中的一个特殊标记特性，它用于改变编译器如何编译和优化泛型函数，告诉编译器生成特定类型参数的专门化版本的代码。</p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 比较两个 Comparable 的元素并返回最小的一个</span>
<span class="token keyword">func</span> <span class="token function-definition function">min</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> y <span class="token operator">&lt;</span> x <span class="token operator">?</span> y <span class="token punctuation">:</span> x
<span class="token punctuation">}</span>

<span class="token comment">// @_specialize 优化，生成一个专门处理 Int 的版本</span>
<span class="token attribute atrule">@_specialize</span><span class="token punctuation">(</span><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token operator">==</span> <span class="token class-name">Int</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function-definition function">min</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> y <span class="token operator">&lt;</span> x <span class="token operator">?</span> y <span class="token punctuation">:</span> x
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓泛型类型擦除如何实现" tabindex="-1"><a class="header-anchor" href="#❓泛型类型擦除如何实现" aria-hidden="true">#</a> ❓泛型类型擦除如何实现？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>泛型类型擦除 : 将具有特定泛型类型约束的对象转化为一个不再具有特定泛型类型的对象，但仍然保持相似的行为。</p></blockquote><p>泛型类型擦除处理，一般是通过将泛型类型或函数包装在一个非泛型类型中来达成的。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 协议</span>
<span class="token keyword">protocol</span> <span class="token class-name">MyProtocol</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 实现 MyProtocol 的泛型类</span>
<span class="token keyword">class</span> <span class="token class-name">MyGenericClass</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">MyProtocol</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 将泛型类 MyGenericClass 进行类型擦除，同事具备 MyProtocol 的行为</span>
<span class="token keyword">class</span> <span class="token class-name">AnyMyGenericClass</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> _myClass<span class="token punctuation">:</span> <span class="token class-name">AnyObject</span>
  <span class="token keyword">init</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">MyProtocol</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> myClass<span class="token punctuation">:</span> <span class="token class-name">MyGenericClass</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _myClass <span class="token operator">=</span> myClass
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="anyiterator-了解吗" tabindex="-1"><a class="header-anchor" href="#anyiterator-了解吗" aria-hidden="true">#</a> <code>AnyIterator</code> 了解吗？</h3><hr><h2 id="codable" tabindex="-1"><a class="header-anchor" href="#codable" aria-hidden="true">#</a> Codable</h2><blockquote><p><code>Codable</code>是一个组合协议，它是 <code>Decodable</code> 和 <code>Encodable</code> 的 &quot;混合协议&quot;，用于通用序列化和反序列化的情况。</p></blockquote><h3 id="codable-如何实现-key-映射" tabindex="-1"><a class="header-anchor" href="#codable-如何实现-key-映射" aria-hidden="true">#</a> <code>Codable</code> 如何实现 <code>key</code> 映射?</h3><details class="hint-container details"><summary>💡</summary></details><h3 id="❓codable-实现原理" tabindex="-1"><a class="header-anchor" href="#❓codable-实现原理" aria-hidden="true">#</a> ❓<code>Codable</code> 实现原理</h3><details class="hint-container details"><summary>💡</summary><p>在标准库中，定义了一个 <code>Decoder</code> 协议，一般解码器（比如 <code>JSONDecoder</code>）都会遵循这个协议。相应地，还有一个 <code>Encoder</code> 协议，编码器（如 <code>JSONEncoder</code>）会遵循这个协议。</p><p>对于每个数据类型，只要它遵循了 <code>Decodable</code> 协议，就可以解码；遵循了 <code>Encodable</code> 协议，就可以编码。通过协议默认实现编码解码任务。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 解码方法</span>
<span class="token keyword">init</span><span class="token punctuation">(</span>from decoder<span class="token punctuation">:</span> <span class="token class-name">Decoder</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>
<span class="token comment">// 编码方法</span>
<span class="token keyword">func</span> <span class="token function-definition function">encode</span><span class="token punctuation">(</span>to encoder<span class="token punctuation">:</span> <span class="token class-name">Encoder</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程" aria-hidden="true">#</a> 异步编程</h2><h3 id="❓async-await" tabindex="-1"><a class="header-anchor" href="#❓async-await" aria-hidden="true">#</a> ❓<code>async/await</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.5</code> 新引入的两个关键字，主要用于简化、美化 <code>Swift</code> 中的异步任务的编码和阅读。</p></blockquote><p><code>async/await</code> 带来了更清晰、更简洁的异步编程模型。解决了过去处理多异步任务回调地狱的问题，可以和同步代码一样顺序编写，大大提高了代码的可读性和可维护性。</p><ul><li><p><code>async</code>：表示一个函数为异步函数。异步函数是一个可以在后台进程运行而不会阻塞当前的运行进程。</p></li><li><p><code>await</code>：通常在异步函数中调用另一个异步函数时使用，以表示等待这个异步函数的执行结果。</p></li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">fetchDataFromServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">-&gt;</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function-definition function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchDataFromServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓sendable" tabindex="-1"><a class="header-anchor" href="#❓sendable" aria-hidden="true">#</a> ❓<code>Sendable</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Swift 5.5</code> 中与并发相关的新特性之一，是一个标记性的协议。用于表示遵循该协议的类型是能安全地发送到和接收自别的并发上下文（例如，异步任务、actor）。</p></blockquote><p>类型可以标记 <code>Sendable</code> 协议的两个条件：</p><ul><li>值类型（例如，枚举、结构体</li><li>所有的存储属性（包括递归地）都是 <code>Sendable</code></li></ul><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 直接遵循 Sendable 协议</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span><span class="token punctuation">:</span> <span class="token class-name">Sendable</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">Double</span>
  <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token class-name">Double</span>
<span class="token punctuation">}</span>

<span class="token comment">// 扩展遵循 Sendable 协议</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token class-name">Double</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token class-name">Double</span>
<span class="token punctuation">}</span>
<span class="token keyword">extension</span> <span class="token class-name">Point</span><span class="token punctuation">:</span> <span class="token class-name">Sendable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><blockquote><p>❓<code>class</code> 类型可以标记为 <code>Sendable</code> 吗？</p></blockquote><details class="hint-container details"><summary>💡</summary><p><code>class</code> 并不是值类型，因此不能直接让 <code>class</code> 遵从 <code>Sendable</code> 协议。但是可以通过 <code>@unchecked Sendable</code> 属性强制表明 <code>class</code> 是 <code>Sendable</code>。必须保证这个类型是 <code>class</code>，在传递这个类的实例时仍旧能保证线程安全。</p><p><code>class</code>遵从 <code>Sendable</code> 协议时必须小心，因为 <code>Sendable</code> 要求遵循该协议的类型是线程安全的。如果不能保证线程安全，使用 <code>@unchecked Sendable</code> 可能引发难以调试的线程问题。</p></details>`,68);function p(i,l){return n(),a("div",null,[e(" more "),o])}const u=s(c,[["render",p],["__file","swift.html.vue"]]);export{u as default};

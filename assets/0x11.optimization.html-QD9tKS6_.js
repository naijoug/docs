import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as l,a as o,b as a,f as d}from"./app-kxfs-vhO.js";const c={},t=a("p",null,"程序开发中的“优化”，从程序的整个运行过程来说...",-1),r=d('<hr><h2 id="代码优化" tabindex="-1"><a class="header-anchor" href="#代码优化" aria-hidden="true">#</a> 代码优化</h2><h3 id="❓说说你常用的几个重构的技巧" tabindex="-1"><a class="header-anchor" href="#❓说说你常用的几个重构的技巧" aria-hidden="true">#</a> ❓说说你常用的几个重构的技巧</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>重构：系统性改变代码结构的过程，旨在改善代码的可读性，简化代码设计，提高效率，并且要在不改变软件的外在行为的情况下进行。</p></blockquote><p>重构技巧：</p><ul><li><p>提炼方法（<code>Extract Method</code>）：如果看到有一块代码可以被单独封装起来，那么就可以创建一个新的方法，并将这段代码的逻辑放到新的方法里。</p></li><li><p>合并重复的代码：这是减少代码复制的一个好方法，当看到多段相似的代码时，尝试将它们合并到一个公共的方法或类中。</p></li><li><p>重命名（<code>Rename</code>）：重命名是一个极其常用的优化技术，如果一个变量或方法的名字不够清晰，可以重新命名它以透露它的真实功能。</p></li><li><p>分解条件表达式：当一个复杂的逻辑条件在一个函数中被多次使用时，将它提取到一个独立的方法中，会使代码变得更易读。</p></li><li><p>替换临时变量（<code>Replace Temp with Query</code>）：取代对一个临时变量的多次引用以一个针对其计算的函数调用。</p></li><li><p>使用对象组合代替类继承：面向对象的警语：尽量使用组合/聚合，少用继承。</p></li></ul></details><blockquote><p>❓你觉得重构适合什么时候来做</p></blockquote><details class="hint-container details"><summary>💡</summary><p>重构时机：</p><ul><li><p>新功能开发需要调整现有结构：在添加新功能之前，先重构那些让添加新功能变得困难的代码，将代码修整到容易添加新功能的状态。</p></li><li><p>代码阅读时发现代码质量问题：在代码阅读时发现代码不易读或代码重复等问题时，便可以对其重构。</p></li><li><p>修复 <code>Bug</code> 时：在修复 <code>Bug</code> 时，通常需要修改代码，这为我们提供了一次思考如何提升代码质量、是否有更好设计的机会。</p></li></ul><p>以上三种情况，都可以将重构安排在「事情未发生前」，使重构帮助我们更容易地完成工作。同时，这样的重构，往往可以很确定其价值，因为经常能立即看到效果。</p><p>总结：重构应该是持续不断地进行，而不是紧急情况下的一次大行动。使代码保持良好的结构，使得我们可以维持正常的开发速度，防止技术债务的累积。不要害怕修改代码，代码是用来被改的，只要有了好的单元测试，改一点，跑一下单元测试，持续反馈、持续改进，重构将是一件非常愉快的事情。</p></details><h3 id="❓如何避免使用-if-else" tabindex="-1"><a class="header-anchor" href="#❓如何避免使用-if-else" aria-hidden="true">#</a> ❓如何避免使用 <code>if else</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p>使用多态：在面向对象编程中，可以通过多态来避免使用 <code>if-else</code>。</p><blockquote><p>例如，你可以定义一个接口或者父类，并为每一个可能的情况实现一个子类。这种方式可以将代码的决策逻辑转移到运行时系统中。</p></blockquote></li><li><p>使用映射：如果代码中包含了许多针对特定值进行特定操作的 <code>if-else</code>，那么可以考虑使用查找表或者字典来替换。将值映射到函数或者对应的处理代码。</p></li><li><p>使用早返回：如果一个函数的某个路径需要在一系列条件满足时执行，那么可以考虑使用 &quot;早返回&quot;，这样可以减少条件嵌套的深度，并提升代码的可读性。</p></li><li><p>使用异常处理：将检查边界条件或者异常值的代码放入 <code>try-catch</code> 块中，让异常处理机制处理错误情况。</p></li><li><p>使用状态机：如果代码是处理复杂的业务逻辑或者流程控制，可以考虑使用状态机来替代 <code>if-else</code>。</p></li><li><p>使用函数式编程中的模式匹配：在支持函数式编程的语言中，有的提供模式匹配的功能，可以根据输入参数的模式选择执行的代码，而无需使用多个 <code>if-else</code>。</p></li></ul></details><h3 id="❓如何避免回调地狱" tabindex="-1"><a class="header-anchor" href="#❓如何避免回调地狱" aria-hidden="true">#</a> ❓如何避免回调地狱</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>回调地狱是由于多个异步请求操作嵌套造成的问题，通常看到很多嵌套的 “回调” 代码。</p></blockquote><ul><li><p><strong>使用Promises或者Futures库：</strong> 这些库让您可以将异步操作连锁在一起，而不用嵌套。它们通常引入了一种类似于同步编程的编程风格，但仍然非阻塞。</p></li><li><p><strong>使用Async/Await模式：</strong> 这是最近几年在很多语言中兴起的一种新的编程模式，它可以让你以一种类似同步的方式编写异步代码。例如在<code>JS</code>、<code>C#</code>和<code>Python</code>中都有这种模式。</p></li><li><p><strong>使用Reactive编程库：</strong> 如<code>RxJava</code>，<code>RxSwift</code>等，可以让你将异步操作表示为数据流，然后你可以对这些数据流进行各种各样的组合和处理。</p></li><li><p><strong>使用协程：</strong> 协程是可以挂起和恢复的函数，很适合用来简化异步编程。比如 <code>Kotlin</code> 中就内置了协程支持。</p></li><li><p><strong>将回调函数提取成单独的函数或者方法：</strong> 尽量避免在一个方法中编写过多的嵌套代码。每个回调函数都可以提取成单独的函数或者方法。</p></li><li><p><strong>使用事件驱动设计：</strong> 将每个操作作为事件，通过事件监听和触发来完成操作，可以有效地避免回调地狱。</p></li></ul></details><hr><h2 id="网络优化" tabindex="-1"><a class="header-anchor" href="#网络优化" aria-hidden="true">#</a> 网络优化</h2><h3 id="❓网络层的优化方案有哪些" tabindex="-1"><a class="header-anchor" href="#❓网络层的优化方案有哪些" aria-hidden="true">#</a> ❓网络层的优化方案有哪些</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>服务端优化</p><ul><li><strong>数据压缩</strong>：如果需要传输的数据很大，可以对数据进行压缩，减少传输的数据量，从而提高传输速度。不过这样可能会增加 <code>CPU</code> 的使用量，因此需要针对具体的场景进行权衡。</li><li><strong>使用CDN</strong>：使用内容分发网络（CDN）进行数据的分发，可以有效降低服务器压力，保障数据传输速度。</li></ul></li><li><p>网络层优化</p><ul><li><strong>DNS 预解析</strong>：预先解析可能需要用到的域名，这样在需要进行网络请求时，就可以省去 <code>DNS</code> 解析的时间。</li><li><strong>减少重定向</strong>：重定向会增加网络请求的 <code>RTT</code>，即往返时间，合理规划 <code>API</code> ，尽量减小重定向。</li><li><strong>使用 HTTP/2</strong>：<code>HTTP/2</code> 相比 <code>HTTP/1.1</code> 在多路复用、数据压缩、服务器推送等方面都有所优化，可以用来提高网络传输效率。</li></ul></li><li><p>客户端优化</p><ul><li><strong>请求合并</strong>：如果有大量小的网络请求，可以尝试将这些请求合并，尽可能地减少请求数量，因为每个请求在请求发送和响应接收时都会有一定的固定开销。</li><li><strong>调整超时时间</strong>：根据网络环境的实际情况，合理设置网络请求的超时时间，避免无果等待，浪费资源。</li><li><strong>使用缓存</strong>：对于获取到的网络数据，如果可能多次使用，可以将其缓存到本地，这样在下次需要时，就可以直接从本地读取，避免重新发起网络请求。</li><li><strong>优化图片加载</strong>：针对图片资源，可以优化图片的尺寸和质量，选择合适的图片格式，或使用一些图片加载与缓存的框架等方式来加快图片的加载速度。</li></ul></li></ul></details><hr><h2 id="前端优化" tabindex="-1"><a class="header-anchor" href="#前端优化" aria-hidden="true">#</a> 前端优化</h2><blockquote><p>前端程序来说，由于是和用户交互，这些优化不仅涉及程序的本身的优化，还涉及用户体验方面的优化。</p></blockquote><h3 id="❓启动优化" tabindex="-1"><a class="header-anchor" href="#❓启动优化" aria-hidden="true">#</a> ❓启动优化</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>启动优化：也就是打开程序的快慢。<code>App</code> 角度来说就是用户点击打开 <code>App</code> 到看到首屏展示的速度。<code>Web</code> 角度来说就是用户打开网站到网页加载完成。</p></blockquote><ul><li>减小包体积。</li><li>减少启动逻辑，将启动无关的逻辑延迟加载。</li></ul></details><h3 id="❓数据优化" tabindex="-1"><a class="header-anchor" href="#❓数据优化" aria-hidden="true">#</a> ❓数据优化</h3><details class="hint-container details"><summary>💡</summary><ul><li>分页 :</li><li>缓存 :</li><li>压缩 :</li><li>预加载 :</li></ul></details><h3 id="❓体验优化" tabindex="-1"><a class="header-anchor" href="#❓体验优化" aria-hidden="true">#</a> ❓体验优化</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>体验优化：用户在使用前端应用过程是否出现卡顿、白屏、交互困难、交互体验(进入页面后加载时间长，或者提交表单之后等待时间长等问题)等问题。</p></blockquote><ul><li>耗时操作放入子线程</li><li>FPS 帧率调试</li></ul></details><hr><h2 id="后端优化" tabindex="-1"><a class="header-anchor" href="#后端优化" aria-hidden="true">#</a> 后端优化</h2><blockquote><p>后端程序来说，由于主要是和数据打交道，这些优化主要是程序逻辑、数据处理、架构等方面的优化。</p></blockquote><h3 id="数据库优化" tabindex="-1"><a class="header-anchor" href="#数据库优化" aria-hidden="true">#</a> 数据库优化</h3><h4 id="❓数据库的查询优化方案" tabindex="-1"><a class="header-anchor" href="#❓数据库的查询优化方案" aria-hidden="true">#</a> ❓数据库的查询优化方案</h4><details class="hint-container details"><summary>💡</summary><p>主要目标：减少查询的执行时间和系统的空间占用。</p><p>优化方案：</p><ul><li><p>优化 <code>SQL</code> 语句：这是最直接也是最有效的优化手段。</p><blockquote><p>比如尽量避免全表扫描，减少 <code>JOIN</code> 操作的数量，使用 <code>WHERE</code> 子句而不是 <code>HAVING</code> 子句，用 <code>EXISTS</code> 代替 <code>IN</code> 等。</p></blockquote></li><li><p>建立索引：索引是数据库中用于提高数据检索效率的数据结构。</p><blockquote><p>在适当的列上建立索引，可以显著减小查询的执行时间，但是要注意索引也会占用存储空间且对数据的插入、删除和修改有一定的先来花费。</p></blockquote></li><li><p>数据库表分区：如果一个表中的数据量太大，可以将它分区，分散到多个磁盘或者表中。</p><blockquote><p>这样查询时只需从包含所需数据的表或磁盘中读取，可以减少 <code>IO</code> 操作。</p></blockquote></li><li><p>数据库表分割：对于大量数据的表，考虑分割成多个小表，采用垂直分割或水平分割，这样可以提高查询效率以及数据操作效率。</p></li><li><p>使用视图：视图是一种虚拟的表，内容是由查询定义的。</p><blockquote><p>如果某一查询语句需要多个步骤执行，可以将其转化为视图，这样下次进行相同查询时，只需要查询视图就可以了。</p></blockquote></li><li><p>优化数据模型：根据业务需求优化数据模型设计，第三范式是追求完全规范化、无冗余，而反范式则是为了追求高效的查询性能。</p></li><li><p>使用数据库的查询优化器：现代数据库系统，如<code>MySQL</code>, <code>PostgreSQL</code>等，通常自带查询优化器，它会对查询语句进行分析，并尝试找到最优的执行计划。</p></li></ul></details><h4 id="❓数据库的分库分表方案" tabindex="-1"><a class="header-anchor" href="#❓数据库的分库分表方案" aria-hidden="true">#</a> ❓数据库的分库分表方案</h4><details class="hint-container details"><summary>💡</summary><p>四种方案：</p><ul><li><p>水平分表：将一个大表按照某种规则（例如 <code>ID</code> 范围，日期范围）拆分成多个小表。</p><blockquote><p>例如，用户表有百万甚至千万级别的数据行，可以按照用户 <code>ID</code> 的范围分成多个小表。</p></blockquote></li><li><p>垂直分表：根据业务需求，将一个表分拆成多个业务相关的小表。</p><blockquote><p>例如，用户表中有很多字段，可以将一部分基础信息字段和一部分扩展信息字段拆分开来。</p></blockquote></li><li><p>水平分库：和水平分表类似，只是在更大的维度上将一个数据库拆分成多个小数据库。</p><blockquote><p>例如，用户表可以按照用户 <code>ID</code> 的范围将数据分散存储到多个数据库中。</p></blockquote></li><li><p>垂直分库：根据业务关系将一个数据库的表分配到不同的数据库中，每个数据库负责整个业务流程中的一部分。</p><blockquote><p>例如，将订单表和用户信息表分配到不同的数据库中。</p></blockquote></li></ul></details><h4 id="❓数据库存储的实现方案" tabindex="-1"><a class="header-anchor" href="#❓数据库存储的实现方案" aria-hidden="true">#</a> ❓数据库存储的实现方案</h4><details class="hint-container details"><summary>💡</summary><p>存储实现方案：</p><ul><li><p>堆文件组织：数据记录可以在文件中的任何位置，记录间没有任何排序关系也没有任何先后关系。这种方式非常简单，但是访问效率低，因为找到一个特定的数据，可能需要全文扫描。</p></li><li><p>顺序文件组织：该存储方法根据某一属性（或属性组合）的值的顺序，把记录插入到文件中对应的位置。尤其在进行大量的查找操作时性能优良，但插入单条数据或者更新数据的性能较差。</p></li><li><p>散列表组织：散列技术是把记录的位置与其关键字之间建立一种直接的对应关系，以便能直接访问到这个记录。但是，同时也会导致更新操作比较复杂，并且空间利用率相对较低。</p></li><li><p><code>B+</code> 树索引组织：将数据根据键值以 <code>B+</code> 树的方式组织，非常适合范围查询和排序返回等操作，也支持单值快速查找。</p></li><li><p><code>LSM</code> 树(<code>LSM-Tree</code>, <code>Log-Structured Merge-Tree</code>)：通过两种不同类型的数据结构，即内存中的数据结构和硬盘上的数据结构，组成一个高效的硬盘存储引擎。如<code>RocksDB</code>，<code>LevelDB</code>等。</p></li></ul></details>',33);function s(p,n){return i(),l("div",null,[t,o(" more "),r])}const m=e(c,[["render",s],["__file","0x11.optimization.html.vue"]]);export{m as default};

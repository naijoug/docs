import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as l,c as n,a as d,b as e,e as t,d as a,f as c}from"./app-g9omgN1g.js";const s={},h=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),t(" reference")],-1),p={href:"https://refactoringguru.cn/design-patterns/catalog",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/me115/design_patterns",target:"_blank",rel:"noopener noreferrer"},P={href:"https://github.com/youlookwhat/DesignPattern",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/quanke/design-pattern-java",target:"_blank",rel:"noopener noreferrer"},b=c('<h2 id="solid-设计原则" tabindex="-1"><a class="header-anchor" href="#solid-设计原则" aria-hidden="true">#</a> <code>SOLID</code> 设计原则</h2><table><thead><tr><th>设计原则</th><th>英文名</th><th>中文名</th><th>说明</th></tr></thead><tbody><tr><td><code>SRP</code></td><td>Single Responsibility Principle</td><td>单一职责原则</td><td>一个类只负责一件事。</td></tr><tr><td><code>OCP</code></td><td>Open Closed Principle</td><td>开放封闭原则</td><td>对修改关闭，对扩展开放。</td></tr><tr><td><code>LSP</code></td><td>Liskov Substitution Principle</td><td>里式替换原则</td><td>父类可以被子类替换，且功能不受影响</td></tr><tr><td><code>ISP</code></td><td>Interface Segregation Principle</td><td>接口隔离原则</td><td>根据功能设计单独的接口，不要设置一个臃肿的接口</td></tr><tr><td><code>DIP</code></td><td>Dependency Inversion Principle</td><td>依赖倒置原则</td><td>抽象不依赖具体，具体依赖于抽象</td></tr></tbody></table><ul><li><code>LoD</code> : Law of Demeter 迪米特法则 (LKP Least Knowledge Principle 最少知识原则) 高内聚，低耦合</li></ul><h2 id="creational-patterns-创建型-5" tabindex="-1"><a class="header-anchor" href="#creational-patterns-创建型-5" aria-hidden="true">#</a> <code>Creational Patterns</code> - “创建型” (5)</h2><blockquote><p>对象是如何创建的</p></blockquote><ul><li>Abstract Factory Pattern : 抽象工厂模式</li><li>Builder Pattern : 建造者模式</li><li>Factory Pattern : 工厂模式</li><li>Prototype Pattern : 原型模式</li><li>Singleton Pattern : 单例模式</li></ul><h2 id="structural-patterns-结构型-7" tabindex="-1"><a class="header-anchor" href="#structural-patterns-结构型-7" aria-hidden="true">#</a> <code>Structural Patterns</code> - “结构型” (7)</h2><blockquote><p>对象是按照怎样的结构组合的</p></blockquote><ul><li>Adapter Pattern : 适配器模式</li><li>Bridge Pattern : 桥接模式</li><li>Composite Pattern : 组合模式</li><li>Decorator Pattern : 装饰器模式</li><li>Facade Pattern : 外观模式</li><li>Flyweight Pattern : 亨元模式</li><li>Proxy Pattern : 代理模式</li></ul><h2 id="behavioral-patterns-行为型-11" tabindex="-1"><a class="header-anchor" href="#behavioral-patterns-行为型-11" aria-hidden="true">#</a> <code>Behavioral Patterns</code> - “行为型” (11)</h2><blockquote><p>对象之间的访问行为如何完成的</p></blockquote><ul><li>Chain of Responsibility : 责任链模式</li><li>Command : 命令模式</li><li>Interpreter : 解释器模式</li><li>Iterator : 迭代器模式</li><li>Mediator : 中介者模式</li><li>Memento : 备忘录模式</li><li>Observer : 观察者模式</li><li>State : 状态模式</li><li>Strategy : 策略模式</li><li>Template Method : 模板方法模式</li><li>Visitor : 访问者模式</li></ul>',12);function f(g,m){const r=o("ExternalLinkIcon");return l(),n("div",null,[d(" more "),h,e("ul",null,[e("li",null,[e("a",p,[t("设计模式"),a(r)])]),e("li",null,[e("a",u,[t("图说设计模式"),a(r)])]),e("li",null,[e("a",P,[t("📚 Java 23种设计模式全归纳"),a(r)])]),e("li",null,[e("a",_,[t("设计模式 Java版本"),a(r)])])]),b])}const x=i(s,[["render",f],["__file","design-pattern.html.vue"]]);export{x as default};

import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as a,f as t}from"./app-YVf6zcZH.js";const c={},i=t('<h2 id="_402-464" tabindex="-1"><a class="header-anchor" href="#_402-464" aria-hidden="true">#</a> 402 ~ 464</h2><p>#402. 12.9 先关注概念，然后再担心具体的实现。应该怎么看待智能指针？</p><p>#403. 15.2 上下文切换是指在两个进程之间切换所花费的时间。当你将一个进程引入执行并置换现有进程时，就会发生这种情况。</p><p>#404. 13.1 想想谁能访问私有方法。</p><p>#405. 15.1 它们在内存方面有什么不同？</p><p>#406. 12.11 回想一下，二维数组本质上就是数组的数组。</p><p>#407. 15.2 理想情况下，我们希望记录一个进程“停止”时的时间戳和另一个进程“启动”时的时间戳。但如何知道两个进程何时会进行交换呢？</p><p>#408. 14.1 GROUP BY子句可能有用。</p><p>#409. 13.2 何时会执行finally代码块？有没有不执行的情况？</p><p>#410. 12.2 我们能做到原址吗？</p><p>#411. 14.2 将方法分成两部分可能会有所帮助。第一步是获取每个建筑物ID和状态为“Open”的申请数量。然后，我们可以得到建筑物的名称。</p><p>#412. 13.3 考虑到其中一些可能具有不同的含义，具体取决于它们的应用位置。</p><p>#413. 12.10 通常，malloc只会给我们一个任意的内存块。如果不能重写这个行为，我们可以用它来做我们需要的吗？</p><p>#414. 15.7 首先实现单线程FizzBuzz问题。</p><p>#415. 15.2 尝试设置两个进程，让它们来回地传递少量数据。这将促使系统停止一个进程并载入另一个进程。#416. 13.4 它们的目的可能有些相似，但实现有什么不同呢？</p><p>#417. 15.5 怎样确保first()在调用second()之前已终止？</p><p>#418. 12.11 一种方法是为每个数组调用malloc。我们在这里怎样释放内存？</p><p>#419. 15.3 当一个“循环”按谁等待谁的顺序出现时，就会发生死锁。我们如何打破或阻止这种循环？</p><p>#420. 13.5 考虑底层数据结构。</p><p>#421. 12.7 想想为什么我们使用虚函数。</p><p>#422. 15.4 如果每个线程都必须预先声明它可能需要的进程，我们是否可以提前检测到可能的死锁？</p><p>#423. 12.3 每种数据背后的基础数据结构是什么？这有什么影响？</p><p>#424. 13.5 HashMap使用链表数组。TreeMap使用红黑树。LinkedHashMap使用双向链表桶。这意味着什么？</p><p>#425. 13.4 考虑基本数据类型的使用。在如何使用这些类型方面，它们还有什么不同之处？#426. 12.11 我们可以将它分配为一个连续的内存块吗？</p><p>#427. 12.8 此数据结构可以描绘为二叉树，但不一定。如果结构中有循环怎么办？</p><p>#428. 14.7 你可能需要学生列表，即他们的课程列表以及另一个表示学生和课程之间关系的表。请注意，这是一种多对多关系。</p><p>#429. 15.6 关键字synchronized确保两个线程不能同时在同一个实例上执行同步方法。</p><p>#430. 13.5 想想它们在遍历key的顺序方面可能有何不同。为什么你想要其中之一而不是其他呢？#431. 14.3 首先尝试获取所有相关公寓的ID列表（仅仅是ID）。</p><p>#432. 12.10 想象一下，我们有一组连续的整数（3，4，5 …）。这个集合需要多大才能确保其中一个数字可以被16整除？</p><p>#433. 15.5 为什么使用布尔标志是一个坏主意？</p><p>#434. 15.4 把请求的顺序想象成一个图。在图里死锁是什么样子？</p><p>#435. 13.6 对象反射允许访问对象中方法和字段的信息。为什么它有用？</p><p>#436. 14.6 要特别注意哪些关系是一对一，一对多，多对多。</p><p>#437. 15.3 一个点子是，如果哲学家拿不到另一根筷子，那一开始就不要让他拿到左手边的筷子。</p><p>#438. 12.9 考虑追踪引用的数量，这能告诉我们什么？</p><p>#439. 15.7 不要在单线程问题上做任何花哨的事情。只是得到简单易读的东西。</p><p>#440. 12.10 我们如何释放内存？</p><p>#441. 15.2 如果你的解决方案不完美也没关系。完美可能并不存在。权衡你的方法的利弊。</p><p>#442. 14.7 选择前10% 时，仔细考虑如何处理关系。</p><p>#443. 13.8 一个简单的方法是选择一个随机的子集大小z，然后遍历，每个元素放进集合的可能性为z/list_size。为什么这样行不通？</p><p>#444. 14.5 反规范化意味着向表中添加冗余数据。它通常用于非常大的系统中。为什么这样有用呢？</p><p>#445. 12.5 浅复制只复制初始数据结构。深复制不仅复制初始数据结构，还复制一切基础数据。既然如此，为什么还要使用浅复制呢？</p><p>#446. 15.5 信号量有用武之地吗？</p><p>#447. 15.7 概述线程的结构，而不必担心同步任何事情。</p><p>#448. 13.7 优先考虑一下在没有lambda表达式的情况下如何实现它。</p><p>#449. 12.1 如果已经有文件中的行数，我们要怎么做？</p><p>#450. 13.8 选择包含n个元素集合的所有子集列表。对于任何给定的x，一半的子集包含x，一半则不包含。</p><p>#451. 14.4 描述INNER JOIN和OUTER JOIN。OUTER JOIN可以分为几种子类型：LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。</p><p>#452. 12.2 小心null字符。</p><p>#453. 12.9 我们想覆写的所有不同的方法/操作符是什么？</p><p>#454. 13.5 常见操作的运行时间是多少？</p><p>#455. 14.5 想想在大型系统里join操作的成本。</p><p>#456. 12.6 关键字volatile表示一个变量可能从程序之外被改变，比如被另一个进程改变。这样为什么是必要的？</p><p>#457. 13.8 不要预先选择子集的长度。你不需要那样做。相反，考虑一下对于每个元素，是否选择将元素放入集合中。</p><p>#458. 15.7 等完成每个线程的结构以后，你就可以考虑需要同步什么了。</p><p>#459. 12.1 假设我们没有文件中的行数。有没有一种方法可以在不预先计算行数的情况下做到这件事。</p><p>#460. 12.7 如果析构函数不是虚拟的，会发生什么？</p><p>#461. 13.7 将其分为两部分：过滤国家，然后计算和。</p><p>#462. 12.8 考虑使用散列表。</p><p>#463. 12.4 在这里你应该讨论虚函数表。</p><p>#464. 13.7 你能不做filter操作吗？</p>',61),n=[i];function o(s,l){return e(),a("div",null,n)}const d=p(c,[["render",o],["__file","basic.html.vue"]]);export{d as default};

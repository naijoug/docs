import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as a,a as o,f as c}from"./app-KOLbvikU.js";const i={},r=c(`<h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><h3 id="swift-类和结构体的区别" tabindex="-1"><a class="header-anchor" href="#swift-类和结构体的区别" aria-hidden="true">#</a> <code>Swift</code> 类和结构体的区别</h3><h3 id="swift-中的枚举和其它编程语言的区别" tabindex="-1"><a class="header-anchor" href="#swift-中的枚举和其它编程语言的区别" aria-hidden="true">#</a> <code>Swift</code> 中的枚举和其它编程语言的区别</h3><h3 id="swift-中的-switch-和其它编程语言有什么区别" tabindex="-1"><a class="header-anchor" href="#swift-中的-switch-和其它编程语言有什么区别" aria-hidden="true">#</a> <code>Swift</code> 中的 <code>switch</code> 和其它编程语言有什么区别？</h3><blockquote><p>匹配模式深入说一下？</p></blockquote><h3 id="swift-中的-string-的设计理念" tabindex="-1"><a class="header-anchor" href="#swift-中的-string-的设计理念" aria-hidden="true">#</a> <code>Swift</code> 中的 <code>String</code> 的设计理念</h3><p>支持 <code>Unicode</code> 和字符串操作的安全性。不能直接使用下标索引访问，使用 <code>String.Index</code> 进行字符串的访问和操作。</p><h3 id="值类型-vs-引用类型" tabindex="-1"><a class="header-anchor" href="#值类型-vs-引用类型" aria-hidden="true">#</a> 值类型 vs 引用类型</h3><h3 id="swift-中基础类型-array、dictionary、set-为什么设计成值类型" tabindex="-1"><a class="header-anchor" href="#swift-中基础类型-array、dictionary、set-为什么设计成值类型" aria-hidden="true">#</a> <code>Swift</code> 中基础类型 <code>Array</code>、<code>Dictionary</code>、<code>Set</code> 为什么设计成值类型？</h3><h3 id="cow-设计说一下" tabindex="-1"><a class="header-anchor" href="#cow-设计说一下" aria-hidden="true">#</a> <code>cow</code> 设计说一下？</h3><p><code>cow</code> (Copy on Write) : Swift 的写时拷贝，也就是说数据只有等到赋值修改时才进行拷贝，主要应用在系统设计的值类型(<code>String</code>、<code>Array</code>、<code>Dictionary</code>)</p><blockquote><p><code>isKnownUniquelyReferenced</code> 实现自定义结构体 <code>Cow</code></p></blockquote><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="inout-关键字做了什么" tabindex="-1"><a class="header-anchor" href="#inout-关键字做了什么" aria-hidden="true">#</a> <code>inout</code> 关键字做了什么？</h3><h3 id="swift-中的闭包" tabindex="-1"><a class="header-anchor" href="#swift-中的闭包" aria-hidden="true">#</a> <code>Swift</code> 中的闭包</h3><ul><li>逃逸闭包 : 闭包作为函数参数传入函数，如果这个闭包在函数返回之后再执行，则为逃逸闭包，闭包参数需要使用 <code>@escaping</code> 修饰。</li><li>非逃逸闭包 : 闭包作为函数参数，在函数返回之前，这个闭包已经执行，则为非逃逸闭包。</li><li>尾随闭包 : 将闭包作为函数的最后一个参数，函数调用时，闭包参数就是一个写在尾随函数调用后面的一个闭包表达式。</li><li>自动闭包 : 需要一个不接受参数的闭包作为函数参数，使用 <code>@autoclosure</code> 修饰。用作闭包表达式的延迟加载，只有当闭包表达式真正调用时才执行。</li></ul><h3 id="swift-可选类型-optional-说一下理解" tabindex="-1"><a class="header-anchor" href="#swift-可选类型-optional-说一下理解" aria-hidden="true">#</a> <code>Swift</code> 可选类型 <code>Optional</code> 说一下理解？</h3><blockquote><p><code>Optional</code> 可选类型的底层实现</p></blockquote><ul><li><code>Swift</code> 语法特性泛型 (<code>@_specialize</code>)、运算符、下标、字面量协议、尾随闭包</li><li><code>Swift</code> 泛型类型擦除如何实现？</li><li><code>Swift</code> 函数式编程 (函子、单子)，“函数是第一等公民”这句话你是怎么理解的？</li><li>响应式编程中数据响应、UI 响应。 <code>RxSwift</code> <code>Combine</code> 这两个框架第比较？</li><li><code>Swift 5.1</code> 新特性 <code>@propertyWrapper</code>、<code>@_functionBuilder</code>、<code>@dynamicMemberLookup</code></li><li><code>Swift</code> 在其它领域的扩展 (AI、AR、VR、Web、Backend)</li><li><code>SwiftUI</code> vs <code>Flutter</code></li><li><code>Swift</code> 函数派发机制</li><li><code>swift_once</code> 是用在什么地方的？</li></ul><h2 id="protocol" tabindex="-1"><a class="header-anchor" href="#protocol" aria-hidden="true">#</a> <code>protocol</code></h2><h3 id="swift-中的协议与-oc-中协议的特点和区别-面向协议开发说一下你的理解" tabindex="-1"><a class="header-anchor" href="#swift-中的协议与-oc-中协议的特点和区别-面向协议开发说一下你的理解" aria-hidden="true">#</a> <code>Swift</code> 中的协议与 <code>OC</code> 中协议的特点和区别？面向协议开发说一下你的理解？</h3><h2 id="codable" tabindex="-1"><a class="header-anchor" href="#codable" aria-hidden="true">#</a> <code>Codable</code></h2><h3 id="codable-实现原理" tabindex="-1"><a class="header-anchor" href="#codable-实现原理" aria-hidden="true">#</a> <code>Codable</code> 实现原理</h3><h2 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> <code>async/await</code></h2><h3 id="sendable" tabindex="-1"><a class="header-anchor" href="#sendable" aria-hidden="true">#</a> <code>Sendable</code></h3><p><code>Swift 5.5</code> 引入并发模型之后添加的。</p>`,26);function t(h,n){return d(),a("div",null,[o(" more "),r])}const f=e(i,[["render",t],["__file","swift.html.vue"]]);export{f as default};

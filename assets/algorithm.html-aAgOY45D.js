import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e,f as t}from"./app-8wVbLcw5.js";const o={},p=t(`<h2 id="算法知多少" tabindex="-1"><a class="header-anchor" href="#算法知多少" aria-hidden="true">#</a> 算法知多少</h2><table><thead><tr><th>Algorithm</th><th>说明</th></tr></thead><tbody><tr><td>traverse</td><td>遍历</td></tr><tr><td>recursion</td><td>递归</td></tr><tr><td>backtrace</td><td>回溯</td></tr><tr><td>greedy</td><td>贪婪</td></tr><tr><td>divide-conquer</td><td>分治</td></tr><tr><td>sort</td><td>排序</td></tr><tr><td>search</td><td>搜索</td></tr><tr><td>dynamic programming</td><td>动态规划</td></tr></tbody></table><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h2><ul><li>最好时间复杂度</li><li>最坏时间复杂度</li><li>平均时间复杂度</li><li>摊还分析法 : 均摊时间复杂度，一种特殊的平均时间复杂度</li></ul><h2 id="recursion-递归" tabindex="-1"><a class="header-anchor" href="#recursion-递归" aria-hidden="true">#</a> recursion - “递归”</h2><p>递归的本质就是使用栈的数据结构来进行问题求解。</p><blockquote><p>可以进行递归求解的三要素？</p></blockquote><ul><li>求解问题可以分解问子问题</li><li>求解问题与子问题具有相同的求解思路</li><li>存在递归终止条件</li></ul><blockquote><p>递归有哪些弊端？</p></blockquote><ul><li>递归层数较深，会照成堆栈溢出</li><li>递归过程中会存在重复计算</li><li>空间复杂度高，函数调用耗时</li></ul><blockquote><p>尾递归</p></blockquote><p>尾递归是在进行递归代码编写时，将递归的调用操作作为函数的最后一个操作直接。 这个时候依赖编译器的“尾调用优化”(Tail Call Optimization) 会将递归代码优化为迭代代码。编译的优化的关键在于函数的最后一步就是递归调用，这个时候就不需要新开辟栈，直接将控制器和调用交个调用函数。</p><p>尾递归的优化是编译器的特性，如果编程语言的编译器不支持“尾调用优化”，那么尾递归写法和常规递归也就没有区别了。</p><p>尾递归的写法其实是一种自底向上的一种写法，使用的迭代的思维，需要将子问题的求解结果，从边界情况一直向上传递。从代码理解成面来讲，如果想要使用尾递归优化，还不如直接将递归代码转化为迭代代码清晰。并且尾递归的优化依赖编程语言的编译器，并不一定是百分百有效。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token comment">// 斐波纳契 : 0,1,1,2,3,5,8</span>
<span class="token comment">//  f(n) = f(n-1) + fn(n-2)</span>
<span class="token keyword">func</span> <span class="token function-definition function">fib</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> n<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">guard</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 尾递归优化</span>
<span class="token keyword">func</span> <span class="token function-definition function">fibTail</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> n<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> current<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">guard</span> n <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> current <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">fibTail</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> current<span class="token punctuation">:</span> next<span class="token punctuation">,</span> next<span class="token punctuation">:</span> current <span class="token operator">+</span> next<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 迭代</span>
<span class="token keyword">func</span> <span class="token function-definition function">fibTraverse</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> n<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">guard</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n <span class="token punctuation">}</span>
    <span class="token keyword">var</span> pre <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> current <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">2</span><span class="token operator">...</span>n <span class="token punctuation">{</span>
         <span class="token keyword">let</span> next <span class="token operator">=</span> pre <span class="token operator">+</span> current
         pre <span class="token operator">=</span> current
         current <span class="token operator">=</span> next
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> current
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法" aria-hidden="true">#</a> 排序算法</h2><h3 id="比较排序" tabindex="-1"><a class="header-anchor" href="#比较排序" aria-hidden="true">#</a> 比较排序</h3><blockquote><p>交换排序</p></blockquote><ul><li>冒泡排序</li><li>快速排序</li></ul><blockquote><p>插入排序</p></blockquote><ul><li>简单插入排序</li><li>希尔排序</li></ul><blockquote><p>选择排序</p></blockquote><ul><li>简单选择排序</li><li>堆排序</li></ul><blockquote><p>归并排序</p></blockquote><ul><li>二路归并排序</li><li>多路归并排序</li></ul><h3 id="非比较排序" tabindex="-1"><a class="header-anchor" href="#非比较排序" aria-hidden="true">#</a> 非比较排序</h3><ul><li>桶排序</li><li>计数排序</li><li>基数排序</li></ul><h3 id="还有什么排序算法吗" tabindex="-1"><a class="header-anchor" href="#还有什么排序算法吗" aria-hidden="true">#</a> 还有什么排序算法吗？</h3><ul><li>猴子排序</li><li>睡眠排序</li><li>面条排序</li></ul><h2 id="搜素算法" tabindex="-1"><a class="header-anchor" href="#搜素算法" aria-hidden="true">#</a> 搜素算法</h2><blockquote><p>顺序搜素</p></blockquote><blockquote><p>二分搜索</p></blockquote><blockquote><p>二叉搜索树</p></blockquote><h2 id="动态规划-dynamic-programming" tabindex="-1"><a class="header-anchor" href="#动态规划-dynamic-programming" aria-hidden="true">#</a> 动态规划(Dynamic Programming)</h2><p>动态规划的特点</p><ul><li>最优子结构 : 最优解是否可以通过子问题的最优解来计算得到，而子问题可以通过更小的最优解来得到。</li><li>重叠子问题 : 解决每个子问题时，是否会遇到相同的子问题。可以使用缓存子问题结果(<code>DP</code> 表)，避免重复计算，提高算法效率。</li><li>状态转移方程 : 当前状态是否可以使用子问题的状态描述。</li></ul><p>动态规划求解方向</p><ul><li>自底向上 (<code>Bottom-Up</code>) : 迭代的方式解决问题</li><li>自顶向下 (<code>Top-Down</code>) : 递归的方式解决问题</li></ul>`,38);function l(c,i){return s(),a("div",null,[e(" more "),p])}const d=n(o,[["render",l],["__file","algorithm.html.vue"]]);export{d as default};

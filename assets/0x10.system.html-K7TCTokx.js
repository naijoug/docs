import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,a as r,f as c}from"./app-UZzaqt-K.js";const i={},h=c('<hr><h2 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h2><h3 id="❓-虚拟内存-是什么" tabindex="-1"><a class="header-anchor" href="#❓-虚拟内存-是什么" aria-hidden="true">#</a> ❓“虚拟内存”是什么？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Virtual Memory</code> - “虚拟内存”</p></blockquote></details><h3 id="一个程序当中的地址是虚拟地址还是物理地址" tabindex="-1"><a class="header-anchor" href="#一个程序当中的地址是虚拟地址还是物理地址" aria-hidden="true">#</a> 一个程序当中的地址是虚拟地址还是物理地址？</h3><h3 id="拿到一个虚拟地址后-怎么转成物理地址" tabindex="-1"><a class="header-anchor" href="#拿到一个虚拟地址后-怎么转成物理地址" aria-hidden="true">#</a> 拿到一个虚拟地址后，怎么转成物理地址？</h3><h3 id="❓tlb-了解吗" tabindex="-1"><a class="header-anchor" href="#❓tlb-了解吗" aria-hidden="true">#</a> ❓<code>TLB</code> 了解吗？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>TLB (Translation Lookaside Buffer) 是一个硬件缓存，系统用 <code>TLB</code> 来改进和加速虚拟地址到物理地址的转换过程。</p></blockquote><p>操作系统通常使用一种叫做分页的内存管理技术，把虚拟地址空间和物理地址空间分割成大小相等的块，称为页面。这种页面映射一般会存储在内存中，但每次地址转换都访问这个映射的开销很大，因此 <code>TLB</code> 用于缓存最近使用过的映射，以减少访问内存的次数，加快地址转换速度。</p><p><code>TLB</code> 是一种依赖硬件支持的高速缓存，它提供了从虚拟内存到物理内存的快速转换，使得内存访问更加高效。</p></details><hr><h2 id="页表" tabindex="-1"><a class="header-anchor" href="#页表" aria-hidden="true">#</a> 页表</h2><h3 id="行间的换页算法有哪些" tabindex="-1"><a class="header-anchor" href="#行间的换页算法有哪些" aria-hidden="true">#</a> 行间的换页算法有哪些？</h3><h3 id="页表在-linux-中怎么用的-页式、段式、段页式聊了聊" tabindex="-1"><a class="header-anchor" href="#页表在-linux-中怎么用的-页式、段式、段页式聊了聊" aria-hidden="true">#</a> 页表在 <code>Linux</code> 中怎么用的，页式、段式、段页式聊了聊？</h3><h3 id="你是怎么理解页表的" tabindex="-1"><a class="header-anchor" href="#你是怎么理解页表的" aria-hidden="true">#</a> 你是怎么理解页表的？</h3><h3 id="二级页表是什么" tabindex="-1"><a class="header-anchor" href="#二级页表是什么" aria-hidden="true">#</a> 二级页表是什么？</h3><hr><h2 id="cpu" tabindex="-1"><a class="header-anchor" href="#cpu" aria-hidden="true">#</a> CPU</h2><h3 id="cpu-是如何调用-gpu" tabindex="-1"><a class="header-anchor" href="#cpu-是如何调用-gpu" aria-hidden="true">#</a> <code>CPU</code> 是如何调用 <code>GPU</code>？</h3><details class="hint-container details"><summary>💡</summary><p>图像的成像原理 : 计算中的图像的展示，需要 <code>CPU</code>、<code>GPU</code> 和显示器合作完成。<code>CPU</code> 负责计算图像哪些数据需要显示，<code>GPU</code> 负责将需要显示的图像数据渲染，然后放入缓存区，显示器读取缓存区数据将图像显示出来。</p></details><hr><h2 id="用户态" tabindex="-1"><a class="header-anchor" href="#用户态" aria-hidden="true">#</a> 用户态</h2><details class="hint-container details"><summary>💡</summary><blockquote><p><code>User Mode</code> - “用户态”</p></blockquote><blockquote><p><code>Kernel Mode</code> - “核心态”</p></blockquote><p>这个区分是一种安全机制，保证了用户程序不能随意访问操作系统核心数据和硬件，保证了操作系统运行的稳定性和安全性。</p><ul><li>在用户态运行的代码不能访问操作系统核心数据结构和硬件，不能执行影响操作系统稳定性的操作。</li><li>核心态运行的代码可以访问操作系统的所有的内存和硬件，大多数操作系统核心程序运行在核心态上，可以执行 CPU 指令，也可以访问所有硬件资源。</li></ul></details><h3 id="用户态和内核态-什么时候用户态会转为内核态" tabindex="-1"><a class="header-anchor" href="#用户态和内核态-什么时候用户态会转为内核态" aria-hidden="true">#</a> 用户态和内核态，什么时候用户态会转为内核态？</h3><h3 id="backtrace-是在用户态实现吗-能否讲讲实现它的大致思路" tabindex="-1"><a class="header-anchor" href="#backtrace-是在用户态实现吗-能否讲讲实现它的大致思路" aria-hidden="true">#</a> <code>backtrace</code> 是在用户态实现吗？能否讲讲实现它的大致思路？</h3><details class="hint-container details"><summary>💡</summary><p>先理解两个概念 : <code>backtrace</code>、用户态</p><ul><li><code>backtrace</code> 是回溯栈，记录程序运行过程中的调用栈信息，当程序 <code>Crash</code> 时，可以通过这个信息了解程序崩溃的上下文，调试程序问题。</li><li>用户态是属于操作系统的一个分区概念，主要分为内核态和用户态。两者的区别的是为了保证内核安全，只有以内核态运行的程序才具备操作系统所有资源的访问权限，而以用户态运行的程序会受到限制，这样是为了保证操作系统的稳定运行。</li></ul></details>',24);function o(t,s){return a(),d("div",null,[r(" more "),h])}const u=e(i,[["render",o],["__file","0x10.system.html.vue"]]);export{u as default};

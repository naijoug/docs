import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as o,a as c,f as t}from"./app-8AiZ3QvE.js";const i={},l=t('<h2 id="flutter" tabindex="-1"><a class="header-anchor" href="#flutter" aria-hidden="true">#</a> <code>Flutter</code></h2><h3 id="❓命令式-ui-vs-声明式-ui" tabindex="-1"><a class="header-anchor" href="#❓命令式-ui-vs-声明式-ui" aria-hidden="true">#</a> ❓命令式 <code>UI</code> vs 声明式 <code>UI</code></h3><details class="hint-container details"><summary>💡</summary><ul><li>命令式 : 告诉程序一步一步如何搭建所需要的界面，类似做菜的教程</li><li>声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单</li></ul><p>命令式 <code>UI</code> 和声明式 <code>UI</code> 是两种不同的用户界面编程范式。</p><ul><li><p>命令式 <code>UI</code>: 一种更为<strong>传统</strong>的编程范式，开发者需要手动管理 <code>UI</code> 的状态，当状态发生变化时，也需要手动更新 <code>UI</code>。</p><blockquote><p>例如，开发者需要知道何时调用 <code>UI</code> 库的方法去创建部件，并且保存这些部件的引用，以便之后可以更新或删除它们。命令式 <code>UI</code> 编程的挑战是同步状态和 <code>UI</code> 视图的复杂性。</p></blockquote></li><li><p>声明式 <code>UI</code>: 一种更为<strong>现代</strong>的编程范式，开发者仅需要声明 <code>UI</code> 应该如何根据当前状态进行展示，而无需手动管理 <code>UI</code> 的创建和更新。如果状态发生变化，<code>UI</code> 框架会自动重新构建 <code>UI</code>。</p><blockquote><p>在声明式 <code>UI</code> 中，状态和 <code>UI</code> 视图的同步已经被内部处理，开发者可以专注于描述 <code>UI</code> 的外观和行为，而不需要关注如何同步状态和视图。</p></blockquote></li></ul><p>对比：</p><ul><li>命令式 <code>UI</code> 的优点包括更细粒度的控制，但缺点是需要手动管理 <code>UI</code> 和状态的同步。</li><li>声明式 <code>UI</code> 的优点是简化了状态管理，使 <code>UI</code> 代码更清晰，但缺点是它通常需要更多的内存和 <code>CPU</code> 来处理 <code>UI</code> 的自动更新。</li></ul></details><h3 id="❓flutter-与-rn-react-native-不同之处" tabindex="-1"><a class="header-anchor" href="#❓flutter-与-rn-react-native-不同之处" aria-hidden="true">#</a> ❓<code>Flutter</code> 与 <code>RN</code> (<code>React Native</code>) 不同之处</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>开发语言：</p><ul><li><code>React Native</code> 使用的是 `JavaScript</li><li><code>Flutter</code> 使用的是 <code>Dart</code></li></ul></li><li><p><code>UI</code> 组件</p><ul><li><code>React Native</code> 依赖于原生控件来呈现用户界面，这可能会导致在不同平台之间的 <code>UI</code> 和 <code>UX</code> 有所不同。</li><li><code>Flutter</code> 有一套自己的 <code>Widget</code>（包含 <code>Material</code> 和 <code>Cupertino</code>），这些 <code>Widget</code> 完全用 <code>Dart</code> 实现，并且在不同的平台中有着一致的行为和外观。</li></ul></li><li><p>性能：由于 <code>Flutter</code> 使用 <code>Dart</code> 语言，并使用自身的高性能渲染引擎进行绘制，所以一般情况下，<code>Flutter</code> 的性能要优于 <code>React Native</code>。</p></li><li><p>社区和生态系统</p><ul><li><code>React Native</code> 由于发布得更早，并且得益于庞大的 <code>JavaScript</code> 社区，其生态系统相对较成熟，提供的第三方库也更多。</li><li><code>Flutter</code> 起步较晚，但由于其出色的设计和性能，社区发展也非常迅速，并且得到了 <code>Google</code> 的大力推广和支持。</li></ul></li><li><p>热重载：都支持热重载功能，但 <code>Flutter</code> 的热重载速度通常更快。</p></li><li><p>学习曲线：</p><ul><li>对于已经熟悉 <code>JavaScript</code> 的开发者来说，<code>React Native</code> 的学习曲线可能会相对较缓和容易。</li><li><code>Dart</code> 其语言特性与 <code>Java</code> 和 <code>C#</code> 等主流语言相近，因此对已有这些背景的开发者来说，学习曲线也并不陡峭。</li></ul></li></ul></details><h3 id="❓widget-element-renderobject-之间的关系" tabindex="-1"><a class="header-anchor" href="#❓widget-element-renderobject-之间的关系" aria-hidden="true">#</a> ❓<code>Widget</code> <code>Element</code> <code>RenderObject</code> 之间的关系</h3><details class="hint-container details"><summary>💡</summary><p><code>Flutter</code> 三棵树：</p><ul><li><p><code>Widget</code>：一个描述部件（用户界面元素）的配置数据。<code>Widget</code> 本身是不可变的，当 <code>UI</code> 需要变化时，创建一个新的 <code>Widget</code> 实例。</p></li><li><p><code>Element</code>：<code>Widget</code>在树形结构中的一个实例，可以认为 <code>Element</code> 是 <code>Widget</code> 的实例化，同时它也保存了子 <code>Widget</code> 的状态。<code>Element</code> 使 <code>Widget</code> 获得了生命周期。</p></li><li><p><code>RenderObject</code>：一个描述并实现了绘制操作的对象，也就是承担渲染工作的对象。</p></li></ul><p>工作过程：</p><ul><li>当在 <code>Flutter</code> 中构建 <code>UI</code> 时，会创建一组 <code>Widget</code>。这组 <code>Widget</code> 会通过 <code>createElement</code> 方法创建对应的 <code>Element</code>，并形成一个 <code>Element</code> 树（也就是 <code>Widget</code> 的具象化）。</li><li>每个 <code>Element</code> 又会通过 <code>createRenderObject</code> 方法创建对应的 <code>RenderObject</code>。在这个过程中 <code>Element</code> 起到了桥梁的作用，它连接了 <code>Widget</code> 和 <code>RenderObject</code>，使 <code>Widget</code> 的配置可以应用到 <code>RenderObject</code>。</li><li><code>RenderObject</code> 负责处理最终的布局(<code>layout</code>)和绘制(<code>paint</code>)。</li></ul><p>总结：<code>Widget</code>定义了他们的样式和行为，通过<code>Element</code>配置到<code>RenderObject</code>，然后由<code>RenderObject</code>进行实际的渲染。</p></details><h3 id="❓flutter-跨平台是如何实现的" tabindex="-1"><a class="header-anchor" href="#❓flutter-跨平台是如何实现的" aria-hidden="true">#</a> ❓<code>Flutter</code> 跨平台是如何实现的</h3><details class="hint-container details"><summary>💡</summary><p><code>Flutter</code> 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。</p><ul><li><p>界面渲染 : 内置的高性能渲染引擎。</p><ul><li><code>Skia</code> 绘制引擎进行视图的统一渲染。 <blockquote><p>相比于其他跨平台解决方案，如 <code>React Native</code> 或者 <code>Cordova</code> 这种依赖于原生控件的方式，<code>Flutter</code> 自己在引擎层面提供了一套 <code>2D</code> 渲染引擎，使用 <code>OpenGL</code> 或 <code>Vulkan</code> 等底层图形库直接与设备硬件交互，再加上其以 <code>Dart</code> 语言为基础的高效调度机制，使得 <code>Flutter</code> 可以在 <code>Android</code> 和 <code>iOS</code> 系统上执行高效的 <code>GPU</code> 渲染。</p></blockquote></li><li>丰富的组件。 <blockquote><p>在Flutter中，所有的组件 (<code>Widget</code>) 都是由底层绘制，并提供了 <code>Material</code> 和 <code>Cupertino</code> 两套设计语言风格的控件。</p></blockquote></li></ul></li><li><p>原生通信 : 通过 <code>Channel</code> 机制进行与原生进行交互，实现特定的 <code>Plugin</code> 来访问原生功能。</p><ul><li><code>BasicMessageChannel</code> : 用于基本的字符串信息通信</li><li><code>MethodChannel</code> : 方法调用通信</li><li><code>EventChannel</code> : 数据流通信</li></ul></li></ul></details><h3 id="❓为什么说-flutter-是原生的" tabindex="-1"><a class="header-anchor" href="#❓为什么说-flutter-是原生的" aria-hidden="true">#</a> ❓为什么说 <code>Flutter</code> 是原生的</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>性能接近原生：<code>Flutter</code> 使用 <code>Dart</code> 语言，<code>Dart</code> 代码会被直接编译为机器代码，无须额外的 <code>JavaScript</code> 桥接层，因此性能与原生接近。而且 <code>Flutter</code> 引擎中有自己的图形渲染引擎，直接利用 <code>GPU</code> 进行渲染，因此图形渲染性能非常高。</p></li><li><p>访问原生功能：虽然 <code>Flutter</code> 的 <code>UI</code> 构建是独立于平台的，但是它的插件系统允许 <code>Flutter</code> 访问每个平台的原生代码，如相机、定位、蓝牙等。开发者也可以编写自定义插件，调用原生 <code>API</code>，实现自定义功能。</p></li><li><p>构建原生应用：<code>Flutter</code> 构建的应用程序是真正的 <code>iOS</code> 和 <code>Android</code> 应用程序，它会被编译成 <code>ARM</code> 或 <code>x86</code> 二进制代码，可以直接在设备上运行，不依赖于任何 <code>WebView</code>。</p></li><li><p>原生般的用户体验：<code>Flutter</code> 为 <code>Android</code> 和 <code>iOS</code> 提供了分别遵循 <code>Material</code> 和 <code>Cupertino</code> 设计语言的两套 <code>Widget</code>，它们完全用 <code>Dart</code> 实现，有着一致的行为和外观，细节也处理得非常好。最终给用户带来的就是与原生应用无异的体验。</p></li></ul></details><h3 id="❓flutter-的优缺点" tabindex="-1"><a class="header-anchor" href="#❓flutter-的优缺点" aria-hidden="true">#</a> ❓<code>Flutter</code> 的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>优点：</p><ul><li><p>高性能： <code>Flutter</code> 使用 <code>Dart</code> 语言开发，<code>Dart</code> 语言执行效率高，节省了不少性能；<code>Flutter</code> 引擎中有自己的图形渲染引擎，直接利用 <code>GPU</code> 进行渲染，因此图形渲染性能非常高，避免了 <code>JavaScript</code> 桥接层。</p></li><li><p>开发效率高：<code>Flutter</code> 支持热重载，进行小的更改可以在几秒内在设备或模拟器上看到效果。</p></li><li><p>良好的用户体验：<code>Flutter</code> 不需要借助第三方库也可以实现良好的界面体验。引入了自己的设计和交互模式，使 <code>UI</code> 设计在不同的平台上看起来很一致。</p></li><li><p>跨平台： 编写一套代码，即可在 <code>iOS</code> 和 <code>Android</code> 上运行。</p></li><li><p>强大的社区支持：虽然 <code>Flutter</code> 还相对较新，但由于它是由 <code>Google</code> 建立并支持，因此已经有了一个很大，积极的社区。</p></li></ul><p>缺点：</p><ul><li><p>编程语言：<code>Dart</code> 不如 <code>JavaScript</code> 那么流行，如果团队成员还不熟悉 <code>Dart</code> 的话，可能需要花一些时间去学。</p></li><li><p>类库生态：由于 <code>Flutter</code> 比 <code>React</code> 或者 <code>React Native</code> 等其他一些框架发布得晚，所以 <code>Flutter</code> 提供的开放源代码库和框架没有那么多。</p></li><li><p>包体积大小：<code>Flutter</code> 应用程序的基础大小相对较大，尽管团队正在努力进行优化，但是如果正在开发应该尽可能小的应用程序，这可能是需要考虑的因素。</p></li></ul></details><h3 id="❓flutter-的渲染原理" tabindex="-1"><a class="header-anchor" href="#❓flutter-的渲染原理" aria-hidden="true">#</a> ❓<code>Flutter</code> 的渲染原理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Flutter</code> 的应用程序界面渲染采用自下而上的方式，基于一个先进的 <code>2D</code> 渲染引擎（称为 <code>Skia</code>）来创建视觉效果，包括文本、形状和颜色等。</p></blockquote><p>渲染过程：</p><ul><li>启动时，<code>Flutter</code> 通过自身的高性能 <code>C++</code> 运行库加载并运行 <code>Dart</code> 代码。</li><li><code>Dart</code> 层采用声明式编程，这些声明（通常为在屏幕上显示的 <code>Widget</code>）全部保存在一个树状结构中，每当状态变化时，<code>Flutter</code> 都会创建一个新的 <code>Widget</code> 树。</li><li>当 <code>Widget</code> 树在 <code>Dart</code> 代码中有所更新，这些变化会转换为绘制命令。</li><li>渲染引擎会按照 <code>Widget</code> 树的层次顺序进行绘制，每一个 <code>Widget</code> 都会映射为 <code>Skia</code> 画笔操作来进行渲染。</li><li>最后生成的图像会在 <code>Flutter</code> 引擎中被组合在一起，并显示在设备的屏幕上。</li></ul></details><h3 id="❓flutter-中的各种-key" tabindex="-1"><a class="header-anchor" href="#❓flutter-中的各种-key" aria-hidden="true">#</a> ❓<code>Flutter</code> 中的各种 <code>Key</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Key</code> 在 <code>Flutter</code> 中被用于控制框架在更新 <code>Widget</code> 树时如何与旧的 <code>Widget</code> 进行匹配。</p></blockquote><p>🌰 一个无 <code>key</code> 的 <code>Widget</code> 列表，向列表的起始位置添加一个新的项目，会发现新的 <code>Widget</code> 实际上被渲染到了列表的最后一个项目的位置。这发生的原因就在于 <code>Flutter</code> 没有一个唯一的方式来确定新加入的 <code>Widget</code> 应该插入到列表的哪个位置。</p><ul><li><p><code>GlobalKey</code>: 在整个 <code>Widget</code> 树中保持一致，而且允许在树中的任何地方进行访问和操作。使用 <code>GlobalKey</code> 可以跨 <code>Widget</code> 访问状态，但是过度使用 <code>GlobalKey</code> 可能会导致性能问题。</p><blockquote><p>使用场景：</p><ul><li>保持状态：当 <code>Widget</code> 的状态需要跨多个 <code>Widget</code> 保持时，可以使用 <code>GlobalKey</code>。</li><li>导航参数传递：当需要向新的界面传递数据，或者从新界面获取数据，可以使用 <code>GlobalKey</code> 来实现。</li></ul></blockquote></li><li><p><code>LocalKey</code></p><ul><li><p><code>ValueKey</code>: 需要一个与当前 <code>Widget</code> 相关联的值，并且这个值在整个 <code>Widget</code> 树中是唯一的。常常用于比对。</p><blockquote><p>使用场景：在滚动的列表中，可能想要确保同类型的项在重建时能保持相同的状态。</p></blockquote></li><li><p><code>ObjectKey</code>: 使用一个对象的 <code>identity</code> 作为 <code>key</code>，在它所关联的对象的整个生命周期内保持一致。</p><blockquote><p>使用场景：在构建列表或表格时，可以用数据源中每个对象的索引作为 <code>ObjectKey</code>。这可以帮助框架区别列表中的不同元素，并在数据源更新时善加利用已有的 <code>Widget</code>。</p></blockquote></li><li><p><code>UniqueKey</code>: 在每次创建时都是全局唯一的，通常用来控制 “顺序无关” 的列表。通常用于改变现有 <code>Widget</code> 的状态。</p><blockquote><p>使用场景：如果有两个相同的 <code>Widget</code> 并想交换它们的位置，可以给它们分配 <code>UniqueKey</code>。当框架比较新老 <code>Widget</code> 时，它们的 <code>Key</code> 将不同，因此框架会交换两个 <code>Widget</code>。</p></blockquote></li></ul></li></ul></details><hr><h2 id="widget" tabindex="-1"><a class="header-anchor" href="#widget" aria-hidden="true">#</a> <code>Widget</code></h2><h3 id="❓listview-与-sliver-区别" tabindex="-1"><a class="header-anchor" href="#❓listview-与-sliver-区别" aria-hidden="true">#</a> ❓<code>ListView</code> 与 <code>Sliver</code> 区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ListView</code>: 一个常用的滚动列表控件，可以包含多个子控件并在垂直或水平方向滚动。</p><blockquote><p>最常用的长列表展示的控件，适用于大多数的滚动列表场景，例如新闻和社交应用里的信息流。</p></blockquote></li><li><p><code>Sliver</code>: 一种特殊类型的可滚动组件，在效果上可以实现更为复杂的滚动模型和高级效果。</p><blockquote><p>如折叠工具栏(<code>Collapsing Toolbar</code>)，或者在滚动时改变其他元素的布局。这些效果在 <code>ListView</code>中不能直接实现，需要使用 <code>Sliver Widget</code> 进行布局。</p></blockquote></li></ul><p>总结：<code>ListView</code>更简单直接，方便快速构建滚动列表；<code>Sliver</code>为开发者提供了更多的可能性和自由度，来构建高级和富交互的滚动效果，但使用和理解起来相对较复杂一些。</p></details><h3 id="❓inheritedwidget-作用" tabindex="-1"><a class="header-anchor" href="#❓inheritedwidget-作用" aria-hidden="true">#</a> ❓<code>InheritedWidget</code> 作用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>InheritedWidget</code>：<code>Flutter</code> 中一个非常重要的幕后角色，主要用于在 <code>Widget</code> 树中有效地传递数据。</p></blockquote><p>问题：<code>Flutter</code> 中 <code>Widget</code> 是不可变的，由于其自身不能改变，所以如果有任何数据更改，总是按照从上到下的方式重新构建所有的 <code>Widget</code>。然而这可能导致重绘的性能问题，特别是对于大型树状结构来说。</p><p>解决方案：<code>InheritedWidget</code> 则为这个问题提供了解决方案。它允许开发者在 <code>Widget</code> 树的顶部或任何位置提供数据，然后这些数据可以在树的任何下层都能获取到。当 <code>InheritedWidget</code> 更新时，它会通知使用其数据的所有 <code>Widget</code>，这些 <code>Widget</code> 只需通过 <code>BuildContext</code> 即可访问到这些数据，这个过程称为依赖。</p><p>作用：可以让开发者更高效地分享数据，避免了不必要的 <code>Widget</code> 重置，避免了一些性能问题，同时让 <code>Widget</code> 树的状态管理更加清晰和方便。</p><p>🌰 <code>Flutter</code> 的 <code>Theme</code> 和 <code>Locale</code> 就是通过 <code>InheritedWidget</code> 来传递的。</p></details><hr><h2 id="lifecycle-生命周期" tabindex="-1"><a class="header-anchor" href="#lifecycle-生命周期" aria-hidden="true">#</a> <code>lifecycle</code> - “生命周期”</h2><h3 id="❓flutter-的生命周期" tabindex="-1"><a class="header-anchor" href="#❓flutter-的生命周期" aria-hidden="true">#</a> ❓<code>Flutter</code> 的生命周期</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>应用级别的生命周期</p><ul><li><code>created</code>（应用程序启动）</li><li><code>running</code>（应用程序处于激活状态，界面可见）</li><li><code>paused</code>（应用程序处于非激活状态，界面不可见）</li><li><code>suspended</code>（应用程序被系统暂停）。</li></ul></li><li><p><code>Widget</code> 级别的生命周期</p><ul><li><code>createState()</code>: 创建状态，当构建一个新的 <code>StatefulWidget</code> 时，会立即调用此方法。</li><li><code>initState()</code>: 初始化，在创建 <code>State</code> 对象后调用，在整个生命周期中只会被调用一次。</li><li><code>didChangeDependencies()</code>: 状态改变时调用，可能会被多次调用。</li><li><code>build()</code>: 构建方法，用于构建UI界面，典型的Flutter函数式编程思维，可能会被多次调用。</li><li><code>didUpdateWidget()</code>: 当Widget中的配置改变时就会调用此函数。</li><li><code>deactivate()</code>: 移除时调用，当State对象从树中被移除时，会调用此方法。</li><li><code>dispose()</code>: 销毁时调用，当State对象永久从树中被移除时，Framework会调用此方法，常用于资源清理。</li></ul></li></ul></details><h3 id="❓flutter-didchangedependencies-哪些情况下会触发" tabindex="-1"><a class="header-anchor" href="#❓flutter-didchangedependencies-哪些情况下会触发" aria-hidden="true">#</a> ❓<code>Flutter</code> <code>didChangeDependencies()</code> 哪些情况下会触发</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>第一次构建 <code>Widget</code> 时: 在生命周期内，这是 <code>State</code> 对象第一次创建完后会调用的方法，当 <code>State</code> 对象的依赖发生变化后也会调用此方法。</p></li><li><p>调用 <code>initState</code> 后: 初始化状态后，系统总是马上调用 <code>didChangeDependencies</code> 函数。</p></li><li><p><code>InheritedWidget</code>改变时: 如果当前 <code>State</code> 对象依赖的 <code>InheritedWidget</code> 发生改变（即数据发生改变），会重新构建当前 <code>Widget</code>（即调用 <code>build</code> 方法），之前会调用 <code>didChangeDependencies</code> 方法。</p></li><li><p>使用 <code>Navigator.of(context)</code> 调用时: 如果 <code>Widget</code> 的构造函数引用了与它有关联关系的数据，一旦这些数据改变， <code>didChangeDependencies()</code> 就会被触发。</p></li><li><p>使用 <code>Theme.of(context)</code> 或 <code>MediaQuery.of(context)</code> 等类似方法时，它们内部使用 <code>InheritedWidget</code> 来共享数据，所以它们可能会改变，然后触发 <code>didChangeDependencies()</code>。</p></li></ul></details><hr><h2 id="state-状态管理" tabindex="-1"><a class="header-anchor" href="#state-状态管理" aria-hidden="true">#</a> <code>state</code> - “状态管理”</h2><h3 id="❓说一下什么是状态管理" tabindex="-1"><a class="header-anchor" href="#❓说一下什么是状态管理" aria-hidden="true">#</a> ❓说一下什么是状态管理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>状态管理：处理应用中数据改变以及数据如何影响应用界面的过程。在开发应用程序时，操作的是用户的交互行为，后台数据，以及应用向用户展示的视图，这些因素的改变都需要被适当地管理。数据管理和视图反馈的过程就是状态管理。</p></blockquote><p>为什么我们需要状态管理？</p><ul><li><p>在复杂的应用中，有些数据需要在很多页面中使用。使用全局的状态管理可以使应用保持同步，避免数据在各个页面之间产生不一致。</p></li><li><p>状态管理利于代码的结构清晰，具有可控性、可预测性。在大型项目中尤其重要，因为它有助于降低调试和理解代码的复杂性。</p></li><li><p>状态管理能提高渲染效率。在 <code>React</code> 或者 <code>Flutter</code> 这种声明式编程框架中，当本地状态发生变化时，会引起组件的重新渲染，而状态管理库通过维护一个单一的状态树，能够有选择性地通知某一部分的组件去更新，提高渲染效率。</p></li></ul></details><h3 id="❓provider-bloc-getx-区别" tabindex="-1"><a class="header-anchor" href="#❓provider-bloc-getx-区别" aria-hidden="true">#</a> ❓<code>Provider</code> <code>BLoc</code> <code>GetX</code> 区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Provider</code> 是业界并且 <code>Google</code> 官方推荐的状态管理库，它是基于 <code>InheritedWidget</code> 的数据流传递。它可以直接使用状态，状态变化自动通知其依赖组件进行刷新，使用简直且入门容易。</p></li><li><p><code>BLoC（Business Logic Component）</code> 是 <code>Google</code> 推出的一种应用程序架构设计模式。其核心概念是，通过使用 <code>Dart</code> 的<code>Stream</code> 将数据的输入输出抽象为 <code>Sink</code> 和 <code>Stream</code>，进行业务逻辑处理。<code>BLoC</code> 相比 <code>Provider</code> 更适合大型项目，可以实现更大程度的代码解耦。</p></li><li><p><code>GetX</code> 是来自社区的 <code>Flutter</code> 库，它不仅实现了状态管理，还提供了路由管理，依赖注入等功能。<code>GetX</code> 优势在于其简洁的 <code>API</code>、高效的性能以及对空安全的天然支持。</p></li></ul></details><h3 id="❓provider-实现原理" tabindex="-1"><a class="header-anchor" href="#❓provider-实现原理" aria-hidden="true">#</a> ❓<code>Provider</code> 实现原理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Provider</code> 是一种非常流行的状态管理工具。实现原理主要利用了 <code>Flutter</code> 中的 <code>InheritedWidget</code> 和 <code>ChangeNotifier</code>。</p></blockquote><ul><li><p><code>InheritedWidget</code>: 一个能在子 <code>Widget</code> 树中快速提供数据的 <code>Widget</code>，通过它可以实现数据在 <code>Widget</code> 树中的向下传递。</p></li><li><p><code>ChangeNotifier</code>: 可以将它理解为一个可以通知 <code>Flutter</code> <code>UI</code> 发生更新的方法，通常是它的模型发生改变、获得新数据或变为空的时候。当数据改变的时候，可以调用 <code>ChangeNotifier.notifyListeners()</code> 这样的话，所有的监听器（<code>UI</code>）会接收通知，进行对应的业务处理，比如刷新 <code>UI</code>。</p></li></ul><p>在使用 <code>Provider</code> 的时候，会创建一个继承自 <code>ChangeNotifier</code> 的数据模型，并把它提供给那些需要这些数据的 <code>Widget</code>。在需要接收数据的 <code>Widget</code> 中，使用 <code>Provider.of</code> 或者 <code>Consumer</code> 来接收数据。并且明确了当数据发送改变的时候是否需要 <code>Widget</code> 显示刷新。</p></details><h3 id="❓说一下-bloc-模式" tabindex="-1"><a class="header-anchor" href="#❓说一下-bloc-模式" aria-hidden="true">#</a> ❓说一下 <code>BLoC</code> 模式</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>BLoC</code>（Business Logic Component）是 <code>Google</code> 推出的一种应用程序架构设计模式。其核心概念是，将&quot;事件(<code>event</code>)&quot;流转换为&quot;状态(<code>state</code>)&quot;流。</p></blockquote><p>使用流程：</p><ul><li><p>定义事件（<code>Event</code>）：这些事件表示可以从用户界面发送到 <code>BLoC</code> 的各种操作</p><blockquote><p>例如用户的点击，拖动以及其他行为。</p></blockquote></li><li><p>定义状态（<code>State</code>）：这些状态表示 <code>BLoC</code> 在接收事件后可能处于的不同状态</p><blockquote><p>例如加载，成功，错误等。</p></blockquote></li><li><p>创建 <code>BLoC</code>： 生产状态(<code>state</code>)流，并消费事件(<code>event</code>)流。在 <code>BLoC</code> 内部，使用一个或多个 <code>Stream</code> 来表示状态，使用 <code>Sink</code> 来接收事件。<code>BLoC</code> 里面的业务逻辑就是将事件流转变为状态流。</p></li><li><p><code>UI</code> 中使用 <code>BLoC</code>：通常使用 <code>StreamBuilder</code> 和各种事件触发器如按钮点击，来连接 <code>BLoC</code> 和 <code>UI</code>。</p></li></ul><p>优点：可以将业务逻辑完全从 <code>UI</code> 层中分离出来，使得代码更加模块化并且易于测试。也提高了应用的响应性，因为它基于流，可以便捷地处理异步操作和各种事件。</p></details><h3 id="❓flutter-如何统一管理错误页面" tabindex="-1"><a class="header-anchor" href="#❓flutter-如何统一管理错误页面" aria-hidden="true">#</a> ❓<code>Flutter</code> 如何统一管理错误页面</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ErrorWidget.builder</code>：<code>Flutter</code> 框架级别的错误页面处理方法，所有的 <code>Widget</code> 错误都会走这里，但这里只会处理非 <code>debug</code> 模式(生产模式)下的错误。</p></li><li><p>使用 <code>FutureBuilder</code> 或 <code>StreamBuilder</code>：对于网络请求等异步操作产生的错误，通过 <code>builder</code> 属性中判断请求状态，如果发生错误，则展示错误页面。</p></li><li><p>使用 <code>Flutter</code> 的路由管理：针对特定的路由展示特殊的错误页面。比如当路由到某页面时，预加载数据发生错误，可以直接展示错误页面。</p></li><li><p>使用 <code>try-catch</code>：在可能发生异常的操作中使用 <code>try-catch</code>，如果捕获到异常就展示相应的错误页面。</p></li><li><p>自定义预期内的错误：如网络请求返回码非成功码，可以抛出自定义异常，然后在上层统一捕获并处理。</p></li><li><p>全局错误页面：可以通过设置 <code>Flutter</code> 的 <code>navigatorObservers</code>，当发生错误的时候，导航到特定的错误页面。</p></li></ul></details>',41);function a(r,u){return d(),o("div",null,[c(" more "),l])}const s=e(i,[["render",a],["__file","0x02.flutter.html.vue"]]);export{s as default};

import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as n,c as a,b as e,e as l,d as o,f as s}from"./app-rtVqrOTq.js";const c={},p=e("h2",{id:"plc",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#plc","aria-hidden":"true"},"#"),l(" PLC")],-1),h=e("blockquote",null,[e("p",null,"PLC : Programmable Logic Controller (可编程控制器)")],-1),u={href:"http://plc.baike.com/category-135700.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://www.crifan.com/summary_plc_detail_introduction/",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"ethercat",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#ethercat","aria-hidden":"true"},"#"),l(" EtherCAT")],-1),b=e("blockquote",null,[e("p",null,"EtherCAT : Control Automation Technology (以太网控制自动化技术) 是一个开放架构，以以太网为基础的现场总线系统。EtherCAT是确定性的工业以太网，最早是由德国的Beckhoff公司所研发。")],-1),f=e("blockquote",null,[e("p",null,"自动化对通信一般会要求较短的数据更新时间（或称为周期时间）、数据同步时的通信抖动量低，而且硬件的成本要低，EtherCAT开发的目的就是让以太网可以运用在自动化应用中。")],-1),S=e("h2",{id:"usb",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#usb","aria-hidden":"true"},"#"),l(" USB")],-1),U={href:"https://github.com/libusb/libusb",target:"_blank",rel:"noopener noreferrer"},B={href:"https://github.com/pyusb/pyusb",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/GavinAndre/UsbAccessoryDemo",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/myarrow/article/details/8484113",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.csdn.net/encourage2011/article/details/73265161",target:"_blank",rel:"noopener noreferrer"},A={href:"http://blog.sina.com.cn/s/blog_4513dde60102wxt4.html",target:"_blank",rel:"noopener noreferrer"},D=s("<blockquote><p>Concept</p></blockquote><ul><li><p>USB Host : 设备可以作为 USB 主机连接 USB 外围设备(如：U盘、键盘、鼠标...)</p></li><li><p>USB Slave : USB 外围设备, 被动响应</p></li><li><p>PC USB 接口 : USB Host Only</p></li><li><p>Phone USB 接口 : OTG(On The Go) , 同时支持 Host 和 Device 模式</p></li><li><p>VID : (Vendor ID) 供应商 ID。供应商向 USB 执行论坛申请，每个供应商的VID是唯一的。</p></li><li><p>PID : (Product ID) 产品识别码。由供应商自行决定。</p></li><li><p>HardwareID : 硬件唯一标识，根据 PID / VID 而生成的。</p></li><li><p>序列号 : 厂家固化到芯片中的信息而已。</p></li><li><p>GUIID : 标志你按照的设备是属于哪一类。</p></li><li><p>Device -&gt; configurations -&gt; interfaces -&gt; endpoint</p></li><li><p>Endpoint : 端点。位于 USB 设备或主机上的一个数据缓冲区，用来存放和发送 USB 的各种数据。每一个端点都有唯一的确定地址，有不同的传输特点(如：输入端点、输出端点、配置端点、批量传输端点)</p></li><li><p>Frame : 帧。时间概念，在 USB 中，一帧就是 1MS，它是一个独立的单元，包含了一系列的总线动作，USB 将一帧分为好几份，每一份中都是一个 USB 的传输动作。</p></li><li><p>上行 : 设备到主机</p></li><li><p>下行 : 主机到设备</p></li><li><p>USB 数据传输 : 串行总线，数据在总线上市一位一位传输，先传输低位数据，最后传输高位数据。对于多字节的数据传输，采用小端格式，先传输低字节数据，后传输高字节数据。</p></li><li><p>Packet : 包。USB 信息传输的基本单位，所有数据都是经过打包后在总线上传输的。包只能在帧内传输。</p></li><li><p>USB 传输类型</p><ul><li>控制传输 : Control Transfer <ul><li>Setup : 建立阶段，主机从 USB 设备获取配置信息，并设置设备的配置值。</li><li>Data : 数据阶段 <ul><li>控制读取 : 读取 USB 描述符。主机发送一个 IN 令牌信息包，设备将数据通过 DATA1/DATA0 数据信信报传给主机。</li><li>控制写入 : 对 USB 设备配置信息。主机发送一个 OUT 令牌信息包，设备发送 ACK 令牌表示正确接收，NAK 令牌表示忙碌，STALL 令牌表示发生错误。</li></ul></li><li>Status : 状态阶段，表示整个传输过程已完全结束。</li></ul></li><li>中断传输 : Interrupt Transfer</li><li>批量传输 : Bulk Transfer</li><li>同步传输 : Isochronous</li></ul></li><li><p>For IN Token</p><ul><li>ACK : 表示 Host 正确无误地接收到数据</li><li>NAK : 设备暂时不能反悔或接收数据(如：设备忙)</li><li>STALL : 只是设备永远停止，需要 Host 软件的干预 (如: 设备出错)</li></ul></li><li><p>For OUT Token</p><ul><li>ACK : Device 已经正确接收到数据包，通知 Host 可以按顺序发送下一个数据包</li><li>NAK : Device 已经正确接收到数据包，通知 Host 重传数据，由于 Device 临时状况 (如: buffer 满)</li><li>STALL : 指示 Device endpoint 已经停止，通知 Host 不再回传</li></ul></li></ul>",2);function T(C,I){const t=i("ExternalLinkIcon");return n(),a("div",null,[p,h,e("ul",null,[e("li",null,[e("a",u,[l("PLC 百科"),o(t)])]),e("li",null,[e("a",d,[l("PLC 详解"),o(t)])])]),_,b,f,S,e("ul",null,[e("li",null,[e("a",U,[l("libusb"),o(t)]),l(" : 跨平台 USB 硬件访问库")]),e("li",null,[e("a",B,[l("pyusb"),o(t)])]),e("li",null,[e("a",m,[l("UsbAccessoryDemo"),o(t)]),l(" : Android 使用 Usb Accessory 模式与 linux 下位机进行通信")]),e("li",null,[e("a",g,[l("USB协通讯议--深入理解"),o(t)])]),e("li",null,[e("a",k,[l("USB 2.0 协议中文注解"),o(t)])]),e("li",null,[e("a",A,[l("读PyUSB源码"),o(t)])])]),D])}const P=r(c,[["render",T],["__file","hardware.html.vue"]]);export{P as default};

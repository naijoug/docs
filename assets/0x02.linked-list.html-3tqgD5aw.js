import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as o,a as r,b as e,f as c}from"./app-BayOxrKR.js";const d={},n=e("blockquote",null,[e("p",null,"02 链表 (8)")],-1),h=c(`<h2 id="_2-1-移除重复节点" tabindex="-1"><a class="header-anchor" href="#_2-1-移除重复节点" aria-hidden="true">#</a> 2.1 移除重复节点</h2><blockquote><p>编写代码，移除未排序链表中的重复节点。</p></blockquote><p>进阶：如果不得使用临时缓冲区，该怎么解决？</p><h2 id="_2-2-返回倒数第k个节点" tabindex="-1"><a class="header-anchor" href="#_2-2-返回倒数第k个节点" aria-hidden="true">#</a> 2.2 返回倒数第k个节点</h2><blockquote><p>实现一种算法，找出单向链表中倒数第k个节点。</p></blockquote><h2 id="_2-3-删除中间节点" tabindex="-1"><a class="header-anchor" href="#_2-3-删除中间节点" aria-hidden="true">#</a> 2.3 删除中间节点</h2><blockquote><p>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。</p></blockquote><pre><code>示例：
    输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c
    结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f
</code></pre><h2 id="_2-4-分割链表" tabindex="-1"><a class="header-anchor" href="#_2-4-分割链表" aria-hidden="true">#</a> 2.4 分割链表</h2><blockquote><p>编写程序以x为基准分割链表，使得所有小于x的节点排在大于或等于x的节点之前。如果链表中包含x，x只需出现在小于x的元素之前（如下所示）。分割元素x只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p></blockquote><pre><code>示例：
    输入：3-&gt; 5-&gt; 8-&gt; 5-&gt; 10-&gt; 2-&gt; 1 [分节点为5]
    输出：3-&gt; 1-&gt; 2-&gt; 10-&gt; 5-&gt; 5-&gt; 8
</code></pre><h2 id="_2-5-链表求和" tabindex="-1"><a class="header-anchor" href="#_2-5-链表求和" aria-hidden="true">#</a> 2.5 链表求和</h2><blockquote><p>给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。</p></blockquote><pre><code>示例：
    输入：(7-&gt; 1-&gt; 6) + (5-&gt; 9-&gt; 2)，即617 + 295
    输出：2-&gt; 1-&gt; 9，即912
</code></pre><p>进阶：假设这些数位是正向存放的，请再做一遍。</p><pre><code>示例：
    输入：(6-&gt; 1-&gt; 7) + (2-&gt; 9-&gt; 5)，即617 + 295
    输出：9-&gt; 1-&gt; 2，即912
</code></pre><h2 id="_2-6-回文链表" tabindex="-1"><a class="header-anchor" href="#_2-6-回文链表" aria-hidden="true">#</a> 2.6 回文链表</h2><blockquote><p>编写一个函数，检查链表是否为回文。</p></blockquote><h2 id="_2-7-链表相交" tabindex="-1"><a class="header-anchor" href="#_2-7-链表相交" aria-hidden="true">#</a> 2.7 链表相交</h2><blockquote><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p></blockquote><h2 id="_2-8-环路检测" tabindex="-1"><a class="header-anchor" href="#_2-8-环路检测" aria-hidden="true">#</a> 2.8 环路检测</h2><blockquote><p>给定一个有环链表，实现一个算法返回环路的开头节点。有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p></blockquote><pre><code>示例：
    输入：A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; C（C节点出现了两次）
    输出：C
</code></pre>`,23);function i(l,g){return a(),o("div",null,[n,r(" more "),h])}const _=t(d,[["render",i],["__file","0x02.linked-list.html.vue"]]);export{_ as default};

import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c,f as t}from"./app-4FjOShZC.js";const d={},l=t('<h1 id="swift" tabindex="-1"><a class="header-anchor" href="#swift" aria-hidden="true">#</a> Swift</h1><blockquote><p><code>Swift</code> 中的 <code>String</code> 的设计理念</p></blockquote><p>支持 <code>Unicode</code> 和字符串操作的安全性。不能直接使用下标索引访问，使用 <code>String.Index</code> 进行字符串的访问和操作。</p><blockquote><p>值类型 vs 引用类型</p></blockquote><blockquote><p><code>Swift</code> 中基础类型 <code>Array</code>、<code>Dictionary</code>、<code>Set</code> 为什么设计成值类型？</p></blockquote><blockquote><p><code>cow</code>(Copy on Write)</p></blockquote><blockquote><p><code>inout</code> 关键字做了什么？</p></blockquote><blockquote><p><code>Swift</code> 中的闭包</p></blockquote><ul><li>逃逸闭包 : 闭包作为函数参数传入函数，如果这个闭包在函数返回之后再执行，则为逃逸闭包，闭包参数需要使用 <code>@escaping</code> 修饰。</li><li>非逃逸闭包 : 闭包作为函数参数，在函数返回之前，这个闭包已经执行，则为非逃逸闭包。</li><li>尾随闭包 : 将闭包作为函数的最后一个参数，函数调用时，闭包参数就是一个写在尾随函数调用后面的一个闭包表达式。</li><li>自动闭包 : 需要一个不接受参数的闭包作为函数参数，使用 <code>@autoclosure</code> 修饰。用作闭包表达式的延迟加载，只有当闭包表达式真正调用时才执行。</li></ul><blockquote><p><code>Optional</code> 可选类型的底层实现</p></blockquote><blockquote><p>面向协议编程</p></blockquote><blockquote><p><code>Sendable</code></p></blockquote><p><code>Swift 5.5</code> 引入并发模型之后添加的。</p>',13),i=[l];function p(u,n){return e(),c("div",null,i)}const s=o(d,[["render",p],["__file","swift.html.vue"]]);export{s as default};

import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,a as e,f as o}from"./app-KOLbvikU.js";const c={},t=o(`<h2 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配" aria-hidden="true">#</a> 内存分配</h2><h3 id="oc-中一个-nsobject-对象-占几个字节" tabindex="-1"><a class="header-anchor" href="#oc-中一个-nsobject-对象-占几个字节" aria-hidden="true">#</a> <code>OC</code> 中一个 <code>NSObject</code> 对象，占几个字节？</h3><p>一个 <code>NSObject</code> 对象应该就是存放这个对象的指针地址。一个指针的大小应该是占用 16 个直接。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Todo<span class="token punctuation">:</span> NSObject 
<span class="token punctuation">{</span>
   <span class="token keyword">int</span><span class="token punctuation">:</span> _no<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _title<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _detail<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="oc-中的-tagged-pointer-了解吗" tabindex="-1"><a class="header-anchor" href="#oc-中的-tagged-pointer-了解吗" aria-hidden="true">#</a> <code>OC</code> 中的 <code>Tagged Pointer</code> 了解吗？</h3><h3 id="如何使用-uiimageview-显示一个超大图片-并且支持缩放功能" tabindex="-1"><a class="header-anchor" href="#如何使用-uiimageview-显示一个超大图片-并且支持缩放功能" aria-hidden="true">#</a> 如何使用 <code>UIImageView</code> 显示一个超大图片，并且支持缩放功能？</h3><p>由于 <code>UIImageView</code> 通过 <code>UIImage</code> 加载图片，是一次性将图片加载到内存，超大图片会引发内存不足的的问题。所以这个时候不能一次全部加载，需要使用分治思想，将图片像素点分块加载，只加载可视区域像素点。使用 <code>Tile Rendering</code> 的解决方案，类似家庭装修贴地砖的方式，先将图片像素按照一定的大小分割成 <code>Tile</code>，然后根据图片显示区域渲染。<code>CATiledLayer</code> 是一种适用于处理大量数据的渲染的 layer，适合处理这种情况。 缩放功能可以通过将 <code>UIImageView</code> 嵌套在 <code>UIScrollView</code> 里面，根据缩放的代理回调，进行 <code>Tile</code> 的重新绘制。</p><h3 id="c-中-placement-new-特性-在-oc-中可以使用吗" tabindex="-1"><a class="header-anchor" href="#c-中-placement-new-特性-在-oc-中可以使用吗" aria-hidden="true">#</a> <code>C++</code> 中 <code>placement new</code> 特性，在 <code>OC</code> 中可以使用吗？</h3><p><code>placement new</code> : 是一种可以已分配内存的位置直接构造对象的特性，而这个已分配内存可以栈区也可以是堆区。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 栈内存</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 堆内存</span>
<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>OC</code> 是不具备这个特性，但是可以借助 <code>C</code> 语言分配内存。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// OC 常规方案</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Foo alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 C 分配内存</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>foo init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="找-bug" tabindex="-1"><a class="header-anchor" href="#找-bug" aria-hidden="true">#</a> “找 bug”</h3><blockquote><p>以下代码存在什么问题？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> INT_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Test alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>申请对象时，在 <code>ARC</code> 编译期间，会添加 <code>autorelease</code>，将申请的对象加入到自动释放池中。如果在一个自动释放池申请大量对象，那么对象的释放都需要等到这个这个自动释放所在的 <code>RunLoop</code> 休眠或结束时才能释放，申请大量对象时会造成内存泄漏。这种情况下，需要将 <code>@autoreleasepool</code> 加入到 <code>for</code> 循环里面。</p><blockquote><p>^ 如果将 <code>for</code> 循环改为 <code>enumerateObjectsUsingBlock</code> 会不会有问题？</p></blockquote><p>不会有问题，这是因为枚举器方法实现时，已经将 <code>block</code> 嵌套在 <code>@autoreleasepool</code> 中。</p><h2 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h2><h3 id="如果让你实现属性的-weak-如何实现的" tabindex="-1"><a class="header-anchor" href="#如果让你实现属性的-weak-如何实现的" aria-hidden="true">#</a> 如果让你实现属性的 <code>weak</code>，如何实现的？</h3><h3 id="什么情况下需要手动创建-autoreleasepool" tabindex="-1"><a class="header-anchor" href="#什么情况下需要手动创建-autoreleasepool" aria-hidden="true">#</a> 什么情况下需要手动创建 <code>autoreleasepool</code> ？</h3><h2 id="内存分析" tabindex="-1"><a class="header-anchor" href="#内存分析" aria-hidden="true">#</a> 内存分析</h2><h3 id="app-内存是如何分析的" tabindex="-1"><a class="header-anchor" href="#app-内存是如何分析的" aria-hidden="true">#</a> app 内存是如何分析的？</h3><h3 id="内存泄漏可能会出现的几种原因" tabindex="-1"><a class="header-anchor" href="#内存泄漏可能会出现的几种原因" aria-hidden="true">#</a> 内存泄漏可能会出现的几种原因？</h3><blockquote><p>非 <code>OC</code> 对象如何处理？</p></blockquote><blockquote><p>如果常用框架出现内存泄漏如何处理？</p></blockquote>`,26);function p(i,l){return a(),s("div",null,[e(" more "),t])}const r=n(c,[["render",p],["__file","memory.html.vue"]]);export{r as default};

import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as t,a as d,b as e,f as r}from"./app-enJ7wihl.js";const c={},n=e("blockquote",null,[e("p",null,"04 树 & 图 (12)")],-1),h=r(`<h2 id="_4-1-节点间通路" tabindex="-1"><a class="header-anchor" href="#_4-1-节点间通路" aria-hidden="true">#</a> 4.1 节点间通路</h2><blockquote><p>给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p></blockquote><h2 id="_4-2-最小高度树" tabindex="-1"><a class="header-anchor" href="#_4-2-最小高度树" aria-hidden="true">#</a> 4.2 最小高度树</h2><blockquote><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p></blockquote><h2 id="_4-3-特定深度节点链表" tabindex="-1"><a class="header-anchor" href="#_4-3-特定深度节点链表" aria-hidden="true">#</a> 4.3 特定深度节点链表</h2><blockquote><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</p></blockquote><h2 id="_4-4-检查平衡性" tabindex="-1"><a class="header-anchor" href="#_4-4-检查平衡性" aria-hidden="true">#</a> 4.4 检查平衡性</h2><blockquote><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。</p></blockquote><h2 id="_4-5-合法二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_4-5-合法二叉搜索树" aria-hidden="true">#</a> 4.5 合法二叉搜索树</h2><blockquote><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p></blockquote><h2 id="_4-6-后继者" tabindex="-1"><a class="header-anchor" href="#_4-6-后继者" aria-hidden="true">#</a> 4.6 后继者</h2><blockquote><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。可以假定每个节点都含有指向父节点的连接。</p></blockquote><h2 id="_4-7-编译顺序" tabindex="-1"><a class="header-anchor" href="#_4-7-编译顺序" aria-hidden="true">#</a> 4.7 编译顺序</h2><blockquote><p>给你一系列项目（projects）和一系列依赖关系（依赖关系dependencies为一个链表，其中每个元素为两个项目的编组，且第二个项目依赖于第一个项目）。所有项目的依赖项必须在该项目被编译前编译。请找出可以使得所有项目顺利编译的顺序。如果没有合法的编译顺序，返回错误。</p></blockquote><pre><code>示例：
    输入：
        projects: a, b, c, d, e, f
        dependencies: (a, d), (f, b), (b, d), (f, a), (d, c)
    输出：
        f, e, a, b, d, c
</code></pre><h2 id="_4-8-首个共同祖先" tabindex="-1"><a class="header-anchor" href="#_4-8-首个共同祖先" aria-hidden="true">#</a> 4.8 首个共同祖先</h2><blockquote><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p></blockquote><h2 id="_4-9-二叉搜索树序列" tabindex="-1"><a class="header-anchor" href="#_4-9-二叉搜索树序列" aria-hidden="true">#</a> 4.9 二叉搜索树序列</h2><blockquote><p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。</p></blockquote><pre><code>示例：
    输入:
         2
        /  \\
       1    3
    输出: 
        {2, 1, 3}, {2, 3, 1}
</code></pre><h2 id="_4-10-检查子树" tabindex="-1"><a class="header-anchor" href="#_4-10-检查子树" aria-hidden="true">#</a> 4.10 检查子树</h2><blockquote><p>你有两棵非常大的二叉树：T1，有几百万个节点；T2，有几百个节点。设计一个算法，判断T2是否为T1的子树。如果T1有这么一个节点n，其子树与T2一模一样，则T2为T1的子树，也就是说，从节点n处把树砍断，得到的树与T2完全相同。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">提示</p><p>#4，#11，#18，#31，#37</p></div><h2 id="_4-11-随机节点" tabindex="-1"><a class="header-anchor" href="#_4-11-随机节点" aria-hidden="true">#</a> 4.11 随机节点</h2><blockquote><p>你现在要从头开始实现一个二叉树类，该类除了插入（insert）、查找（find）和删除（delete）方法外，需要实现getRandomNode()方法用于返回树中的任意节点。该方法应该以相同的概率选择任意的节点。设计并实现getRandomNode方法并解释如何实现其他方法。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">提示</p><p>#42，#54，#62，#75，#89，#99，#112，#119</p></div><h2 id="_4-12-求和路径" tabindex="-1"><a class="header-anchor" href="#_4-12-求和路径" aria-hidden="true">#</a> 4.12 求和路径</h2><blockquote><p>给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。</p></blockquote>`,28);function i(l,s){return o(),t("div",null,[n,d(" more "),h])}const b=a(c,[["render",i],["__file","0x04.tree-graph.html.vue"]]);export{b as default};

import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as a,a as n,f as o}from"./app-engARqLh.js";const d={},c=o(`<h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h2><h3 id="❓数据库的三大范式" tabindex="-1"><a class="header-anchor" href="#❓数据库的三大范式" aria-hidden="true">#</a> ❓数据库的三大范式</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>数据库的三大范式，是数据库设计的基础理论，主要是为了解决数据冗余以及提高数据一致性和完整性。</p></blockquote><ul><li><p>第一范式(<code>1NF</code>)：具有原子性。要求数据库表的每一列都是不可分割的原子数据项，也就是说一个字段只能保存一种数据，不能像 <code>Excel</code> 那样在一个单元格里保存多个数据。</p></li><li><p>第二范式(<code>2NF</code>)：满足完全函数依赖。首先必须满足第一范式。其次，如果数据库表中有组合主键，要求非主键列必须完全依赖于全部主键，而不是部分主键。</p></li><li><p>第三范式(<code>3NF</code>)：消除传递依赖。首先必须满足第二范式。其次，非主属性必须直接依赖于主关键字，即如果诸如 <code>X -&gt; Y, Y -&gt; Z</code> 的关系，说明 <code>Z</code> 依赖于 <code>X</code>，那么在 <code>3NF</code> 中，<code>Z</code> 只能直接依赖于 <code>X</code>，而不能通过 <code>Y</code> 传递依赖。</p></li></ul><p>注：这三种范式是设计关系数据库表结构的基础理论，但是在实际工程设计中，为了追求更高的查询性能，通常会适当降低范式标准，引入一定的数据冗余。</p></details><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="❓数据库建表的时候索引有什么用" tabindex="-1"><a class="header-anchor" href="#❓数据库建表的时候索引有什么用" aria-hidden="true">#</a> ❓数据库建表的时候索引有什么用</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>索引是数据库中用于加速数据查询的数据结构。</p></blockquote><ul><li><p>提升查询性能：通过创建索引，数据库可以高效地查找、排序和连接表中的行。当对表进行查询时，如果没有索引，数据库需要遍历整个表（全表扫描）才能找到需要的数据，这将消耗大量的处理器和磁盘资源。但是如果有了索引，数据库在查找数据的时候就像在字典中查找单词那样快速，极大地提高了查询效率。</p></li><li><p>加速排序和分组操作：索引对于加快排序和行分组操作也很有用，因为在索引中的数据已经按照一定的顺序进行了排序，所以数据库可以利用这一特性加速这些操作。</p></li><li><p>保证数据的唯一性：通过在字段上创建唯一索引，可以确保整个表或某一列的数据的唯一性。</p></li><li><p>帮助服务器避免排序和临时表：在存在合适索引的情况下，<code>MySQL</code> 可以使用索引来找到数据，而无需进行排序和临时表的操作。</p></li><li><p>将随机 <code>IO</code> 变为顺序 <code>IO</code>：索引通常以 <code>B-Tree</code>（平衡多路查找树）或相关数据结构存储，这使得数据读取更趋近于顺序，而顺序 <code>IO</code> 相比随机 <code>IO</code> 拥有更好的性能。</p></li></ul><p>注意：虽然索引可以大大提高查询性能，但创建和维护索引也需要时间和存储空间，且过多不必要的索引会影响数据的插入、删除和更新操作的性能。因此，开发者需要根据实际的数据库使用情况设计和选择合适的索引。</p></details><h3 id="❓数据库索引的优缺点" tabindex="-1"><a class="header-anchor" href="#❓数据库索引的优缺点" aria-hidden="true">#</a> ❓数据库索引的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>索引的作用:</p><ul><li><p>提高查询效率: 索引的第一个并且是最重要的作用就是可以极大的提高数据的查询效率，这也是索引最初被设计出来的主要目的。</p></li><li><p>加速排序分组操作: <code>SQL</code> 语句在进行排序（<code>ORDER BY</code>）和分组（<code>GROUP BY</code>）等操作时，如果对应的字段建立了索引，那么效率会快很多。</p></li><li><p>提高表连接速度: 对于多表查询（<code>join</code>）语句，如果没有索引，那么每个表都会被执行一次全表扫描，所以数据量大的时候查询效率非常低。但如果建立了足够的索引，查询效果就会有明显提高。</p></li><li><p>强制数据的唯一性和完整性: 创建唯一性索引，可以保证数据库表中每一行数据的唯一性。也可以作为主键约束的一部分，确保主键的唯一性和完整性。</p></li></ul><p>索引的优点:</p><ul><li><p>所有的索引，包括与之相对的表，保持在物理上的有序，可以提升查询速度。</p></li><li><p>通过索引，我们可以在查询时使用优化隐藏器，借此改变数据读取的次数，获得更好的读取性能。</p></li><li><p>索引在任何时候都保持着与之相对的表同步。</p></li></ul><p>索引的缺点:</p><ul><li><p>索引需要占物理和数据存储空间，除了数据表空间，索引也需要占用一定的物理存储空间。如果数据表中需要建立的索引过多，索引文件可能会占用更多的存储空间。</p></li><li><p>索引不仅需要存储空间，还会影响数据库的性能。在插入和修改数据时，索引需要动态维护，这会消耗大量的系统资源，如 <code>CPU</code> 和 <code>IO</code>，并会对数据库的性能产生影响。而且，太多的索引也会使数据库在进行索引选择时消耗更多的时间。</p></li><li><p>虽然索引大大提高了查询速度，同时也降低了更新表的速度，如对表进行<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>。因为更新表时， <code>MySQL</code> 不仅要保存数据，还要保存一下索引文件。</p></li><li><p>索引可能导致数据重复，如果在一个大的表中创建了许多索引，这将需要更多的磁盘空间，并且可能产生大量的重复数据。</p></li></ul></details><hr><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><h3 id="join" tabindex="-1"><a class="header-anchor" href="#join" aria-hidden="true">#</a> join</h3><h4 id="sql-中-join-常见用法" tabindex="-1"><a class="header-anchor" href="#sql-中-join-常见用法" aria-hidden="true">#</a> <code>SQL</code> 中 <code>join</code> 常见用法</h4><details class="hint-container details"><summary>💡</summary><blockquote><p>在 <code>SQL</code> 中，<code>JOIN</code> 子句用于将一个或多个表的记录组合在一起。</p></blockquote><ul><li><p><code>INNER JOIN</code>：返回两个表中具有匹配值的记录。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName 
<span class="token keyword">FROM</span> Orders
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Customers <span class="token keyword">ON</span> Orders<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>LEFT JOIN</code>（或 <code>LEFT OUTER JOIN</code>）：返回左表中的所有记录，以及右表中的匹配记录。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>RIGHT JOIN</code>（或 <code>RIGHT OUTER JOIN</code>）：返回右表中的所有记录，以及左表中的匹配记录。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Orders<span class="token punctuation">.</span>OrderID<span class="token punctuation">,</span> Customers<span class="token punctuation">.</span>CustomerName 
<span class="token keyword">FROM</span> Orders
<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Customers <span class="token keyword">ON</span> Orders<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Customers<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>FULL JOIN</code>（或 <code>FULL OUTER JOIN</code>）：返回左表和右表中的所有记录。如果有匹配的值，则返回匹配的值。如果没有匹配的记录，则结果是 <code>NULL</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>CROSS JOIN</code>: 完全依赖采用笛卡尔积算法来返回列的所有可能组合。 即每一个左表中的记录与右表中的每一个记录都相结合。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Products<span class="token punctuation">.</span>ProductName 
<span class="token keyword">FROM</span> Customers
<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> Products<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>SELF JOIN</code>: 用于将一个表与自身联接。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>CustomerName <span class="token keyword">AS</span> CustomerName1<span class="token punctuation">,</span> B<span class="token punctuation">.</span>CustomerName <span class="token keyword">AS</span> CustomerName2
<span class="token keyword">FROM</span> Customers A<span class="token punctuation">,</span> Customers B
<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span>CustomerID <span class="token operator">&lt;&gt;</span> B<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h4 id="❓sql-中的连表查询-left-join-与-right-join-的区别" tabindex="-1"><a class="header-anchor" href="#❓sql-中的连表查询-left-join-与-right-join-的区别" aria-hidden="true">#</a> ❓<code>SQL</code> 中的连表查询 <code>left join</code> 与 <code>right join</code> 的区别</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 是 SQL 中的两种连接（join）类型，它们都用于合并表中的行。</p></blockquote><p>主要区别：在于合并后结果集中包含哪些行。</p><ul><li><p><code>LEFT JOIN</code>：返回左表中的所有行，以及右表中与左表匹配的行。如果左表中的某行在右表中没有匹配行，则结果集中这一行的右表部分将包含 <code>NULL</code>。</p></li><li><p><code>RIGHT JOIN</code>：返回右表中的所有行，以及左表中与右表匹配的行。如果右表中的某行在左表中没有匹配行，则结果集中这一行的左表部分将包含 <code>NULL</code>。</p></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>? <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> : 左连
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span>

? <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> : 右连
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓sqlite-中的读写是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#❓sqlite-中的读写是线程安全的吗" aria-hidden="true">#</a> ❓<code>sqlite</code> 中的读写是线程安全的吗</h3><details class="hint-container details"><summary>💡</summary><p><code>SQLite</code> 本身支持多线程访问，但是线程安全性取决于在编译 <code>SQLite</code> 库时的设置。</p><p>配置选项：</p><ul><li><p><code>SQLITE_THREADSAFE=0</code> : 在非线程安全模式时，它不允许多线程访问，某些线程安全的假设就无法保证了。</p></li><li><p><code>SQLITE_THREADSAFE=1</code> : 在多线程模式下，可以被多个线程同时安全访问，但是每个线程都需要使用一个不同的数据库连接。</p></li><li><p><code>SQLITE_THREADSAFE=2</code> : 在序列化模式下，可以被多个线程同时使用，并且一个数据库连接也能在多个线程之间共享。</p></li></ul></details><hr><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2><h3 id="❓大量数据表的优化方案" tabindex="-1"><a class="header-anchor" href="#❓大量数据表的优化方案" aria-hidden="true">#</a> ❓大量数据表的优化方案</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>合理的表设计：清晰合理的表设计是高效数据库的基础。这包括合理的使用数据类型，避免过多列，规范化数据库等。</p></li><li><p>创建和使用索引：为常用查询列和 <code>join</code> 操作列创建索引可以大大提高数据库查询效率。在创建索引时要平衡查询效率和更新维护成本，避免过度索引。</p></li><li><p>数据分区：数据分区是一种将表的一部分行存储到独立的硬盘上的方式。通过数据分区，可以提高查询性能和管理便利性。</p></li><li><p>数据归档和清理：对于老旧和罕用的数据可以定期归档并从主数据库中删除，这样可以节省大量存储空间并提高整体性能。</p></li><li><p>使用缓存：使用缓存可以大大提高数据读取效率。对于查询结果集不常变动但访问频繁的数据可以缓存在内存中。</p></li><li><p><code>SQL</code> 查询优化：写出高效的 <code>SQL</code> 语句也很重要，尽量减少全表扫描，利用好索引等。</p></li><li><p>使用读写分离：在大数据量的情况下，一个数据库服务器可能无法同时处理大量的读和写请求。读写分离可以将读和写请求分散到不同的服务器，提高处理能力。</p></li><li><p>数据库表水平拆分：当单表数据量过大时，通过水平拆分可以将数据分散到多个物理表里，提高数据读写效率。</p></li></ul></details>`,21);function l(p,i){return e(),a("div",null,[n(" more "),c])}const u=s(d,[["render",l],["__file","0x06.database.html.vue"]]);export{u as default};

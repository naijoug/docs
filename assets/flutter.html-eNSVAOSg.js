import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,a as d,f as t}from"./app-nOqLU-Iw.js";const l={},a=t('<h2 id="flutter" tabindex="-1"><a class="header-anchor" href="#flutter" aria-hidden="true">#</a> <code>Flutter</code></h2><blockquote><p>命令式 <code>UI</code> vs 声明式 <code>UI</code></p></blockquote><ul><li>命令式 : 告诉程序一步一步如何搭建我所需要的界面，类似做菜的教程</li><li>声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单</li></ul><blockquote><p><code>Widget</code> <code>Element</code> <code>RenderObject</code> 之间的关系？</p></blockquote><p><code>Flutter</code> 的三棵树，代表了使用树的数据结构构成的三种元素。</p><ul><li><code>Widget</code> 树，可以理解为对 <code>UI</code> 的一些配置。</li><li><code>Element</code> 树，这个是真正进行 <code>UI</code> 元素。</li><li><code>RenderObject</code> 树，代表渲染树</li></ul><blockquote><p><code>Flutter</code> 跨平台是如何实现的？</p></blockquote><p><code>Flutter</code> 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。</p><ul><li>界面渲染 : <code>Skia</code> 绘制引擎进行视图的统一渲染</li><li>原生通信 : 通过 <code>Channel</code> 机制进行与原生进行交互 <ul><li><code>BasicMessageChannel</code> : 用于基本的字符串信息通信</li><li><code>MethodChannel</code> : 方法调用通信</li><li><code>EventChannel</code> : 数据流通信</li></ul></li></ul><blockquote><p><code>Flutter</code> 与 <code>RN</code> (<code>React Native</code>) 不同之处？</p></blockquote><blockquote><p>为什么说 <code>Flutter</code> 是原生的？</p></blockquote><blockquote><p><code>Flutter</code> 的优缺点?</p></blockquote><blockquote><p><code>Flutter</code> 的渲染原理？</p></blockquote><h2 id="widget" tabindex="-1"><a class="header-anchor" href="#widget" aria-hidden="true">#</a> <code>Widget</code></h2><blockquote><p><code>ListView</code> 与 <code>Sliver</code> 区别</p></blockquote><blockquote><p><code>InheritedWidget</code> 作用</p></blockquote><h2 id="lifecycle-生命周期" tabindex="-1"><a class="header-anchor" href="#lifecycle-生命周期" aria-hidden="true">#</a> <code>lifecycle</code> - “生命周期”</h2><blockquote><p><code>Flutter</code> 的生命周期？</p></blockquote><ul><li><code>StatelessWidget</code> : <code>build</code></li><li><code>StatefulWidget</code> : <code>initState</code> -&gt; ``</li></ul><h2 id="state-状态管理" tabindex="-1"><a class="header-anchor" href="#state-状态管理" aria-hidden="true">#</a> <code>state</code> - “状态管理”</h2><blockquote><p><code>Provider</code> <code>BLoc</code> <code>GetX</code> 区别</p></blockquote><h2 id="aot-vs-jit" tabindex="-1"><a class="header-anchor" href="#aot-vs-jit" aria-hidden="true">#</a> <code>AOT</code> vs <code>JIT</code></h2><ul><li>AOT(Ahead Of Time) : 提前编译或运行前编译，程序运行前已经编译成对应平台的机器码，可以直接运行。</li><li>JIT(Just In Time) : 即时编译或运行时编译，程序运行时编译成运行平台的机器码，提高运行效率。</li></ul><h2 id="hot-reload-热重载" tabindex="-1"><a class="header-anchor" href="#hot-reload-热重载" aria-hidden="true">#</a> <code>hot reload</code> - “热重载”</h2><blockquote><p><code>hot reload</code>(热重载)、<code>hot restart</code>(热重启)、<code>hot update</code>(热更新)？</p></blockquote><blockquote><p><code>Flutter</code> 是如何实现热重载的？</p></blockquote><h2 id="thread-线程模型" tabindex="-1"><a class="header-anchor" href="#thread-线程模型" aria-hidden="true">#</a> <code>thread</code> - “线程模型”</h2><blockquote><p><code>Future</code> 与 <code>microtask</code> 两者的执行顺序</p></blockquote><h2 id="memory-内存管理" tabindex="-1"><a class="header-anchor" href="#memory-内存管理" aria-hidden="true">#</a> <code>memory</code> - “内存管理”</h2><blockquote><p><code>Flutter</code> 的内存管理</p></blockquote><h2 id="optimization-优化" tabindex="-1"><a class="header-anchor" href="#optimization-优化" aria-hidden="true">#</a> <code>optimization</code> - “优化”</h2><blockquote><p><code>Flutter</code> 列表优化方案？</p></blockquote><blockquote><p><code>Flutter</code> 包体积如何优化？</p></blockquote><p>包体积的优化说到底就是包里面所含有资源的优化，主要包含两类文件一类是资源文件，另一个类是二进制文件。</p><ul><li>资源文件的优化: 图片的压缩，bundle 优化，无用资源的移除，资源的动态下发</li><li>二进制文件优化: 无用代码的移除；减少第三方的依赖；编译优化，主要有编译参数相关，以及底层编译生成产物优化，需要去进行底层研究对一些无用功能的裁剪。</li></ul><blockquote><p><code>Flutter</code> 渲染优化方案？</p></blockquote><p>渲染优化来说主要涉及两个方面，其一是首次加载的渲染，其二是 <code>StatefulWidget</code> 状态改变时页面的重建渲染。</p><ul><li>首次渲染方面: 构建 <code>Widget</code> 时应该合理搭建，减少复杂度；能使用 <code>const</code> 的地方尽量使用</li><li>重建渲染方面: 尽量减少状态改变引起重建区域；减少 <code>saveLayer()</code>的触发</li></ul><p>触发 <code>saveLayer()</code> * ShaderMask * ColorFilter * Chip &amp; <code>disabledColorAlpha != 0xff</code> * Text &amp; <code>overflowShader</code></p>',39);function i(r,u){return o(),c("div",null,[d(" more "),a])}const p=e(l,[["render",i],["__file","flutter.html.vue"]]);export{p as default};

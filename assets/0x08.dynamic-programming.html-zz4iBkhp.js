const t=JSON.parse('{"key":"v-6986ba88","path":"/programmer/core/algorithm/0x08.dynamic-programming.html","title":"Dynamic Programming - “动态规划”","lang":"zh-CN","frontmatter":{"title":"Dynamic Programming - “动态规划”","icon":"hashtag","index":true,"description":"动态规划的特点 最优子结构 : 最优解是否可以通过子问题的最优解来计算得到，而子问题可以通过更小的最优解来得到。; 重叠子问题 : 解决每个子问题时，是否会遇到相同的子问题。可以使用缓存子问题结果(DP 表)，避免重复计算，提高算法效率。; 状态转移方程 : 当前状态是否可以使用子问题的状态描述。; 动态规划求解方向 自顶向下 (Top-Down) :...","head":[["meta",{"property":"og:url","content":"https://naijoug.github.io/docs/docs/programmer/core/algorithm/0x08.dynamic-programming.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"Dynamic Programming - “动态规划”"}],["meta",{"property":"og:description","content":"动态规划的特点 最优子结构 : 最优解是否可以通过子问题的最优解来计算得到，而子问题可以通过更小的最优解来得到。; 重叠子问题 : 解决每个子问题时，是否会遇到相同的子问题。可以使用缓存子问题结果(DP 表)，避免重复计算，提高算法效率。; 状态转移方程 : 当前状态是否可以使用子问题的状态描述。; 动态规划求解方向 自顶向下 (Top-Down) :..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-10T13:19:23.000Z"}],["meta",{"property":"article:author","content":"naijoug"}],["meta",{"property":"article:modified_time","content":"2024-01-10T13:19:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dynamic Programming - “动态规划”\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-10T13:19:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"naijoug\\",\\"url\\":\\"https://github.com/naijoug\\"}]}"]]},"headers":[{"level":2,"title":"入门","slug":"入门","link":"#入门","children":[]}],"git":{"createdTime":1704674111000,"updatedTime":1704892763000,"contributors":[{"name":"naijoug","email":"naijoug@outlook.com","commits":4}]},"readingTime":{"minutes":0.69,"words":207},"filePathRelative":"programmer/core/algorithm/0x08.dynamic-programming.md","localizedDate":"2024年1月8日","autoDesc":true}');export{t as data};

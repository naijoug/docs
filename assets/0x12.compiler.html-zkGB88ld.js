import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as a,o as n,c as s,a as l,b as e,e as o,d,f as t}from"./app-tIn8wIjG.js";const p={},r=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),o(" reference")],-1),u={href:"https://juejin.cn/post/6844904200493596680",target:"_blank",rel:"noopener noreferrer"},h={href:"https://juejin.cn/post/6844903912143585288",target:"_blank",rel:"noopener noreferrer"},m=t(`<hr><h2 id="调试" tabindex="-1"><a class="header-anchor" href="#调试" aria-hidden="true">#</a> 调试</h2><h3 id="❓lldb-gdb-常用的调试命令" tabindex="-1"><a class="header-anchor" href="#❓lldb-gdb-常用的调试命令" aria-hidden="true">#</a> ❓<code>lldb (gdb)</code> 常用的调试命令</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>lldb</code>是一个使用 <code>C++</code> 编写的调试工具，用于解决运行在 <code>Apple</code> 平台上的代码问题。</p></blockquote><p>常用的<code>lldb</code>调试命令：</p><ul><li><p>断点调试</p><ul><li><p><strong>watchpoint set variable (w s v)</strong>: 开始监视特定变量的值，当其值改变时，执行会停止。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>w s <span class="token function">v</span> myVariable
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>breakpoint set (br s)</strong>: 设置断点。可以根据函数名、文件名和行号、或者地址设置断点。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>br s <span class="token parameter variable">-n</span> functionName
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>breakpoint delete (br del)</strong>: 删除断点。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>br del <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>continue (c)</strong>: 从当前位置继续执行代码。</p></li><li><p><strong>step over (n)</strong>: 单步执行代码，但是会跳过函数或方法的内部。</p></li><li><p><strong>step into (s)</strong>: 单步执行代码，如果当前行是一个函数或方法，会跳转到它的内部。</p></li><li><p><strong>step out (finish)</strong>: 如果当前位置是在一个函数或方法的内部，单步执行代码直到返回到父级。</p></li></ul></li><li><p>堆栈信息</p><ul><li><p><strong>thread backtrace (bt)</strong>: 显示当前线程的堆栈信息。</p></li><li><p><strong>thread return (th r)</strong>: 返回到上层的线程。</p></li><li><p><strong>frame variable (fr v)</strong>: 显示当前栈帧下的所有变量。</p></li><li><p><strong>frame select (fr s)</strong>: 切换到指定的栈帧。</p></li><li><p><strong>expression (e)</strong>: 在当前栈帧下执行指定的代码，例如修改变量的值，或者执行方法等。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>e self.view.backgroundColor <span class="token operator">=</span> <span class="token punctuation">[</span>UIColor redColor<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>其它命令</p><ul><li><strong>list (l)</strong>: 列出源代码。</li><li><strong>process interrupt (pro int)</strong>: 暂停正在运行的进程。</li></ul></li></ul></details><hr><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><h3 id="❓项目采用-64-位-为什么要用-64-位-怎么修改成-64-位-i386-是什么" tabindex="-1"><a class="header-anchor" href="#❓项目采用-64-位-为什么要用-64-位-怎么修改成-64-位-i386-是什么" aria-hidden="true">#</a> ❓项目采用 <code>64</code> 位，为什么要用 64 位，怎么修改成 <code>64</code> 位，<code>i386</code> 是什么</h3><details class="hint-container details"><summary>💡</summary><p>首先，64位架构的主要优势是它可以使用更多的内存（达到18.4百万TB），而32位系统只能支持到4GB内存。其次，64位架构的处理器还可以处理更多的数据，也就是说 CPU 一次可以读取、处理和传输的数据位数更多，因此性能更强。</p><p>在 iOS 开发中，从 2015 年 2 月 1 日开始，App Store 要求所有新提交的应用和应用更新都需要支持 64 位。也就是说，应用必须同时支持 32 位和 64 位架构。这是因为从 iPhone 5s 开始，所有的 iPhone、iPad 和 iPod touch 都已经转为采用 64 位架构的处理器。</p><p>在 Xcode 中，你可以修改项目的“Build Settings”来指定项目的架构（Target -&gt; Build Settings -&gt; Architectures）。在这里，你应该选择 &quot;Standard Architectures&quot; 来让你的应用同时支持 armv7（32位）、armv7s（32位, iPhone 5以上）、arm64（64位）。</p><p>i386 是 Intel 开发的一种 32 位微处理器架构，同时也是一种指令集架构。在 iOS 开发中，i386 通常用于指代运行在 32 位模拟器上的架构。与之对应的是 x86_64，代表 64 位模拟器的架构。</p></details><hr><h2 id="编译器" tabindex="-1"><a class="header-anchor" href="#编译器" aria-hidden="true">#</a> 编译器</h2><h3 id="❓编译链接了解多少" tabindex="-1"><a class="header-anchor" href="#❓编译链接了解多少" aria-hidden="true">#</a> ❓编译链接了解多少</h3><details class="hint-container details"><summary>💡</summary><p>编译和链接是程序从源代码到可执行文件的两个重要步骤。</p><p>编译主要进行预处理、词法分析、语法分析、语义分析和优化等步骤，完成了源代码语法、语义的检查和优化，生成可被计算机基本理解的中间语言文件，例如C语言的.obj文件。</p><p>链接则是将编译过程中生成的一个或多个中间代码文件以及库文件进行合并，生成可执行文件。链接主要分为静态链接和动态链接两种：</p><ol><li><p>静态链接：链接过程在编译后一次性完成，生成的可执行文件可以独立执行，不依赖任何外部的库文件。</p></li><li><p>动态链接：链接过程在程序运行时实时完成，生成的可执行文件在执行过程中会调用动态链接库中的代码。这样会使得可执行文件体积更小，但是运行环境需要有库文件的支持。</p></li></ol><p>链接的主要步骤包括地址和空间的分配，符号解析，和重定位等。地址和空间的分配主要是将各个模块的地址空间安排好，符号解析是找到每个符号引用的地址，重定位是将符号引用换成实际的内存地址。</p><p>编译和链接的过程中会有各种优化策略，例如编译过程中的常量折叠、死代码消除等，以及链接过程中的死代码消除、库的选择等。这些都是为了生成更高效、更小的可执行文件。</p></details><h3 id="❓ios-整个编译流程说一下" tabindex="-1"><a class="header-anchor" href="#❓ios-整个编译流程说一下" aria-hidden="true">#</a> ❓iOS 整个编译流程说一下</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>预处理：这一步主要是处理源代码中的预处理器指令，如 <code>#define、#include</code> 等，并将结果输出为预处理后的源文件。</p></li><li><p>编译：预处理后的源文件被编译器（例如<code>Clang</code>）编译，进行词法分析、语法分析、语义分析和优化，将代码转换成对应的中间代码。然后将中间代码进一步优化并生成汇编代码。</p></li><li><p>汇编：汇编器（例如 <code>Clang</code> 的集成汇编器）将汇编代码转换为目标文件（<code>.o</code> 文件），即包含了机器语言代码的文件。</p></li><li><p>链接：链接器（例如 <code>ld</code>）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行文件。这里涉及到的主要步骤有地址和空间的分配、符号决议及重定位。</p></li><li><p>打包：可执行文件配合对应的资源文件（如图片、音频等）一起打包，生成 <code>.ipa</code> 文件，这一步主要由 <code>Xcode</code> 的工具完成。</p></li><li><p>签名：<code>.ipa</code> 文件需要经过开发者的私钥进行签名才能在设备上运行，签名过程通常也称为代码签名。</p></li><li><p>安装：将签名后的 <code>.ipa</code> 文件安装到设备上，通常是通过 <code>iTunes</code> 或者 <code>Xcode</code> 进行安装。</p></li></ul></details><h3 id="❓xcode-的编译流程做了啥" tabindex="-1"><a class="header-anchor" href="#❓xcode-的编译流程做了啥" aria-hidden="true">#</a> ❓<code>Xcode</code> 的编译流程做了啥</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>预处理：这个阶段主要是处理源代码文件中的预处理命令，比如 <code>#define</code>、<code>#if</code>、<code>#import/#include</code> 等。在 <code>Swift</code> 项目中这个步骤也可能处理 <code>Swift</code> 的引入和一些编译标记。</p></li><li><p>编译：编译器(<code>Clang for Objective-C</code>, <code>Swiftc for Swift</code>)将经过预处理的代码编译成相应的汇编文件。</p></li><li><p>汇编：将汇编文件进一步转化为目标文件，也就是机器能直接执行的机器码。</p></li><li><p>链接：链接器将所有的目标文件以及库文件链接在一起，生成可执行文件。在这个过程中会处理外部引用，解析符号，把在编译时分散的模块聚合在一起。</p></li><li><p>打包：将可执行文件以及项目中的资源文件（例如图片、音乐、故事版等）打包进 <code>.app</code> 目录中。</p></li><li><p>签名：使用开发者的证书对该 <code>.app</code> 目录进行签名。这个过程是必要的，<code>iOS</code> 在安装应用时会校验该签名。</p></li></ul></details><h3 id="❓swift-和-python-的各自的编译流程" tabindex="-1"><a class="header-anchor" href="#❓swift-和-python-的各自的编译流程" aria-hidden="true">#</a> ❓<code>Swift</code> 和 <code>Python</code> 的各自的编译流程</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Swift</code> 编译流程：</p><ul><li>解析：编译器将 <code>Swift</code> 源代码解析为抽象语法树（<code>AST</code>）。</li><li>类型检查：编译器分析 <code>AST</code> 并进行类型检查以确保代码中的一些操作符和函数被发送到正确的参数类型。</li><li>中间代码生成：编译器进一步将 <code>AST</code> 转换为 <code>SIL</code>（<code>Swift Intermediate Language</code>）中间代码。</li><li>优化：编译器对 <code>SIL</code> 进行一系列的优化，如删除死代码，函数内联等。</li><li>生成 <code>LLVM</code> 中间代码：将优化后的 <code>SIL</code> 代码转化为 <code>LLVM</code> 中间代码。</li><li>原生代码生成：<code>LLVM</code> 将其中间代码生成为原生的机器语言代码。</li></ul></li><li><p><code>Python</code> 编译流程：</p><ul><li>解析：<code>Python</code> 的解释器首先将源代码解析为抽象语法树 <code>AST</code>。</li><li>字节码生成：然后将 <code>AST</code> 转换为字节码并存储在 <code>.pyc</code> 文件中。字节码是一种高级的机器语言，比原始的机器码要高级得多。</li><li>字节码执行：解释器通过 <code>Python</code> 的虚拟机执行字节码。此步骤在运行时动态完成，而不是静态的编译和链接。</li></ul></li></ul><p>总结：<code>Swift</code> 是一种编译式语言，<code>Python</code> 是一种解释型语言，所以它们的编译流程有所不同。在 <code>Python</code> 中，真正的执行过程发生在运行时，而非编译阶段，这使得 <code>Python</code> 具有很强的动态和灵活性。而 <code>Swift</code> 则更倾向于在编译阶段做尽可能多的优化，以提高运行效率。</p></details><h3 id="❓从代码仓库拉取代码-到生成-ipa-都有哪些过程-期间都生成了什么文件" tabindex="-1"><a class="header-anchor" href="#❓从代码仓库拉取代码-到生成-ipa-都有哪些过程-期间都生成了什么文件" aria-hidden="true">#</a> ❓从代码仓库拉取代码，到生成 <code>.ipa</code> 都有哪些过程，期间都生成了什么文件</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>拉取代码</p><blockquote><p>使用版本控制工具（如<code>Git</code>）从代码仓库拉取项目代码。</p></blockquote></li><li><p>预处理</p><blockquote><p>通过 <code>Xcode</code> 或命令行工具进行预处理，将源代码中的宏等预处理指令进行展开。这个过程并不直接生成文件，只是对源代码进行预处理。</p></blockquote></li><li><p>编译</p><blockquote><p>预处理后的代码被编译器（如<code>Clang</code>）逐个编译为目标文件（<code>.o</code> 文件）。此过程中可能会生成一些中间文件，如预编译头文件 <code>.pch</code>，或者 <code>Swift</code> 模块文件 <code>.swiftmodule</code> 等。</p></blockquote></li><li><p>链接</p><blockquote><p>由链接器（如 <code>ld</code>）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行的 <code>Mach-O</code> 文件。</p></blockquote></li><li><p>打包</p><blockquote><p>将可执行文件以及各种资源文件（如图片、<code>xib</code>、<code>storyboard</code> 文件等）打包到 <code>.app</code> 文件（即应用程序包）中。</p></blockquote></li><li><p>签名</p><blockquote><p>对 <code>.app</code> 文件进行签名，生成 <code>embedded.mobileprovision</code>（包含开发者证书和设备 <code>UDID</code>）、<code>CodeResources</code>（包含资源文件的哈希值）等文件，并被包含到 <code>.app</code> 文件中。</p></blockquote></li><li><p>生成 <code>.ipa</code></p><blockquote><p>将上述的 <code>.app</code> 文件以及 <code>iTunesArtwork</code>（<code>iTunes</code> 中用来展示的 <code>App</code> 图标）等文件打包进 <code>Payload</code> 文件夹，然后以 <code>.zip</code> 格式进行压缩，最后将文件后缀名改为 <code>.ipa</code>，就生成了最后的 <code>.ipa</code> 文件。</p></blockquote></li></ul></details><h3 id="❓oclint-实现静态分析的原理是什么-它是如何做到的" tabindex="-1"><a class="header-anchor" href="#❓oclint-实现静态分析的原理是什么-它是如何做到的" aria-hidden="true">#</a> ❓<code>OClint</code> 实现静态分析的原理是什么，它是如何做到的</h3><details class="hint-container details"><summary>💡</summary><p>OClint（Objective-C linter）是一个对Objective-C，C和C++进行静态代码分析的工具。静态分析是一种不需要实际运行程序代码，而是直接分析源代码本身结构、语法、符号等的技术。OClint能够通过静态分析帮助查找出程序中的bug，也能对代码质量进行评估和提升。</p><p>OClint基于LLVM/Clang静态分析技术实现分析。LLVM（Low Level Virtual Machine）是一个自由软件项目，主要包括一套编译器基础设施，用来建立、优化和生产中间代码和目标代码。Clang是LLVM厂家推出的C/C++/Objective-C编译器，基于LLVM，提供了一套具备工业强度的编译、链接和调试功能的完整工具链。</p><p>OClint的具体实现原理如下：</p><ol><li>预处理：OClint首先进行预处理操作，移除注释，并处理预处理器指令。</li><li>语法分析：然后OClint使用Clang对源代码进行语法分析，生成抽象语法树（AST）。</li><li>遍历AST：接着OClint会遍历AST，根据预设的一组规则检查每一个节点。</li><li>提供报告：最后，OClint收集检查结果，并提供详细的报告。分析结果会包括代码中可能存在的问题，和可能引发这些问题的代码片段。</li></ol><p>在遍历抽象语法树（AST）的过程中，OClint通过调用各种检查规则，对语法树的节点进行分析和检查，不断寻找可能违反规则的代码元素。这些检查规则包括但不限于复杂度检查（如代码行数、圈复杂度等）、约定性检查（如命名、注释等）、潜在bug检查（如空指针解引用、内存泄漏等）。</p><p>总的来说，OClint通过语法分析AST，然后在不断的遍历和检查中，通过各种规则来找到可能存在的问题，并最终生成详细的分析报告，以供开发者参考和优化代码。</p></details><h3 id="❓swiftlint-实现静态分析的原理是什么-它是如何做到的" tabindex="-1"><a class="header-anchor" href="#❓swiftlint-实现静态分析的原理是什么-它是如何做到的" aria-hidden="true">#</a> ❓<code>Swiftlint</code> 实现静态分析的原理是什么，它是如何做到的</h3><details class="hint-container details"><summary>💡</summary><p>SwiftLint是一款为Swift编写的工具，用于在Xcode或是AppCode编写的代码中执行一系列的规则，并报告任何不合规的实例。SwiftLint通过对项目源代码进行静态分析，找出不符合设定规则的部分，从风格、习惯方面帮助提升代码质量。</p><p>以下是SwiftLint的基本实现原理和步骤：</p><ol><li><p>解析：SwiftLint首先将源代码解析为抽象语法树（AST）。这是通过SourceKit（Swift的开源库，提供了对Swift源代码进行高效处理的能力）实现的。</p></li><li><p>遍历AST：接下来，SwiftLint会遍历生成的AST，查找是否存在与事先定义好的规则不符合的地方。</p></li><li><p>规则检查：在AST中每遇到一个节点，SwiftLint就会将其与所有启用的规则进行比对。这包括命名规则、空格规则、标点符号规则甚至是某些代码的复杂度规则等。</p></li><li><p>报告：如果SwiftLint在这个过程中发现任何规则的违反情况，就会将这个违规信息添加到报告中。</p></li><li><p>重复执行：SwiftLint会对项目中的每个文件重复上面的过程，最后将所有文件的检查结果组合起来，形成最终的报告。</p></li></ol><p>SwiftLint引入了很多有用的规则，使得开发者可以编写出更高质量、更易于阅读和维护的代码。也让团队的成员在编写代码通过强制规则保证代码风格的统一。</p><p>SwiftLint不仅对代码的规则进行检测，还对命名，排版，最大类和函数长度等代码风格的统一和友好性进行规范。这对维护一个较大的项目或者一个多人协作的项目来说十分有益，它可以帮助团队采用更专业、一致的编程风格，也可以作为一个学习和提高Swift编码技能的工具。</p></details><h3 id="bitcode" tabindex="-1"><a class="header-anchor" href="#bitcode" aria-hidden="true">#</a> bitcode</h3><h4 id="❓说说对-bitcode-的理解和作用" tabindex="-1"><a class="header-anchor" href="#❓说说对-bitcode-的理解和作用" aria-hidden="true">#</a> ❓说说对 <code>bitcode</code> 的理解和作用</h4><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Bitcode</code> 是苹果在 <code>2015</code> 年推出的一个新的编译选项，它是 <code>LLVM</code>（低级虚拟机）的一种中间表示（<code>Intermediate Representation，IR</code>）形式。对源代码做完一些基本的语义分析和验证工作后，就可以转化成<code>Bitcode</code>。</p></blockquote><p><code>Bitcode</code> 的出现是为了支持苹果的 <code>App Thinning</code> 特性。具体来说，当提交一个包含 <code>Bitcode</code> 的应用到 <code>App Store</code> 时，苹果会在后台重新编译提交的应用并进行优化，生成针对各种设备的具体执行文件。因此，当用户从 <code>App Store</code> 下载应用时，他们只需下载适用于他们自己设备架构的二进制代码，而无需下载面向所有设备的通用二进制代码。</p><p>优点：</p><ul><li>节省存储空间：用户下载的应用体积更小，节省了设备的存储空间。</li><li>提高性能：苹果可以根据特定硬件和 <code>iOS</code> 版本进行特定的优化，从而更好地利用硬件性能。</li><li>更新兼容：当苹果引 <code>introduce</code> 新的硬件或者指令集时，可以在后台重新编译 <code>Bitcode</code>，自动使应用适配最新的设备，而无需开发者重新编译和提交。</li></ul><p>缺点：</p><ul><li>失去一些控制权：由于程序最终是由 <code>Apple</code> 的服务器进行编译和优化，开发者无法知道、控制和验证优化的细节。</li><li>调试难度增加：当出现问题时，可能下载的二进制代码已经被修改，与开发者本地编译出的二进制不一致，因此可能带来调试困难。此外，提交的 <code>.ipa</code> 包也无法直接运行和调试，由于里面的二进制代码实际上是 <code>Bitcode</code>，需要通过运行 <code>App Store</code> 版本或者从 <code>Xcode</code> 中下载 <code>dSYM</code> 文件来获取具体的崩溃日志。</li></ul><p>总结：<code>Bitcode</code> 有点像把原先在本地进行的“链接”过程交给了苹果的服务器来完成，进一步加强了苹果对 <code>AppStore</code> 中应用的控制，又能提升用户的下载体验和设备性能。对于开发者来说，需要权衡 <code>Bitcode</code> 带来的好处与潜在问题。</p></details><h4 id="❓ir-和-bitcode-有什么区别" tabindex="-1"><a class="header-anchor" href="#❓ir-和-bitcode-有什么区别" aria-hidden="true">#</a> ❓<code>IR</code> 和 <code>bitcode</code> 有什么区别</h4><details class="hint-container details"><summary>💡</summary><ul><li><p><code>IR</code>(<code>Intermediate Representation</code>) - 中间表示：是 <code>LLVM</code> 的核心，是其编译策略的基石。它是一种低级的编程语言，用于表示编译器中的程序。<code>LLVM</code> 前端（例如 <code>Clang</code>）负责将源代码（例如 <code>C，C++</code> 等）转化为 <code>IR</code>。</p><blockquote><p><code>LLVM IR</code>可以以三种形式存在：</p><ul><li>即时编译（<code>JIT</code>）</li><li>位码（<code>bitcode</code>）</li><li>人类可读的汇编语言格式。</li></ul></blockquote></li><li><p>bitcode：是 <code>LLVM</code> 的二进制编码格式，是 <code>LLVM IR</code> 的一种序列化形式。</p><blockquote><p><code>Apple</code> 在发布 <code>iOS 9</code> 和 <code>OS X 10.11</code> 的时候推出了新的 <code>bitcode</code> 选项。这个选项的目的是让开发者在提交应用给 <code>App Store</code> 的时候只需上传 <code>bitcode</code>，然后由 <code>Apple</code> 服务器进行最后的编译过程。这样 <code>Apple</code> 可以在未通知开发者的情况下，为开发者的应用进行某些优化，稍微延长了二进制的兼容性期限。</p></blockquote></li></ul><p>总结：<code>LLVM</code> 的 <code>IR</code> 是一种更为底层的标识编译器理解的代码的方式，而 <code>bitcode</code> 是 <code>LLVM IR</code> 的一种序列化形式，可以使用 <code>bitcode</code> 轻松地在不同的模块之间共享并操控 <code>IR</code> 代码。</p></details><hr><h2 id="hook" tabindex="-1"><a class="header-anchor" href="#hook" aria-hidden="true">#</a> hook</h2><h3 id="❓ios-中-hook-一个方法有什么途径" tabindex="-1"><a class="header-anchor" href="#❓ios-中-hook-一个方法有什么途径" aria-hidden="true">#</a> ❓<code>iOS</code> 中 <code>hook</code> 一个方法有什么途径</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Method Swizzling</code>：通过 <code>Objective-C</code> 的方法交换 (<code>Method Swizzling</code>)，可以在运行时动态地交换某个类的两个方法的实现。</p></li><li><p>分类(<code>Category</code>)：在其中添加一个新方法，然后用这个新方法的实现替换原始方法的实现。这将导致原始方法被分类中的新方法所替代。</p></li><li><p>反射机制：可以在运行时动态地创建类、检查类的属性和方法，甚至改变类的结构。通过反射可以实现对方法的拦截和替换。</p></li><li><p>使用第三方库：如<code>Aspects</code>，<code>Facebook</code> 的 <code>fishhook</code>，它们提供了较为方便和简洁的 <code>hook</code> 方案。</p></li><li><p><code>Cycript</code>：这是一个用于调试和研究 <code>iOS</code> 应用的工具，它可以注入 <code>JavaScript</code> 语境进入正在运行的应用进程中，从而实现对对象和函数的交互操作。</p></li></ul></details><h3 id="❓ios-如何-hook-一个对象的方法-而不影响其它对象" tabindex="-1"><a class="header-anchor" href="#❓ios-如何-hook-一个对象的方法-而不影响其它对象" aria-hidden="true">#</a> ❓<code>iOS</code> 如何 <code>hook</code> 一个对象的方法，而不影响其它对象</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>“Isa Swizzling”：这是一种动态改变对象的类的技术。</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 原来的类</span>
<span class="token keyword">@interface</span> MyClass <span class="token punctuation">:</span> NSObject
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>originalMethod<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MyClass
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>originalMethod <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Original method&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token comment">// 子类</span>
<span class="token keyword">@interface</span> MySwizzledClass <span class="token punctuation">:</span> MyClass
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MySwizzledClass
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>originalMethod <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Swizzled method&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> originalMethod<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token comment">// 让 hook 的对象使用子类</span>
MyClass <span class="token operator">*</span>myInstance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>MyClass alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">object_setClass</span><span class="token punctuation">(</span>myInstance<span class="token punctuation">,</span> <span class="token punctuation">[</span>MySwizzledClass class<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>myInstance originalMethod<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 输出 “Swizzled method” 和 “Original method”</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓了解-fishhook-吗-说说为什么-fishhook-不能修改非动态连接库中的符号" tabindex="-1"><a class="header-anchor" href="#❓了解-fishhook-吗-说说为什么-fishhook-不能修改非动态连接库中的符号" aria-hidden="true">#</a> ❓了解 <code>fishhook</code> 吗，说说为什么 <code>fishhook</code> 不能修改非动态连接库中的符号</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>fishhook</code> 是 <code>Facebook</code> 开发的一个用于 <code>iOS</code> 和 <code>macOS</code> 应用的开源库，允许你在运行时对 <code>C</code> 语言函数进行重绑定，并且是通过修改 <code>mach-O</code> 文件中的符号表（<code>Symbol Table</code>）实现的。</p></blockquote><p>不能修改非动态连接库中的符号的原因：</p><ul><li><code>fishhook</code> 修改的是动态链接表，在程序启动时，动态链接器(<code>dyld</code>)会根据表中的符号信息，找到动态链接库中的函数地址，并在运行时进行函数调用。而对于静态链接库，链接发生在编译时，对应的函数或者变量的值在编译后就确定了，不存在动态链接表，因此 <code>fishhook</code>无法修改。</li><li>静态库在编译时会直接被合并到可执行文件中，静态库中的符号信息会在编译时被解析并且写入到可执行文件中，所以 <code>fishhook</code>也 无法修改。</li><li>根据 <code>Mach-O</code> 文件格式的定义，<code>fishhook</code> 通过修改 <code>LC_SYMTAB command</code> 下的符号表，而这个符号表主要用于动态连接过程中的符号解析，所以只能修改动态库中的符号。</li></ul><p>总结：<code>fishhook</code> 只能修改动态库的符号，无法修改非动态库的符号。</p></details><h3 id="❓fishhook-的实现原理" tabindex="-1"><a class="header-anchor" href="#❓fishhook-的实现原理" aria-hidden="true">#</a> ❓<code>fishhook</code> 的实现原理</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>fishhook</code>是 <code>Facebook</code> 开源的一个库，它是一个用于在 <code>iOS</code> 中自由地重定向 <code>C</code> 函数的强大工具。我们只需要输入原函数和新函数，<code>fishhook</code> 就能实现与之匹配的重定向。</p></blockquote><p>实现原理：主要基于 <code>Unix</code> 中的动态链接过程，特别是在其中用到的 <code>GOT</code>（<code>Global Offset Table</code>）和 <code>PLT</code>（<code>Procedure Linkage Table</code>）技术。<code>fishhook</code> 会将需要重定向函数的 <code>PLT</code> 表项修改为新函数的地址，从而实现原始函数到新函数的转发。</p><p><code>fishhook</code> 的主要工作过程：</p><ul><li><p><code>fishhook</code> 会通过在目标镜像的 <code>Mach-O</code> 文件中遍历 <code>segment command</code>，找到 <code>Data segment</code> 中的 <code>__nl_symbol_ptr</code> 和 <code>__got</code> 节段。</p></li><li><p>每个节段由一系列指针组成，指向需要重定向的函数。<code>fishhook</code> 会遍历所有的指针，并将其指向的地址替换为新函数的地址。为了能够在后续调用原始函数，<code>fishhook</code> 在替换地址的同时，也会保存原始的地址。</p></li><li><p>当应用程序下次调用函数时，由于 <code>PLT</code> 表中的地址已经被修改，因此，实际运行的将是新函数。如果新函数需要调用原始函数，则可以通过 <code>fishhook</code> 提供的接口直接访问。</p></li></ul><p>注：<code>fishhook</code> 只能重定向动态链接的 <code>C</code> 函数。对于静态链接的函数，由于它们被直接嵌入到了可执行文件中，因此 <code>fishhook</code> 无法进行操作。</p></details><hr><h2 id="逆向安全" tabindex="-1"><a class="header-anchor" href="#逆向安全" aria-hidden="true">#</a> 逆向安全</h2><h3 id="❓数据是怎么加密的-怎么保证逆向拿不到我们的加密秘钥" tabindex="-1"><a class="header-anchor" href="#❓数据是怎么加密的-怎么保证逆向拿不到我们的加密秘钥" aria-hidden="true">#</a> ❓数据是怎么加密的，怎么保证逆向拿不到我们的加密秘钥</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>iOS</code> 设备上数据加密的方式主要有两种：</p><ul><li><p>文件级别的加密：</p><blockquote><p><code>iOS</code> 系统提供了数据保护 <code>API</code>，开发者可以轻松的利用这些 <code>API</code> 给 <code>App</code> 中的文件进行加密。只需在创建文件或写数据时，指定正确的数据保护等级即可。具体的数据保护等级有：<code>No Protection</code>, <code>Complete Until First User Authentication</code>, <code>Complete Unless Open</code>, <code>Complete Protection</code>。</p></blockquote></li><li><p>数据库级别的加密：</p><blockquote><p>对于存储在数据库中的数据，可以使用如 <code>SQLCipher</code> 这样的工具进行加密。<code>SQLCipher</code> 是一个开源的 <code>SQLite</code> 数据库的扩展，它为数据库文件添加了透明的 256 级 <code>AES</code> 加密。</p></blockquote></li></ul><p>保证逆向工程拿不到加密秘钥的方法：</p><ul><li><p>不要在代码中硬编码秘钥。一旦硬编码，逆向工程师可以很容易地通过静态分析找到它。可以选择在运行时动态生成秘钥，或者从服务器获取。</p></li><li><p>利用 <code>iOS</code> 的钥匙串服务（<code>Keychain Services</code>）来存储秘钥。钥匙串是 <code>iOS</code> 系统提供的一个安全的存储容器，可以用来存储秘钥、密码等敏感信息。钥匙串中的数据是加密的，且默认只有相同开发者账号下的应用才能访问。</p></li><li><p>尽可能地使用最新和最安全的加密算法，并定期更新你的加密策略。因为老旧的加密算法可能已经被破解。</p></li><li><p>确保你的应用有反逆向工程的保护，例如混淆代码，使得攻击者很难从可执行文件中复原源代码。</p></li><li><p>利用操作系统提供的安全特性，例如在 <code>iOS</code> 上可以使用 <code>App Transport Security</code>（<code>ATS</code>）来保证网络数据传输的安全。</p></li></ul></details><h3 id="❓ios-逆向分析" tabindex="-1"><a class="header-anchor" href="#❓ios-逆向分析" aria-hidden="true">#</a> ❓<code>iOS</code> 逆向分析</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>iOS</code> 逆向分析，通常指破解者通过分析和修改设备中的 <code>iOS</code> 应用程序来了解其工作原理的行为。逆向分析的应用场景广泛，包括但不限于：<code>Bug</code> 定位、性能优化、安全测试以及对竞品的调研等。</p></blockquote><p><code>iOS</code> 逆向分析的方法：</p><ul><li><p>静态分析：静态分析是分析字节码或逆向编译后的代码来了解其功能和行为的过程，未运行程序代码。常用的静态分析工具有 <code>Hopper Disassembler</code>、<code>IDA Pro</code> 等。</p></li><li><p>动态分析：动态分析是在程序运行时观察其行为，常用到的工具有 <code>LLDB</code>、<code>Cycript</code>、<code>frida</code> 等。通过动态分析可以实时查看和修改程序的运行状态。</p></li><li><p><code>Class-Dump</code>：是一个用来解析在 <code>Mach-O</code> 文件中 <code>Objc</code> 的类信息的命令行工具。逆向分析的第一步常常是使用 <code>Class-Dump</code> 获取被分析对象的头文件信息。</p></li><li><p><code>Mach-O</code> 文件探索：<code>Mach-O</code> 文件是 <code>macOS</code> 和 <code>iOS</code> 的可执行文件的格式。通过探索 <code>Mach-O</code> 文件，可以获取到程序的 <code>Segments、Sections、Symbol</code> 等信息，分析程序的入口点、链接库等。</p></li></ul></details><h3 id="❓lild-重签名" tabindex="-1"><a class="header-anchor" href="#❓lild-重签名" aria-hidden="true">#</a> ❓<code>lild</code> 重签名</h3><details class="hint-container details"><summary>💡</summary><p><code>Resigning</code> 重签名：对给定的库或者插件进行签名才能将它包含在我们的应用中。</p><p><code>lild</code>（Link Identity Editor）是一个在 <code>macOS</code> 上可以用来重签名可执行文件的命令行工具。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 清除原有签名</span>
codesign --remove-signature /path/to/my.framework
    
<span class="token comment"># 添加新的签名</span>
<span class="token comment">#   -f: 强制重签名，即使已经签过名了</span>
<span class="token comment">#   -s: 开发者证书，可以在 Keychain Access 应用程序中找到</span>
codesign <span class="token parameter variable">-f</span> <span class="token parameter variable">-s</span> <span class="token string">&quot;iPhone Developer: Your Name (ID)&quot;</span> /path/to/my.framework
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：进行重签名操作需要正确的开发者证书和配套的 <code>Provisioning Profiles</code>，否则重签名后的文件将无法在设备上运行。重签名是安全敏感操作，必须确保源文件和签名证书的可信任性。遵守相关法律法规和协议出于合法合规的前提操作。</p></details><h3 id="❓简述下-match-o-文件结构" tabindex="-1"><a class="header-anchor" href="#❓简述下-match-o-文件结构" aria-hidden="true">#</a> ❓简述下 <code>Match-O</code> 文件结构</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Mach-O</code> （Mach Object）文件格式是用于可执行文件、对象代码、共享库、动态加载代码以及内核代码等在 <code>macOS</code> 和 <code>iOS</code> 中的格式。</p></blockquote><ul><li><p><code>Header</code>：描述了整个 <code>Mach-O</code> 文件的一些基本信息。</p><blockquote><p>例如文件类型（如可执行文件、动态库或对象文件等）、<code>CPU</code> 类型、加载命令的数量和大小等。</p></blockquote></li><li><p><code>Load Commands</code>：负责描述 <code>Mach-O</code> 文件的内部结构和布局。</p><blockquote><p>例如 <code>Segment、Section、Dynamic Symbol Table、Dylib ID、Entry Point</code> 等信息。</p></blockquote></li><li><p><code>Segments and Sections</code>：<code>Segments</code> 包含一种或多种类型的 <code>Sections</code>。每个 <code>Segment</code> 对应程序运行时的一个内存映射，<code>Sections</code> 则存储具体的代码和数据。</p></li><li><p><code>Data</code>：包括符号表、字符串表等各种实际的数据。</p><blockquote><p>例如程序的执行代码、常量、全局变量等。</p></blockquote></li></ul></details><h3 id="❓怎么防止别人反编译你的-ios-app" tabindex="-1"><a class="header-anchor" href="#❓怎么防止别人反编译你的-ios-app" aria-hidden="true">#</a> ❓怎么防止别人反编译你的 <code>iOS App</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p>代码混淆：这是最基本的方法，通过改变变量名和方法名，添加无用代码等手段来让反编译出的代码难以阅读。</p></li><li><p>字符串加密：很多时候，敏感的信息是以字符串的形式存在于程序中的，通过将这些字符串加密，可以有效防止这些信息被泄露。</p></li><li><p>符号剥离：将程序中的符号信息剥离掉，这样在反编译的时候就看不到原始的符号信息，降低可读性。</p></li><li><p>把关键代码部分用汇编或者 <code>C</code> 语言重写：高级语言相比于底层语言更易于被反编译和理解，把关键部分的代码用汇编或者 <code>C</code> 语言写可以增加破解难度。</p></li><li><p>使用防护壳：就像电脑端的软件可以使用加壳技术一样，移动端的程序也可以通过防护壳来对抗反编译。</p></li><li><p>运行时防护：可以在程序中加入一些运行时检测的代码，比如检测设备是否被越狱，检测正在运行的进程等，一旦发现破解行为，就立即终止运行。</p></li></ul></details>`,51);function b(k,v){const c=a("ExternalLinkIcon");return n(),s("div",null,[l(" more "),r,e("ul",null,[e("li",null,[e("a",u,[o("2020-06-27 Swift 编译器中间码 SIL"),d(c)])]),e("li",null,[e("a",h,[o("2019-08-13 iOS程序员的自我修养"),d(c)])])]),m])}const g=i(p,[["render",b],["__file","0x12.compiler.html.vue"]]);export{g as default};

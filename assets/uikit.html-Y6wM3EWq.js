import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,f as i}from"./app-8wVbLcw5.js";const t={},r=i('<h1 id="uiview-那些事" tabindex="-1"><a class="header-anchor" href="#uiview-那些事" aria-hidden="true">#</a> <code>UIView</code> 那些事</h1><h2 id="uiview-vs-calayer" tabindex="-1"><a class="header-anchor" href="#uiview-vs-calayer" aria-hidden="true">#</a> <code>UIView</code> vs <code>CALayer</code></h2><h2 id="uiview-vs-calayer-为什么要这样设计" tabindex="-1"><a class="header-anchor" href="#uiview-vs-calayer-为什么要这样设计" aria-hidden="true">#</a> <code>UIView</code> vs <code>CALayer</code> 为什么要这样设计？</h2><h2 id="屏幕渲染" tabindex="-1"><a class="header-anchor" href="#屏幕渲染" aria-hidden="true">#</a> 屏幕渲染</h2><table><thead><tr><th>渲染类型</th><th>说明</th></tr></thead><tbody><tr><td>CPU 渲染</td><td>简单视图 CPU 渲染可能高于 GPU (不需要创建缓冲区和上下文切换)</td></tr><tr><td>GPU 渲染</td><td>GPU 浮点运算能力强于 CPU，所以 GPU 渲染效率高于 CPU</td></tr></tbody></table><ul><li><strong>屏幕渲染</strong>(On-Screen Rendering) : 在当前屏幕的缓冲区进行渲染。优点：不需要创建新的缓存，也不需要进行上下文切换，性能较好；缺点：缓存大小受限制，无法进行复杂的操作。</li><li><strong>离屏渲染</strong>(Off-Screen Rendering) : GPU 在当前屏幕外，新开辟了一个缓冲区进行图片的渲染和合成。渲染完成之后再放入当前屏幕的缓冲区。这个过程需要 CPU 调度，将任务分配给 GPU 进行渲染然后再将渲染结果返回，需要进行上下文切换和内存读写等操作，对性能影响较大。</li></ul><blockquote><p>哪些场景可以触发离屏渲染？</p></blockquote><ul><li>圆角 <code>layer.masksToBounds = YES &amp; layer.cornerRadius &gt; 0</code></li><li>图层蒙版 <code>layer.mask</code></li><li>阴影 <code>layer.shadowXXX (除 shadowPath)</code></li><li>光栅化 <code>layer.shouldRasterize = YES</code></li><li>抗锯齿 <code>antialiasing</code></li><li>不透明 <code>opacity</code></li></ul>',8),o=[r];function c(l,s){return a(),d("div",null,o)}const u=e(t,[["render",c],["__file","uikit.html.vue"]]);export{u as default};

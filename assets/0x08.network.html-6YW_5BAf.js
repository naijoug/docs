import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e,f as o}from"./app-y9eVcN9t.js";const t={},p=o(`<hr><h2 id="urlsession" tabindex="-1"><a class="header-anchor" href="#urlsession" aria-hidden="true">#</a> URLSession</h2><h3 id="❓nsurlsession-vs-nsurlconnection" tabindex="-1"><a class="header-anchor" href="#❓nsurlsession-vs-nsurlconnection" aria-hidden="true">#</a> ❓<code>NSURLSession</code> vs <code>NSURLConnection</code></h3><details class="hint-container details"><summary>💡</summary><p><code>NSURLConnection</code> 和 <code>NSURLSession</code> 都是iOS SDK提供的用于网络请求的类。</p><ol><li><p><strong>NSURLConnection</strong></p><p><code>NSURLConnection</code> 是iOS 5之前用于处理HTTP、FTP等协议的网络请求的主要类。它提供了同步和异步两种方式来获取网络数据。由于同步请求会阻塞主线程，因此开发中一般使用异步请求。然而，NSURLConnection在iOS 9.0之后已经被标记为过期。</p><p>使用<code>NSURLConnection</code>发送异步请求的一般步骤如下：</p><ul><li>创建<code>NSURLRequest</code>对象；</li><li>创建<code>NSURLConnection</code>对象，传入<code>NSURLRequest</code>以及实现了<code>NSURLConnectionDataDelegate</code>的对象；</li><li>实现相应的delegate方法以处理连接的结果。</li></ul></li><li><p><strong>NSURLSession</strong></p><p><code>NSURLSession</code>是在iOS 7之后引入的新的网络请求类，用于替代<code>NSURLConnection</code>。相比于<code>NSURLConnection</code>，<code>NSURLSession</code>提供了一些新的特性，例如后台下载、上传任务等。同时，<code>NSURLSession</code>提供了更现代化、组件化的接口，使得网络请求的处理更为方便和灵活。</p><p>使用<code>NSURLSession</code>发送请求的一般步骤如下：</p><ul><li>创建<code>NSURLSessionConfiguration</code>对象；</li><li>根据<code>NSURLSessionConfiguration</code>创建<code>NSURLSession</code>对象；</li><li>通过<code>NSURLSession</code>创建<code>NSURLSessionTask</code>(例如<code>NSURLSessionDataTask</code>、<code>NSURLSessionDownloadTask</code>)；</li><li>调用<code>NSURLSessionTask</code>的<code>resume</code>方法发送请求。</li></ul></li></ol><p>注意，NSURLSession还有DataTask、UploadTask、DownloadTask三种任务类型，分别对应获取数据、上传和下载文件的操作。对于任务的处理，NSURLSession采用了Block的方式，使得请求的结果处理在同一个地方，更为清晰。</p></details><h3 id="❓urlsession-解决了-urlconnection-什么问题" tabindex="-1"><a class="header-anchor" href="#❓urlsession-解决了-urlconnection-什么问题" aria-hidden="true">#</a> ❓URLSession 解决了 URLConnection 什么问题</h3><details class="hint-container details"><summary>💡</summary><p>使用 <code>NSURLConnection</code> 进行网络请求时有几个问题需要被解决，<code>NSURLSession</code> 的设计就是为了解决这些问题。</p><ol><li><p><strong>后台传输</strong>：<code>NSURLConnection</code> 不支持在应用退出后继续传输数据，<code>NSURLSession</code> 通过创建后台会话可以在应用处于后台或者被杀死后继续进行数据传输。</p></li><li><p><strong>请求的暂停和续传</strong>：<code>NSURLConnection</code> 无法像<code>NSURLSession</code>那样暂停和续传网络请求，因为它并没有提供相应的方法或者对应的操作状态。</p></li><li><p><strong>代理回调</strong>： <code>NSURLConnection</code> 使用代理的方式进行回调，在复杂应用场景下，可能导致代理方法混杂，变得难以管理和维护。而 <code>NSURLSession</code> 则采用了基于 block 的回调方式，更加直观和方便。</p></li><li><p><strong>配置会话</strong>：<code>NSURLSession</code> 提供了 <code>NSURLSessionConfiguration</code> 类，可以用于配置会话的行为，比如请求超时、蜂窝网络是否访问、HTTP 最大并发数等，而 <code>NSURLConnection</code> 则无法做到这些。</p></li><li><p><strong>重用和取消网络请求</strong>：<code>NSURLSession</code> 通过 <code>NSURLSessionTask</code> 对象来管理每个网络请求，每个任务都是可以取消、暂停和恢复的，而 <code>NSURLConnection</code> 则无法做到。</p></li></ol><p>因此，<code>NSURLSession</code> 是对 <code>NSURLConnection</code> 的改进和增强，使得开发者能够更加方便和高效地进行网络请求。</p></details><h3 id="❓说一下-nsurlsession-具体的实现原理" tabindex="-1"><a class="header-anchor" href="#❓说一下-nsurlsession-具体的实现原理" aria-hidden="true">#</a> ❓说一下 <code>NSURLSession</code> 具体的实现原理</h3><details class="hint-container details"><summary>💡</summary><p><code>NSURLSession</code> 是 iOS 7.0 及以后系统提供的一个用于网络请求的类。其使用以下五个对象来完成网络请求：</p><ol><li><p><code>NSURLSessionConfiguration</code>：这是一个会话配置对象，它决定了会话的行为模式，如：允许蜂窝访问、cookie 策略、超时设置、HTTP 管道化等。</p></li><li><p><code>NSURLSession</code>：这是网络加载的上下文环境，它协调一组相关网络数据转换任务的完成。会话中包含一个代理以及一个用来监控特定任务组的进度的委托。</p></li><li><p><code>NSURLSessionTask</code>：任务对象负责启动并维护相关的网络操作，提供了开始、暂停、取消任务的操作；并且可以查看传输进度、网络状态等信息。该类又被细分为三个子类，分别是 <code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，对应的是数据获取任务、上传任务和下载任务。</p></li><li><p><code>NSURLSessionDelegate</code>：会话代理，监听整个会话的事件，比如任务的完成、认证请求、后台下载完成等。</p></li><li><p><code>NSURLSessionTaskDelegate</code>：任务代理，监听特定任务的事件，例如上传进度、下载进度等。</p></li></ol><p>这些构成了 <code>NSURLSession</code> 的基本架构。</p><p>至于实现原理： 首先我们通过创建一个 <code>NSURLSessionConfiguration</code> 对象来配置一个 <code>NSURLSession</code> 的行为，如超时时间，是否允许蜂窝网络访问等。然后我们使用 <code>NSURLSessionConfiguration</code> 对象来创建一个 <code>NSURLSession</code> 对象。为 <code>NSURLSession</code> 对象设置代理以便获取会话的相关事件。最后我们通过 <code>NSURLSession</code> 对象创建一个 <code>NSURLSessionTask</code> 对象并调用 <code>resume</code> 方法开始任务，我们还可以通过 <code>cancel</code>、<code>suspend</code> 方法来控制任务。</p></details><h3 id="❓断点续传怎么实现-需要设置什么" tabindex="-1"><a class="header-anchor" href="#❓断点续传怎么实现-需要设置什么" aria-hidden="true">#</a> ❓断点续传怎么实现，需要设置什么</h3><details class="hint-container details"><summary>💡</summary><p>实现断点续传主要是利用HTTP协议中的&quot;Range&quot;请求头字段，在发起网络请求时设置&quot;Range&quot;字段，告诉服务器我们需要从哪个字节开始接收数据。</p><p>具体实现步骤如下：</p><ol><li><p>在用户暂停或者请求失败等需要断点续传的情况下，我们需要保存已经接收到的数据长度，比如使用<code>NSURLSessionDownloadTask</code> 进行下载时，可以调用 <code>cancelByProducingResumeData:</code> 方法获取到一个 <code>NSData</code> 对象，这个对象包含了已经下载数据的长度以及资源的链接等信息，可以保存到本地用于以后恢复下载。</p></li><li><p>当需要恢复下载时，可以使用这个 <code>NSData</code> 对象调用NSURLSession的 <code>downloadTaskWithResumeData:</code> 方法来创建一个NSURLSessionDownloadTask对象，然后再调用resume方法，即可完成断点下载。</p></li><li><p>另外一种方法则是，我们自己在请求头部添加<code>Range</code>字段，值为<code>bytes=已下载长度-</code>，这样在发出请求时，服务器会接收到这个字段，然后从我们需要的字节开始返回数据。这种方式我们需要自己处理已下载的数据，将新下载的数据拼接到已下载的数据后面。</p></li></ol><p>注意：并不是所有服务器都支持断点续传的，这需要服务器支持HTTP协议中的&quot;Range&quot;字段。</p></details><h3 id="❓网络层的优化方案有哪些" tabindex="-1"><a class="header-anchor" href="#❓网络层的优化方案有哪些" aria-hidden="true">#</a> ❓网络层的优化方案有哪些</h3><details class="hint-container details"><summary>💡</summary><p>网络层的优化主要集中在以下几个方面：</p><ol><li><p><strong>DNS 预解析</strong>：预先解析可能需要用到的域名，这样在需要进行网络请求时，就可以省去DNS解析的时间。</p></li><li><p><strong>请求合并</strong>：如果有大量小的网络请求，可以尝试将这些请求合并，尽可能地减少请求数量，因为每个请求在请求发送和响应接收时都会有一定的固定开销。</p></li><li><p><strong>数据压缩</strong>：如果需要传输的数据很大，可以对数据进行压缩，减少传输的数据量，从而提高传输速度。不过这样可能会增加CPU的使用量，因此需要针对具体的场景进行权衡。</p></li><li><p><strong>使用缓存</strong>：对于获取到的网络数据，如果可能多次使用，可以将其缓存到本地，这样在下次需要时，就可以直接从本地读取，避免重新发起网络请求。</p></li><li><p><strong>调整超时时间</strong>：根据网络环境的实际情况，合理设置网络请求的超时时间，避免无果等待，浪费资源。</p></li><li><p><strong>减少重定向</strong>：重定向会增加网络请求的 RTT，即往返时间，合理规划 API ，尽量减小重定向。</p></li><li><p><strong>使用 HTTP/2</strong>：HTTP/2相比HTTP/1.1在多路复用、数据压缩、服务器推送等方面都有所优化，可以用来提高网络传输效率。</p></li><li><p><strong>优化图片加载</strong>：针对图片资源，可以优化图片的尺寸和质量，选择合适的图片格式，或使用一些图片加载与缓存的框架等方式来加快图片的加载速度。</p></li><li><p><strong>使用CDN</strong>：使用内容分发网络（CDN）进行数据的分发，可以有效降低服务器压力，保障数据传输速度。</p></li></ol></details><h3 id="❓如何解决两个网络请求之间的依赖" tabindex="-1"><a class="header-anchor" href="#❓如何解决两个网络请求之间的依赖" aria-hidden="true">#</a> ❓如何解决两个网络请求之间的依赖</h3><details class="hint-container details"><summary>💡</summary><p>在iOS中，解决网络请求之间的依赖，一般可使用以下两种方式：</p><p><strong>1. DispatchGroup – GCD分组</strong></p><p>利用队列组进行网络请求之间的依赖。可以把两个网络请求添加到一个队列分组中，然后利用队列组的<code>notify</code>方法,告知你希望在队列组中所有任务都完成后才执行的方法。示例代码如下：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> dispatchGroup <span class="token operator">=</span> <span class="token class-name">DispatchGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

dispatchGroup<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
doSomething <span class="token punctuation">{</span>
    <span class="token comment">// when task is done</span>
    dispatchGroup<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

dispatchGroup<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
doSomethingElse <span class="token punctuation">{</span>
    <span class="token comment">// when another task is done</span>
    dispatchGroup<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

dispatchGroup<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Both asynchronous tasks are complete!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. Operation and OperationQueue</strong></p><p><code>Operation</code>是基于GCD更高一层的封装，提供了更多的可控制性。利用它的<code>addDependency</code>方法，可轻易创建依赖关系。示例代码如下：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token class-name">OperationQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> operation1 <span class="token operator">=</span> <span class="token class-name">BlockOperation</span> <span class="token punctuation">{</span>
  <span class="token comment">// your network request</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> operation2 <span class="token operator">=</span> <span class="token class-name">BlockOperation</span> <span class="token punctuation">{</span>
  <span class="token comment">// Another network request</span>
<span class="token punctuation">}</span>

operation2<span class="token punctuation">.</span><span class="token function">addDependency</span><span class="token punctuation">(</span>operation1<span class="token punctuation">)</span>

queue<span class="token punctuation">.</span><span class="token function">addOperations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>operation1<span class="token punctuation">,</span>operation2<span class="token punctuation">]</span><span class="token punctuation">,</span> waitUntilFinished<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码会确保operation2在operation1完成后才执行，也就实现了两个网络请求之间的依赖。</p></details><h3 id="❓设计一个网络框架" tabindex="-1"><a class="header-anchor" href="#❓设计一个网络框架" aria-hidden="true">#</a> ❓设计一个网络框架</h3><details class="hint-container details"><summary>💡</summary><p>设计一个网络框架需要遵循一些基本的原则：</p><ul><li>解耦性：网络框架与业务代码相分离，做到各部分职责明确，降低各部分之间的耦合程度。</li><li>扩展性：应对业务或需求的变化，有良好的扩展性是十分重要的。</li><li>安全性：保证数据的安全传输，包括数据加密，HTTPS 验证等。</li><li>易用性：网络请求的发起和结果的处理应该尽可能简洁明了。</li></ul><p>以下是一个网络框架的简单设计：</p><p><strong>1. 网络请求类 <code>NetworkRequest</code>：</strong></p><p>这是一个抽象的基类，它包含一个请求的所有必要要素，例如：URL、HTTP方法（GET、POST...）、HTTP头、请求参数等。</p><p>也可以创建这个类的子类，比如 <code>JSONNetworkRequest</code>、<code>FormDataNetworkRequest</code> 等，它们覆盖和扩展基类一些行为以适应特定类型的网络请求。</p><p><strong>2. 网络会话类 <code>NetworkSession</code>：</strong></p><p>这个类用来执行 <code>NetworkRequest</code>，它依赖于 <code>URLSession</code> 等系统组件执行实际的网络请求。这个类也是处理证书挑战，提供 URLSessionDelegate 等系统回调的地方。</p><p>这个类通常是个单例对象，所有的 <code>NetworkRequest</code> 都由它来负责发送，但是你也可以创建多个 <code>NetworkSession</code> 对象，每个对象可以有自己的 URLSessionConfiguration。</p><p><strong>3. 结果处理 <code>NetworkResponse</code>：</strong></p><p>用一个类或者结构体来封装网络请求的返回结果，它一般包含原始的 <code>HTTPURLResponse</code> 对象，请求是否成功的标志，请求返回的数据或者是请求失败的错误对象。</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">NetworkResponse</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> response<span class="token punctuation">:</span> <span class="token class-name">HTTPURLResponse</span><span class="token operator">?</span>
    <span class="token keyword">var</span> data<span class="token punctuation">:</span> <span class="token class-name">Data</span><span class="token operator">?</span>
    <span class="token keyword">var</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token operator">?</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4. 错误定义 <code>NetworkError</code>：</strong></p><p>定义一个 <code>NetworkError</code> 的错误类型，用来在网络请求时产生错误时返回给调用者具体的错误信息。可以使用 Swift 的 <code>Error</code> 协议来定义。</p><p><strong>5. 网络配置类 <code>NetworkConfiguration</code>：</strong></p><p>用于处理一些全局的网络配置，比如 BaseURL、超时时间、公共的请求头、公共的请求参数等。</p><p>把上述的组成部分组合起来，就形成了一个基本的网络框架。它可以满足大部分的需求，并且很容易对它进行扩展和维护。</p></details><blockquote><p>重连机制如何处理</p></blockquote><details class="hint-container details"><summary>💡</summary><p>网络重连机制主要是在网络连接失败或断开时，自动进行重新连接。以下是一些通用的处理步骤：</p><ol><li><p>立即重连：在网络连接断开后立即进行连接，但是这种方式并不总是有效，因为有可能是网络环境问题，立即重连也可能会失败。</p></li><li><p>延时重连：这是一个更好的策略，即在初次连接断开後，不立即重连，而是采用逐步增加的时间间隔进行重连，例如初次连接失败后2秒后进行第一次重连，如果还是失败，则4秒后进行第二次重连，依次类推，增加重试间隔。</p></li><li><p>最大重连次数：设置一个最大的重连次数，例如3次或5次。一旦重连次数达到这个值，就不再进行重连，而是将错误报告给用户。</p></li><li><p>网络状态检查：在进行重连之前，先检查当前的网络状态，如果网络不可用，那么就不进行重连。</p></li></ol><p>大多数的网络库，例如OkHttp、AFNetworking、Alamofire等，都内置了这种网络重试的机制，只需要简单的配置即可启用。需要注意的是，过于频繁的重连可能会加重服务器的负担，所以需要根据实际情况合理配置重连策略。</p></details><blockquote><p>状态码错误转发机制的处理</p></blockquote><details class="hint-container details"><summary>💡</summary><p>状态码错误通常是指网络请求已经成功完成，但是服务端返回了一个错误的状态码，例如HTTP 400，403，404，500等错误。处理这类错误的一种常见方法是使用HTTP错误中间件或者拦截器。</p><p>以下是一种可能的处理步骤：</p><p><strong>1. 判断HTTP状态码：</strong></p><p>在接收到网络请求的响应后，首先检查HTTP状态码。如果状态码在200-299之间，通常表示请求成功。否则，就表示发生了错误。</p><p><strong>2. 创建错误对象：</strong></p><p>根据HTTP状态码，创建一个表示具体错误的对象。这个错误对象通常会包含错误的状态码，以及服务器返回的错误信息。</p><p><strong>3. 使用中间件或者拦截器：</strong></p><p>创建一个错误处理中间件或者拦截器。这个中间件的任务是在每个网络请求完成后，检查请求的结果。如果发现结果中包含了HTTP错误，那么就把这个错误转发给应用程序的其他部分。</p><p><strong>4. 错误处理：</strong></p><p>在应用程序的其他部分，注册错误处理函数。这些处理函数会在接收到由中间件转发的错误时被调用。根据错误的具体情况，执行相应的处理，例如显示错误信息，或者重新执行网络请求。</p><p>以上是一个通用的处理流程，实际的实现会根据具体的网络库和应用程序的需求有所不同。例如，有的网络库提供了内置的错误处理机制，有的应用程序可能需要根据HTTP状态码执行复杂的错误恢复流程。</p></details><h3 id="❓如何避免网络回调地狱" tabindex="-1"><a class="header-anchor" href="#❓如何避免网络回调地狱" aria-hidden="true">#</a> ❓如何避免网络回调地狱</h3><details class="hint-container details"><summary>💡</summary><p>网络回调地狱是由于多个异步网络请求操作嵌套造成的问题，通常看到很多嵌套的 &quot;回调&quot; 代码。为了避免这种情况，可以采用以下的一些策略：</p><ol><li><p><strong>使用Promises或者Futures库：</strong> 这些库让您可以将异步操作连锁在一起，而不用嵌套。它们通常引入了一种类似于同步编程的编程风格，但仍然非阻塞。</p></li><li><p><strong>使用Async/Await模式：</strong> 这是最近几年在很多语言中兴起的一种新的编程模式，它可以让你以一种类似同步的方式编写异步代码。例如在JS、C#和Python中都有这种模式。</p></li><li><p><strong>使用Reactive编程库：</strong> 如RxJava，RxSwift等，可以让你将异步操作表示为数据流，然后你可以对这些数据流进行各种各样的组合和处理。</p></li><li><p><strong>使用协程：</strong> 协程是可以挂起和恢复的函数，很适合用来简化异步编程。比如Kotlin中就内置了协程支持。</p></li><li><p><strong>将回调函数提取成单独的函数或者方法：</strong> 尽量避免在一个方法中编写过多的嵌套代码。每个回调函数都可以提取成单独的函数或者方法。</p></li><li><p><strong>使用事件驱动设计：</strong> 将每个操作作为事件，通过事件监听和触发来完成操作，可以有效地避免回调地狱。</p></li></ol><p>记住，并没有一种 &quot;最好的&quot; 选择，适合的才是最好的，根据你当前的语言环境，编程风格和任务需求来选择适合自己的策略。</p></details><h3 id="swift-如何实现自己的-promise" tabindex="-1"><a class="header-anchor" href="#swift-如何实现自己的-promise" aria-hidden="true">#</a> <code>swift</code> 如何实现自己的 <code>Promise</code></h3><details class="hint-container details"><summary>💡</summary><p>实现自己的 <code>Promise</code> 实质上是要创建一个可以包装异步操作，并能够在之后获取其结果的对象。如果你只需要一种简单的实现，可以参考以下不依赖第三方库的示例：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token operator">?</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token operator">?</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token class-name">Error</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">func</span> <span class="token function-definition function">fulfill</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function-definition function">reject</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> error<span class="token punctuation">:</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>error <span class="token operator">=</span> error
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function-definition function">then</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> callback<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token class-name">Error</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        callbacks<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
        <span class="token function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function-definition function">executeCallbacksIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> value <span class="token operator">=</span> value <span class="token punctuation">{</span>
            callbacks<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
            callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> error <span class="token operator">=</span> error <span class="token punctuation">{</span>
            callbacks<span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
            callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，<code>Promise</code> 类可包含一个值或错误，它们初始为nil，并将在 <code>Promise</code> 被解决 (fulfilled 或 rejected) 时设置。一旦 <code>Promise</code> 被解决，它就会执行所有回调函数，并清空回调队列。<code>then</code> 方法被调用来添加一个将在 <code>Promise</code> 解决时调用的回调。</p><p>你可以通过以下方式使用这个 <code>Promise</code>：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span>then <span class="token punctuation">{</span> result <span class="token keyword">in</span>
    <span class="token keyword">switch</span> result <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">let</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Value: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">failure</span><span class="token punctuation">(</span><span class="token keyword">let</span> error<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Error: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">error</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// simulate async operation</span>
    promise<span class="token punctuation">.</span><span class="token function">fulfill</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，我们首先创建了一个 <code>Promise&lt;Int&gt;</code>，然后在其中添加一个通过 <code>then</code> 方法添加的回调。之后我们在全局队列上模拟一个异步操作，2秒后，<code>fulfill</code> 方法将 <code>Promise</code> 状态更改为已解决，并打印“Value: 5”。</p><p>提醒一下，这只是一种基础的实现方式，实际上可能需要追加一些额外的功能，例如错误处理、链式调用和并发控制等。</p></details><hr><h2 id="web" tabindex="-1"><a class="header-anchor" href="#web" aria-hidden="true">#</a> Web</h2><h3 id="❓wkwebview-缓存和清理缓存的方法" tabindex="-1"><a class="header-anchor" href="#❓wkwebview-缓存和清理缓存的方法" aria-hidden="true">#</a> ❓<code>WKWebView</code> 缓存和清理缓存的方法</h3><details class="hint-container details"><summary>💡</summary><p>以下是如何在WKWebView中缓存网页并清理缓存:</p><p>在 <code>WKWebView</code> 中，可以通过修改 <code>WKWebViewConfiguration</code> 对象的缓存策略来改变 <code>WKWebView</code> 的缓存行为。默认情况下，<code>WKWebView</code> 会像普通浏览器一样自动缓存资源。</p><p>要设置禁止缓存，可以使用如下方法构建 <code>URLRequest</code>：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token function">URL</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;https://www.website.com&quot;</span></span><span class="token punctuation">)</span><span class="token operator">!</span>
<span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token class-name">URLRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> url<span class="token punctuation">)</span>
request<span class="token punctuation">.</span>cachePolicy <span class="token operator">=</span> <span class="token punctuation">.</span>reloadIgnoringLocalCacheData
wkWebView<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要清除 <code>WKWebView</code> 的缓存，使用如下的方法：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> dateFrom <span class="token operator">=</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>timeIntervalSince1970<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> websiteDataTypes <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
websiteDataTypes<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">WKWebsiteDataTypeDiskCache</span><span class="token punctuation">)</span>
websiteDataTypes<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">WKWebsiteDataTypeMemoryCache</span><span class="token punctuation">)</span>

<span class="token class-name">WKWebsiteDataStore</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeData</span><span class="token punctuation">(</span>ofTypes<span class="token punctuation">:</span> websiteDataTypes<span class="token punctuation">,</span> modifiedSince<span class="token punctuation">:</span> dateFrom<span class="token punctuation">,</span> completionHandler<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>WKWebsiteDataStore.default()</code> 会返回 <code>WKWebView</code> 默认使用的一个 data store。通过调用 <code>removeData(ofTypes:modifiedSince:completionHandler:)</code> 方法可以清除指定的缓存类型。此例中选择清除磁盘与内存中的缓存。</p><p>注意：清理缓存操作可能需要几秒钟的时间去完成，特别是当磁盘中的缓存比较大的情况下，应当对它进行异步处理。</p></details>`,28);function c(i,l){return s(),a("div",null,[e(" more "),p])}const r=n(t,[["render",c],["__file","0x08.network.html.vue"]]);export{r as default};

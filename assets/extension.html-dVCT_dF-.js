import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as a,f as r}from"./app-CmXikh8R.js";const e={},n=r('<h2 id="_465-499" tabindex="-1"><a class="header-anchor" href="#_465-499" aria-hidden="true">#</a> 465 ~ 499</h2><p>#465. 16.12 考虑递归或类似于树状结构的做法。</p><p>#466. 17.1 手动（慢慢地）完成二进制加法，尝试真正理解发生了什么。</p><p>#467. 16.13 画一个正方形和一些把它切成两半的线。这些线位于哪里？</p><p>#468. 17.24 从蛮力解法开始。</p><p>#469. 17.14 实际上有几种方法。动脑筋想一想。从简单的方法开始也没问题。</p><p>#470. 16.20 想想递归。</p><p>#471. 16.3 所有的线都会相交吗？什么决定两条线是否相交？</p><p>#472. 16.7 如果a&gt;b，则k为1，否则为0。如果给定k，你能返回最大值吗（没有比较或if-else逻辑）？</p><p>#473. 16.22 棘手的是处理无限网格。你有什么选择？</p><p>#474. 17.15 试着简化这个问题：如果你只需要知道由列表中其他两个单词组成的最长单词会如何？</p><p>#475. 16.10 方案1：你能计算出每年有多少人活着吗？</p><p>#476. 17.25 首先根据单词长度对字典进行分组，因为你知道每一列的长度必须相同，每一行的长度也必须相同。</p><p>#477. 17.7 讨论一下简单方法：当它们是同义词时将名称合并到一起。你如何确定传递关系？<code>A==B, A==C, C==D</code> 表示 <code>A==D==B==C</code>。</p><p>#478. 16.13 任何把正方形切成两半的直线都穿过正方形的中心。那你怎么才能找到一条把两个正方形切成两半的线呢？</p><p>#479. 17.17 从蛮力解法开始。运行时间是多少？</p><p>#480. 16.22 选项1：你真的需要一个无线的网络吗？再次审题。你知道网格的最大尺寸吗？</p><p>#481. 16.16 在开始和结束时知道最长的排序序列会有帮助吗？</p><p>#482. 17.2 尝试递归地解决这个问题。</p><p>#483. 17.26 解法1：从一个简单的算法开始，将每个文档依次与其他文档进行比较。你如何尽快计算两个文档的相似度？</p><p>#484. 17.5 是哪个字母或数字并不重要。你可以把该问题简化为只包含A和B的数组。然后寻找具有相同数量的A和B的最长子数组。</p><p>#485. 17.11 如果只运行一次算法，请首先考虑寻找最近距离的算法。你应该能够在O(N)时间内完成这项工作，其中N是文档中的字数。</p><p>#486. 16.20 你能递归地尝试所有的可能性吗？</p><p>#487. 17.9 明确这个问题的要求。要求满足3a×5b×7c这一形式的第k小的值。</p><p>#488. 16.2 想想这个问题的最佳运行时间是多少。如果你的解法匹配最理想的运行时间，那么你可能无法做的更好了。</p><p>#489. 16.10 方案1：用散列表或数组试试，将出生年份映射到该年还有多少人活着。</p><p>#490. 16.14 有时，蛮力解法是相当好的办法。你能试试所有可能的直线吗？</p><p>#491. 16.1 尝试在数轴上画出a和b两个数字。</p><p>#492. 17.7 该问题的核心是将名字分组成不同的拼写。基于此，计算出频率就相对容易了。</p><p>#493. 17.3 如果你实在解不出来，那么先解决17.2吧。</p><p>#494. 17.16 此题有递归和遍历两种解法，但从递归开始可能更容易一些。#495. 17.13 试试递归方法。</p><p>#496. 16.3 无限长的线几乎总会相交，除非它们相互平行。平行线也仍然有可能“相交”——如果它们是同一条线。这对线段来说意味着什么？</p><p>#497. 17.26 解法1：要计算两个文档的相似性，可以尝试用某种方式重新组织数据。排序？使用其他的数据结构？</p><p>#498. 17.15 如果只想知道由列表中其他两个单词组成的最长单词，那么可以遍历全部单词，从最长到最短，检查每个单词是否可以由其他两个单词组成。为了检查，我们可以将字符串从所有可能的位置分开。</p><p>#499. 17.25 你能找到一个特定长宽的单词矩阵吗？如果尝试了所有的选项会怎样？</p><h2 id="_500-599" tabindex="-1"><a class="header-anchor" href="#_500-599" aria-hidden="true">#</a> 500 ~ 599</h2><p>#500. 17.11 调整你的算法，使它成为可以重复调用的算法的一次执行。它哪里慢？你能优化它吗？</p><p>#501. 16.8 试着从三位作为一段的角度思考。</p><p>#502. 17.19 从第一部分开始：如果只缺少一个数字，那么找到它。</p><p>#503. 17.16 递归解法：每个预约都有两个选择（接受预约或拒绝预约）。作为一种蛮力方法，你可以在所有可能性的地方递归。但是请注意，如果接收了预约请求i，那么你的递归算法应该跳过预约请求i+1。</p><p>#504. 16.23 需要特别注意的是，你的解法实际上概率地返回0到6之间的每个数。</p><p>#505. 17.22 从一个蛮力的递归解法开始。只需要创建所有一次编辑的单词，检查它们是否在字典中，然后尝试该编辑路径。</p><p>#506. 16.10 解法2：如果对年份排序会如何？你会根据什么排序？</p><p>#507. 17.9 蛮力解法得到的形如3a×5b×7c的第k小的值是什么样的？</p><p>#508. 17.12 尝试递归解法。</p><p>#509. 17.26 解法1：你应该能够得到一个O(A+B) 的算法来计算两个文档的相似性。</p><p>#510. 17.24 蛮力解法要求连续计算每个矩阵的和。能优化它吗？</p><p>#511. 17.7 你要尝试的一件事是维护每个名称到其“真正”拼写的映射。你还需要从真正的拼写映射到所有同义词。有时，你可能要合并两组不同的名称。运行一下这个算法，看看你能否让它工作。然后看看是否能简化/优化它。</p><p>#512. 16.7 如果当a&gt;b时，k等于1，那么当k等于0时则相反，然后你可以返回<code>a*k+b*（非k）</code>。但你如何创建k？</p><p>#513. 16.10 解法2：你真的有必要匹配出生年份和死亡年份吗？当一个特定的人死了，会有什么关系，或者你只是需要一份死亡年份的清单？</p><p>#514. 17.5 从蛮力解法开始。</p><p>#515. 17.16 递归解法：你可以通过制表法优化这种方法。这种方法的运行时间是多少？</p><p>#516. 16.3 我们怎样才能找到两条线的交点。如果两条线相交，那么交点必须与它们的“无限”延伸处于同一点。这两条线之间是交点吗？</p><p>#517. 17.26 解法1：交集和并集之间是什么关系？你能用一个计算出另一个吗？</p><p>#518. 17.20 回想一下，中位数是指比一半数字更大、一半数字更小的数字。</p><p>#519. 16.14 你不能真的试遍世界上所有可能的无限长的线。但你知道一条“最好”的线必须至少相交两点。你能连接每对点吗？你可以检查每一条线是否是最优的吗？</p><p>#520. 16.26 我们可以从左到右处理表达式吗？为什么会失败？</p><p>#521. 17.10 从蛮力解法开始。你能检查一下每个值是否为主要元素吗？</p><p>#522. 16.10 解法2：观察到人是“可替代的”，不管谁出生，何时死亡。你需要的只是一份出生年份和死亡年份的列表。这可能会使你对人员列表的排序变得更加容易。</p><p>#523. 16.25 首先明确问题。你到底想要什么功能？</p><p>#524. 17.24 你能做任何形式的预计算来使计算子矩阵和的运行时间为O(1)吗？</p><p>#525. 17.16 递归解法：记忆法的时间复杂度为O(N)，空间复杂度也为O(N)。</p><p>#526. 16.3 仔细考虑如何处理线段具有相同斜率和与y轴相交的情况。</p><p>#527. 16.13 要将两个正方形切成两半，这条线必须穿过这两个正方形的中心。</p><p>#528. 16.14 你应该能得到O(N2)的解法。</p><p>#529. 17.14 考虑以某种方式重新组织数据或者使用其他数据结构。</p><p>#530. 16.17 把数字想象成正负交替的数字序列。注意，我们永远不会只包含一个正序列的一部分或者一个负序列的一部分。</p><p>#531. 16.10 解法2：尝试创建一份排序的出生列表和一份排序的死亡列表。通过遍历两个列表，你能追踪任意时间活着的人的数量吗？</p><p>#532. 16.22 选项2：想想ArrayList的工作原理。它能派上用场吗？</p><p>#533. 17.26 解法1：要理解两个集合的交集和并集的关系，考虑用Venn图（一个圆与另一个圆重叠的图）。</p><p>#534. 17.22 一旦你有了一个蛮力解法，就可以尝试找到一个更快的方法以得到所有一次编辑的有效单词。当绝大多数字符串都不是有效的字典单词时，你不会想创建所有一次编辑的字符串。</p><p>#535. 16.2 可以使用散列表来优化重复的情况吗？</p><p>#536. 17.7 使用上述方法的一种简单方式是将每个名称映射到一个备选拼写列表。当一个组中的一个名称设置为等于另一个组中的名称时会发生什么？</p><p>#537. 17.11 你可以构建一个查找表，把每个单词映射到它出现位置的列表。然后怎样找到最近的两个位置呢？</p><p>#538. 17.24 如果你预先计算从左上角开始并扩展到全部单元格的子矩阵的和会怎样？计算它需要多长时间？计算完以后，你能在O(1)时间内得到任意子矩阵的和吗？</p><p>#539. 16.22 选项2：使用ArrayList是不可能的，因为那样太烦琐了。也许构建自己的列表会更容易，但要专门针对矩阵。</p><p>#540. 16.10 每个出生增加一个人，每个死亡移除一个人。尝试编写一份人员列表（出生年份和死亡年份）示例，然后将其重新格式化为每年的列表，出生时加1，死亡时减1。</p><p>#541. 17.16 迭代法：对递归法进一步研究。你可以迭代地实现类似的策略吗？</p><p>#542. 17.15 将前面的想法扩展到多个单词的情况。我们能不能把每个单词都拆分为所有可能的形式？</p><p>#543. 17.1 你可以把二进制加法看成是对数字的每一位进行迭代、两位进行加和，并在必要时进位。你也可以对操作进行分组。如果首先对每位相加（不进位）会怎样？之后，你可以再处理进位。</p><p>#544. 16.21 在这里用一些例子做些数学计算。这一对数值有什么需求？你发现它们的值有什么特点？</p><p>#545. 17.20 注意，必须存储见过的所有元素。即使是前100个元素中最小的元素也可以成为中间值。你不能抛弃较大或较小的元素。</p><p>#546. 17.26 解法2：人们很容易想到一些小的优化——例如，在每个数组中跟踪最小和最大元素。然后，在特定情况下，你可以快速计算出两个数组是否不重叠。这样做（以及其他类似的优化）的问题是，仍然需要将所有文档与其他文档进行比较。它没有利用相似度是“稀疏”的这一事实。考虑到我们有很多文档，真的不需要将所有文档与其他文档进行比较（即使比较运算速度很快）。所有这类解复杂度都是O(D2)，其中D是文档的编号。我们不应该将所有的文档与其他文档进行比较。</p><p>#547. 16.24 从蛮力解法开始。运行复杂度是什么？解决这个问题的最佳时间是什么？</p><p>#548. 16.10 解法3：如果你创建了一个年份数组并保存每个年份的人口变化会如何？你能找到人口最多的那一年吗？</p><p>#549. 17.9 在寻找3a×5b×7c的第k个最小值时，我们知道a、b、c将小于等于k。你能生成所有可能的数字吗？</p><p>#550. 16.17 注意，如果你有一个和是负数的数列，那么其一定不是一个数列的开始或结束（如果它们连接了另外两个数列，那么就可以以一个数列的形式出现）。</p><p>#551. 17.14 你能把这些数字排序吗？</p><p>#552. 16.16 我们可以把这个数组分成3个子数组：LEFT、MIDDLE和RIGHT。LEFT和RIGHT都是有序的。MIDDLE的元素顺序是任意的。我们需要展开MIDDLE，直到可以对这些元素排序并使整个数组有序。</p><p>#553. 17.16 迭代法：从数组的末尾开始，然后向后计算可能是最简单的。</p><p>#554. 17.26 解法2：如果我们不能将所有文档与其他文档进行比较，那么就需要进一步比较其元素。考虑一个简单的解决方案，看看是否可以将其扩展到多个文档。</p><p>#555. 17.22 为了快速得到编辑距离为1的有效单词，试着将字典中的单词以一种有效的方式进行分组。注意，b_ll形式的所有单词（如bill、ball、bell和bull）的编辑距离为1。然而，这些并不是仅有的编辑距离为1的单词。</p><p>#556. 16.21 当你把一个值a从数组A移动到数组B时，A的和减少了a, B的和增加了a。当你交换两个值时会发生什么？交换两个值并得到相同的和需要什么？</p><p>#557. 17.11 如果你有一个每个单词出现次数的列表，那么你实际上需要在两个数组中寻找一对值（每个数组中选一个值），使它们之间的差异最小。这应该是一个与初始算法很相似的算法。</p><p>#558. 16.22 方法2：一种方法是当蚂蚁到达边缘时，将数组的大小加倍。但是，你将如何处理蚂蚁到达负坐标的问题呢？数组不能有负的索引。</p><p>#559. 16.13 给定一条直线（斜率和y轴截距），你能找到它与另一条直线的交点吗？</p><p>#560. 17.26 解法2：思考这个问题的一种方法是，我们需要能够非常快速地找到与特定文档有某一相似值的所有文档的列表（同样地，我们不应该“查看所有文档并快速消除不具备某相似值的文档”。那样的话时间复杂度至少是O(D2)）。#561. 17.16 迭代法：注意，你永远不会连续跳过3个预约。为什么不会？因为你总是可以接受中间的预约。#562. 16.14 你试过使用散列表吗？</p><p>#563. 16.21 如果你交换两个值，即a和b，那么A的和变成sumA - a+b，而B的和变成sumB - b+a。这两个和需要相等。</p><p>#564. 17.24 如果你能预先计算从左上角到每个单元格的和，那么便可以在O(1)时间内用它来计算任意子矩阵的和。画一个特定的子矩阵。这个子矩阵上面的数组（C）、左边的数组（B），以及上边和左边的数组（A）的和均分别预先计算完成。你如何计算D的和？[插图]</p><p>#565. 17.10 考虑蛮力解法。我们选择一个元素，然后通过计算匹配和非匹配元素的数量来验证它是否是主要元素。假设对于第一个元素，前几次检查显示7个不匹配的元素和3个匹配的元素。有必要继续检查这个元素吗？</p><p>#566. 16.17 从数组的开头开始。当这个子数列增长时，它仍然是最佳子数列。然而，一旦变成负数，它就没有意义了。</p><p>#567. 17.16 迭代法：如果你选择i，那么将永远不会选择i+1，但是总会选择i+2或i+3。</p><p>#568. 17.26 解法2：根据前面的提示，我们可以思考是什么构成了与特定文档（类似于{13, 16, 21,3}文档）有指定相似度的文档。这个列表有哪些属性？我们如何收集所有的那样的文档？</p><p>#569. 16.22 选项2：注意，问题中没有规定坐标的标签必须保持不变。你能把蚂蚁和所有的单元格信息移动到正坐标吗？换句话说，如果当你需要让数组n向负方向增长时，你重新标记了所有的指标使它们仍然是正的，会发生什么？</p><p>#570. 16.21 你在寻找a和b的值，其中sumA - a+b=sumB - b+a。用数学方法算出这对a和b的值意味着什么。</p><p>#571. 16.9 从减法开始，逐步解决。一旦完成了一个函数，你可以用它来实现其他函数。</p><p>#572. 17.6 从蛮力解法开始。</p><p>#573. 16.23 从蛮力解法开始。在最坏的情况下，需要调用多少次rand5() ？</p><p>#574. 17.20 另一种思考方法是：你能维护元素的下半部分和上半部分吗？</p><p>#575. 16.10 解法3：注意这个问题中的细节。你的算法/代码是否考虑一个在出生的同一年去世的人？这个人应该被计算为人口总数中的一人。</p><p>#576. 17.26 解法2：与{13, 16, 21, 3}相似的文档列表包括所有包含3、16、21和3的文档。如何才能有效地找到这个列表？记住，我们将对许多文档做此计算，所以一些预处理是必要的。</p><p>#577. 17.16 迭代法：使用一个例子并从后往前计算。你可以很容易地找到子数组{rn}、{rn-1, rn}和{rn-2, ..., rn}。如何使用这些结果快速找到{rn-3, ..., rn}的最优解？</p><p>#578. 17.2 假设你有一个方法shuffle，它可以处理最多n-1个元素。你能用这个方法来实现一个新的shuffle方法使其处理最多n个元素吗？</p><p>#579. 17.22 创建从通配符形式（如b_ll）到该通配符所匹配的所有单词的映射。然后，当你想要查找与bill相隔编辑距离为1的所有单词时，可以在映射中查找_ill、b_ll、bi_l和bil_。</p><p>#580. 17.24 D的和将是sum(A&amp;B&amp;C&amp;D) - sum(A&amp;B) - sum(A&amp;C)+sum(A)。</p><p>#581. 17.17 你能用trie吗？</p><p>#582. 16.21 如果计算一下，那我们要找一对这样的值，即a - b=(sumA - sumB) / 2。然后，问题归结为寻找具有特定差的一对值。</p><p>#583. 17.26 解法2：尝试构建一个散列表，使其从每个单词映射到包含此单词的文档。这将允许我们轻松地找到所有与{13, 16, 21, 3}有特定相似值的文档。</p><p>#584. 16.5 0如何变成n!？这是什么意思？</p><p>#585. 17.7 如果每个名称都映射到其替代拼写的列表，那么在将X和Y设置为同义词时，你可能需要更新许多列表。如果X是{A, B, C}的同义词，而Y是{D, E, F}的同义词，那么你需要将{Y, D, E, F}添加到A的同义词列表、B的同义词列表、C的同义词列表和X的同义词列表中。{Y, D, E, F}同理。有更快的方法么？</p><p>#586. 17.16 迭代法：如果你预约某一时间段，那就不能预约紧邻的下一时间段，但可以预约之后的任何时间。因此，optimal(ri, ..., rn)=max(ri+optimal(ri+2, ..., rn)，optimal(ri+1, ..., rn))。你可以通过从后往前迭代来解决这个问题。</p><p>#587. 16.8 你考虑过负数吗？你的解决方案是否适用于100030000这样的值？</p><p>#588. 17.15 当你得到非常低效的递归算法时，试着查找重复发生的子问题。</p><p>#589. 17.19 第1部分：如果你必须在O(1)的空间复杂度和O(N)的时间复杂度下找到丢失的数字，那么只能在数组中执行常数次遍历，并且只能存储少许变量。</p><p>#590. 17.9 查看3a×5b×7c对应的所有值的列表，可以观察到列表中的每个值都是3×（列表中前面的某值）、5×（列表中前面的某值）或7×（列表中前面的某值）。</p><p>#591. 16.21 一种蛮力解法是遍历所有的数值对，以找到一个具有正确差值的数值对。这可能看起来为：对A进行外循环，对B进行内循环。对于每个值，计算差值并与目标差值进行比较。能说得更具体些吗？给定A中的值和目标差，可以知道要找的B中的元素的确切值吗？</p><p>#592. 17.14 使用堆或某种树怎么样？</p><p>#593. 16.17 如果跟踪计算中的和，那就应该在子数列为负时立即重置它。我们永远不会在另一个子数列的开头或结尾添加一个和为负数的数列。</p><p>#594. 17.24 通过预计算，你应该能够得到O(N4)的时间复杂度。可以更快些吗？</p><p>#595. 17.3 试试递归解法。假设你有一种算法能从n-1个元素中得到一个大小为m的子集。你能开发出一种算法从n个元素中得到大小为m的子集吗？</p><p>#596. 16.24 我们可以用散列表使它更快吗？</p><p>#597. 17.22 你之前的算法可能类似于深度优先搜索。你能使它更快吗？</p><p>#598. 16.22 选项3：另一件需要考虑的事情是，你是否真的需要一个网格来实现它。在这个问题中你真正需要什么信息？</p><p>#599. 16.9 减法：取负函数（将正整数转换为负数）有用吗？你可以使用加法操作符来实现吗？</p><h2 id="_600-699" tabindex="-1"><a class="header-anchor" href="#_600-699" aria-hidden="true">#</a> 600 ~ 699</h2><p>#600. 17.1 只关注上面的一个步骤。如果你“忘记”进位，那么加法操作会是什么样子？</p><p>#601. 16.21 蛮力解法其实是在B中寻找一个等于a - target的值。你如何能更快地找到这个元素？什么方法可以帮助我们快速找到数组中是否存在某个元素？</p><p>#602. 17.26 解法2：一旦有了一种方法可以容易地找到与特定文档有某一相似值的所有文档，你就可以通过一个简单的算法进行计算。你能让算法更快一些吗？具体来说，可以直接从散列表计算相似度吗？</p><p>#603. 17.10 主要元素一开始看起来并不一定像主要元素。例如，有可能主要元素出现在数组的第一个元素中，然后在接下来的8个元素中都不再出现。但是，在这些情况下，主要元素将在数组的后面出现（实际上，在数组的后面会出现很多次）。当某个元素看起来“不太像”主要元素时，继续检查它并不一定很重要。</p><p>#604. 17.7 相反，X、A、B和C应该映射到同一个集合{X, A, B, C}。Y、D、E和F应该映射到同一个集合{Y, D, E, F}。当我们将X和Y设置为同义词时，可以将其中一个集合复制到另一个集合中（例如，将{Y, D, E, F}添加到{X, A, B, C}中）。散列表还需进行其他更改么？</p><p>#605. 16.21 可以用散列表，也可以尝试排序。两者都能帮助我们更快地定位元素。</p><p>#606. 17.16 迭代解法：如果你仔细考虑真正需要的数据，应该能够在O(n)时间复杂度和O(1)额外空间复杂度内解出它。</p><p>#607. 17.12 这样想：如果你有convertLeft和convertRight方法（它们可以把左右子树转换成双链表），你能使用它们把整个树转换成双链表吗？</p><p>#608. 17.19 第1部分：如果将数组中的所有值相加会怎么样？然后你能算出缺失的数字吗？</p><p>#609. 17.4 你需要多长时间才能算出缺失数字的最小有效位？</p><p>#610. 17.26 解法2：假设你正在通过查找一个从单词映射到文档的散列表来查找与{1, 4, 6}相似的文档。执行此查找时，同一文档ID会出现多次。这说明了什么？</p><p>#611. 17.6 不要计算每一个数中有多少个2，要一位数一位数地想，也就是说，首先计算（对于每个数字）第1位中有多少个2，然后计算（对于每个数字）第2位中有多少个2，再计算（对于每个数字）第3位中有多少个2，以此类推。</p><p>#612. 16.9 乘法：用加法很容易实现乘法运算，但是如何处理负数呢？</p><p>#613. 16.17 你可以在O(N)时间复杂度和O(1)空间复杂度内解决此问题。</p><p>#614. 17.24 假设这只是一个数组。如何计算有最大和的子数组呢？详见16.17。</p><p>#615. 16.22 选项3：你实际上需要的是来查看一个单元格是白色的还是黑色的某种方式（当然还有蚂蚁的位置）。你能把所有的白色方格存在一个链表中吗？</p><p>#616. 17.17 一种解决方案是将较大字符串的每个后缀都插入trie。例如，如果单词是dogs，那么后缀应该是dogs、ogs、gs和s。这将如何帮助你解决该问题？其运行时间是多少？</p><p>#617. 17.22 广度优先的搜索通常比深度优先的搜索要快。在最坏的情况下未必如此，但在很多情况下都是这样。为什么？你能找到更快的方法吗？</p><p>#618. 17.5 如果你从一开始就计算A的个数和B的个数会怎样（试着构建数组构成的表并保存到目前为止A和B的数量）？</p><p>#619. 17.10 还要注意，主要元素对于某些子数组也必须是主要元素，而且子数组不能拥有多个主要元素。</p><p>#620. 17.24 假设我只是想让你找出从第r1行开始到第r2行结束的最大子矩阵，怎么才能最有效地做到这一点（参见前面的提示）？如果我现在让你找出从r1到(r2+2)的最大子数组，你能有效地做到吗？</p><p>#621. 17.9 由于每个数字都是列表中先前值的3倍、5倍或7倍，因此我们可以检查所有可能的值，然后选择下一个还没有看到的值。这将导致许多重复的工作。如何才能避免这种情况呢？</p><p>#622. 17.13 你能把所有的可能性都试一试吗？那会是什么样子？</p><p>#623. 16.26 乘法和除法是优先级较高的运算。在 <code>3*4+5*9/2+3</code> 这样的表达式中，乘法和除法部分需要组合在一起。</p><p>#624. 17.14 如果你选了一个任意的元素，那么需要多长时间才能算出它的元素的排序（比它大或比它小的元素的个数）？</p><p>#625. 17.19 第2部分：我们现在正在寻找两个缺失的数字，可以称其为a和b。第1部分中的计算方法将告诉我们a和b的和，但它实际上不会告诉我们a和b。还需要做什么计算？</p><p>#626. 16.22 选项3：你可以考虑维护一个所有白色方格的散列集合。不过，你怎么才能打印出整个网格呢？</p><p>#627. 17.1 仅相加步骤就可以做如下转化：1+1-&gt; 0，1+0-&gt; 1，0+1-&gt; 1，0+0-&gt; 0。没有+号要怎么做？</p><p>#628. 17.21 直方图中最高的长方形起什么作用？</p><p>#629. 16.25 什么数据结构对查找最有用？维护元素顺序最有用的数据结构是什么？</p><p>#630. 16.18 从蛮力解法开始。你能试一下a和b的所有可能性吗？</p><p>#631. 16.6 如果你对数组排序呢？</p><p>#632. 17.11 能用两个指针遍历两个数组吗？你应该能在O(A+B)时间内完成，其中A和B是两个数组的大小。</p><p>#633. 17.2 你可以递归地建立这个算法，把第n个元素换成它之前的任何一个元素。迭代解法会是什么样子？</p><p>#634. 16.21 如果A的和是11，B的和是8呢？能有一对数刚好有目标差吗？检查你的解决方案是否恰当地处理了这种情况。</p><p>#635. 17.26 解法3：有另一种解决方案。考虑从所有的文档中提取所有的单词，将它们放入一个巨大的列表中，并对这个列表进行排序。假设你仍然知道每个单词来自哪个文档。如何跟踪相似的文档？</p><p>#636. 16.23 制作一个表格用于表示rand5()的每个可能的调用序列如何映射为rand7()的结果。如果你使用(rand2()+rand2()) % 3实现rand3()，那么表格将如下所示。分析这个表格。它能告诉你什么？</p><table><thead><tr><th>第一次调用</th><th>第二次调用</th><th>结果</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td></tr></tbody></table><p>#637. 17.8 这个问题要求我们找出可以构建的最长的序列对，使其每个序列都在不断增长。如果你只需要一个元素不断增长呢？</p><p>#638. 16.15 首先尝试创建一个具有每个元素发生频率的数组。</p><p>#639. 17.21 想象一下最高的长方形、左边第二高的长方形和右边第二高的长方形。水会填满它们之间的区域。你能计算出其面积吗？其余的面积怎么办？</p><p>#640. 17.6 是否有一种更快的方法来计算某一特定位在一个数值范围内有多少个2？注意，任何位的大约1/10应该是2，但这只是大概比例。如何将其表述得更准确些？</p><p>#641. 17.1 可以使用XOR执行加法步骤。</p><p>#642. 16.18 观察其中一个子字符串，a或b都可以，必须从字符串的开头开始。这减少了可能性的种类。</p><p>#643. 16.24 如果数组有序呢？#644. 17.18 从蛮力解法开始。</p><p>#645. 17.12 一旦你对递归算法有了一个基本的概念，就可能会陷入这种情况：有时你的递归算法需要返回链表的头部，有时它需要返回链表的尾部。解决这个问题有多种方法，想想不同的方法。</p><p>#646. 17.14 如果你选择一个任意的元素，平均来说，就会得到一个在第50百分位数附近的元素（一半的元素比它大，一半的元素比它小）。如果反复这样做呢？</p><p>#647. 16.9 除法：如果你想计算x=a/b，请记住a=bx。你能找出x的最近值吗？记住这是整数除法，x应该是一个整数。</p><p>#648. 17.19 第2部分：有很多不同的计算方法可以试一试。例如，可以把所有的数都相乘，但这只会得到a和b的乘积。</p><p>#649. 17.10 试试这个：给定一个元素，开始检查它是否是一个子数组的开始，同时对于这个子数组，该元素是它的主要元素。一旦它变得“不太可能”（出现的次数少于一半），就开始检查下一个元素（子数组之后的元素）。</p><p>#650. 17.21 为了计算出整体上最高的长方形和左侧最高的长方形之间的面积，你只需遍历直方图并减去这两个长方形之间的任何长方形的面积。你可以在右侧做同样的事情。如何处理剩下的图表？</p><p>#651. 17.18 一种蛮力解决方案是对于每个起始位置不断向前移动，直到你找到一个包含所有目标字符的子序列为止。#652. 16.18 不要忘记处理pattern中的第一个字符是b的可能性。</p><p>#653. 16.20 在现实世界中，我们应该知道一些前缀/子字符串是行不通的。例如，考虑数字33835676368。虽然3383确实对应于fftf，但是没有以fftf开头的单词。有没有什么办法对于这样的情况做特殊处理？</p><p>#654. 17.7 另一种方法是把它看作一幅图。应该怎么做？</p><p>#655. 17.13 你可以用两种方法中的一种来考虑递归算法：(1)对于每个字符，我应该在这里放一个空格吗？(2)下一个空格应该放在哪里？两种方案都可以递归地解决。</p><p>#656. 17.8 如果你只需要序列对中的一个元素为递增序列，那么只对该序列排序就好了。你的最长序列实际上是所有序列对（而不是重复的序列，因为最长序列是需要严格递增的）。对于最初的问题，这说明了什么？</p><p>#657. 17.21 你可以通过重复这个过程来处理图的其余部分：找到最高的长方形和第二高的长方形，然后减去它们之间的长方形的面积。</p><p>#658. 17.4 要找到缺失的数字中的最小有效位，你其实知道有多少个0和1。例如，如果你看到最小有效位有3个0和3个1，那么缺失的数字的最小值必定是1。想想看：在任何0和1的序列中，你会得到0，然后是1，然后又是0，然后又是1，以此类推。</p><p>#659. 17.9 不要检查列表中的所有值来寻找下一个值（通过将每个值乘以3、5、7），而是这样考虑：当你将一个值x插入列表时，可以“构造”3x、5x和7x以供以后使用。</p><p>#660. 17.14 回想一下前面的提示，特别是与快速排序相关的提示。</p><p>#661. 17.21 怎样才能更快地找到两边的下一个最高的长方形？#662. 16.18 谨慎地选择分析时间复杂度的方式。如果遍历O(n2)个子字符串，每个子字符串都进行O(n)次的字符串比较，那么总体运行时间为O(n3)。#663. 17.1 现在关注进位。在什么情况下两个值会进位？如何使用进位？</p><p>#664. 16.26 把它想成当你遇到乘法或除法时，跳至一个单独的“进程”来计算该结果。</p><p>#665. 17.8 如果你根据高度对值进行排序，那么这将告诉你最后序列对的排序。最长序列必定符合这个相对顺序（但不一定包含所有的序列对）。现在只需要找到权重尺度上的最长递增子序列，并保持这些项的相对顺序不变。这本质上与下面的问题相同：对于一个整数数组找到最长的序列（不重新排序）。</p><p>#666. 16.16 考虑3个子数组：LEFT、MIDDLE和RIGHT。只关注这个问题：是否可以排序MIDDLE以使整个数组有序？如何进行验证？</p><p>#667. 16.23 再次查看这个表，注意行数为5k，其中k是对rand5()的最大调用次数。为了使0到6之间的每个值具有相等的概率，必须将行数的1/7映射到0，1/7映射到1，以此类推。这有可能吗？</p><p>#668. 17.18 另一种对蛮力方法的考虑是，我们取每个起始索引，在目标字符串中寻找每个元素的下一个出现位置。所有这些出现位置的最大值标志着子序列的尾部（该子序列包含所有目标字符）。这个算法的时间复杂度是多少？怎样才能使它更快呢？</p><p>#669. 16.6 考虑如何合并两个有序数组。</p><p>#670. 17.5 当表中A和B的个数相等时，整个子数组（从索引0开始）的A和B的个数相等。如何使用该表来查找不以索引0开始的、符合条件的子数组？</p><p>#671. 17.19 第2部分：把数字加在一起会得到a+b的结果。把数字相乘会得到a×b的结果。怎样才能得到a和b的确切值？</p><p>#672. 16.24 如果我们对数组进行排序，那么就可以对数字进行重复的二进制搜索。如果数组是有序的呢？我们能否在O(N)时间和O(1)空间中求解这个问题？</p><p>#673. 16.19 如果给你一个指代水的单元格的行和列，你如何找到所有相邻的水域？</p><p>#674. 17.7 可以把将X,Y记为同义词看作是在X节点和Y节点之间添加一条边。那么如何计算一组同义词有哪些呢？</p><p>#675. 17.21 你能通过预计算来得出每边下一个最高的长方形是哪个么？#676. 17.13 递归算法是否会反复遇到相同的子问题？你能用一个散列表进行优化吗？</p><p>#677. 17.14 如果当你选择一个元素时，你交换周围的元素（就像在快速排序中所做的那样），使它所有下方的元素都位于上方的元素之前，那会怎么样？如果你重复做这个，能找到最小的一百万个数吗？</p><p>#678. 16.6 假设你把两个数组排序，然后遍历它们。如果第一个数组中的指针指向3，第二个数组中的指针指向9，那么移动第二个指针会对这一对数字的差产生什么影响？</p><p>#679. 17.12 要处理递归算法是返回链表的头节点还是尾节点，可以尝试传递一个参数作为标志。但这不会很好。问题是，当调用convert(current.left)时，你希望得到left链表的尾节点。这样就可以将链表的末尾与current连接。但是，如果current是其他节点的右子树，那么convert(current)需要返回链表的头节点（其实是current.left的头节点）。实际上，链表的头节点和尾节点你都需要。</p><p>#680. 17.18 考虑一下前面解释的蛮力解法。瓶颈在于我们反复查询某个特定字符的下一个出现位置。有办法优化该过程么？你应该能在O(1)时间内完成。</p><p>#681. 17.8 尝试用递归方法来评估所有的可能性。#682. 17.4 一旦确定最小有效位是0（或1），就可以排除所有不以0作为最小有效位的数。这个问题和前面的有什么不同？</p><p>#683. 17.23 从蛮力解法开始。你能先试试最大的正方形吗？</p><p>#684. 16.18 假设你确定了一个模式中“a”部分的值。b有多少种可能性？</p><p>#685. 17.9 当你将x添加到前k个值的列表中时，可以将3x、5x和7x添加到新的列表中。如何使其尽可能地优化？保留多个队列如何？总是需要插入3x、5x和7x吗？或者，有时你只需要插入7x？你需要避免相同的数字出现两次。</p><p>#686. 16.19 尝试递归计算含水单元格的数目。</p><p>#687. 16.8 考虑把一个数字分成由3位数组成的序列。</p><p>#688. 17.19 第2部分：我们可以两者都计算。如果知道a+b=87，a×b=962，那么就解出a和b:a=13且b=74。但这也将导致必须对非常大的数相乘。所有数的乘积可以大于10157。还有更简单的计算方法吗？#689. 16.11 考虑制作一个跳水板。你的选择是什么？</p><p>#690. 17.18 你能从每个索引中预先计算一个特定字符的出现位置吗？尝试使用一个多维数组。</p><p>#691. 17.1 进位在1+1时发生。如何将进位应用到数值中？</p><p>#692. 17.21 作为另一种解决方案，请从每个长方形的角度来考虑。每个长方形上面都有水。每个长方形上面会有多少水？</p><p>#693. 16.25 散列表和双向链表都很有用。你能把这两者结合起来吗？</p><p>#694. 17.23 最大的正方形是N×N。所以你先试一下该正方形，如果可行，那么你便知道已经找到了最佳正方形。否则，可以尝试下一个最小的正方形。</p><p>#695. 17.19 第2部分：几乎任何我们能想到的“方程”都可以用在这里（只要它和线性和不等价）。只要保持这个和很小就可以。</p><p>#696. 16.23 把5k除以7是不可能的。这是否意味着你不能使用rand5()实现rand7()？</p><p>#697. 16.26 你还可以维护两个栈，一个用于操作符，另一个用于数字。每次看到一个数字，就把它压入栈。那么操作符呢？什么时候从栈中取出操作符并将它们与数字进行计算？</p><p>#698. 17.8 另一种思考这个问题的方法是：如果有结束于A[0]到A[n-1]每个元素的最长序列，你能用它来找出结束于元素A[n]的最长序列吗？</p><p>#699. 16.11 考虑递归解法。</p><h2 id="_700-748" tabindex="-1"><a class="header-anchor" href="#_700-748" aria-hidden="true">#</a> 700 ~ 748</h2><p>#700. 17.12 许多人在这一点上左右为难，不知道该怎么办。有时他们需要链表的头部，有时他们需要链表的尾部。给定的节点通常不知道它在convert调用中应返回什么。有时候，最简单的解决方案就是：总是同时返回这两个值。有什么方法可以做到这一点？</p><p>#701. 17.19 第2部分：试着求所有值的平方的和。</p><p>#702. 16.20 trie可以帮助我们。如果将整个单词列表存储在trie中会怎样？</p><p>#703. 17.7 每个连通子图表示一组同义词。要找到每个组，可以重复广度优先（或深度优先）搜索。</p><p>#704. 17.23 描述蛮力解法的时间复杂度。</p><p>#705. 16.19 你如何确保不会再次访问相同的单元格？考虑一下图上的广度优先搜索或深度优先搜索是如何工作的。</p><p>#706. 16.7 当a&gt;b时，a-b&gt; 0。你能得到a-b的符号位吗？</p><p>#707. 16.16 为了能够对MIDDLE进行排序并对整个数组进行排序，需要MAX(LEFT)&lt;=MIN(MIDDLE,RIGHT)和MAX(LEFT, MIDDLE)&lt;=MIN(RIGHT)。</p><p>#708. 17.20 如果使用堆呢？或是两个堆？</p><p>#709. 16.4 如果多次调用hasWon，你的解决方案可能会发生什么变化？</p><p>#710. 16.5 n!中的每个0表示n能被10整除一次。这是什么意思？</p><p>#711. 17.1 可以用AND运算来计算进位。如何使用它？</p><p>#712. 17.5 假设在这个表中，索引i满足count(A, 0-&gt;i)=3和count(B, 0-&gt;i)=7。这意味着B比A多4个。如果你发现后面的某点j具有相同的差值（count(B, 0-&gt;j) - count(a, 0-&gt;j)），那么这表示子数组中有相同数量的A和B。</p><p>#713. 17.23 你能通过预处理来优化这个解决方案吗？</p><p>#714. 16.11 一旦有了递归算法，就考虑一下时间复杂度。能快点吗？如何进行？</p><p>#715. 16.1 定义diff为a和b之间的差。你能以某种方式使用diff吗？那么你能去掉这个临时变量吗？</p><p>#716. 17.19 第2部分：你可能需要二次公式。如果你不记得也没什么大不了的，大多数人都不会记得。知道二次公式的存在即可。</p><p>#717. 16.18 由于a的值决定b的值（反之亦然），并且a或b必须出现于值的起始处，所以你应该只有O(n)种可能来分解模式串。</p><p>#718. 17.12 可以通过多种方式返回链表的头部和尾部。可以返回一个双元素数组，可以定义一个新的数据结构来保存头节点和尾节点，还可以重用BiNode数据结构。如果你使用的语言（如Python）支持返回多个值，你就可以使用此功能。可以将这个问题作为一个循环链表来解决，即头节点的前一个指针指向尾部，然后在外部的函数中拆开循环链表。试试这些解决方案。你最喜欢哪个？为什么？</p><p>#719. 16.23 可以用rand5()来实现rand7()，只是你不能有效地确定其执行次数（即你知道在一定数量的调用之后它肯定会终止）。考虑到这一点，写下一个可行的解决方案。</p><p>#720. 17.23 你应该能在O(N3)时间内完成，其中N是正方形一边的长度。</p><p>#721. 16.11 考虑使用缓存来优化时间复杂度。仔细想想你到底需要缓存什么。时间复杂度是什么？时间复杂度与表的最大尺寸密切相关。</p><p>#722. 16.19 你应该有一个算法，其在N×N矩阵上的时间复杂度是O(N2)。如果你的算法并非如此，请考虑是否错误地计算了时间复杂度，或者是否你的算法不是最优的。</p><p>#723. 17.1 你可能需要不止一次地执行加法/进位操作。将进位加到和中可能会产生新的进位值。</p><p>#724. 17.18 在得到了预计算的解法之后，考虑一下如何降低空间复杂度。你应该能够将其降低到O(SB)的时间和O(B)的空间（其中B是较大数组的大小，S是较小数组的大小）。</p><p>#725. 16.20 我们可能会多次运行这个算法。如果做更多的预处理，这里有办法优化吗？</p><p>#726. 16.18 你应该能够有一个O(n2)的算法。#727. 16.7 你考虑过如何处理a-b中的整数溢出吗？#728. 16.5 n!中每一个因子10都意味着n!能被5和2整除。#729. 16.15 为了在实现中简单明了，你可能需要使用其他方法和类。</p><p>#730. 17.18 另一种考虑方法是：假设你有一个每个元素所在索引的列表。你能找到包含所有元素的第一个子序列吗？你能找到第二个吗？</p><p>#731. 16.4 如果你正在为N×N的大小进行计算，你的解决方案可能会发生什么变化？</p><p>#732. 16.5 你能计算出5和2的因数的个数吗？需要两者都计算吗？</p><p>#733. 17.21 每个长方形的顶部都有水，水的高度应与左侧最高长方形和右侧最高长方形的较小值相匹配，也就是说，water_on_top[i]=min(tallest_ bar(0-&gt;i), tallest_bar(i, n))。</p><p>#734. 16.16 你能把中间部分展开直到满足前面的条件吗？</p><p>#735. 17.23 当你检查一个特定的正方形是否有效时（所有边框为黑色），需要检查在一个坐标的上面（或下面）和这个坐标的左边（或右边）有多少个黑色像素。你能预先计算出给定单元格上面和左边的黑色像素的数量吗？</p><p>#736. 16.1 你也可以尝试使用XOR。</p><p>#737. 17.22 如果同时从起始单词和目标单词开始进行广度优先搜索，结果会怎样？</p><p>#738. 17.13 在现实生活中，我们知道有些路径不会构成一个词。例如，没有以hellothisism开头的单词。能在明知行不通的情况下提前终止吗？</p><p>#739. 16.11 有一个替代的、聪明的（而且非常快速的）解决方案。实际上你可以在线性时间内不用递归求解。如何进行？</p><p>#740. 17.18 考虑使用堆。</p><p>#741. 17.21 你应该能在O(N)时间和O(N)空间中解出该题。</p><p>#742. 17.17 或者，可以将每个较小的字符串插入到trie中。你将如何解决这个问题？时间复杂度是什么？</p><p>#743. 16.20 通过预处理，实际上可以将查找时间降低到O(1)。</p><p>#744. 16.5 你是否考虑过25实际上记录了两次因数5？</p><p>#745. 16.16 你应该能在O(N)时间内解出来。</p><p>#746. 16.11 这样想：你选择K块木板，其有两种不同的类型。对于第一种木板选择10个、第二种木板选择4个的所有方案，它们的和都是相同的。你能遍历所有可能的选择吗？</p><p>#747. 17.25 当矩形看起来无效时，可以使用trie提前终止吗？</p><p>#748. 17.13 如果想提前终止，可以试一试trie。</p>',276),d=[n];function i(b,o){return t(),a("div",null,d)}const s=p(e,[["render",i],["__file","extension.html.vue"]]);export{s as default};

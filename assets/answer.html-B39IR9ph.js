import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as h,a as e,f as i}from"./app-4FjOShZC.js";const o={},a=i('<blockquote><p>Cracking the Coding Interviews (150)</p></blockquote><h2 id="_1-数组与字符串-8" tabindex="-1"><a class="header-anchor" href="#_1-数组与字符串-8" aria-hidden="true">#</a> 1 数组与字符串 (8)</h2><ul><li><p>1.1 确定字符互异</p><blockquote><p>实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead><tbody><tr><td>1</td><td>O(n)</td><td>O(n)</td><td>使用哈希表，存储每个字符的个数，判断个数是否大于1</td></tr><tr><td>2</td><td>O(1)</td><td>O(?)</td><td></td></tr></tbody></table></li><li><p>1.2 原串翻转</p><blockquote><p>用 C 或 C++ 实现<code>void reverse(char* str)</code>函数，即反转一个<code>null</code>结尾的字符串。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.3 确定两串乱序同构</p><blockquote><p>给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.4 空格替换</p><blockquote><p>编写一个方法，将字符串中的空格全部替换为&quot;%20&quot;。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的&quot;真实&quot;长度。(注：用 Java 实现的话，请使用字符数组实现，以便在数组上操作。) 示例 输入: &quot;Mr John Smith&quot; 输出: &quot;Mr%20John%20Smith&quot;</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.5 基本字符串压缩</p><blockquote><p>利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串 &quot;aabcccccaaa&quot; 会变为 &quot;a2b1c5a3&quot;。若&quot;压缩&quot;后的字符串没有变短，则返回原先的字符串。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.6 像素翻转</p><blockquote><p>给定一幅由 N x N 矩阵表示的图像，其中每个像素的大小为 4 字节，编写一个方法，将图像旋转90度。不占用额外内存空间能否做到？</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.7 清零行列</p><blockquote><p>编写一个算法，若 M x N 矩阵中某个元素为0，则将其所在的行与列清零。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>1.8 翻转子串</p><blockquote><p>假定有一个方法<code>isSubstring</code>，可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成，要求只能调用一次<code>isSubstring</code>。（比如，waterbottle是erbottlewat旋转后的字符串。）</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul><h2 id="_2-链表-7" tabindex="-1"><a class="header-anchor" href="#_2-链表-7" aria-hidden="true">#</a> 2 链表 (7)</h2><ul><li><p>2.1 链表去重</p><blockquote><p>编写代码，移除未排序链表中的重复结点。 进阶 如果不得使用临时缓冲区，又该怎么解决？</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>2.2 链表中倒数第 k 个节点</p><blockquote><p>实现一个算法，找出单向链表中倒数第 k 个结点。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead><tbody><tr><td>1</td><td>O(1)</td><td>O(n)</td><td>双指针法，前一个指针移动k位之后，下一个指针开始移动。</td></tr></tbody></table></li><li><p>2.3 访问单个节点的删除</p><blockquote><p>实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。示例： 输入: 单向链表a-&gt;b-&gt;c-&gt;d-&gt;e中的结点c 结果: 不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead><tbody><tr><td>1</td><td>O(1)</td><td>O(1)</td><td>将后一个结点的数据复制到删除结点，然后删除一下个结点</td></tr></tbody></table></li><li><p>2.4 链表分割</p><blockquote><p>编写代码，以给定值 x 为基准将链表分割成两部分，所有小于 x 的结点排在大于或等于 x 的结点之前。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>2.5 链式 A+B</p><blockquote><p>给定两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。 示例 输入: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2)，即 617 + 295 输出: 2-&gt;1-&gt;9，即 912 假设这些数位是正向存放的，请再做一遍。 示例 输入: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5)，即 617 + 295 输出: 9-&gt;1-&gt;2，即 912</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>2.6 确定有环链表开头节点</p><blockquote><p>给定一个有环链表，实现一个算法返回环路的开头结点。 有环链表的定义 在链表中某个结点的 next 元素指向在它前面出现过的结点，则表明该链表存在环路。 示例 输入: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C（C结点出现了两次） 输出: C</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>2.7 回文链表</p><blockquote><p>编写一个函数，检查链表是否为回文。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul><h2 id="_3-栈与队列-7" tabindex="-1"><a class="header-anchor" href="#_3-栈与队列-7" aria-hidden="true">#</a> 3 栈与队列 (7)</h2><ul><li><p>3.1 一个数组实现三个栈</p><blockquote><p>描述如何只用一个数组来实现三个栈。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.2 含有 min 函数的栈</p><blockquote><p>请设计一个栈，除 pop 与 push 方法，还支持 min 方法，可返回栈元素中的最小值。pop、push 和 min 三个方法的时间复杂度必须为O(1)。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.3 集合栈</p><blockquote><p>设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，<code>pop()</code>返回的值，应该跟只有一个栈时的情况一样）。 进阶 实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行 pop 操作。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.4 汉诺塔问题</p><blockquote><p>在经典问题汉诺塔中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制： (1) 每次只能移动一个盘子 (2) 盘子只能从柱子顶端滑出移到下一根柱子 (3) 盘子只能叠在比它大的盘子上 请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.5 两个栈实现队列</p><blockquote><p>实现一个<code>MyQueue</code>类，该类用两个栈来实现一个队列。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.6 双栈排序</p><blockquote><p>编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek 和 isEmpty。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>3.7 猫狗收容所</p><blockquote><p>有家动物收容所只收容狗与猫，且严格遵守&quot;先进先出&quot;的原则。在收养该收容所的动物时，收养人只能收养所有动物中&quot;最老&quot;（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中&quot;最老&quot;的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。允许使用 Java 内置的<code>LinkedList</code>数据结构。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul><h2 id="_4-树与图-9" tabindex="-1"><a class="header-anchor" href="#_4-树与图-9" aria-hidden="true">#</a> 4 树与图 (9)</h2><ul><li><p>4.1 二叉树平衡检查</p><blockquote><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.2 有向路径检查</p><blockquote><p>给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.3 高度最小的 BST</p><blockquote><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.4 输出单层结点</p><blockquote><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.5 检查是否为 BST</p><blockquote><p>实现一个函数，检查一棵二叉树是否为二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.6 寻找下一个结点</p><blockquote><p>设计一个算法，找出二叉查找树中指定结点的 &quot;下一个&quot; 结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.7 最近公共祖先</p><blockquote><p>设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.8 子树判断</p><blockquote><p>你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一个结点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树。也就是说，从结点 n 处把树砍断，得到的树与 T2 完全相同。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>4.9 二叉树中和为某一值的路径</p><blockquote><p>给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul><h2 id="_5-位操作-8" tabindex="-1"><a class="header-anchor" href="#_5-位操作-8" aria-hidden="true">#</a> 5 位操作 (8)</h2><ul><li><p>5.1 二进制插入</p><blockquote><p>给定两个 32 位的整数 N 和 M，以及标识比特位置的 i 与 j。编写一个方法，将 M 插入 N，使得 M 从 N 的第 j 位开始，到第 i 位结束。假设从 j 位到 i 位足以容纳 M，也即若 M=10011，那么 j 和 i 之间至少可容纳 5 个位。例如，不可能出现 j = 3 和 i = 2 的情况，因为第 3 位和第 2 位之间放不下 M。 示例 输入: N = 10000000000, M = 10011, i = 2, j = 6 输出: N = 10001001100</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.2 二进制小数</p><blockquote><p>给定一个介于 0 和 1 之间的实数(如 0.72)，类型为 double，打印它的二进制表示。如果该数字无法精确地用32位以内的二进制表示，则打印 &quot;ERROR&quot;。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.3 最接近的数</p><blockquote><p>给定一个正整数，找出与其二进制表示中 1 的个数相同、且大小最接近的那两个数(一个略大，一个略小)。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.4 解释代码<code>((n &amp; (n-1)) == 0)</code>的具体含义</p></li><li><p>5.5 整数转化</p><blockquote><p>编写一个函数，确定需要改变几个位，才能将整数 A 转成整数 B。 示例 输入: 31, 14 输出: 2</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.6 奇偶位交换</p><blockquote><p>编写程序，交换某个整数的奇数位和偶数位，使用指令越少越好(也就是说，位 0 与 位 1 交换，位 2 与位 3 交换，依次类推)。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.7 找出缺失的整数</p><blockquote><p>数组 A 包含 0 到 n 的所有整数，但其中缺了一个。在这个问题中，只用一次操作无法取得数组 A 里某个整数的完整内容。此外数组 A 的元素皆以二进制表示，唯一可用的访问操作是 &quot;从 A[i] 取出第 j 位数据&quot;，该操作的时间复杂度为常数。请编写代码找出那个缺少的整数。你有办法在 O(n) 时间内完成吗?</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>5.8 像素设定</p><blockquote><p>有个单色屏幕存储在一个一维字节数组中，使得 8 个连续像素可以存放在一个字节里。屏幕宽度为 w，且 w 可被 8 整除 (即一个字节不会分布在两行上)，屏幕高度可由数组长度及屏幕宽度推算得出。请事先一个函数<code>drawHorizontalLine(byte[] screen, int width, int x1, int x2, int y)</code>，绘制从点 (x1, y) 到点 (x2, y) 的水平线。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li></ul><h2 id="_6-智力题-6" tabindex="-1"><a class="header-anchor" href="#_6-智力题-6" aria-hidden="true">#</a> 6 智力题 (6)</h2><ul><li>6.1</li><li>6.2</li><li>6.3</li><li>6.4</li><li>6.5</li><li>6.6</li></ul><h2 id="_7-数学-概率-7" tabindex="-1"><a class="header-anchor" href="#_7-数学-概率-7" aria-hidden="true">#</a> 7 数学 &amp; 概率 (7)</h2><ul><li><p>7.1</p></li><li><p>7.2 碰撞的蚂蚁</p><blockquote><p>类似问题: 在n个顶点的多边形上有n只蚂蚁，请求出这些蚂蚁发生碰撞的概率。</p></blockquote></li><li><p>7.3 判断直线相交</p><blockquote><p>给定直角坐标系上的两条直线，确定这两条直线会不会相交。</p></blockquote></li><li><p>7.4 加法运算替代</p><blockquote><p>请编写一个方法，实现整数的乘法、减法和除法运算(这里的除指整除)。只允许使用加号。</p></blockquote></li><li><p>7.5 平分的直线</p><blockquote><p>在二维平面上，有两个正方形，请找出一条直线，能够将这两个正方形对半分。假定正方形的上下两条边与x轴平行。</p></blockquote></li><li><p>7.6 穿点最多的直线</p><blockquote><p>在二维平面上，有一些点，请找出经过点数最多的那条线。</p></blockquote></li><li><p>7.7 第 k 个数</p><blockquote><p>有一些数的素因子只有3、5、7，请设计一个算法，找出其中的第 k 个数。</p></blockquote></li></ul><h2 id="_8-面向对象设计-10" tabindex="-1"><a class="header-anchor" href="#_8-面向对象设计-10" aria-hidden="true">#</a> 8 面向对象设计 (10)</h2><ul><li>8.1</li><li>8.2</li><li>8.3</li><li>8.4</li><li>8.5</li><li>8.6</li><li>8.7</li><li>8.8</li><li>8.9</li><li>8.10</li></ul><h2 id="_9-递归-动态规划-11" tabindex="-1"><a class="header-anchor" href="#_9-递归-动态规划-11" aria-hidden="true">#</a> 9 递归 &amp; 动态规划 (11)</h2><ul><li><p>9.1 上楼梯</p><blockquote><p>有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶、3阶。请实现一个方法，计算小孩有多少种上楼的方式</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>9.2 机器人走方格</p><blockquote><p>有一个 X x Y 的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人从 (0,0) 到 (x,y) 有多少种走法? 进阶 假设有些店为 &quot;禁区&quot;，机器人不能踏足。设计一种算法，找出一条路径，让机器人从左上角移动到右下角。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>9.3 魔术索引</p><blockquote><p>在数组A[0..n-1]中，有所谓的魔术索引，满足条件 A[i]=i。给定一个升序数组，元素值各不相同，编写一个方法，在数组 A 中找出一个魔术索引，若存在的话。 进阶 如果数组元素有重复值，又该如何处理？</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>9.4 集合的子集</p><blockquote><p>请编写一个方法，返回某集合的所有非空子集。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead></table></li><li><p>9.5 字符串排序</p><blockquote><p>编写一个方法，确定某字符串的所有排列组合。</p></blockquote></li><li><p>9.6 合法括号序列判断</p><blockquote></blockquote></li><li><p>9.7</p></li><li><p>9.8 硬币表示</p><blockquote><p>给定数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算 n 分有几种表示法。</p></blockquote></li><li><p>9.9 n 皇后问题</p><blockquote></blockquote></li><li><p>9.10 堆箱子</p><blockquote><p>有一堆 n 个箱子，每个箱子宽wi，高hi，深di。 箱子不能翻转，将箱子堆起来，下面的箱子的宽度和长度必须大于上面的箱子。请实现一个方法，搭出最高的一堆箱子，箱堆的高度为每个箱子的高度的总和。</p></blockquote></li><li><p>9.11</p></li></ul><h2 id="_10-扩展性-存储限制-7" tabindex="-1"><a class="header-anchor" href="#_10-扩展性-存储限制-7" aria-hidden="true">#</a> 10 扩展性 &amp; 存储限制 (7)</h2><ul><li>10.1</li><li>10.2</li><li>10.3</li><li>10.4</li><li>10.5</li><li>10.6</li><li>10.7</li></ul><h2 id="_11-排序-查找-8" tabindex="-1"><a class="header-anchor" href="#_11-排序-查找-8" aria-hidden="true">#</a> 11 排序 &amp; 查找 (8)</h2><ul><li><p>11.1</p></li><li><p>11.2 变位词排序</p><blockquote></blockquote></li><li><p>11.3</p></li><li><p>11.4</p></li><li><p>11.5 找出字符串</p></li><li><p>11.6 矩阵元素查找</p><blockquote><p>有一个 N x M 的整数矩阵，矩阵的行和列都是从小到大有序的。请设计一个高效的查找算法，查找矩阵中元素x的位置。</p></blockquote></li><li><p>11.7 叠罗汉</p><blockquote></blockquote></li><li><p>11.8 维护 x 的秩</p></li></ul><h2 id="_12-测试-6" tabindex="-1"><a class="header-anchor" href="#_12-测试-6" aria-hidden="true">#</a> 12 测试 (6)</h2><ul><li>12.1</li><li>12.2</li><li>12.3</li><li>12.4</li><li>12.5</li><li>12.6</li></ul><h2 id="_13-c-c-10" tabindex="-1"><a class="header-anchor" href="#_13-c-c-10" aria-hidden="true">#</a> 13 C &amp; C++ (10)</h2><ul><li>13.1</li><li>13.2</li><li>13.3</li><li>13.4</li><li>13.5</li><li>13.6</li><li>13.7</li><li>13.8</li><li>13.9</li><li>13.10</li></ul><h2 id="_14-java-6" tabindex="-1"><a class="header-anchor" href="#_14-java-6" aria-hidden="true">#</a> 14 Java (6)</h2><ul><li>14.1</li><li>14.2</li><li>14.3</li><li>14.4</li><li>14.5</li><li>14.6</li></ul><h2 id="_15-数据库-7" tabindex="-1"><a class="header-anchor" href="#_15-数据库-7" aria-hidden="true">#</a> 15 数据库 (7)</h2><ul><li>15.1</li><li>15.2</li><li>15.3</li><li>15.4</li><li>15.5</li><li>15.6</li><li>15.7</li></ul><h2 id="_16-线程-锁-6" tabindex="-1"><a class="header-anchor" href="#_16-线程-锁-6" aria-hidden="true">#</a> 16 线程 &amp; 锁 (6)</h2><ul><li>16.1</li><li>16.2</li><li>16.3</li><li>16.4</li><li>16.5</li><li>16.6</li></ul><h2 id="_17-中等难题-14" tabindex="-1"><a class="header-anchor" href="#_17-中等难题-14" aria-hidden="true">#</a> 17 中等难题 (14)</h2><ul><li><p>17.1 无缓存交换</p><blockquote><p>请编写一个函数，函数内不使用任何临时变量，直接交换两个数的值。</p></blockquote></li><li><p>17.2 井字棋</p><blockquote><p>对于一个给定的井字棋棋盘，请设计一个高效算法判断当前玩家是否获胜。</p></blockquote></li><li><p>17.3 阶乘尾零</p><blockquote><p>请设计一个算法，计算n的阶乘有多少个尾随零。</p></blockquote></li><li><p>17.4 无判断 max</p></li><li><p>17.5 珠玑妙算</p></li><li><p>17.6 最小调整有序</p></li><li><p>17.7 数字发音</p></li><li><p>17.8 最大连续数列和</p></li><li><p>17.9 词频统计</p></li><li><p>17.10</p></li><li><p>17.11</p></li><li><p>17.12 整数对查找</p></li><li><p>17.13 树转链表</p><blockquote></blockquote></li><li><p>17.14</p></li></ul><h2 id="_18-高难度题-13" tabindex="-1"><a class="header-anchor" href="#_18-高难度题-13" aria-hidden="true">#</a> 18 高难度题 (13)</h2><ul><li><p>18.1 另类加法</p><blockquote><p>请编写一个函数，将两个数字相加。不得使用+或其他算数运算符。</p></blockquote></li><li><p>18.2</p></li><li><p>18.3</p></li><li><p>18.4 2 的个数</p><blockquote><p>请编写一个方法，输出0到n(包括n)中数字2出现了几次。</p></blockquote></li><li><p>18.5 单词最近距离</p><blockquote><p>有一篇文章内含多个单词，现给定两个单词，请设计一个高效算法，找出文中这两个单词的最短距离(即最少相隔的单词数,也就是两个单词在文章中位置的差的绝对值)。</p></blockquote></li><li><p>18.6</p></li><li><p>18.7 最长合成字符串</p><blockquote><p>有一组单词，请编写一个程序，在数组中找出由数组中字符串组成的最长的串A，即A是由其它单词组成的(可重复)最长的单词。</p></blockquote></li><li><p>18.8 子串判断</p><blockquote><p>现有一个小写英文字母组成的字符串s和一个包含较短小写英文字符串的数组p，请设计一个高效算法，对于p中的每一个较短字符串，判断其是否为s的子串。</p></blockquote><table><thead><tr><th>解法</th><th>空间复杂度</th><th>时间复杂度</th><th>思路</th></tr></thead><tbody><tr><td>1</td><td>O(1)</td><td>O(n*m)</td><td>BF，暴力匹配，遍历字符串匹配比较</td></tr><tr><td>2</td><td>O(1)</td><td>O(?)</td><td>KMP，</td></tr></tbody></table></li><li><p>18.9 实时中位数</p><blockquote><p>现有一些随机生成的数字要将其依次传入，请设计一个高效算法，对于每次传入一个数字后，算出当前所有传入数字的中位数。(若传入了偶数个数字则令中位数为第n/2小的数字，n为已传入数字个数)。</p></blockquote></li><li><p>18.10 字符串变换</p><blockquote><p>现有一个字典，同时给定字典中的两个字符串s和t，给定一个变换，每次可以改变字符串中的任意一个字符，请设计一个算法，计算由s变换到t所需的最少步数，同时需要满足在变换过程中的每个串都是字典中的串。</p></blockquote></li><li><p>18.11 最大子方阵</p><blockquote><p>有一个方阵，其中每个单元(像素)非黑即白(非0即1)，请设计一个高效算法，找到四条边颜色相同的最大子方阵。</p></blockquote></li><li><p>18.12 最大和子矩阵</p><blockquote><p>有一个正整数和负整数组成的NxN矩阵，请编写代码找出元素总和最大的子矩阵。请尝试使用一个高效算法。</p></blockquote></li><li><p>18.13 最大字母矩阵</p><blockquote><p>有一个单词清单，请设计一个高效算法，计算由清单中单词组成的最大子矩阵，要求矩阵中的行和列都是清单中的单词。</p></blockquote></li></ul>',37);function p(d,b){return l(),h("div",null,[e(" more "),a])}const r=t(o,[["render",p],["__file","answer.html.vue"]]);export{r as default};

import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as n,a as s,f as o}from"./app-TyFLvDt8.js";const c={},t=o(`<h3 id="❓dart-是不是单线程模型-是如何运行的" tabindex="-1"><a class="header-anchor" href="#❓dart-是不是单线程模型-是如何运行的" aria-hidden="true">#</a> ❓<code>Dart</code> 是不是单线程模型，是如何运行的</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Dart</code> 是单线程执行模型，它的并发模型基于“事件循环”。</p></blockquote><p><code>Dart</code> 使用单线程事件循环模型，所有的 <code>Dart</code> 代码在一个称为 <code>Isolate</code> 的单线程执行环境中运行。每个 <code>Isolate</code> 有自己的内存堆，不同的 <code>Isolate</code> 之间不能共享内存，只能通过消息传递来交互。</p><p>事件循环可以看作是一个大循环，在这个循环中，<code>Dart</code> 语言会不断去检查事件队列，如果有事件（如用户交互、<code>I/O</code>、计时器等）就处理事件，事件处理完后再去检查下一个事件，如果事件队列为空则等待事件的发生。</p><p>由于 <code>Dart</code> 是单线程模型，所以针对某个特定的任务，假如这个任务特别耗时，会占据线程大量时间，其他任务就无法得到及时的处理，因此 <code>Dart</code> 中有 <code>Microtask</code> 和 <code>Event</code> 两种任务队列，<code>Microtask</code> 队列优先级高于 <code>Event</code> 队列。执行顺序为：先执行所有 <code>Microtask</code> 任务，然后再处理一个 <code>Event</code> 任务，再执行此 <code>Event</code> 产生的所有 <code>Microtask</code>，依此类推。</p></details><h3 id="❓dart-多任务如何并行的" tabindex="-1"><a class="header-anchor" href="#❓dart-多任务如何并行的" aria-hidden="true">#</a> ❓<code>Dart</code> 多任务如何并行的</h3><details class="hint-container details"><summary>💡</summary><p><code>Dart</code> 本身是单线程的，它依赖于事件循环和异步编程以便在单一线程中完成尽可能多的任务。对于需要并行计算或者诸如文件读写等阻塞性操作，<code>Dart</code> 提供了 <code>Isolate</code> 的概念。</p><p><code>Isolate</code> 可以被看作是 <code>Dart</code> 的轻量级线程。每个 <code>Isolate</code> 有其自己的内存堆并且不与其他 <code>Isolate</code> 共享内存。这避免了多线程环境中的常见问题，如线程锁定和数据紊乱等，并增强了安全性。但是，因为内存不共享，所以 <code>Isolates</code> 之间只能通通过消息传递进行通信。</p><p><code>Dart</code> 的并发实现：在单线程中处理异步任务，如果需要任务并行计算则可以创建多个 <code>Isolates</code> 来执行任务。</p><p>注意：虽然每个 <code>Isolate</code> 有自己的事件队列，但是创建、启动和管理 <code>Isolate</code> 需要相对较重的资源（比如内存和计算时间），并且消息传递和上下文切换也有一些开销。所以在确实需要的情况下才使用 <code>Isolate</code> 进行并发操作，例如处理 <code>CPU</code> 密集型任务或者进行大量的 <code>I/O</code> 操作。</p></details><h3 id="❓future-与-microtask-两者的执行顺序" tabindex="-1"><a class="header-anchor" href="#❓future-与-microtask-两者的执行顺序" aria-hidden="true">#</a> ❓<code>Future</code> 与 <code>microtask</code> 两者的执行顺序</h3><details class="hint-container details"><summary>💡</summary><p><code>Dart</code> 中的事件队列：</p><ul><li>事件队列 <code>Event Queue</code></li><li>微任务队列 <code>Microtask Queue</code></li></ul><p>区别：</p><ul><li><p><code>Future</code> 是将任务添加到 <code>Event Queue</code> 中，然后按照事件顺序来处理。</p></li><li><p><code>Microtask</code> 是将任务添加到 <code>Microtask Queue</code> 中。</p></li></ul><p>运行机制：</p><blockquote><p><code>Microtask Queue</code> 的优先级高于 <code>Event Queue</code>，执行顺序一般来说，<code>Microtask</code> 会在 <code>Future</code> 之前执行。</p></blockquote><ul><li><p>事件循环从 <code>Microtask Queue</code> 中获取任务，如果 <code>Microtask Queue</code> 中有任务，那么一直执行到 <code>Microtask Queue</code> 为空。</p></li><li><p>当 <code>Microtask Queue</code> 为空时，事件循环会检查 <code>Event Queue</code>，如果有任务，那么取出一个执行，然后再去执行 <code>Microtask Queue</code> 中的任务。</p></li></ul></details><h3 id="❓isolate-compute-是如何运行的" tabindex="-1"><a class="header-anchor" href="#❓isolate-compute-是如何运行的" aria-hidden="true">#</a> ❓<code>Isolate</code> <code>compute</code> 是如何运行的</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Isolate</code>: 内部创建一个新的、独立运行的执行线程，它有自己的内存（堆和栈），并运行一个事件循环。<code>Isolate</code> 可以运行重复或者持续的任务。</p><blockquote><p>例如计时器或者监听某个特定资源的变化，它有自身的生命周期，且可以一直运行，直到显式地被停止。</p></blockquote><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;dart:isolate&#39;</span></span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Isolate</span><span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span>printMessage<span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&#39;Hello, Isolate!&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>compute</code>：这个函数会创建一个新的 <code>Isolate</code>，执行给定的函数，并返回结果。当计算完成后，这个 <code>Isolate</code> 会被自动销毁。</p></li><li><p><code>compute</code>: <code>Flutter</code> 提供的便捷函数，它在内部使用 <code>Isolate</code>，并返回 <code>Future</code>，执行结束，创建的 <code>Isolate</code> 就会被销毁。更适用于处理单次耗时计算任务。</p><blockquote><p>例如一个复杂的排序、过滤操作。</p></blockquote><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;dart:isolate&#39;</span></span><span class="token punctuation">;</span>

int <span class="token function">longRunningCalculation</span><span class="token punctuation">(</span>int value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This could be a CPU-intensive operation that lasts a long time.</span>
  <span class="token keyword">return</span> value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  int result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">compute</span><span class="token punctuation">(</span>longRunningCalculation<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Will print: 20</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details>`,8);function d(i,l){return a(),n("div",null,[s(" more "),t])}const r=e(c,[["render",d],["__file","0x04.thread.html.vue"]]);export{r as default};

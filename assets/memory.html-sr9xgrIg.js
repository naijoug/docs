import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,a as e,f as o}from"./app-_jE41G-y.js";const t={},p=o(`<h2 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配" aria-hidden="true">#</a> 内存分配</h2><h3 id="❓oc-中一个-nsobject-对象-占几个字节" tabindex="-1"><a class="header-anchor" href="#❓oc-中一个-nsobject-对象-占几个字节" aria-hidden="true">#</a> ❓<code>OC</code> 中一个 <code>NSObject</code> 对象，占几个字节？</h3><details class="hint-container details"><summary>💡</summary><p>一个 <code>NSObject</code> 对象应该就是存放这个对象的指针地址。一个指针的大小应该是占用 16 个直接。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Todo<span class="token punctuation">:</span> NSObject 
<span class="token punctuation">{</span>
   <span class="token keyword">int</span><span class="token punctuation">:</span> _no<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _title<span class="token punctuation">;</span>
   String<span class="token punctuation">:</span> _detail<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓如何使用-uiimageview-显示一个超大图片-并且支持缩放功能" tabindex="-1"><a class="header-anchor" href="#❓如何使用-uiimageview-显示一个超大图片-并且支持缩放功能" aria-hidden="true">#</a> ❓如何使用 <code>UIImageView</code> 显示一个超大图片，并且支持缩放功能？</h3><details class="hint-container details"><summary>💡</summary><p>由于 <code>UIImageView</code> 通过 <code>UIImage</code> 加载图片，是一次性将图片加载到内存，超大图片会引发内存不足的的问题。所以这个时候不能一次全部加载，需要使用分治思想，将图片像素点分块加载，只加载可视区域像素点。使用 <code>Tile Rendering</code> 的解决方案，类似家庭装修贴地砖的方式，先将图片像素按照一定的大小分割成 <code>Tile</code>，然后根据图片显示区域渲染。<code>CATiledLayer</code> 是一种适用于处理大量数据的渲染的 layer，适合处理这种情况。 缩放功能可以通过将 <code>UIImageView</code> 嵌套在 <code>UIScrollView</code> 里面，根据缩放的代理回调，进行 <code>Tile</code> 的重新绘制。</p></details><h3 id="❓c-中-placement-new-特性-在-oc-中可以使用吗" tabindex="-1"><a class="header-anchor" href="#❓c-中-placement-new-特性-在-oc-中可以使用吗" aria-hidden="true">#</a> ❓<code>C++</code> 中 <code>placement new</code> 特性，在 <code>OC</code> 中可以使用吗？</h3><details class="hint-container details"><summary>💡</summary><p><code>placement new</code> : 是一种可以已分配内存的位置直接构造对象的特性，而这个已分配内存可以栈区也可以是堆区。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 栈内存</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 堆内存</span>
<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>OC</code> 是不具备这个特性，但是可以借助 <code>C</code> 语言分配内存。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// OC 常规方案</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Foo alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 C 分配内存</span>
Foo<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>foo init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="autoreleasepool-自动释放池" tabindex="-1"><a class="header-anchor" href="#autoreleasepool-自动释放池" aria-hidden="true">#</a> <code>autoreleasepool</code> - “自动释放池”</h2><h3 id="什么情况下需要手动创建-autoreleasepool" tabindex="-1"><a class="header-anchor" href="#什么情况下需要手动创建-autoreleasepool" aria-hidden="true">#</a> 什么情况下需要手动创建 <code>autoreleasepool</code> ？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>大量的对象在短时间内被创建和销毁，且会占用大量内存。在这种情况下，及时地回收内存非常重要。由于 <code>ARC</code>（自动引用计数）机制在一次 <code>RunLoop</code> 循环结束后才进行垃圾回收，所以如果不使用 <code>autoreleasepool</code>，那么在一次 <code>RunLoop</code> 循环期间创建的所有对象都不会被立刻释放，这可能会导致内存峰值的显著增加。使用 <code>autoreleasepool</code> 可以在代码块结束时立即释放这些对象，从而有效地降低内存峰值。</p></li><li><p>在子线程或者自定义的线程中运行的代码。默认情况下，只有主线程的 <code>RunLoop</code> 会自动创建 <code>autoreleasepool</code>，其他的线程需要我们手动创建。</p></li></ul><p>下面是一个使用 <code>autoreleasepool</code> 的例子：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">1000000</span> <span class="token punctuation">{</span>
  autoreleasepool <span class="token punctuation">{</span>
      <span class="token comment">// 这里面的代码在每次 loop 结束时，会自动释放掉使用了 autorelease 的所有对象</span>
      <span class="token keyword">let</span> image <span class="token operator">=</span> <span class="token class-name">UIImage</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;huge_image.png&quot;</span></span><span class="token punctuation">)</span>
      <span class="token function">print</span><span class="token punctuation">(</span>image<span class="token operator">?</span><span class="token punctuation">.</span>size <span class="token operator">??</span> <span class="token string-literal"><span class="token string">&quot;No image found&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，每一次循环，都会创建一个新的autorelease对象Image。这可能会消耗大量内存。使用<code>autoreleasepool</code>则可以保证在每次循环结束时，Image对象都能够被立即回收，从而有效控制内存使用。</p></details><h3 id="找-bug" tabindex="-1"><a class="header-anchor" href="#找-bug" aria-hidden="true">#</a> “找 bug”</h3><blockquote><p>❓以下代码存在什么问题？</p></blockquote><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> INT_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Test alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>申请对象时，在 <code>ARC</code> 编译期间，会添加 <code>autorelease</code>，将申请的对象加入到自动释放池中。如果在一个自动释放池申请大量对象，那么对象的释放都需要等到这个这个自动释放所在的 <code>RunLoop</code> 休眠或结束时才能释放，申请大量对象时会造成内存泄漏。这种情况下，需要将 <code>@autoreleasepool</code> 加入到 <code>for</code> 循环里面。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> INT_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
      Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Test alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><blockquote><p>❓^ 如果将 <code>for</code> 循环改为 <code>enumerateObjectsUsingBlock</code> 会不会有问题？</p></blockquote><details class="hint-container details"><summary>💡</summary><p>不会有问题，这是因为枚举器方法实现时，已经将 <code>block</code> 嵌套在 <code>@autoreleasepool</code> 中。</p></details><h2 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h2><h3 id="如果让你实现属性的-weak-如何实现的" tabindex="-1"><a class="header-anchor" href="#如果让你实现属性的-weak-如何实现的" aria-hidden="true">#</a> 如果让你实现属性的 <code>weak</code>，如何实现的？</h3><h2 id="内存分析" tabindex="-1"><a class="header-anchor" href="#内存分析" aria-hidden="true">#</a> 内存分析</h2><h3 id="app-内存是如何分析的" tabindex="-1"><a class="header-anchor" href="#app-内存是如何分析的" aria-hidden="true">#</a> app 内存是如何分析的？</h3><h3 id="内存泄漏可能会出现的几种原因" tabindex="-1"><a class="header-anchor" href="#内存泄漏可能会出现的几种原因" aria-hidden="true">#</a> 内存泄漏可能会出现的几种原因？</h3><blockquote><p>非 <code>OC</code> 对象如何处理？</p></blockquote><blockquote><p>如果常用框架出现内存泄漏如何处理？</p></blockquote>`,23);function c(i,l){return a(),s("div",null,[e(" more "),p])}const r=n(t,[["render",c],["__file","memory.html.vue"]]);export{r as default};

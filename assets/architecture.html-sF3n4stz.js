import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,a as d,f as h}from"./app-1T2PYfcf.js";const i={},c=h('<h2 id="架构设计" tabindex="-1"><a class="header-anchor" href="#架构设计" aria-hidden="true">#</a> 架构设计</h2><h3 id="🌀-从-0-开始做一个项目-你是如何架构思考的" tabindex="-1"><a class="header-anchor" href="#🌀-从-0-开始做一个项目-你是如何架构思考的" aria-hidden="true">#</a> 🌀 从 0 开始做一个项目，你是如何架构思考的？</h3><h3 id="设计一个时长统计模块" tabindex="-1"><a class="header-anchor" href="#设计一个时长统计模块" aria-hidden="true">#</a> _&gt; 设计一个时长统计模块</h3><h3 id="设计一个日志记录模块" tabindex="-1"><a class="header-anchor" href="#设计一个日志记录模块" aria-hidden="true">#</a> 设计一个日志记录模块</h3><h3 id="设计一个缓存模块-lrucache-算法怎么实现" tabindex="-1"><a class="header-anchor" href="#设计一个缓存模块-lrucache-算法怎么实现" aria-hidden="true">#</a> 设计一个缓存模块？LRUCache 算法怎么实现？</h3><h3 id="内存缓存策略有哪些-例如-lru策略-nscache使用什么缓存策略" tabindex="-1"><a class="header-anchor" href="#内存缓存策略有哪些-例如-lru策略-nscache使用什么缓存策略" aria-hidden="true">#</a> 内存缓存策略有哪些？（例如：LRU策略）NSCache使用什么缓存策略？</h3><h3 id="设计一个通用网络模块" tabindex="-1"><a class="header-anchor" href="#设计一个通用网络模块" aria-hidden="true">#</a> 设计一个通用网络模块</h3><h3 id="模块化分层设计方案" tabindex="-1"><a class="header-anchor" href="#模块化分层设计方案" aria-hidden="true">#</a> 模块化分层设计方案</h3><h2 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h2><h3 id="❓组件化设计思路" tabindex="-1"><a class="header-anchor" href="#❓组件化设计思路" aria-hidden="true">#</a> ❓组件化设计思路？</h3><details class="hint-container details"><summary>详情</summary><p>组件化：有时也称为“模块化”。将一个大的业务功能，按照不同的功能模块进行拆分。</p><p>拆分原则：类似 <code>SOLID</code> 原则。 * 单一职责原则 : 拆分的功能模块应该尽量做到功能单一。 * 接口隔离原则 : 功能模块尽量做到对外暴露接口的最小化。</p><p>分层原则：网上有一个借用经典四象限法则来划分(以 <strong>业务相关</strong>、<strong><code>UI</code> 相关</strong> 作为两个轴线，来进行组件化分层) * 业务功能层 : 业务有关 &amp; <code>UI</code> 有关。用户看到的主要功能页面。 * 业务逻辑层 : 业务有关 &amp; <code>UI</code> 无关。在用户使用业务功能时，背后的处理逻辑。 * <code>UI</code> 层 : 业务无关 &amp; <code>UI</code> 有关。通用的 <code>UI</code> 页面，不关联具体的业务逻辑。 * 基础层 : 业务无关 &amp; <code>UI</code> 无关。通用的基础功能。</p><p>单向依赖原则：组件之间的依赖关系，应该做到上层依赖下层，下层不要依赖上层。</p></details><h3 id="❓下层组件需要调用上层组件怎样处理" tabindex="-1"><a class="header-anchor" href="#❓下层组件需要调用上层组件怎样处理" aria-hidden="true">#</a> ❓下层组件需要调用上层组件怎样处理？</h3><details class="hint-container details"><summary>详情</summary><p>方案一：依赖注入方式。下层组件定义好钩子函数，注册时，将上层组件注入下层组件定义好的钩子函数。</p><p>方案二：间接访问。通过底层的路由组件，将上层组件注册到路由表中，这样下层组件就可以通过路由间接访问到上层组件。</p></details><h3 id="你是如何组件化解耦的" tabindex="-1"><a class="header-anchor" href="#你是如何组件化解耦的" aria-hidden="true">#</a> 你是如何组件化解耦的？</h3><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h2><h3 id="ios-单例实现" tabindex="-1"><a class="header-anchor" href="#ios-单例实现" aria-hidden="true">#</a> iOS 单例实现</h3><h3 id="ios-常用设计模式" tabindex="-1"><a class="header-anchor" href="#ios-常用设计模式" aria-hidden="true">#</a> iOS 常用设计模式？</h3><h3 id="m、v、c-相互通讯规则你知道的有哪些" tabindex="-1"><a class="header-anchor" href="#m、v、c-相互通讯规则你知道的有哪些" aria-hidden="true">#</a> <code>M、V、C</code> 相互通讯规则你知道的有哪些？</h3><h3 id="mvc、mvvm、coordinator" tabindex="-1"><a class="header-anchor" href="#mvc、mvvm、coordinator" aria-hidden="true">#</a> MVC、MVVM、Coordinator</h3><h3 id="单向数据流-redux、reswift、rxfeedback" tabindex="-1"><a class="header-anchor" href="#单向数据流-redux、reswift、rxfeedback" aria-hidden="true">#</a> 单向数据流 (Redux、ReSwift、RxFeedback)</h3><h2 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理" aria-hidden="true">#</a> 错误处理</h2><h3 id="容错处理一般是怎么做的" tabindex="-1"><a class="header-anchor" href="#容错处理一般是怎么做的" aria-hidden="true">#</a> 容错处理一般是怎么做的？</h3><h3 id="项目刚开始没做容错处理-如何防止拦截潜在的崩溃" tabindex="-1"><a class="header-anchor" href="#项目刚开始没做容错处理-如何防止拦截潜在的崩溃" aria-hidden="true">#</a> 项目刚开始没做容错处理，如何防止拦截潜在的崩溃？</h3><h3 id="如何检测-bug-和崩溃-包括线上版本" tabindex="-1"><a class="header-anchor" href="#如何检测-bug-和崩溃-包括线上版本" aria-hidden="true">#</a> 如何检测 <code>Bug</code> 和崩溃，包括线上版本？</h3>',24);function n(t,s){return e(),r("div",null,[d(" more "),c])}const u=a(i,[["render",n],["__file","architecture.html.vue"]]);export{u as default};

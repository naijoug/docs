import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,f as a}from"./app-LHYJVB-r.js";const d={},t=a('<h2 id="oc-中为什么使用-nonatomic-而非-atomic" tabindex="-1"><a class="header-anchor" href="#oc-中为什么使用-nonatomic-而非-atomic" aria-hidden="true">#</a> OC 中为什么使用 <code>nonatomic</code> 而非 <code>atomic</code>？</h2><h2 id="oc-中的-atomic-修饰符保证线程安全吗" tabindex="-1"><a class="header-anchor" href="#oc-中的-atomic-修饰符保证线程安全吗" aria-hidden="true">#</a> OC 中的 <code>atomic</code> 修饰符保证线程安全吗？</h2><h2 id="如何保证线程安全-与-atomic-有什么区别" tabindex="-1"><a class="header-anchor" href="#如何保证线程安全-与-atomic-有什么区别" aria-hidden="true">#</a> 如何保证线程安全，与 <code>atomic</code> 有什么区别？</h2><h2 id="gcd-vs-nsoperation" tabindex="-1"><a class="header-anchor" href="#gcd-vs-nsoperation" aria-hidden="true">#</a> <code>GCD</code> vs <code>NSOperation</code></h2><p><code>NSOperation</code> 是对 <code>GCD</code> 的封装，对比 <code>GCD</code> 多了添加任务依赖、优先级设置的功能。</p><p><code>GCD</code> (Grand Central Dispatch) : 直译为大中央调度，是一种多线程并发解决方案。底层使用线程池来管理线程，屏蔽了程序创建线程的工作。只需要指定任务运行队列(串行或并行队列)，以及任务运行方式(同步或异步)。</p><p><code>GCD</code> 中的队列</p><ul><li>主队列 : 串行队列</li><li>全局队列 : 并行队列</li><li>自定义队列 : 串行或并行队列</li></ul>',8),i=[t];function r(n,h){return o(),c("div",null,i)}const m=e(d,[["render",r],["__file","thread.html.vue"]]);export{m as default};

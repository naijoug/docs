import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as h,a as r,b as a,f as i}from"./app-y9eVcN9t.js";const c={},n=a("hr",null,null,-1),t=a("p",null,"title: thread - “多线程” icon: hashtag",-1),s=a("p",null,"index: true",-1),o=a("hr",null,null,-1),l=i('<hr><h2 id="概念知识" tabindex="-1"><a class="header-anchor" href="#概念知识" aria-hidden="true">#</a> 概念知识</h2><h3 id="说说你理解的多线程" tabindex="-1"><a class="header-anchor" href="#说说你理解的多线程" aria-hidden="true">#</a> 说说你理解的多线程？</h3><h3 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程" aria-hidden="true">#</a> 进程与线程</h3><details class="hint-container details"><summary>💡</summary><p>进程 : 程序的一次运行活动，各个进程之间相互资源独立。操作系统分配资源的基本单位，具有唯一的 PID 和 port 号。</p><p>线程 : 线程是进程的最小执行单位，同一个进程内的多个线程共享进程内的资源。</p></details><h3 id="协程与线程" tabindex="-1"><a class="header-anchor" href="#协程与线程" aria-hidden="true">#</a> 协程与线程</h3><details class="hint-container details"><summary>💡</summary><p>协程(Coroutine) : 也被称为“微线程”。运行在用户态，相比于线程具有极高的执行效率和极低的切换成本。</p></details><h3 id="并行-vs-串行" tabindex="-1"><a class="header-anchor" href="#并行-vs-串行" aria-hidden="true">#</a> 并行 vs 串行</h3><p>并行 (Concurrency) : 多个任务会同时执行。如果是多核 CPU 会是真正意义上并行，多个任务会在不同 CPU 上同时运行；如果是单核 CPU 是一种伪并行，是同一时间间隔上运行多个任务，CPU 在多个任务上切换运行，其实某一时刻上其实只有一个任务执行，由于 CPU 运行速度比较快，用户角度观察呈现并发状态。</p><hr><h2 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h2><h3 id="进程的通信机制" tabindex="-1"><a class="header-anchor" href="#进程的通信机制" aria-hidden="true">#</a> 进程的通信机制？</h3><h3 id="进程-a-和进程-b-通过管道通信的话是在同一个管道么" tabindex="-1"><a class="header-anchor" href="#进程-a-和进程-b-通过管道通信的话是在同一个管道么" aria-hidden="true">#</a> 进程 A 和进程 B 通过管道通信的话是在同一个管道么？</h3><hr><h2 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h2><h3 id="什么是线程安全" tabindex="-1"><a class="header-anchor" href="#什么是线程安全" aria-hidden="true">#</a> 什么是线程安全？</h3><h3 id="线程死锁的四个条件" tabindex="-1"><a class="header-anchor" href="#线程死锁的四个条件" aria-hidden="true">#</a> 线程死锁的四个条件？</h3><h3 id="主线程是相对于什么而言的" tabindex="-1"><a class="header-anchor" href="#主线程是相对于什么而言的" aria-hidden="true">#</a> 主线程是相对于什么而言的？</h3><h3 id="常见的线程同步策略" tabindex="-1"><a class="header-anchor" href="#常见的线程同步策略" aria-hidden="true">#</a> 常见的线程同步策略？</h3><ul><li><p><code>CAS</code></p><p><code>CAS</code>(Compare And Swap) : 比较并交换，是一种实现原子的机制，可以保证一个变量在读、写时的原子性。</p><p>基本原理：比较三个操作数，V (内存位置值)、A (原值)、B (新值)，比较 V 与 A，如果相等则将更新内存位置值交换为 B，如果不相等则不做交换操作。最后无论是否进行交换操作，都返回该位置的值。线程1 读取值后，在进行写时，将读取的值与要写入内存位置的值进行比较，这样如果线程2 在线程1 写之前修改了数据，那么比较的时候就会不相等，也就不能写入保证了原子性。</p><p><code>CAS</code> 会存在 <code>ABA</code> 问题。也就是说线程2 先将 A 修改为了 B，又将 B 修改为了 A，这样线程1 再进行比较时还是相等，但是其实数据已经是修改过了的。而解决 <code>ABA</code> 问题最常见的方案就是版本号，也就是每次修改数据时，都会加上一个版本号。原始版本号为 1，而线程1 读取数据时版本号为 1，当线程2 进行 <code>ABA</code> 数据修改后，版本号增长为了 3，则线程1 再进行比较时，就会知道 A 是修改后的了，也就不能写入。</p></li></ul><h3 id="sqlite-中的读写是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#sqlite-中的读写是线程安全的吗" aria-hidden="true">#</a> <code>sqlite</code> 中的读写是线程安全的吗？</h3><details class="hint-container details"><summary>💡</summary><p><code>SQLite</code> 本身支持多线程访问，但是线程安全性取决于在编译 <code>SQLite</code> 库时的设置。</p><p><code>SQLite</code> 在几个不同的线程安全级别下运行，这取决于编译时的配置选项：</p><ul><li><p>当 <code>SQLite</code> 被编译到非线程安全（<code>SQLITE_THREADSAFE=0</code>）模式时，它不允许多线程访问，某些线程安全的假设就无法保证了。</p></li><li><p>在多线程模式（<code>SQLITE_THREADSAFE=1</code>）下，核心 <code>SQLite</code> 库可以被多个线程同时安全访问，但是每个线程都需要使用一个不同的数据库连接。</p></li><li><p>当 <code>SQLite</code> 在序列化模式（<code>SQLITE_THREADSAFE=2</code>）下编译时，核心 <code>SQLite</code> 库可以被多个线程同时使用，并且一个数据库连接也能在多个线程之间共享。</p></li></ul></details><hr><h2 id="线程锁" tabindex="-1"><a class="header-anchor" href="#线程锁" aria-hidden="true">#</a> 线程锁</h2><h3 id="❓线程锁有哪些-那个性能最差" tabindex="-1"><a class="header-anchor" href="#❓线程锁有哪些-那个性能最差" aria-hidden="true">#</a> ❓线程锁有哪些？那个性能最差？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>读写锁(read/write-lock)</p></li><li><p>互斥锁(mutex-lock)</p></li><li><p>自旋锁(spin-lock)</p></li><li><p>递归锁(recursive-lock)</p></li><li><p>悲观锁</p></li><li><p>乐观锁</p></li></ul></details><h3 id="各种的线程锁的常见使用场景" tabindex="-1"><a class="header-anchor" href="#各种的线程锁的常见使用场景" aria-hidden="true">#</a> 各种的线程锁的常见使用场景？</h3><h3 id="线程锁的底层实现" tabindex="-1"><a class="header-anchor" href="#线程锁的底层实现" aria-hidden="true">#</a> 线程锁的底层实现?</h3><h3 id="锁和信号量的关系" tabindex="-1"><a class="header-anchor" href="#锁和信号量的关系" aria-hidden="true">#</a> 锁和信号量的关系？</h3><h3 id="信号量有什么功能是锁做不到的" tabindex="-1"><a class="header-anchor" href="#信号量有什么功能是锁做不到的" aria-hidden="true">#</a> 信号量有什么功能是锁做不到的？</h3><h3 id="如果让你设计读写锁-你怎么设计" tabindex="-1"><a class="header-anchor" href="#如果让你设计读写锁-你怎么设计" aria-hidden="true">#</a> 如果让你设计读写锁，你怎么设计？</h3><hr><h2 id="现代化" tabindex="-1"><a class="header-anchor" href="#现代化" aria-hidden="true">#</a> 现代化</h2><h3 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> <code>async/await</code></h3><hr><h2 id="线程设计" tabindex="-1"><a class="header-anchor" href="#线程设计" aria-hidden="true">#</a> 线程设计</h2><h3 id="进程间如何通信" tabindex="-1"><a class="header-anchor" href="#进程间如何通信" aria-hidden="true">#</a> 进程间如何通信？</h3><h3 id="线程间的通信方式" tabindex="-1"><a class="header-anchor" href="#线程间的通信方式" aria-hidden="true">#</a> 线程间的通信方式？</h3><h3 id="最多能开辟多少个进程和线程" tabindex="-1"><a class="header-anchor" href="#最多能开辟多少个进程和线程" aria-hidden="true">#</a> 最多能开辟多少个进程和线程？</h3><h3 id="一个线程打印奇数-一个线程打印偶数-打印-1-100" tabindex="-1"><a class="header-anchor" href="#一个线程打印奇数-一个线程打印偶数-打印-1-100" aria-hidden="true">#</a> 一个线程打印奇数，一个线程打印偶数，打印 1~100？</h3><h3 id="三个线程按照顺序打印-0-100" tabindex="-1"><a class="header-anchor" href="#三个线程按照顺序打印-0-100" aria-hidden="true">#</a> 三个线程按照顺序打印 0~100？</h3>',41);function u(p,f){return d(),h("div",null,[n,t,s,o,r(" more "),l])}const m=e(c,[["render",u],["__file","0x07.thread.html.vue"]]);export{m as default};

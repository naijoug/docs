import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,a as o,f as c}from"./app-YAxt81r4.js";const i={},r=c('<h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><h3 id="swift-中的-string-的设计理念" tabindex="-1"><a class="header-anchor" href="#swift-中的-string-的设计理念" aria-hidden="true">#</a> <code>Swift</code> 中的 <code>String</code> 的设计理念</h3><p>支持 <code>Unicode</code> 和字符串操作的安全性。不能直接使用下标索引访问，使用 <code>String.Index</code> 进行字符串的访问和操作。</p><h3 id="值类型-vs-引用类型" tabindex="-1"><a class="header-anchor" href="#值类型-vs-引用类型" aria-hidden="true">#</a> 值类型 vs 引用类型</h3><h3 id="swift-中基础类型-array、dictionary、set-为什么设计成值类型" tabindex="-1"><a class="header-anchor" href="#swift-中基础类型-array、dictionary、set-为什么设计成值类型" aria-hidden="true">#</a> <code>Swift</code> 中基础类型 <code>Array</code>、<code>Dictionary</code>、<code>Set</code> 为什么设计成值类型？</h3><h3 id="cow-copy-on-write" tabindex="-1"><a class="header-anchor" href="#cow-copy-on-write" aria-hidden="true">#</a> <code>cow</code>(Copy on Write)</h3><h3 id="inout-关键字做了什么" tabindex="-1"><a class="header-anchor" href="#inout-关键字做了什么" aria-hidden="true">#</a> <code>inout</code> 关键字做了什么？</h3><h3 id="swift-中的闭包" tabindex="-1"><a class="header-anchor" href="#swift-中的闭包" aria-hidden="true">#</a> <code>Swift</code> 中的闭包</h3><ul><li>逃逸闭包 : 闭包作为函数参数传入函数，如果这个闭包在函数返回之后再执行，则为逃逸闭包，闭包参数需要使用 <code>@escaping</code> 修饰。</li><li>非逃逸闭包 : 闭包作为函数参数，在函数返回之前，这个闭包已经执行，则为非逃逸闭包。</li><li>尾随闭包 : 将闭包作为函数的最后一个参数，函数调用时，闭包参数就是一个写在尾随函数调用后面的一个闭包表达式。</li><li>自动闭包 : 需要一个不接受参数的闭包作为函数参数，使用 <code>@autoclosure</code> 修饰。用作闭包表达式的延迟加载，只有当闭包表达式真正调用时才执行。</li></ul><h3 id="optional-可选类型的底层实现" tabindex="-1"><a class="header-anchor" href="#optional-可选类型的底层实现" aria-hidden="true">#</a> <code>Optional</code> 可选类型的底层实现</h3><h2 id="protocol" tabindex="-1"><a class="header-anchor" href="#protocol" aria-hidden="true">#</a> <code>protocol</code></h2><h2 id="codable" tabindex="-1"><a class="header-anchor" href="#codable" aria-hidden="true">#</a> <code>Codable</code></h2><h3 id="codable-实现原理" tabindex="-1"><a class="header-anchor" href="#codable-实现原理" aria-hidden="true">#</a> <code>Codable</code> 实现原理</h3><h2 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> <code>async/await</code></h2><h3 id="sendable" tabindex="-1"><a class="header-anchor" href="#sendable" aria-hidden="true">#</a> <code>Sendable</code></h3><p><code>Swift 5.5</code> 引入并发模型之后添加的。</p>',16);function t(h,n){return a(),d("div",null,[o(" more "),r])}const f=e(i,[["render",t],["__file","swift.html.vue"]]);export{f as default};

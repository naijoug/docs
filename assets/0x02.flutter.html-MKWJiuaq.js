import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c,a as o,f as t}from"./app-_Wf1jCxn.js";const i={},l=t('<h2 id="flutter" tabindex="-1"><a class="header-anchor" href="#flutter" aria-hidden="true">#</a> <code>Flutter</code></h2><h3 id="❓命令式-ui-vs-声明式-ui" tabindex="-1"><a class="header-anchor" href="#❓命令式-ui-vs-声明式-ui" aria-hidden="true">#</a> ❓命令式 <code>UI</code> vs 声明式 <code>UI</code></h3><details class="hint-container details"><summary>💡</summary><ul><li>命令式 : 告诉程序一步一步如何搭建所需要的界面，类似做菜的教程</li><li>声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单</li></ul><p>命令式 <code>UI</code> 和声明式 <code>UI</code> 是两种不同的用户界面编程范式。</p><ul><li><p>命令式 <code>UI</code>: 一种更为<strong>传统</strong>的编程范式，开发者需要手动管理 <code>UI</code> 的状态，当状态发生变化时，也需要手动更新 <code>UI</code>。</p><blockquote><p>例如，开发者需要知道何时调用 <code>UI</code> 库的方法去创建部件，并且保存这些部件的引用，以便之后可以更新或删除它们。命令式 <code>UI</code> 编程的挑战是同步状态和 <code>UI</code> 视图的复杂性。</p></blockquote></li><li><p>声明式 <code>UI</code>: 一种更为<strong>现代</strong>的编程范式，开发者仅需要声明 <code>UI</code> 应该如何根据当前状态进行展示，而无需手动管理 <code>UI</code> 的创建和更新。如果状态发生变化，<code>UI</code> 框架会自动重新构建 <code>UI</code>。</p><blockquote><p>在声明式 <code>UI</code> 中，状态和 <code>UI</code> 视图的同步已经被内部处理，开发者可以专注于描述 <code>UI</code> 的外观和行为，而不需要关注如何同步状态和视图。</p></blockquote></li></ul><p>对比：</p><ul><li>命令式 <code>UI</code> 的优点包括更细粒度的控制，但缺点是需要手动管理 <code>UI</code> 和状态的同步。</li><li>声明式 <code>UI</code> 的优点是简化了状态管理，使 <code>UI</code> 代码更清晰，但缺点是它通常需要更多的内存和 <code>CPU</code> 来处理 <code>UI</code> 的自动更新。</li></ul></details><h3 id="❓flutter-与-rn-react-native-不同之处" tabindex="-1"><a class="header-anchor" href="#❓flutter-与-rn-react-native-不同之处" aria-hidden="true">#</a> ❓<code>Flutter</code> 与 <code>RN</code> (<code>React Native</code>) 不同之处</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>开发语言：</p><ul><li><code>React Native</code> 使用的是 `JavaScript</li><li><code>Flutter</code> 使用的是 <code>Dart</code></li></ul></li><li><p><code>UI</code> 组件</p><ul><li><code>React Native</code> 依赖于原生控件来呈现用户界面，这可能会导致在不同平台之间的 <code>UI</code> 和 <code>UX</code> 有所不同。</li><li><code>Flutter</code> 有一套自己的 <code>Widget</code>（包含 <code>Material</code> 和 <code>Cupertino</code>），这些 <code>Widget</code> 完全用 <code>Dart</code> 实现，并且在不同的平台中有着一致的行为和外观。</li></ul></li><li><p>性能：由于 <code>Flutter</code> 使用 <code>Dart</code> 语言，并使用自身的高性能渲染引擎进行绘制，所以一般情况下，<code>Flutter</code> 的性能要优于 <code>React Native</code>。</p></li><li><p>社区和生态系统</p><ul><li><code>React Native</code> 由于发布得更早，并且得益于庞大的 <code>JavaScript</code> 社区，其生态系统相对较成熟，提供的第三方库也更多。</li><li><code>Flutter</code> 起步较晚，但由于其出色的设计和性能，社区发展也非常迅速，并且得到了 <code>Google</code> 的大力推广和支持。</li></ul></li><li><p>热重载：都支持热重载功能，但 <code>Flutter</code> 的热重载速度通常更快。</p></li><li><p>学习曲线：</p><ul><li>对于已经熟悉 <code>JavaScript</code> 的开发者来说，<code>React Native</code> 的学习曲线可能会相对较缓和容易。</li><li><code>Dart</code> 其语言特性与 <code>Java</code> 和 <code>C#</code> 等主流语言相近，因此对已有这些背景的开发者来说，学习曲线也并不陡峭。</li></ul></li></ul></details><h3 id="❓flutter-跨平台是如何实现的" tabindex="-1"><a class="header-anchor" href="#❓flutter-跨平台是如何实现的" aria-hidden="true">#</a> ❓<code>Flutter</code> 跨平台是如何实现的</h3><details class="hint-container details"><summary>💡</summary><p><code>Flutter</code> 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。</p><ul><li><p>界面渲染 : 内置的高性能渲染引擎。</p><ul><li><code>Skia</code> 绘制引擎进行视图的统一渲染。 <blockquote><p>相比于其他跨平台解决方案，如 <code>React Native</code> 或者 <code>Cordova</code> 这种依赖于原生控件的方式，<code>Flutter</code> 自己在引擎层面提供了一套 <code>2D</code> 渲染引擎，使用 <code>OpenGL</code> 或 <code>Vulkan</code> 等底层图形库直接与设备硬件交互，再加上其以 <code>Dart</code> 语言为基础的高效调度机制，使得 <code>Flutter</code> 可以在 <code>Android</code> 和 <code>iOS</code> 系统上执行高效的 <code>GPU</code> 渲染。</p></blockquote></li><li>丰富的组件。 <blockquote><p>在Flutter中，所有的组件 (<code>Widget</code>) 都是由底层绘制，并提供了 <code>Material</code> 和 <code>Cupertino</code> 两套设计语言风格的控件。</p></blockquote></li></ul></li><li><p>原生通信 : 通过 <code>Channel</code> 机制进行与原生进行交互，实现特定的 <code>Plugin</code> 来访问原生功能。</p><ul><li><code>BasicMessageChannel</code> : 用于基本的字符串信息通信</li><li><code>MethodChannel</code> : 方法调用通信</li><li><code>EventChannel</code> : 数据流通信</li></ul></li></ul></details><h3 id="❓为什么说-flutter-是原生的" tabindex="-1"><a class="header-anchor" href="#❓为什么说-flutter-是原生的" aria-hidden="true">#</a> ❓为什么说 <code>Flutter</code> 是原生的</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>性能接近原生：<code>Flutter</code> 使用 <code>Dart</code> 语言，<code>Dart</code> 代码会被直接编译为机器代码，无须额外的 <code>JavaScript</code> 桥接层，因此性能与原生接近。而且 <code>Flutter</code> 引擎中有自己的图形渲染引擎，直接利用 <code>GPU</code> 进行渲染，因此图形渲染性能非常高。</p></li><li><p>访问原生功能：虽然 <code>Flutter</code> 的 <code>UI</code> 构建是独立于平台的，但是它的插件系统允许 <code>Flutter</code> 访问每个平台的原生代码，如相机、定位、蓝牙等。开发者也可以编写自定义插件，调用原生 <code>API</code>，实现自定义功能。</p></li><li><p>构建原生应用：<code>Flutter</code> 构建的应用程序是真正的 <code>iOS</code> 和 <code>Android</code> 应用程序，它会被编译成 <code>ARM</code> 或 <code>x86</code> 二进制代码，可以直接在设备上运行，不依赖于任何 <code>WebView</code>。</p></li><li><p>原生般的用户体验：<code>Flutter</code> 为 <code>Android</code> 和 <code>iOS</code> 提供了分别遵循 <code>Material</code> 和 <code>Cupertino</code> 设计语言的两套 <code>Widget</code>，它们完全用 <code>Dart</code> 实现，有着一致的行为和外观，细节也处理得非常好。最终给用户带来的就是与原生应用无异的体验。</p></li></ul></details><h3 id="❓flutter-的优缺点" tabindex="-1"><a class="header-anchor" href="#❓flutter-的优缺点" aria-hidden="true">#</a> ❓<code>Flutter</code> 的优缺点</h3><details class="hint-container details"><summary>💡</summary><p>优点：</p><ul><li><p>高性能： <code>Flutter</code> 使用 <code>Dart</code> 语言开发，<code>Dart</code> 语言执行效率高，节省了不少性能；<code>Flutter</code> 引擎中有自己的图形渲染引擎，直接利用 <code>GPU</code> 进行渲染，因此图形渲染性能非常高，避免了 <code>JavaScript</code> 桥接层。</p></li><li><p>开发效率高：<code>Flutter</code> 支持热重载，进行小的更改可以在几秒内在设备或模拟器上看到效果。</p></li><li><p>良好的用户体验：<code>Flutter</code> 不需要借助第三方库也可以实现良好的界面体验。引入了自己的设计和交互模式，使 <code>UI</code> 设计在不同的平台上看起来很一致。</p></li><li><p>跨平台： 编写一套代码，即可在 <code>iOS</code> 和 <code>Android</code> 上运行。</p></li><li><p>强大的社区支持：虽然 <code>Flutter</code> 还相对较新，但由于它是由 <code>Google</code> 建立并支持，因此已经有了一个很大，积极的社区。</p></li></ul><p>缺点：</p><ul><li><p>编程语言：<code>Dart</code> 不如 <code>JavaScript</code> 那么流行，如果团队成员还不熟悉 <code>Dart</code> 的话，可能需要花一些时间去学。</p></li><li><p>类库生态：由于 <code>Flutter</code> 比 <code>React</code> 或者 <code>React Native</code> 等其他一些框架发布得晚，所以 <code>Flutter</code> 提供的开放源代码库和框架没有那么多。</p></li><li><p>包体积大小：<code>Flutter</code> 应用程序的基础大小相对较大，尽管团队正在努力进行优化，但是如果正在开发应该尽可能小的应用程序，这可能是需要考虑的因素。</p></li></ul></details><hr><h2 id="widget" tabindex="-1"><a class="header-anchor" href="#widget" aria-hidden="true">#</a> <code>Widget</code></h2><h3 id="❓listview-与-sliver-区别" tabindex="-1"><a class="header-anchor" href="#❓listview-与-sliver-区别" aria-hidden="true">#</a> ❓<code>ListView</code> 与 <code>Sliver</code> 区别</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ListView</code>: 一个常用的滚动列表控件，可以包含多个子控件并在垂直或水平方向滚动。</p><blockquote><p>最常用的长列表展示的控件，适用于大多数的滚动列表场景，例如新闻和社交应用里的信息流。</p></blockquote></li><li><p><code>Sliver</code>: 一种特殊类型的可滚动组件，在效果上可以实现更为复杂的滚动模型和高级效果。</p><blockquote><p>如折叠工具栏(<code>Collapsing Toolbar</code>)，或者在滚动时改变其他元素的布局。这些效果在 <code>ListView</code>中不能直接实现，需要使用 <code>Sliver Widget</code> 进行布局。</p></blockquote></li></ul><p>总结：<code>ListView</code>更简单直接，方便快速构建滚动列表；<code>Sliver</code>为开发者提供了更多的可能性和自由度，来构建高级和富交互的滚动效果，但使用和理解起来相对较复杂一些。</p></details><hr><h2 id="lifecycle-生命周期" tabindex="-1"><a class="header-anchor" href="#lifecycle-生命周期" aria-hidden="true">#</a> <code>lifecycle</code> - “生命周期”</h2><h3 id="❓flutter-的生命周期" tabindex="-1"><a class="header-anchor" href="#❓flutter-的生命周期" aria-hidden="true">#</a> ❓<code>Flutter</code> 的生命周期</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>应用级别的生命周期</p><ul><li><code>created</code>（应用程序启动）</li><li><code>running</code>（应用程序处于激活状态，界面可见）</li><li><code>paused</code>（应用程序处于非激活状态，界面不可见）</li><li><code>suspended</code>（应用程序被系统暂停）。</li></ul></li><li><p><code>Widget</code> 级别的生命周期</p><ul><li><code>createState()</code>: 创建状态，当构建一个新的 <code>StatefulWidget</code> 时，会立即调用此方法。</li><li><code>initState()</code>: 初始化，在创建 <code>State</code> 对象后调用，在整个生命周期中只会被调用一次。</li><li><code>didChangeDependencies()</code>: 状态改变时调用，可能会被多次调用。</li><li><code>build()</code>: 构建方法，用于构建 <code>UI</code> 界面，可能会被多次调用。</li><li><code>didUpdateWidget()</code>: 当 <code>Widget</code> 中的配置改变时就会调用此函数。</li><li><code>deactivate()</code>: 移除时调用，当 <code>State</code> 对象从树中被移除时，会调用此方法。</li><li><code>dispose()</code>: 销毁时调用，当 <code>State</code> 对象永久从树中被移除时，会调用此方法，常用于资源清理。</li></ul></li></ul></details><h3 id="❓flutter-中-didchangedependencies-哪些情况下会触发" tabindex="-1"><a class="header-anchor" href="#❓flutter-中-didchangedependencies-哪些情况下会触发" aria-hidden="true">#</a> ❓<code>Flutter</code> 中 <code>didChangeDependencies()</code> 哪些情况下会触发</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>第一次构建 <code>Widget</code> 时: 在生命周期内，这是 <code>State</code> 对象第一次创建完后会调用的方法，当 <code>State</code> 对象的依赖发生变化后也会调用此方法。</p></li><li><p>调用 <code>initState</code> 后: 初始化状态后，系统总是马上调用 <code>didChangeDependencies</code> 函数。</p></li><li><p><code>InheritedWidget</code>改变时: 如果当前 <code>State</code> 对象依赖的 <code>InheritedWidget</code> 发生改变（即数据发生改变），会重新构建当前 <code>Widget</code>（即调用 <code>build</code> 方法），之前会调用 <code>didChangeDependencies</code> 方法。</p></li><li><p>使用 <code>Theme.of(context)</code> 或 <code>MediaQuery.of(context)</code> 等类似方法时，它们内部使用 <code>InheritedWidget</code> 来共享数据，所以它们可能会改变，然后触发 <code>didChangeDependencies()</code>。</p></li><li><p>使用 <code>Navigator.of(context)</code> 调用时: 如果 <code>Widget</code> 的构造函数引用了与它有关联关系的数据，一旦这些数据改变， <code>didChangeDependencies()</code> 就会被触发。</p></li></ul></details><h3 id="❓flutter-如何统一管理错误页面" tabindex="-1"><a class="header-anchor" href="#❓flutter-如何统一管理错误页面" aria-hidden="true">#</a> ❓<code>Flutter</code> 如何统一管理错误页面</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>ErrorWidget.builder</code>：<code>Flutter</code> 框架级别的错误页面处理方法，所有的 <code>Widget</code> 错误都会走这里，但这里只会处理非 <code>debug</code> 模式(生产模式)下的错误。</p></li><li><p>使用 <code>FutureBuilder</code> 或 <code>StreamBuilder</code>：对于网络请求等异步操作产生的错误，通过 <code>builder</code> 属性中判断请求状态，如果发生错误，则展示错误页面。</p></li><li><p>使用 <code>Flutter</code> 的路由管理：针对特定的路由展示特殊的错误页面。比如当路由到某页面时，预加载数据发生错误，可以直接展示错误页面。</p></li><li><p>使用 <code>try-catch</code>：在可能发生异常的操作中使用 <code>try-catch</code>，如果捕获到异常就展示相应的错误页面。</p></li><li><p>自定义预期内的错误：如网络请求返回码非成功码，可以抛出自定义异常，然后在上层统一捕获并处理。</p></li><li><p>全局错误页面：可以通过设置 <code>Flutter</code> 的 <code>navigatorObservers</code>，当发生错误的时候，导航到特定的错误页面。</p></li></ul></details><hr><h2 id="触摸事件" tabindex="-1"><a class="header-anchor" href="#触摸事件" aria-hidden="true">#</a> 触摸事件</h2><h3 id="❓hittest-和-dispatchevent" tabindex="-1"><a class="header-anchor" href="#❓hittest-和-dispatchevent" aria-hidden="true">#</a> ❓<code>hitTest</code> 和 <code>dispatchEvent</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>hitTest</code> 和 <code>dispatchEvent</code> 是配合使用的。首先通过 <code>hitTest</code> 找到用户触摸的 <code>Widget</code>，然后通过 <code>dispatchEvent</code> 给找到的 <code>Widget</code> 分发事件。两者是构成 <code>Flutter</code> 触摸事件系统的重要组成部分。</p></blockquote><ul><li><p><code>hitTest</code>: 主要用于检测用户的触摸操作是否击中了某个 <code>Widget</code>。</p><blockquote><p>当用户触摸屏幕时，会触发 <code>hitTest</code> 方法来确定用户究竟触摸到了哪个 <code>Widget</code>。<code>hitTest</code> 方法需要一个命中测试对象（一个表示屏幕上一个点的对象，比如一个 <code>Offset</code>）作为参数。<code>hitTest</code> 在 <code>Widget</code> 树中进行，从根节点开始，沿着树形结构，一直走到叶节点。结果存储在由 <code>HitTestResult</code> 类实例化的对象中，这个对象被称为 “命中测试结果”。</p></blockquote></li><li><p><code>dispatchEvent</code>: 主要用于分发触摸事件。</p><blockquote><p>当 <code>hitTest</code> 命中测试结束后，系统知道了用户触摸到的 <code>Widget</code>，然后就会将这个触摸事件分发给这个 <code>Widget</code>，这个过程就是通过调用 <code>dispatchEvent</code> 来完成的。<code>dispatchEvent</code> 需要一个触摸事件（<code>PointerEvent</code>）作为参数，它的分发是从命中测试路径的末尾（也就是最顶层的 <code>Widget</code>）开始的，然后一直往路径的开始返回，直到所有的 <code>Widget</code> 都收到了这个事件或者有一个 <code>Widget</code> 消耗了它（返回true）。</p></blockquote></li></ul></details><hr><h2 id="滑动原理" tabindex="-1"><a class="header-anchor" href="#滑动原理" aria-hidden="true">#</a> 滑动原理</h2>',29);function a(r,u){return d(),c("div",null,[o(" more "),l])}const h=e(i,[["render",a],["__file","0x02.flutter.html.vue"]]);export{h as default};

import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as a,o as c,c as h,a as n,b as t,e as d,d as r,f as l}from"./app-_-qFKnfQ.js";const i={},s=t("p",null,[d("“内存”顾名思义就是我们平常所说的电脑内存条。专业术语：随机存取存储器 "),t("code",null,"RAM"),d("(Random Access Memory)。这个随机存取是重点，表明了存储器的特性，指定的是访问存储器的任意位置数据的时间周期都是恒定的。")],-1),b=t("h2",{id:"reference",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),d(" reference")],-1),p={href:"https://zhuanlan.zhihu.com/p/82746153",target:"_blank",rel:"noopener noreferrer"},u={href:"https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/",target:"_blank",rel:"noopener noreferrer"},m=l('<h2 id="存储器" tabindex="-1"><a class="header-anchor" href="#存储器" aria-hidden="true">#</a> 存储器</h2><table><thead><tr><th>访问方式</th><th>存储器</th></tr></thead><tbody><tr><td>顺序存取(Sequential Access)</td><td>这类存储器已经比较远古，磁带、黑胶唱片。</td></tr><tr><td>随机存取(Random Access)</td><td>内存条 <code>RAM</code>(Random Access Memory)、磁盘存储器 <code>HDD</code>(Hard Disk Drive)、固态硬盘 <code>SSD</code> (Solid-State Drive)。</td></tr></tbody></table><p>顺序存取的介质，访问数据时都必须重头开始，所以访问速度是不如随机存储的存储器的。使用过的磁带的朋友应该很好理解这个过程，每次要听指定位置的歌曲，都必须重头开始不停快进才能定位指定位置。那说完顺序存取存储器，那接下来说说随机存取存储器的问题。</p><blockquote><p>大家都是随机存取(Random Access)为什么“内存”访问速度快？</p></blockquote><p>这些存储的访问速度的快慢就与存储数据介质材料和制造工艺有关。</p><table><thead><tr><th>存储器</th><th>制造工艺</th><th>工作原理</th></tr></thead><tbody><tr><td>RAM</td><td>半导体</td><td>通过改变电子状态来实现数据存储</td></tr><tr><td>HDD</td><td>磁性材料</td><td>通过磁头对磁盘的的磁性状态改变，来实现数据存储</td></tr><tr><td>SSD</td><td>晶体管</td><td>通过向晶体管加电，改变电荷数量来实现数据的存储</td></tr></tbody></table><h2 id="内存分区" tabindex="-1"><a class="header-anchor" href="#内存分区" aria-hidden="true">#</a> 内存分区</h2><p>一个程序启动时，会被操作系统分配一块内存区域。程序运行过程中，又将得到的这块内存区域分为如下五个区域。其中代码区、常量区、全局/静态区大小在程序加载之后，大小不变。栈区和堆区的内存大小会根据程序运行过程中动态调整。</p><table><thead><tr><th>分区</th><th>说明</th></tr></thead><tbody><tr><td>代码区</td><td>存放程序的二进制代码，这块区域在程序加载到内存中之后大小不变</td></tr><tr><td>常量区</td><td>程序定义的常量存储区域</td></tr><tr><td>全局/静态区</td><td>存放程序定义的全局和静态变量</td></tr><tr><td>栈区</td><td>由操作系统分配和管理，主要存储局部变量、函数参数等</td></tr><tr><td>堆区</td><td>由程序员手动申请和释放，如果管理不当会导致内存泄漏的问题</td></tr></tbody></table><ul><li><p>程序可执行文件结构</p><table><thead><tr><th>类型</th><th>可读写</th><th>说明</th></tr></thead><tbody><tr><td><code>.text</code></td><td>只读</td><td>代码区</td></tr><tr><td><code>rodata</code></td><td>只读</td><td>常量区</td></tr><tr><td><code>.data</code></td><td>读写</td><td>全局变量和静态变量区 (已经初始化)</td></tr><tr><td><code>.bss</code></td><td>读写</td><td>全局变量和静态变量区 (未初始化)</td></tr><tr><td><code>heap</code></td><td>读写</td><td>堆区</td></tr><tr><td><code>stack</code></td><td>读写</td><td>栈区</td></tr></tbody></table></li><li><p>全局变量 &amp; 静态变量</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>全局变量</code></td><td>变量在整个项目中都能使用，不同文件不能命名相同的全局变量名</td></tr><tr><td><code>静态变量</code></td><td>static 对变量进行了作用域限制 (函数外: 当前文件可见 ; 函数内: 当前函数可见，多次调用不会丢失)</td></tr></tbody></table></li><li><p>内存分配</p><table><thead><tr><th>地址分类</th><th>说明</th></tr></thead><tbody><tr><td><code>虚拟地址</code></td><td>用户编程时将代码分成若干个段，每段代码的地址 = <code>段名称 + 段内相对地址</code></td></tr><tr><td><code>逻辑地址</code></td><td>虚拟地址中的段内相对地址</td></tr><tr><td><code>物理地址</code></td><td>实际物理内存中所看到的存储地址</td></tr></tbody></table></li></ul><h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h2><p>堆区的内存是由程序员申请使用，大多数现代编程语言为了提高编程效率，都实现了自动内存管理。而垃圾回收 <code>GC</code>(Garbage Collection)是自动内存管理中常使用的技术。</p><table><thead><tr><th>垃圾回收技术</th><th>说明</th></tr></thead><tbody><tr><td>标记清除 (Mark - Sweep)</td><td>标记阶段遍历内存区域，标记对象的是否还存活；清除阶段，将已不在使用的内存区域回收清理。</td></tr><tr><td>引用计数 (Reference Counting)</td><td>顾名思义，堆每块分配的内存区域对象设置一个计数器。每当引用一次该内存区域数据时，进行计数器 +1，不使用时进行 -1。当引用计数为 0 时表明该区域内存可以回收。引用计数会存在循环引用的问题。</td></tr><tr><td>分代回收 (Generational)</td><td>将内存划分为若干代(新生代、老年代)，经过多次垃圾回收仍然存活的对象会被移动到老年代区域。</td></tr></tbody></table><table><thead><tr><th>编程语言</th><th>内存管理</th></tr></thead><tbody><tr><td><code>C++</code></td><td>C++ 11 之后添加了智能指针，使用引用计数计数</td></tr><tr><td><code>Java</code></td><td>分代垃圾回收技术</td></tr><tr><td><code>Python</code></td><td>以引用计数为主，结合使用标记清除和分代回收技术</td></tr><tr><td><code>Swift</code></td><td>自动引用计数 <code>ARC</code>(Automatic Reference Counting)</td></tr><tr><td><code>JavaScript</code></td><td>标记-清除(Mark Sweep)技术</td></tr></tbody></table><h2 id="内存对齐" tabindex="-1"><a class="header-anchor" href="#内存对齐" aria-hidden="true">#</a> 内存对齐</h2><p>先说说数据的内存分布，基础的数据类型来说，<code>Int</code> 在 32 位机器上占用 4 字节，在 64 位机器上占用 8 个字节；<code>Float</code> 占用 4 个字节；<code>Double</code> 占用 8 字节；<code>Bool</code> 占用 1 字节；<code>String</code> 占用 16 字节。<code>struct</code> 结构体的内存占用与其包含的数据类型的占用有关系；<code>class</code> 是引用类型，所以内存占用就是指针内存占用，在 32位机器上占用 4 字节，64 位机器上占用 8 字节。</p><p>还需要了解一个概念就是内存与 CPU 的交互。我们常说的 32 位、64位指的就是计算 CPU 的最大计算能力，也就是 CPU 上的寄存器的宽度。而 CPU 与内存交互调度的过程中，数据总线调度的最大宽度就是寄存器的这个宽度。为了提高 CPU 读取内存效率，最好在一个时钟周期内，读取数据的宽度刚好为这个宽度为最优。</p><p>数据类型根据类型不同，占用的字节数可能存在不会刚好等于这个宽度。而“内存对齐”就是为了解决这个问题的。为了提高 CPU 读取内存效率，64 位机器来说，会将数据按照 8 字节的倍数进行对齐和排列，这样 CPU 在读取过程会，数据的起始地址都是 8 的倍数(例如 Float 类型数据只占用 4 个字节，后面会填充 4 个字节的空隙，后面再布局其它类型数据)。这样会照成一定的内存浪费，但是提高了 CPU 处理速度，是一种以空间换时间的优化方案。</p><h2 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏" aria-hidden="true">#</a> 内存泄漏</h2><p>对于计算机来说内存是有限了，程序使用内存时，如果申请了内存而未释放，这就会引起内存泄漏。通俗一点理解，将内存比如成一堆砖头，如果使用内存的码农都只借砖头，而不将砖头换回来，最后就会造成计算内存不足。</p>',20);function _(f,y){const e=a("ExternalLinkIcon");return c(),h("div",null,[s,n(" more "),b,t("ul",null,[t("li",null,[t("a",p,[d("什么是虚拟内存(Virtual Memory)?"),r(e)])]),t("li",null,[t("a",u,[d("虚拟内存的那点事儿"),r(e)])])]),m])}const S=o(i,[["render",_],["__file","memory.html.vue"]]);export{S as default};

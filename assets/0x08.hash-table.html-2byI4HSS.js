import{_ as d}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as u,c as h,a,b as e,e as l,d as n,w as r}from"./app-wImInECU.js";const _={},p=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),l(" reference")],-1),b={href:"https://visualgo.net/zh/hashtable/print",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/apple/swift-corelibs-foundation/blob/main/CoreFoundation/Collections.subproj/CFDictionary.c",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/apple/swift/blob/main/stdlib/public/core/Dictionary.swift",target:"_blank",rel:"noopener noreferrer"},g=e("hr",null,null,-1),k={href:"https://github.com/apple/swift-collections/blob/main/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary.swift",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/LinkedHashMap.java",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/python/cpython/blob/main/Lib/collections/__init__.py#L83",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"lru-cache-最近最少使用缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#lru-cache-最近最少使用缓存","aria-hidden":"true"},"#"),l(),e("code",null,"LRU Cache"),l(" - “最近最少使用缓存”")],-1),O={href:"https://leetcode.cn/problems/lru-cache",target:"_blank",rel:"noopener noreferrer"},j=e("blockquote",null,[e("p",null,[e("code",null,"get"),l(),e("code",null,"put"),l(" 操作需要 O(1) 的平均时间复杂度")])],-1),C={class:"hint-container details"},L=e("summary",null,"💡",-1),w=e("p",null,"【思路】: 哈希表 + 双向链表",-1),D=e("ul",null,[e("li",null,"首先解决数据的缓存问题。由于需要 O(1) 的时间复杂度，所以应该很自然的想到了使用哈希表来保存数据。这样保存和查询都可以做到 O(1) 的时间复杂度。"),e("li",null,[l("再来解决最近最少使用的问题。这需要使用双向链表的结构来保存数据，链表头部为最少使用的数据，链表尾部为最近使用的数据。 "),e("ul",null,[e("li",null,"查询数据时，这个查询过的数据为最近使用，也就是需要移除就之前链表中的这个数据，将这个数据重新加入到链表尾部。"),e("li",null,"添加数据时，如果这个 key 已存在，则移除旧数据，将新数据加入链表尾部；如果 key 不存在，需要判断缓存是否已满，如果已满则移除链表头部最少使用数据，添加新数据到链表尾部，如果未满则直接添加新数据到链表尾部。")])])],-1),N=e("div",{class:"language-java line-numbers-mode","data-ext":"java"},[e("pre",{class:"language-java"},[e("code",null,`
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),T=e("h2",{id:"lfu-cache-最不经常使用缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#lfu-cache-最不经常使用缓存","aria-hidden":"true"},"#"),l(),e("code",null,"LFU Cache"),l(" - “最不经常使用缓存”")],-1),U={href:"https://leetcode.cn/problems/lfu-cache",target:"_blank",rel:"noopener noreferrer"},F=e("blockquote",null,[e("p",null,[e("code",null,"get"),l(),e("code",null,"put"),l(" 操作需要 O(1) 的时间复杂度")])],-1),S=e("details",{class:"hint-container details"},[e("summary",null,"💡"),e("p",null,"【思路】: 双哈希表"),e("ul",null,[e("li",null,[l("数据缓存的问题。同 "),e("code",null,"LRU"),l(" 一样需要哈希表来保证数据存取的 O(1) 的时间复杂度。")]),e("li",null,"最不经常时间的问题。这个需要为没有数据加上一个 frequency 使用频率计数值来进行标记。关键点在于需要 O(1) 时间复杂度，那么使用")])],-1);function V(q,B){const t=o("ExternalLinkIcon"),i=o("CodeTabs");return u(),h("div",null,[a(" more "),p,e("ul",null,[e("li",null,[e("a",b,[l("哈希表"),n(t)])]),e("li",null,[e("a",f,[l("NSDictionary"),n(t)])]),e("li",null,[e("a",m,[l("Swift- Dictionary"),n(t)])])]),g,a(" `Ordered Hash Table` - “有序哈希表” "),e("ul",null,[e("li",null,[e("a",k,[l("Swift - OrderedDictionary"),n(t)])]),e("li",null,[e("a",v,[l("Java - LinkedHashMap"),n(t)])]),e("li",null,[e("a",y,[l("Python - OrderedDict"),n(t)])])]),x,e("ul",null,[e("li",null,[e("a",O,[l("🟠 146 - LRU 缓存"),n(t)]),j])]),e("details",C,[L,w,D,n(i,{id:"84",data:[{id:"java"}]},{title0:r(({value:s,isActive:c})=>[l("java")]),tab0:r(({value:s,isActive:c})=>[N]),_:1})]),T,e("ul",null,[e("li",null,[e("a",U,[l("🔴 460 - LFU 缓存"),n(t)]),F])]),S])}const R=d(_,[["render",V],["__file","0x08.hash-table.html.vue"]]);export{R as default};

import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,a as i,f as o}from"./app-LFcJklNL.js";const t={},c=o('<h2 id="uikit" tabindex="-1"><a class="header-anchor" href="#uikit" aria-hidden="true">#</a> <code>UIKit</code></h2><h3 id="❓你了解的-uikit-结构" tabindex="-1"><a class="header-anchor" href="#❓你了解的-uikit-结构" aria-hidden="true">#</a> ❓你了解的 <code>UIKit</code> 结构？</h3><h2 id="uiview" tabindex="-1"><a class="header-anchor" href="#uiview" aria-hidden="true">#</a> <code>UIView</code></h2><h3 id="❓uiview-vs-calayer-为什么要这样设计" tabindex="-1"><a class="header-anchor" href="#❓uiview-vs-calayer-为什么要这样设计" aria-hidden="true">#</a> ❓<code>UIView</code> vs <code>CALayer</code> 为什么要这样设计？</h3><h3 id="❓layoutsubviews-那些情况下会触发" tabindex="-1"><a class="header-anchor" href="#❓layoutsubviews-那些情况下会触发" aria-hidden="true">#</a> ❓<code>layoutSubviews</code> 那些情况下会触发？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>layoutSubviews</code> 在 iOS 的 UIView 的生命周期中，是负责布局及排版子视图的方法。</p></blockquote><ul><li>在初始化 <code>UIView</code> 并添加到界面上时，系统会自动调用 <code>layoutSubviews</code> 方法进行子视图的布局。</li><li>当 <code>UIView</code> 的 <code>bounds</code> 发生变化，如改变宽高、旋转设备时，系统会调用 <code>layoutSubviews</code>。</li><li>当直接调用 <code>UIView</code> 的 <code>setNeedsLayout</code>或者 <code>layoutIfNeeded</code> 方法时，系统会调用 <code>layoutSubviews</code>。 <ul><li><code>setNeedsLayout</code> 会标记当前视图被标记为需要重新布局，然后在接下来的更新周期中，调用 <code>layoutSubviews</code> 对标记进行重新布局</li><li><code>layoutIfNeeded</code> 则会立即对视图进行重新布局，通常在动画的 <code>block</code> 内使用</li></ul></li><li>当视图的某个子视图的 <code>frame</code> 被显式地修改，也会触发父视图的 <code>layoutSubviews</code>。</li><li>添加或者删除子视图的时候，也会触发父视图的 <code>layoutSubviews</code>。</li></ul></details><h3 id="❓根据-uicontrol-实现-uibutton" tabindex="-1"><a class="header-anchor" href="#❓根据-uicontrol-实现-uibutton" aria-hidden="true">#</a> ❓根据 <code>UIControl</code> 实现 <code>UIButton</code></h3><h2 id="屏幕渲染" tabindex="-1"><a class="header-anchor" href="#屏幕渲染" aria-hidden="true">#</a> 屏幕渲染</h2><details class="hint-container details"><summary>💡</summary><table><thead><tr><th>渲染类型</th><th>说明</th></tr></thead><tbody><tr><td>CPU 渲染</td><td>简单视图 CPU 渲染可能高于 GPU (不需要创建缓冲区和上下文切换)</td></tr><tr><td>GPU 渲染</td><td>GPU 浮点运算能力强于 CPU，所以 GPU 渲染效率高于 CPU</td></tr></tbody></table><ul><li><strong>屏幕渲染</strong>(On-Screen Rendering) : 在当前屏幕的缓冲区进行渲染。优点：不需要创建新的缓存，也不需要进行上下文切换，性能较好；缺点：缓存大小受限制，无法进行复杂的操作。</li><li><strong>离屏渲染</strong>(Off-Screen Rendering) : GPU 在当前屏幕外，新开辟了一个缓冲区进行图片的渲染和合成。渲染完成之后再放入当前屏幕的缓冲区。这个过程需要 CPU 调度，将任务分配给 GPU 进行渲染然后再将渲染结果返回，需要进行上下文切换和内存读写等操作，对性能影响较大。</li></ul></details><h3 id="❓哪些场景可以触发离屏渲染" tabindex="-1"><a class="header-anchor" href="#❓哪些场景可以触发离屏渲染" aria-hidden="true">#</a> ❓哪些场景可以触发离屏渲染？</h3><details class="hint-container details"><summary>💡</summary><ul><li>圆角 <code>layer.masksToBounds = YES &amp; layer.cornerRadius &gt; 0</code></li><li>图层蒙版 <code>layer.mask</code></li><li>阴影 <code>layer.shadowXXX (除 shadowPath)</code></li><li>光栅化 <code>layer.shouldRasterize = YES</code></li><li>抗锯齿 <code>antialiasing</code></li><li>不透明 <code>opacity</code></li></ul></details><h2 id="event-dispatch-事件分发" tabindex="-1"><a class="header-anchor" href="#event-dispatch-事件分发" aria-hidden="true">#</a> event dispatch - “事件分发”</h2><h3 id="❓用户点击屏幕上按钮-整个过程讲一下" tabindex="-1"><a class="header-anchor" href="#❓用户点击屏幕上按钮-整个过程讲一下" aria-hidden="true">#</a> ❓用户点击屏幕上按钮，整个过程讲一下？</h3>',13);function r(l,s){return a(),d("div",null,[i(" more "),c])}const u=e(t,[["render",r],["__file","uikit.html.vue"]]);export{u as default};

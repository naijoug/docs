import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as d,a as r,f as i}from"./app-enJ7wihl.js";const h={},c=i('<hr><h2 id="架构设计" tabindex="-1"><a class="header-anchor" href="#架构设计" aria-hidden="true">#</a> 架构设计</h2><h3 id="appdelegate-如何瘦身" tabindex="-1"><a class="header-anchor" href="#appdelegate-如何瘦身" aria-hidden="true">#</a> <code>AppDelegate</code> 如何瘦身？</h3><h3 id="从-0-开始做一个项目-你是如何架构思考的" tabindex="-1"><a class="header-anchor" href="#从-0-开始做一个项目-你是如何架构思考的" aria-hidden="true">#</a> 从 0 开始做一个项目，你是如何架构思考的？</h3><h3 id="设计一个时长统计模块" tabindex="-1"><a class="header-anchor" href="#设计一个时长统计模块" aria-hidden="true">#</a> _&gt; 设计一个时长统计模块</h3><h3 id="设计一个日志记录模块" tabindex="-1"><a class="header-anchor" href="#设计一个日志记录模块" aria-hidden="true">#</a> 设计一个日志记录模块</h3><h3 id="设计一个网络模块" tabindex="-1"><a class="header-anchor" href="#设计一个网络模块" aria-hidden="true">#</a> 设计一个网络模块？</h3><details class="hint-container details"><summary>💡</summary><p>设计一个网络模块，应该从如下几个方面设计。</p><ul><li><p>功能设计: 分析目前的应用需求、技术栈、预期目标等进行全面的分析，定义网络库的功能（如，数据请求、上传、下载、缓存、安全策略、错误处理等）。</p></li><li><p>接口设计: 设计易于使用并清晰明了的API。例如设计一个主类，用于处理HTTP请求，此类应包含GET，POST，PUT，DELETE等HTTP方法。并且应该要定义清晰的请求和响应类。</p></li><li><p>线程处理：对于网络请求，一般使用异步队列，以避免阻塞主线程。可以使用 <code>DispatchQueue</code> 来进行相关处理。</p></li><li><p>数据序列化：请求数据的序列化和反序列化。可以使用 <code>Codable</code> 来实现数据模型的序列化和反序列化。</p></li><li><p>错误处理：网络请求中会有各种错误可能发生，需要设计合理的错误处理机制，使得错误能被准确捕获并传递给调用者。</p></li><li><p>安全策略：对于需要保密的数据进行加密处理。如用户凭证，应该使用相应的散列或加密算法进行安全处理。</p></li><li><p>缓存策略：对于一些频繁请求但不常变动的数据，可以采用合理的缓存策略。可以显著提升应用性能以及减少用户的流量消耗。</p></li><li><p>测试用例：编写完善的单元测试和集成测试，保证网络库的稳定性和可靠性。</p></li></ul></details><h3 id="设计一个缓存模块-lrucache-算法怎么实现" tabindex="-1"><a class="header-anchor" href="#设计一个缓存模块-lrucache-算法怎么实现" aria-hidden="true">#</a> 设计一个缓存模块？<code>LRUCache</code> 算法怎么实现？</h3><h3 id="内存缓存策略有哪些-nscache-使用什么缓存策略" tabindex="-1"><a class="header-anchor" href="#内存缓存策略有哪些-nscache-使用什么缓存策略" aria-hidden="true">#</a> 内存缓存策略有哪些？<code>NSCache</code> 使用什么缓存策略？</h3><h3 id="无痕埋点如何实现-你认为理想的无痕埋点应该具备哪些特点" tabindex="-1"><a class="header-anchor" href="#无痕埋点如何实现-你认为理想的无痕埋点应该具备哪些特点" aria-hidden="true">#</a> 无痕埋点如何实现？你认为理想的无痕埋点应该具备哪些特点？</h3><h3 id="手动埋点、自动化埋点、可视化埋点" tabindex="-1"><a class="header-anchor" href="#手动埋点、自动化埋点、可视化埋点" aria-hidden="true">#</a> 手动埋点、自动化埋点、可视化埋点？</h3><h3 id="持续集成方案" tabindex="-1"><a class="header-anchor" href="#持续集成方案" aria-hidden="true">#</a> 持续集成方案</h3><hr><h2 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h2><h3 id="❓组件化设计思路" tabindex="-1"><a class="header-anchor" href="#❓组件化设计思路" aria-hidden="true">#</a> ❓组件化设计思路？</h3><details class="hint-container details"><summary>💡</summary><p>组件化：有时也称为“模块化”。将一个大的业务功能，按照不同的功能模块进行拆分。</p><p>拆分原则：类似 <code>SOLID</code> 原则。</p><ul><li>单一职责原则 : 拆分的功能模块应该尽量做到功能单一。</li><li>接口隔离原则 : 功能模块尽量做到对外暴露接口的最小化。</li></ul><p>分层原则：网上有一个借用经典四象限法则来划分(以 <strong>业务相关</strong>、<strong><code>UI</code> 相关</strong> 作为两个轴线，来进行组件化分层)</p><ul><li>业务功能层 : 业务有关 &amp; <code>UI</code> 有关。用户看到的主要功能页面。</li><li>业务逻辑层 : 业务有关 &amp; <code>UI</code> 无关。在用户使用业务功能时，背后的处理逻辑。</li><li><code>UI</code> 层 : 业务无关 &amp; <code>UI</code> 有关。通用的 <code>UI</code> 页面，不关联具体的业务逻辑。</li><li>基础层 : 业务无关 &amp; <code>UI</code> 无关。通用的基础功能。</li></ul><p>单向依赖原则：组件之间的依赖关系，应该做到上层依赖下层，下层不要依赖上层。</p></details><h3 id="❓下层组件需要调用上层组件怎样处理" tabindex="-1"><a class="header-anchor" href="#❓下层组件需要调用上层组件怎样处理" aria-hidden="true">#</a> ❓下层组件需要调用上层组件怎样处理？</h3><details class="hint-container details"><summary>💡</summary><p>方案一：依赖注入方式。下层组件定义好钩子函数，注册时，将上层组件注入下层组件定义好的钩子函数。</p><p>方案二：间接访问。通过底层的路由组件，将上层组件注册到路由表中，这样下层组件就可以通过路由间接访问到上层组件。</p></details><h3 id="你是如何组件化解耦的" tabindex="-1"><a class="header-anchor" href="#你是如何组件化解耦的" aria-hidden="true">#</a> 你是如何组件化解耦的？</h3><h3 id="ctmediator、mgjrouter-路由优缺点对比" tabindex="-1"><a class="header-anchor" href="#ctmediator、mgjrouter-路由优缺点对比" aria-hidden="true">#</a> <code>CTMediator</code>、<code>MGJRouter</code> 路由优缺点对比？</h3><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h2><h3 id="ios-中的的单例实现" tabindex="-1"><a class="header-anchor" href="#ios-中的的单例实现" aria-hidden="true">#</a> <code>iOS</code> 中的的单例实现？</h3><h3 id="说说单例模式优缺点-苹果设计的类对象是不是单例模式" tabindex="-1"><a class="header-anchor" href="#说说单例模式优缺点-苹果设计的类对象是不是单例模式" aria-hidden="true">#</a> 说说单例模式优缺点？苹果设计的类对象是不是单例模式？</h3><h3 id="ios-中常用设计模式实践有哪些" tabindex="-1"><a class="header-anchor" href="#ios-中常用设计模式实践有哪些" aria-hidden="true">#</a> <code>iOS</code> 中常用设计模式实践有哪些？</h3><h3 id="m、v、c-相互通讯规则你知道的有哪些" tabindex="-1"><a class="header-anchor" href="#m、v、c-相互通讯规则你知道的有哪些" aria-hidden="true">#</a> <code>M、V、C</code> 相互通讯规则你知道的有哪些？</h3><h3 id="mvc、mvp、mvvm、coordinator" tabindex="-1"><a class="header-anchor" href="#mvc、mvp、mvvm、coordinator" aria-hidden="true">#</a> <code>MVC</code>、<code>MVP</code>、<code>MVVM</code>、<code>Coordinator</code></h3><h3 id="单向数据流-redux、reswift、rxfeedback" tabindex="-1"><a class="header-anchor" href="#单向数据流-redux、reswift、rxfeedback" aria-hidden="true">#</a> 单向数据流 (<code>Redux</code>、<code>ReSwift</code>、<code>RxFeedback</code>)</h3>',28);function o(t,n){return a(),d("div",null,[r(" more "),c])}const u=e(h,[["render",o],["__file","architecture.html.vue"]]);export{u as default};

import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c,a as d,b as e,f as r}from"./app-pRGiPbnF.js";const t={},l=e("blockquote",null,[e("p",null,"12 - C & C++ (11)")],-1),h=r('<h2 id="_12-1-最后k行" tabindex="-1"><a class="header-anchor" href="#_12-1-最后k行" aria-hidden="true">#</a> 12.1 最后K行</h2><blockquote><p>用 <code>C++</code> 写个方法，打印输入文件的最后K行。</p></blockquote><h2 id="_12-2-反转字符串" tabindex="-1"><a class="header-anchor" href="#_12-2-反转字符串" aria-hidden="true">#</a> 12.2 反转字符串</h2><blockquote><p>用 <code>C</code> 或 <code>C++</code> 实现一个名为 <code>reverse(char*str)</code> 的函数，它可以反转一个 <code>null</code> 结尾的字符串。</p></blockquote><h2 id="_12-3-散列表与-stl-map" tabindex="-1"><a class="header-anchor" href="#_12-3-散列表与-stl-map" aria-hidden="true">#</a> 12.3 散列表与 <code>STL map</code></h2><blockquote><p>比较并对比散列表和 <code>STL map</code>。散列表是怎么实现的？如果输入的数据量不大，可以选用哪些数据结构替代散列表？</p></blockquote><h2 id="_12-4-虚函数原理" tabindex="-1"><a class="header-anchor" href="#_12-4-虚函数原理" aria-hidden="true">#</a> 12.4 虚函数原理</h2><blockquote><p><code>C++</code> 虚函数的工作原理是什么？</p></blockquote><h2 id="_12-5-浅复制与深复制" tabindex="-1"><a class="header-anchor" href="#_12-5-浅复制与深复制" aria-hidden="true">#</a> 12.5 浅复制与深复制</h2><blockquote><p>浅复制和深复制之间有何区别？请阐述两者的不同用法。</p></blockquote><h2 id="_12-6-volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_12-6-volatile-关键字" aria-hidden="true">#</a> 12.6 <code>volatile</code> 关键字</h2><blockquote><p><code>C</code> 语言的关键字 <code>volatile</code> 有何作用？</p></blockquote><h2 id="_12-7-虚基类" tabindex="-1"><a class="header-anchor" href="#_12-7-虚基类" aria-hidden="true">#</a> 12.7 虚基类</h2><blockquote><p>基类的析构函数为何要声明为 <code>virtual</code>？</p></blockquote><h2 id="_12-8-复制节点" tabindex="-1"><a class="header-anchor" href="#_12-8-复制节点" aria-hidden="true">#</a> 12.8 复制节点</h2><blockquote><p>编写一种方法，传入参数为指向 <code>Node</code> 结构的指针，返回传入数据结构的完整副本，其中，<code>Node</code> 数据结构含有两个指向其他 <code>Node</code> 的指针。</p></blockquote><h2 id="_12-9-智能指针" tabindex="-1"><a class="header-anchor" href="#_12-9-智能指针" aria-hidden="true">#</a> 12.9 智能指针</h2><blockquote><p>编写一个智能指针类。智能指针是一种数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录 <code>SmartPointer&lt;T*&gt;</code> 对象的引用计数，一旦T类型对象的引用计数为0，就会释放该对象。</p></blockquote><h2 id="_12-10-分配内存" tabindex="-1"><a class="header-anchor" href="#_12-10-分配内存" aria-hidden="true">#</a> 12.10 分配内存</h2><blockquote><p>编写支持对齐分配的 <code>malloc</code> 和 <code>free</code> 函数，分配内存时，<code>malloc</code> 函数返回的地址必须能被2的n次方整除。</p></blockquote><pre><code>示例：\n    `align_malloc(1000,128)` 返回的内存地址可被128整除，并指向一块1000字节大小的内存。\n    `aligned_free()` 会释放 `align_malloc` 分配的内存。\n</code></pre><h2 id="_12-11-二维数组分配" tabindex="-1"><a class="header-anchor" href="#_12-11-二维数组分配" aria-hidden="true">#</a> 12.11 二维数组分配</h2><blockquote><p>用 <code>C</code> 编写一个 <code>my2DAlloc</code> 函数，可分配二维数组。将 <code>malloc</code> 函数的调用次数降到最少，并确保可通过 <code>arr[i][j]</code> 访问该内存。</p></blockquote>',23);function i(n,s){return a(),c("div",null,[l,d(" more "),h])}const p=o(t,[["render",i],["__file","0x12.c-cpp.html.vue"]]);export{p as default};

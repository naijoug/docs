<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.0" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://naijoug.github.io/docs/docs/interview/ios/0x01.objective-c.html"><meta property="og:site_name" content="知识库"><meta property="og:title" content="Objective-C"><meta property="og:description" content="设计理念 OC 底层是使用 C/C++ 实现。定一个继承 NSObject 的类，这个类底层使用 C 语言中的 struct 结构体来实现的。 ❓OC、Java、Python 运行效率孰高 💡 Objective-C: 编译型语言，运行效率通常优于解释型语言。底层是基于 C，但是由于动态派发的特性会一定程度上影响效率。; Java: 编译型语言，运行..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-02-22T13:43:15.000Z"><meta property="article:author" content="naijoug"><meta property="article:modified_time" content="2024-02-22T13:43:15.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Objective-C","image":[""],"dateModified":"2024-02-22T13:43:15.000Z","author":[{"@type":"Person","name":"naijoug","url":"https://github.com/naijoug"}]}</script><title>Objective-C | 知识库</title><meta name="description" content="设计理念 OC 底层是使用 C/C++ 实现。定一个继承 NSObject 的类，这个类底层使用 C 语言中的 struct 结构体来实现的。 ❓OC、Java、Python 运行效率孰高 💡 Objective-C: 编译型语言，运行效率通常优于解释型语言。底层是基于 C，但是由于动态派发的特性会一定程度上影响效率。; Java: 编译型语言，运行...">
    <link rel="preload" href="/docs/assets/style-EcuGG40z.css" as="style"><link rel="stylesheet" href="/docs/assets/style-EcuGG40z.css">
    <link rel="modulepreload" href="/docs/assets/app-SX6jYwBY.js"><link rel="modulepreload" href="/docs/assets/0x01.objective-c.html-TnGS4oHQ.js"><link rel="modulepreload" href="/docs/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/docs/assets/0x01.objective-c.html-80F8MJyP.js">
    <link rel="prefetch" href="/docs/assets/index.html-rp0XavOZ.js" as="script"><link rel="prefetch" href="/docs/assets/guide.html-a3sfnEZ_.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Fpl-nJGU.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-wZZhzaeu.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-zKVZ-EKi.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-xQ4SQAz8.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-4S6PhqH0.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9aHAI-Bt.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-aI0CQxPB.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-a32MdlSQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-VzOe9G4C.js" as="script"><link rel="prefetch" href="/docs/assets/history.html-vFSaCWyv.js" as="script"><link rel="prefetch" href="/docs/assets/poem.html-8pDu4nCr.js" as="script"><link rel="prefetch" href="/docs/assets/song.html-rE1oZSqy.js" as="script"><link rel="prefetch" href="/docs/assets/story.html-pd8xV29y.js" as="script"><link rel="prefetch" href="/docs/assets/think.html-tJBlNfTD.js" as="script"><link rel="prefetch" href="/docs/assets/zen.html-W6AIY9i3.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-2pbaHWqG.js" as="script"><link rel="prefetch" href="/docs/assets/读《程序员的底层思维》.html-PqQRq2v4.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-qtlkqv2M.js" as="script"><link rel="prefetch" href="/docs/assets/中国古代三大修身奇书.html-lz5TU18V.js" as="script"><link rel="prefetch" href="/docs/assets/读《三体》.html-5-jNX1xd.js" as="script"><link rel="prefetch" href="/docs/assets/读《太白金星有点烦》.html-g5kZs5XT.js" as="script"><link rel="prefetch" href="/docs/assets/读《成为讲书人》.html-fO9JjUCE.js" as="script"><link rel="prefetch" href="/docs/assets/读《拖延心理学》.html-0x0WHX5r.js" as="script"><link rel="prefetch" href="/docs/assets/读《故事力》.html-Rf7zgtP9.js" as="script"><link rel="prefetch" href="/docs/assets/读《时空画师》.html-DRvPWDiI.js" as="script"><link rel="prefetch" href="/docs/assets/读《认知觉醒》.html-cTIaOkGx.js" as="script"><link rel="prefetch" href="/docs/assets/读《认知驱动》.html-R6XWqJaL.js" as="script"><link rel="prefetch" href="/docs/assets/读《长安的荔枝》.html-HzyuIiKn.js" as="script"><link rel="prefetch" href="/docs/assets/读《阅读力》.html-yHCw5s9U.js" as="script"><link rel="prefetch" href="/docs/assets/读《非暴力沟通》.html-b6iXcJcu.js" as="script"><link rel="prefetch" href="/docs/assets/读《高效能人士的七个习惯》.html-YJbVDSI-.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-34j2XOUH.js" as="script"><link rel="prefetch" href="/docs/assets/github-action.html-k6rccGYS.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-DL_zNs9A.js" as="script"><link rel="prefetch" href="/docs/assets/mongodb.html-wnsWDtID.js" as="script"><link rel="prefetch" href="/docs/assets/mysql.html-pQfxVXH8.js" as="script"><link rel="prefetch" href="/docs/assets/oracle.html-i2TncRJr.js" as="script"><link rel="prefetch" href="/docs/assets/postgres.html-aoFvP7yq.js" as="script"><link rel="prefetch" href="/docs/assets/redis.html-RDrQCVtz.js" as="script"><link rel="prefetch" href="/docs/assets/sql.html-knl846Sy.js" as="script"><link rel="prefetch" href="/docs/assets/sqlite.html-j29WESpz.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-lMM5HRF6.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-sn6L2OES.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-SPdEXrJt.js" as="script"><link rel="prefetch" href="/docs/assets/react-native.html-HuBMfc2D.js" as="script"><link rel="prefetch" href="/docs/assets/weex.html-08TPigzB.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-e47BjjFA.js" as="script"><link rel="prefetch" href="/docs/assets/awesome.html-xspO2a1_.js" as="script"><link rel="prefetch" href="/docs/assets/browser.html-8Zdu6uut.js" as="script"><link rel="prefetch" href="/docs/assets/miniprogram.html-xr3Ku0hO.js" as="script"><link rel="prefetch" href="/docs/assets/react.html-R2M6vMYa.js" as="script"><link rel="prefetch" href="/docs/assets/soild.html-KmX1ZU44.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.algorithm.html-g83J1WZ9.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.data-structure.html-VGA4Od0W.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.big-data.html-XzdD34TP.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.brain.html-Y-ejqeBD.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.network.html-Vh8Xup96.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.database.html-hcTxHb2x.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.thread.html-QE3tcB1r.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.memory.html-DlA68IF6.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.compiler.html-fWUtP3UQ.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.system.html-8b1_Zv3P.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.optimization.html-Au9rfzpl.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.architecture.html-Yg_39vpl.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.other.html-vYGpWIz7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-wAdryk_i.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.dart.html-IdHWclAh.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.flutter.html-rbwjrCJU.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.hot-reload.html-eGxbmeV0.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.thread.html-qm4MsL0K.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.memory.html-oTcxuRen.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.optimization.html-xYjj8LHf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-N_Hwanx2.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.swift.html-MMZqmx8l.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.uikit.html-z24noZK3.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.kvc-kvo.html-OrEagI7u.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.notification.html-x5GIad_6.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.runtime.html-8wJXbYNv.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.runloop.html-0gUPwQac.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.network.html-gna8DelM.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.store.html-Y0U30Yls.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.thread.html-WnNRvl21.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.memory.html-OXDC-PKO.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.compiler.html-U8hGu6j5.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.optimization.html-5nBIrEcM.js" as="script"><link rel="prefetch" href="/docs/assets/0x14.architecture.html-09ZBAMvM.js" as="script"><link rel="prefetch" href="/docs/assets/0x15.media.html-BDFFjJuc.js" as="script"><link rel="prefetch" href="/docs/assets/0x16.other.html-0fydOPIq.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-5Q4iD-sO.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-tuApnvgL.js" as="script"><link rel="prefetch" href="/docs/assets/0x0000.html-zMQLNIhn.js" as="script"><link rel="prefetch" href="/docs/assets/0x0100.html-jSqHw271.js" as="script"><link rel="prefetch" href="/docs/assets/0x0200.html-yBN2qGyn.js" as="script"><link rel="prefetch" href="/docs/assets/0x0300.html-eWMuc2eG.js" as="script"><link rel="prefetch" href="/docs/assets/0x0400.html-rMwJdpMk.js" as="script"><link rel="prefetch" href="/docs/assets/0x0500.html-SJ6TV--0.js" as="script"><link rel="prefetch" href="/docs/assets/0x0600.html-VBLhTvSW.js" as="script"><link rel="prefetch" href="/docs/assets/0x0700.html-5luEKQMY.js" as="script"><link rel="prefetch" href="/docs/assets/0x0800.html-eVAMZ0pT.js" as="script"><link rel="prefetch" href="/docs/assets/0x0900.html-yqVXc6SE.js" as="script"><link rel="prefetch" href="/docs/assets/0x1000.html-dvL4SpIU.js" as="script"><link rel="prefetch" href="/docs/assets/0x1100.html-uuttSM0j.js" as="script"><link rel="prefetch" href="/docs/assets/0x1200.html-mbOjFIZA.js" as="script"><link rel="prefetch" href="/docs/assets/0x1300.html-SSG6gWOo.js" as="script"><link rel="prefetch" href="/docs/assets/0x1400.html-0VZ_1hrt.js" as="script"><link rel="prefetch" href="/docs/assets/0x1500.html-z8Tq-u43.js" as="script"><link rel="prefetch" href="/docs/assets/0x1600.html-lJbajU8w.js" as="script"><link rel="prefetch" href="/docs/assets/0x1700.html-hR3jlthB.js" as="script"><link rel="prefetch" href="/docs/assets/0x1800.html-3KeQc9ea.js" as="script"><link rel="prefetch" href="/docs/assets/0x1900.html-M4TOKp4N.js" as="script"><link rel="prefetch" href="/docs/assets/0x2000.html-tQoHp5Ht.js" as="script"><link rel="prefetch" href="/docs/assets/0x2100.html-QFOnFD0y.js" as="script"><link rel="prefetch" href="/docs/assets/0x2200.html-EJkLLiWJ.js" as="script"><link rel="prefetch" href="/docs/assets/0x2300.html-zxiBxcd6.js" as="script"><link rel="prefetch" href="/docs/assets/0x2400.html-ONXQUe_7.js" as="script"><link rel="prefetch" href="/docs/assets/0x2500.html-J2lJ0phq.js" as="script"><link rel="prefetch" href="/docs/assets/0x2600.html-SqmSK--G.js" as="script"><link rel="prefetch" href="/docs/assets/0x2700.html-ZYV2_0bZ.js" as="script"><link rel="prefetch" href="/docs/assets/0x2800.html-f7qZk-tS.js" as="script"><link rel="prefetch" href="/docs/assets/0x2900.html-SVLsYXPd.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-u6gd_R68.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-dTF6Ak2n.js" as="script"><link rel="prefetch" href="/docs/assets/two-pointer.html-LjNNxfj6.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-fMyVMt-F.js" as="script"><link rel="prefetch" href="/docs/assets/blogger.html-YQU14SIZ.js" as="script"><link rel="prefetch" href="/docs/assets/designer.html-vg-mqBfR.js" as="script"><link rel="prefetch" href="/docs/assets/english.html-gQAA151i.js" as="script"><link rel="prefetch" href="/docs/assets/growing.html-nljnBJnh.js" as="script"><link rel="prefetch" href="/docs/assets/indie-hacker.html-4pYqyQYk.js" as="script"><link rel="prefetch" href="/docs/assets/mirror.html-txfsIywG.js" as="script"><link rel="prefetch" href="/docs/assets/open-api.html-oUnbAbde.js" as="script"><link rel="prefetch" href="/docs/assets/writing.html-2ywXazDL.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-3sR99TA1.js" as="script"><link rel="prefetch" href="/docs/assets/stock.html-voEfGjpx.js" as="script"><link rel="prefetch" href="/docs/assets/tip.html-fY51TefD.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-G_8TGYKG.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-7BfXXsad.js" as="script"><link rel="prefetch" href="/docs/assets/gfw.html-d217k9HE.js" as="script"><link rel="prefetch" href="/docs/assets/http.html-c0ra0IeU.js" as="script"><link rel="prefetch" href="/docs/assets/https.html-kME-nXxE.js" as="script"><link rel="prefetch" href="/docs/assets/spider.html-sJI5DGxT.js" as="script"><link rel="prefetch" href="/docs/assets/ssl.html-6n2hYC14.js" as="script"><link rel="prefetch" href="/docs/assets/vps.html-GBhGlQL4.js" as="script"><link rel="prefetch" href="/docs/assets/websocket.html-2PGgYsQo.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-xvm01b1o.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-3Mhc5dKD.js" as="script"><link rel="prefetch" href="/docs/assets/git.html-oTC6Erg2.js" as="script"><link rel="prefetch" href="/docs/assets/ide.html-HePx6l85.js" as="script"><link rel="prefetch" href="/docs/assets/markdown.html-ZqHd0dAn.js" as="script"><link rel="prefetch" href="/docs/assets/shell.html-_wj0dudg.js" as="script"><link rel="prefetch" href="/docs/assets/svn.html-pP6V7BeP.js" as="script"><link rel="prefetch" href="/docs/assets/vim.html-Y877X6-k.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-gWjn-noC.js" as="script"><link rel="prefetch" href="/docs/assets/cpp.html-TAO4dzXX.js" as="script"><link rel="prefetch" href="/docs/assets/php.html-HcU7F5ar.js" as="script"><link rel="prefetch" href="/docs/assets/ruby.html-QGJlMaSl.js" as="script"><link rel="prefetch" href="/docs/assets/rust.html-99e-of3r.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-TmJ39Hno.js" as="script"><link rel="prefetch" href="/docs/assets/cache.html-qaJPH8dk.js" as="script"><link rel="prefetch" href="/docs/assets/character-encoding.html-Bl1yzfUW.js" as="script"><link rel="prefetch" href="/docs/assets/code-style.html-hMAEzUQ-.js" as="script"><link rel="prefetch" href="/docs/assets/cryptology.html-r3_DZj0T.js" as="script"><link rel="prefetch" href="/docs/assets/design-pattern.html-ueqGEikR.js" as="script"><link rel="prefetch" href="/docs/assets/media.html-WW5BNCV5.js" as="script"><link rel="prefetch" href="/docs/assets/memory.html-FRlvRDup.js" as="script"><link rel="prefetch" href="/docs/assets/paradigm.html-SpmGlRsV.js" as="script"><link rel="prefetch" href="/docs/assets/regular.html-uH1pYI2Z.js" as="script"><link rel="prefetch" href="/docs/assets/serialization.html-Z3x84rqt.js" as="script"><link rel="prefetch" href="/docs/assets/thread.html-YyQ2tfA8.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-HKldMASt.js" as="script"><link rel="prefetch" href="/docs/assets/aigc.html-BXZPoESJ.js" as="script"><link rel="prefetch" href="/docs/assets/chatgpt.html-PZPyHnX8.js" as="script"><link rel="prefetch" href="/docs/assets/coder.html-LRqUoDFR.js" as="script"><link rel="prefetch" href="/docs/assets/gemimi.html-zykZuJ_a.js" as="script"><link rel="prefetch" href="/docs/assets/llms.html-6bERmiwY.js" as="script"><link rel="prefetch" href="/docs/assets/ml.html-w90cz2OA.js" as="script"><link rel="prefetch" href="/docs/assets/nlp.html-o_iqdSSd.js" as="script"><link rel="prefetch" href="/docs/assets/prompt.html-c-PljqYX.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-jIDNGD5c.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Gtf2_pOQ.js" as="script"><link rel="prefetch" href="/docs/assets/ffmpeg.html-Om3hH1pS.js" as="script"><link rel="prefetch" href="/docs/assets/hardware.html-Hejl40hG.js" as="script"><link rel="prefetch" href="/docs/assets/opencv.html-HsGUU4Ok.js" as="script"><link rel="prefetch" href="/docs/assets/opengl.html-Yc5MBwl5.js" as="script"><link rel="prefetch" href="/docs/assets/ros.html-hSWCxiuj.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-yQ3AnSSs.js" as="script"><link rel="prefetch" href="/docs/assets/fly.html-eOM5y6HY.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Fo00Lcu1.js" as="script"><link rel="prefetch" href="/docs/assets/commands.html-OKmyvN6f.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-w8ALA2Ig.js" as="script"><link rel="prefetch" href="/docs/assets/apache.html-SP-Uv1vG.js" as="script"><link rel="prefetch" href="/docs/assets/nginx.html--cQWvWIa.js" as="script"><link rel="prefetch" href="/docs/assets/tomcat.html-NOsxvdHR.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-LsDTrw4t.js" as="script"><link rel="prefetch" href="/docs/assets/koa.html-2X_59Fvh.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-OZlqPP6Y.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-EcRQvi6L.js" as="script"><link rel="prefetch" href="/docs/assets/flask.html-Wul-MQA2.js" as="script"><link rel="prefetch" href="/docs/assets/spring-boot.html-vGoEVNqY.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ifQ4laEp.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-kOlAVst-.js" as="script"><link rel="prefetch" href="/docs/assets/asset.html-Ga5x2326.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-p3L_5NhF.js" as="script"><link rel="prefetch" href="/docs/assets/environment.html-tBD-FIJu.js" as="script"><link rel="prefetch" href="/docs/assets/flutter.html-PHH17Nuc.js" as="script"><link rel="prefetch" href="/docs/assets/state.html-l7-TxEjp.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-5prV580G.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-VFeNd5yq.js" as="script"><link rel="prefetch" href="/docs/assets/css.html-0YyaBFtB.js" as="script"><link rel="prefetch" href="/docs/assets/html.html-AudVrvAj.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-XBDbAow_.js" as="script"><link rel="prefetch" href="/docs/assets/jquery.html-oI9MzSvY.js" as="script"><link rel="prefetch" href="/docs/assets/underscore.html-rB4egCMZ.js" as="script"><link rel="prefetch" href="/docs/assets/web-ui.html-bR4ZXkMW.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-JmU2bfIp.js" as="script"><link rel="prefetch" href="/docs/assets/hexo.html-ouTXe57P.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress-theme-hope.html-8BkV3Y8T.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress.html-qjt8dFLK.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-wjFYXw3D.js" as="script"><link rel="prefetch" href="/docs/assets/basic.html-ChZ8AqHr.js" as="script"><link rel="prefetch" href="/docs/assets/router.html-OEn0ci8A.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-gjnSx-Fl.js" as="script"><link rel="prefetch" href="/docs/assets/algorithm.html-2KiVNnTR.js" as="script"><link rel="prefetch" href="/docs/assets/data-structure.html-XPDQov2I.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.array-string.html-jDX5bGrA.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.linked-list.html-iGip4hSg.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.stack-queue.html-5B_B8o73.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.tree-graph.html-RKKGdSXG.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.bit.html-8REAhKCh.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.math-brain.html-V29AxuL7.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.oriented-object.html-n-gUcBCY.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.recursion-dynamic-programming.html-NX5jvgmG.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.system-design-expansibility.html-l3g0sQ1U.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.sort-search.html-cYKmnPzm.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.test.html-dSsdmMeT.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.c-cpp.html-DtTLTncP.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.java.html-1yKjrBzF.js" as="script"><link rel="prefetch" href="/docs/assets/0x14.database.html-CHohhuxn.js" as="script"><link rel="prefetch" href="/docs/assets/0x15.thread-lock.html-0nefY7ru.js" as="script"><link rel="prefetch" href="/docs/assets/0x16.mid.html-5Mere_it.js" as="script"><link rel="prefetch" href="/docs/assets/0x17.hard.html-x-T1rOAD.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-DkuVvOdk.js" as="script"><link rel="prefetch" href="/docs/assets/0x00.bit.html-BeTA7ym8.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.sort.html-y23M3KSD.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.search.html-znVxMaZK.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.traverse.html-GE-ytA_s.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.recursion.html-zaVKyINm.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.backtracking.html-QEtdHmiv.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.divide-conquer.html-yqBe_KcU.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.greedy.html-S8R4Hwbw.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.dynamic-programming.html-9PlYV0qm.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.math.html-kU501ylF.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-YVvMXBuG.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.string.html-zFJ_eRoG.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.array.html-ICFiZL4J.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.stack.html-9KVQh1um.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.queue.html-UUWTWuqD.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.linked-list.html-aeaLXvGA.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.binary-tree.html-aopr5X10.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.tree.html-QquXQJOA.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.hash-table.html-9LU3kJR2.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.graph.html-ne7fyRQJ.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.heap.html-ZPzJSjsv.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.trie.html-7neZ5i2k.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.union-find-disjoint-set.html-oLjoYfV-.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.bloom-filter.html-DhX1Cg5k.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-1S8l5VUa.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-XOTxZx9O.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-GHbN7Xu9.js" as="script"><link rel="prefetch" href="/docs/assets/funny-command.html-2IXVos9n.js" as="script"><link rel="prefetch" href="/docs/assets/multipass.html-c32sEhKR.js" as="script"><link rel="prefetch" href="/docs/assets/raspberrypi.html-5guowBhy.js" as="script"><link rel="prefetch" href="/docs/assets/ubuntu.html-yt0WO5Ha.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-jJsAOWJo.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-3deKoxFD.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-94_eZQ0R.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ZMJVR_bn.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-rervuk3d.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-GSwpCVm7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-i57RBalg.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-kvLJykT7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-mkbf8u1R.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-FiX1bMTz.js" as="script"><link rel="prefetch" href="/docs/assets/bitcoin-cli.html-bMm6K5KR.js" as="script"><link rel="prefetch" href="/docs/assets/bitcoin.html-xjf6hNff.js" as="script"><link rel="prefetch" href="/docs/assets/blockchain-api.html-a_gqLyJs.js" as="script"><link rel="prefetch" href="/docs/assets/omni.html-O1uG07B5.js" as="script"><link rel="prefetch" href="/docs/assets/omnicore-cli.html-bBFFh7PK.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-oGpvfLs-.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-nvO-XRAz.js" as="script"><link rel="prefetch" href="/docs/assets/cleos.html-vNzgegeD.js" as="script"><link rel="prefetch" href="/docs/assets/eos.html-mG2Ht3AO.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-1tNcuhqN.js" as="script"><link rel="prefetch" href="/docs/assets/ethereum.html-laZNVHHg.js" as="script"><link rel="prefetch" href="/docs/assets/geth.html-ZkBKqiHp.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-pPD899Ea.js" as="script"><link rel="prefetch" href="/docs/assets/auto_route.html-pyLGiKS6.js" as="script"><link rel="prefetch" href="/docs/assets/get_it.html-1ReMeh9V.js" as="script"><link rel="prefetch" href="/docs/assets/i18n.html-XInI9aU9.js" as="script"><link rel="prefetch" href="/docs/assets/json_serializable.html-uuuTu5Rd.js" as="script"><link rel="prefetch" href="/docs/assets/openid_client.html-M-0jgHXk.js" as="script"><link rel="prefetch" href="/docs/assets/provider.html-FTwQ2gb8.js" as="script"><link rel="prefetch" href="/docs/assets/pull_to_refresh.html-BOreAVAe.js" as="script"><link rel="prefetch" href="/docs/assets/qr.html-Rixxtlat.js" as="script"><link rel="prefetch" href="/docs/assets/speech_to_text.html-kxQ9HGki.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.layout.html-pSrxsCoN.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.common.html-77_fRsip.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.box.html-03fcDXAU.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.scroll.html-PyicFqEH.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.gesture.html-H5h4GyFb.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.builder.html-mtSc9vaY.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.animation.html-5ctZRXh5.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.navigtion.html-pZ-ZKpYj.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.material.html-wvxWyNtr.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.cupertino.html-hcPihynh.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Hhe2UmGQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-EjIKtV7V.js" as="script"><link rel="prefetch" href="/docs/assets/animation.html-OMzaeXPI.js" as="script"><link rel="prefetch" href="/docs/assets/architecture.html-EdofzIMp.js" as="script"><link rel="prefetch" href="/docs/assets/autolayout.html-pWDemQT4.js" as="script"><link rel="prefetch" href="/docs/assets/compiler.html-vVmxse_k.js" as="script"><link rel="prefetch" href="/docs/assets/dispatch.html-zgrExm_L.js" as="script"><link rel="prefetch" href="/docs/assets/lifecycle.html-yqQuY_h0.js" as="script"><link rel="prefetch" href="/docs/assets/media.html-h5o90u5D.js" as="script"><link rel="prefetch" href="/docs/assets/modular.html-gYqEwqsg.js" as="script"><link rel="prefetch" href="/docs/assets/notification.html-YvJRbS1n.js" as="script"><link rel="prefetch" href="/docs/assets/performance.html-arWDp_5i.js" as="script"><link rel="prefetch" href="/docs/assets/respond-chain.html-Nn_MNKra.js" as="script"><link rel="prefetch" href="/docs/assets/reverse.html-1iAmHHax.js" as="script"><link rel="prefetch" href="/docs/assets/thread.html-q35BjZ1D.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-w_eoMq3P.js" as="script"><link rel="prefetch" href="/docs/assets/fastlane.html-VJP7mJlK.js" as="script"><link rel="prefetch" href="/docs/assets/ios-x.html-INYZ5VQ1.js" as="script"><link rel="prefetch" href="/docs/assets/macos.html-jHd-8WCC.js" as="script"><link rel="prefetch" href="/docs/assets/objective-c.html-LOENrVOh.js" as="script"><link rel="prefetch" href="/docs/assets/package.html-gjRkkl1O.js" as="script"><link rel="prefetch" href="/docs/assets/rxswift.html-3XXLiP84.js" as="script"><link rel="prefetch" href="/docs/assets/swiftui.html-f1MzP71E.js" as="script"><link rel="prefetch" href="/docs/assets/uikit.html-7tOnEenI.js" as="script"><link rel="prefetch" href="/docs/assets/xcode.html-CWN16n1b.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-usW0LWrV.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--fCcfyZP.js" as="script"><link rel="prefetch" href="/docs/assets/sample.html-bkj0dIQm.js" as="script"><link rel="prefetch" href="/docs/assets/solution.html-jKCZ2EZJ.js" as="script"><link rel="prefetch" href="/docs/assets/tutorial.html-vPiaiv1C.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-fKATec51.js" as="script"><link rel="prefetch" href="/docs/assets/basic.html-fpIepsRX.js" as="script"><link rel="prefetch" href="/docs/assets/concept-algorithm.html-QiGwAjv2.js" as="script"><link rel="prefetch" href="/docs/assets/data-structure.html-j_2Wr90c.js" as="script"><link rel="prefetch" href="/docs/assets/extension.html-7U1_lMZQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-dCnEqBxf.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-1eMtdil2.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-Gkh0AHiD.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.generic.html-kQ0YjZ6e.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-OxlhngF9.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-WIrQJUuQ.js" as="script"><link rel="prefetch" href="/docs/assets/dart-x.html-T0DU2TJA.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-pTJUeSGt.js" as="script"><link rel="prefetch" href="/docs/assets/activiti.html-scPgQln7.js" as="script"><link rel="prefetch" href="/docs/assets/java-web.html-O_NoFOL6.js" as="script"><link rel="prefetch" href="/docs/assets/jvm.html-RrjM2jkt.js" as="script"><link rel="prefetch" href="/docs/assets/scala.html-deR5N342.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-Q_Whjagq.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-qr2sMbso.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.generic.html-Ci2E2P-m.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.io.html-g1VNLmWe.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.error.html-Db6wO_v_.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-DsM2c7wm.js" as="script"><link rel="prefetch" href="/docs/assets/java-x.html-KuyDwDUB.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-pV5kE0sb.js" as="script"><link rel="prefetch" href="/docs/assets/gson.html-juXrDyA1.js" as="script"><link rel="prefetch" href="/docs/assets/guava.html-XibwLUgQ.js" as="script"><link rel="prefetch" href="/docs/assets/junit.html-iQTPEs9p.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-dxwoDnur.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-nTSE9XuJ.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-yR1D3dwa.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.module.html-FpgC6Nf2.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-xTp6tvTH.js" as="script"><link rel="prefetch" href="/docs/assets/javascript-x.html-m6Q5V7zV.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-IxLZz6Y1.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-B-kfqrHs.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-QF_dM0jO.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.module.html-813ljV6l.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.io.html-z3kSMBvb.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.error.html-1aWVAOkj.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ZUCYnrFo.js" as="script"><link rel="prefetch" href="/docs/assets/python-x.html-F_UfFT0V.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-MwmmbTG9.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-S30745j-.js" as="script"><link rel="prefetch" href="/docs/assets/code-style.html-1RHIHG3x.js" as="script"><link rel="prefetch" href="/docs/assets/server.html-nrQ6xSDQ.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-huWmlEiN.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-0YybZtxS.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-71Qj97yo.js" as="script"><link rel="prefetch" href="/docs/assets/codable.html-F8fmgA0O.js" as="script"><link rel="prefetch" href="/docs/assets/swift-x.html-iTdfEHgl.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-sTVaU_X-.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-jQhgxdy3.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-RhfygF6G.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-WVFECozD.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-u-WY0fWK.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-c7Tfnluy.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-GOvGnFTv.js" as="script"><link rel="prefetch" href="/docs/assets/shared_preferences.html-X7CbOfVb.js" as="script"><link rel="prefetch" href="/docs/assets/url_launcher.html-u2uylezO.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-UupQW76y.js" as="script"><link rel="prefetch" href="/docs/assets/runloop.html-JuJrTDbr.js" as="script"><link rel="prefetch" href="/docs/assets/NSObject.html-koH_68pp.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9g-YybBC.js" as="script"><link rel="prefetch" href="/docs/assets/associated-object.html-s8kb5pwV.js" as="script"><link rel="prefetch" href="/docs/assets/category.html-w7clgGzZ.js" as="script"><link rel="prefetch" href="/docs/assets/class.html-Hf7LHwVn.js" as="script"><link rel="prefetch" href="/docs/assets/function.html-ka8Zhxc0.js" as="script"><link rel="prefetch" href="/docs/assets/memory.html-47e9Ne4v.js" as="script"><link rel="prefetch" href="/docs/assets/message-forwarding.html-NExOHbHi.js" as="script"><link rel="prefetch" href="/docs/assets/method.html-YEsgHu4_.js" as="script"><link rel="prefetch" href="/docs/assets/property.html-MBmiUgTb.js" as="script"><link rel="prefetch" href="/docs/assets/protocol.html-TBL_H78N.js" as="script"><link rel="prefetch" href="/docs/assets/runtime.html-ZpVegI3v.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-I7r_unCH.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-lN09dp2Q.js" as="script"><link rel="prefetch" href="/docs/assets/guide.html-nZVvfyQT.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-MbvAFT7O.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-LxEaU1d9.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-vBHQXi0V.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-rl_0oMk1.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-aNS0iS46.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-PVv1q6sF.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-4_sKYK_Y.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-c3PF-oJW.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-FVatqSgx.js" as="script"><link rel="prefetch" href="/docs/assets/history.html-Zcb3-brk.js" as="script"><link rel="prefetch" href="/docs/assets/poem.html-oVJT9dwI.js" as="script"><link rel="prefetch" href="/docs/assets/song.html-Ft9n6-im.js" as="script"><link rel="prefetch" href="/docs/assets/story.html-hBMA9Cc8.js" as="script"><link rel="prefetch" href="/docs/assets/think.html-g9l_vgk7.js" as="script"><link rel="prefetch" href="/docs/assets/zen.html-qLiLYKa8.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-JujmH6nc.js" as="script"><link rel="prefetch" href="/docs/assets/读《程序员的底层思维》.html-R2q9FL43.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Mzm9jR4T.js" as="script"><link rel="prefetch" href="/docs/assets/中国古代三大修身奇书.html-mM5Ur5jR.js" as="script"><link rel="prefetch" href="/docs/assets/读《三体》.html-1-vsY837.js" as="script"><link rel="prefetch" href="/docs/assets/读《太白金星有点烦》.html-R8QBgNzF.js" as="script"><link rel="prefetch" href="/docs/assets/读《成为讲书人》.html-5acjBE6Y.js" as="script"><link rel="prefetch" href="/docs/assets/读《拖延心理学》.html-0HHkReVK.js" as="script"><link rel="prefetch" href="/docs/assets/读《故事力》.html-x-KXcTDu.js" as="script"><link rel="prefetch" href="/docs/assets/读《时空画师》.html-8zw-ePGK.js" as="script"><link rel="prefetch" href="/docs/assets/读《认知觉醒》.html-gnAs_1hR.js" as="script"><link rel="prefetch" href="/docs/assets/读《认知驱动》.html-yIFWfv3c.js" as="script"><link rel="prefetch" href="/docs/assets/读《长安的荔枝》.html-ninyFod0.js" as="script"><link rel="prefetch" href="/docs/assets/读《阅读力》.html-ETCPzQle.js" as="script"><link rel="prefetch" href="/docs/assets/读《非暴力沟通》.html-nIu63Ae-.js" as="script"><link rel="prefetch" href="/docs/assets/读《高效能人士的七个习惯》.html-WaH4ftjJ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-0f2nbTEz.js" as="script"><link rel="prefetch" href="/docs/assets/github-action.html-lBAu-6zN.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-H0QUX3gt.js" as="script"><link rel="prefetch" href="/docs/assets/mongodb.html-BEJuOda7.js" as="script"><link rel="prefetch" href="/docs/assets/mysql.html-rWWEuBCA.js" as="script"><link rel="prefetch" href="/docs/assets/oracle.html-tXDgjBK_.js" as="script"><link rel="prefetch" href="/docs/assets/postgres.html-fw5NJ3Dv.js" as="script"><link rel="prefetch" href="/docs/assets/redis.html-CGxNz1H_.js" as="script"><link rel="prefetch" href="/docs/assets/sql.html-UbpaUO0u.js" as="script"><link rel="prefetch" href="/docs/assets/sqlite.html-5DKwFbIE.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-H6YNFZul.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-wtBXVR13.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-V_UZCJl0.js" as="script"><link rel="prefetch" href="/docs/assets/react-native.html-6sis5Wsn.js" as="script"><link rel="prefetch" href="/docs/assets/weex.html-ea7qDBHm.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--u0v1cc-.js" as="script"><link rel="prefetch" href="/docs/assets/awesome.html-APuS0egp.js" as="script"><link rel="prefetch" href="/docs/assets/browser.html-xPCbJupf.js" as="script"><link rel="prefetch" href="/docs/assets/miniprogram.html-eiXQtFVt.js" as="script"><link rel="prefetch" href="/docs/assets/react.html-Nb1Ne9UI.js" as="script"><link rel="prefetch" href="/docs/assets/soild.html-vApvjKK9.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.algorithm.html-w9mQ5e7H.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.data-structure.html-kPXuGOvt.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.big-data.html-LLxFEUDF.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.brain.html-edYS2NXZ.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.network.html-0LPcVZbI.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.database.html-HG6LPgkQ.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.thread.html-AheyO1tv.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.memory.html-blZbnbhM.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.compiler.html-Ft-un7v9.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.system.html-aNjIhmk7.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.optimization.html-GHOemEuH.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.architecture.html-Tmq60zre.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.other.html--I9sw7QE.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-OjcTUMfT.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.dart.html-a-q5Ioux.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.flutter.html-_6WZzZTl.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.hot-reload.html-pv2ob6R3.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.thread.html-5JCKh9jN.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.memory.html-fWwUIBQ2.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.optimization.html-Yi_Mi7W6.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Y0nVoeg6.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.swift.html-iML1ex7n.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.uikit.html-Dg3cGmQu.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.kvc-kvo.html-g5Nwo7et.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.notification.html-munXlk1V.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.runtime.html-WkuYst0g.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.runloop.html-Kxdr0Lgx.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.network.html-XmYmesVT.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.store.html-MLx3xhQa.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.thread.html-zGE5Otow.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.memory.html-Y_5ggMw5.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.compiler.html-iIrLwa6Q.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.optimization.html-1TQ4VsiC.js" as="script"><link rel="prefetch" href="/docs/assets/0x14.architecture.html-1xxiQN4X.js" as="script"><link rel="prefetch" href="/docs/assets/0x15.media.html-VRVrCCLl.js" as="script"><link rel="prefetch" href="/docs/assets/0x16.other.html-5rIeStqd.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-WHTSD_bW.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-tPAAlAKO.js" as="script"><link rel="prefetch" href="/docs/assets/0x0000.html-PRp6jjo1.js" as="script"><link rel="prefetch" href="/docs/assets/0x0100.html-WjVwy5Zq.js" as="script"><link rel="prefetch" href="/docs/assets/0x0200.html-lp0wJPAP.js" as="script"><link rel="prefetch" href="/docs/assets/0x0300.html-2ybMhPZi.js" as="script"><link rel="prefetch" href="/docs/assets/0x0400.html-abTvyLJk.js" as="script"><link rel="prefetch" href="/docs/assets/0x0500.html-xociPLZv.js" as="script"><link rel="prefetch" href="/docs/assets/0x0600.html-vEi1scsV.js" as="script"><link rel="prefetch" href="/docs/assets/0x0700.html-P5UuorGA.js" as="script"><link rel="prefetch" href="/docs/assets/0x0800.html-0p1jQxHy.js" as="script"><link rel="prefetch" href="/docs/assets/0x0900.html-udvu8wch.js" as="script"><link rel="prefetch" href="/docs/assets/0x1000.html-rCssBwky.js" as="script"><link rel="prefetch" href="/docs/assets/0x1100.html-kxAzgeY6.js" as="script"><link rel="prefetch" href="/docs/assets/0x1200.html-fsrBOj5F.js" as="script"><link rel="prefetch" href="/docs/assets/0x1300.html-aWnit0EN.js" as="script"><link rel="prefetch" href="/docs/assets/0x1400.html-KLEuFTbt.js" as="script"><link rel="prefetch" href="/docs/assets/0x1500.html-WL_4_ERe.js" as="script"><link rel="prefetch" href="/docs/assets/0x1600.html-Jrg2AKlz.js" as="script"><link rel="prefetch" href="/docs/assets/0x1700.html-HyggJrgq.js" as="script"><link rel="prefetch" href="/docs/assets/0x1800.html-MR1sTRnY.js" as="script"><link rel="prefetch" href="/docs/assets/0x1900.html-SN4Vrqbn.js" as="script"><link rel="prefetch" href="/docs/assets/0x2000.html-kR5SDAZf.js" as="script"><link rel="prefetch" href="/docs/assets/0x2100.html-z2FkcSky.js" as="script"><link rel="prefetch" href="/docs/assets/0x2200.html-qB6FJwbx.js" as="script"><link rel="prefetch" href="/docs/assets/0x2300.html-5fKnw5IH.js" as="script"><link rel="prefetch" href="/docs/assets/0x2400.html-XBIne4Q_.js" as="script"><link rel="prefetch" href="/docs/assets/0x2500.html-zgvp6dXC.js" as="script"><link rel="prefetch" href="/docs/assets/0x2600.html-2hrslCDZ.js" as="script"><link rel="prefetch" href="/docs/assets/0x2700.html-wvQHK0uQ.js" as="script"><link rel="prefetch" href="/docs/assets/0x2800.html-QYTOLRkM.js" as="script"><link rel="prefetch" href="/docs/assets/0x2900.html-UJyHxwev.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-oUbZ4kVv.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-1pLX22zI.js" as="script"><link rel="prefetch" href="/docs/assets/two-pointer.html-U3AsJucf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ggsTqKpC.js" as="script"><link rel="prefetch" href="/docs/assets/blogger.html-vt82N_bI.js" as="script"><link rel="prefetch" href="/docs/assets/designer.html-lFXPPzwc.js" as="script"><link rel="prefetch" href="/docs/assets/english.html-K7UeO8i1.js" as="script"><link rel="prefetch" href="/docs/assets/growing.html-SzMZX437.js" as="script"><link rel="prefetch" href="/docs/assets/indie-hacker.html-e1FKEjKm.js" as="script"><link rel="prefetch" href="/docs/assets/mirror.html-zdEQFcuM.js" as="script"><link rel="prefetch" href="/docs/assets/open-api.html-glJUpQor.js" as="script"><link rel="prefetch" href="/docs/assets/writing.html-5bsP51aS.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-mamzcB05.js" as="script"><link rel="prefetch" href="/docs/assets/stock.html-_aj7xdNZ.js" as="script"><link rel="prefetch" href="/docs/assets/tip.html-9_RhfQ5T.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-l6OG04a7.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-p-vZqETt.js" as="script"><link rel="prefetch" href="/docs/assets/gfw.html-yR0rx42G.js" as="script"><link rel="prefetch" href="/docs/assets/http.html-UCYJiadF.js" as="script"><link rel="prefetch" href="/docs/assets/https.html-am0G4bH-.js" as="script"><link rel="prefetch" href="/docs/assets/spider.html-acYCFCwO.js" as="script"><link rel="prefetch" href="/docs/assets/ssl.html-4DxYRPOL.js" as="script"><link rel="prefetch" href="/docs/assets/vps.html-hk02aZ-Z.js" as="script"><link rel="prefetch" href="/docs/assets/websocket.html-R6bWNw1D.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--XZijmvM.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-yYAvWrwn.js" as="script"><link rel="prefetch" href="/docs/assets/git.html-veptJd07.js" as="script"><link rel="prefetch" href="/docs/assets/ide.html-od0_gEoK.js" as="script"><link rel="prefetch" href="/docs/assets/markdown.html-TwIMPY4Q.js" as="script"><link rel="prefetch" href="/docs/assets/shell.html-HOlLPehe.js" as="script"><link rel="prefetch" href="/docs/assets/svn.html-cdyfEvdm.js" as="script"><link rel="prefetch" href="/docs/assets/vim.html-xD35I4Za.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-WwAXPYtr.js" as="script"><link rel="prefetch" href="/docs/assets/cpp.html-sndIzq2T.js" as="script"><link rel="prefetch" href="/docs/assets/php.html-260WLgi6.js" as="script"><link rel="prefetch" href="/docs/assets/ruby.html-shOMb-eH.js" as="script"><link rel="prefetch" href="/docs/assets/rust.html-iK5a8yD_.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-8LupEhKp.js" as="script"><link rel="prefetch" href="/docs/assets/cache.html-e5MPCf3Z.js" as="script"><link rel="prefetch" href="/docs/assets/character-encoding.html-axMcmhPk.js" as="script"><link rel="prefetch" href="/docs/assets/code-style.html-kwTrONUn.js" as="script"><link rel="prefetch" href="/docs/assets/cryptology.html--aRORUVN.js" as="script"><link rel="prefetch" href="/docs/assets/design-pattern.html-_w9-K1gm.js" as="script"><link rel="prefetch" href="/docs/assets/media.html-LmR3afEw.js" as="script"><link rel="prefetch" href="/docs/assets/memory.html-9tY88pg_.js" as="script"><link rel="prefetch" href="/docs/assets/paradigm.html-CD2ZHbWP.js" as="script"><link rel="prefetch" href="/docs/assets/regular.html-28OsrCRX.js" as="script"><link rel="prefetch" href="/docs/assets/serialization.html-Q5j30qn_.js" as="script"><link rel="prefetch" href="/docs/assets/thread.html-OO_GzHGN.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-K1Rjr5kc.js" as="script"><link rel="prefetch" href="/docs/assets/aigc.html-kZyUyXpd.js" as="script"><link rel="prefetch" href="/docs/assets/chatgpt.html-qCBGi3E_.js" as="script"><link rel="prefetch" href="/docs/assets/coder.html-PYsABs4-.js" as="script"><link rel="prefetch" href="/docs/assets/gemimi.html-HX-dMre6.js" as="script"><link rel="prefetch" href="/docs/assets/llms.html-Dgy26DNm.js" as="script"><link rel="prefetch" href="/docs/assets/ml.html-JWwOl9ML.js" as="script"><link rel="prefetch" href="/docs/assets/nlp.html-6qwnAhKj.js" as="script"><link rel="prefetch" href="/docs/assets/prompt.html-aWQEemBy.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-GH46fqVA.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-BqgXaFzr.js" as="script"><link rel="prefetch" href="/docs/assets/ffmpeg.html-QR_pkP3j.js" as="script"><link rel="prefetch" href="/docs/assets/hardware.html-greEJD-Q.js" as="script"><link rel="prefetch" href="/docs/assets/opencv.html-N4yz1AvU.js" as="script"><link rel="prefetch" href="/docs/assets/opengl.html-BhU4DbzO.js" as="script"><link rel="prefetch" href="/docs/assets/ros.html-7RLWooiZ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-VtN4vofc.js" as="script"><link rel="prefetch" href="/docs/assets/fly.html-R_l8PGYf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-rBIa_6PM.js" as="script"><link rel="prefetch" href="/docs/assets/commands.html-ZIOA3W2-.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-BOaxm7i7.js" as="script"><link rel="prefetch" href="/docs/assets/apache.html-idqsT2sj.js" as="script"><link rel="prefetch" href="/docs/assets/nginx.html-0el-QBAT.js" as="script"><link rel="prefetch" href="/docs/assets/tomcat.html-Lu9WY9d1.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-NTmXg4bU.js" as="script"><link rel="prefetch" href="/docs/assets/koa.html-PwYXXScx.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-xECfNXRe.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ZafbDsfK.js" as="script"><link rel="prefetch" href="/docs/assets/flask.html-IoOCB3D3.js" as="script"><link rel="prefetch" href="/docs/assets/spring-boot.html-gRkNxV57.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-7bSaEj1i.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-cHUgLhKg.js" as="script"><link rel="prefetch" href="/docs/assets/asset.html-6JKgZUBI.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-uq-DYn7W.js" as="script"><link rel="prefetch" href="/docs/assets/environment.html-lsx2W-FQ.js" as="script"><link rel="prefetch" href="/docs/assets/flutter.html-uGN9Nt6o.js" as="script"><link rel="prefetch" href="/docs/assets/state.html-RubIv7Mq.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Nyg4bDTy.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Do-4LG0l.js" as="script"><link rel="prefetch" href="/docs/assets/css.html-ovakpFUi.js" as="script"><link rel="prefetch" href="/docs/assets/html.html-qAjLexa-.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-mxp26zhp.js" as="script"><link rel="prefetch" href="/docs/assets/jquery.html-HYNqgCCS.js" as="script"><link rel="prefetch" href="/docs/assets/underscore.html-BZBFW49V.js" as="script"><link rel="prefetch" href="/docs/assets/web-ui.html-0GAWxL3Y.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ABPFi6ek.js" as="script"><link rel="prefetch" href="/docs/assets/hexo.html-WaMFKVz5.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress-theme-hope.html-BreubCI9.js" as="script"><link rel="prefetch" href="/docs/assets/vuepress.html-t5Mbm-ya.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-SyW3mVwr.js" as="script"><link rel="prefetch" href="/docs/assets/basic.html-ZNESyJdf.js" as="script"><link rel="prefetch" href="/docs/assets/router.html-iwaJHf8k.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-AR6FDuyX.js" as="script"><link rel="prefetch" href="/docs/assets/algorithm.html-AlOhWnCl.js" as="script"><link rel="prefetch" href="/docs/assets/data-structure.html-82xzzqud.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.array-string.html-ePR60dq0.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.linked-list.html-1npHUT24.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.stack-queue.html-2jAaE-u3.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.tree-graph.html-sx3IxC5O.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.bit.html-JjWvVhWX.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.math-brain.html-Z5C6pBrs.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.oriented-object.html-rvVl-O4g.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.recursion-dynamic-programming.html-qf-LQvaE.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.system-design-expansibility.html-tyJcMLO8.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.sort-search.html-8kGtf0yd.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.test.html-CGTV7jJu.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.c-cpp.html-596Ktbmg.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.java.html-QHwf1-VR.js" as="script"><link rel="prefetch" href="/docs/assets/0x14.database.html-b8riqr1S.js" as="script"><link rel="prefetch" href="/docs/assets/0x15.thread-lock.html-1EgNH_-b.js" as="script"><link rel="prefetch" href="/docs/assets/0x16.mid.html-n4ABBTbH.js" as="script"><link rel="prefetch" href="/docs/assets/0x17.hard.html-E4rP47jv.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-3riuTVJD.js" as="script"><link rel="prefetch" href="/docs/assets/0x00.bit.html-rI4Po95x.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.sort.html-k3pwq9Dl.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.search.html-RzkPRQU3.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.traverse.html-kqJS9UsU.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.recursion.html-ZA3vxgEw.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.backtracking.html-tRIugTF6.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.divide-conquer.html-_NNsxY4S.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.greedy.html-laioDgv2.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.dynamic-programming.html-bEmVP4zC.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.math.html-uSdUO8f8.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-aCSJfJxu.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.string.html-PZ7agHWn.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.array.html-3rzawnpU.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.stack.html-AarBMIgY.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.queue.html-Oh9ek6Mi.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.linked-list.html-kQQPhzvf.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.binary-tree.html-PEGYeemH.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.tree.html-JecRJ8_J.js" as="script"><link rel="prefetch" href="/docs/assets/0x08.hash-table.html-mcBv92JD.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.graph.html-bs_3NixE.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.heap.html-htbr2sYb.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.trie.html-3yGnQcK0.js" as="script"><link rel="prefetch" href="/docs/assets/0x12.union-find-disjoint-set.html-92WpwQ-K.js" as="script"><link rel="prefetch" href="/docs/assets/0x13.bloom-filter.html-SFGSej-Q.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-YFj-AL3S.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-NsfSkpVm.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-9Thk8xgm.js" as="script"><link rel="prefetch" href="/docs/assets/funny-command.html-CjdktvN5.js" as="script"><link rel="prefetch" href="/docs/assets/multipass.html-0UAE3nTe.js" as="script"><link rel="prefetch" href="/docs/assets/raspberrypi.html-qvYJyM6f.js" as="script"><link rel="prefetch" href="/docs/assets/ubuntu.html-A0qYo7Jc.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-qV9uuKV2.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--yAQLAvH.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-6Y_y28SJ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-PNaLdhSQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-SSCvKOAy.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-JnQWnPkl.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-nqG9s3A_.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-CrhFjH1c.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-YGWVUEj1.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-dTYzWvdy.js" as="script"><link rel="prefetch" href="/docs/assets/bitcoin-cli.html-P6lXMBSy.js" as="script"><link rel="prefetch" href="/docs/assets/bitcoin.html-prnrlIVC.js" as="script"><link rel="prefetch" href="/docs/assets/blockchain-api.html-UzqT75ZR.js" as="script"><link rel="prefetch" href="/docs/assets/omni.html-ccLmXham.js" as="script"><link rel="prefetch" href="/docs/assets/omnicore-cli.html-CRaWeolX.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-56p2HrGC.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-OC6Care1.js" as="script"><link rel="prefetch" href="/docs/assets/cleos.html-EJdU1Dti.js" as="script"><link rel="prefetch" href="/docs/assets/eos.html-UjYkLYws.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-relaflAp.js" as="script"><link rel="prefetch" href="/docs/assets/ethereum.html-W6TkbcFg.js" as="script"><link rel="prefetch" href="/docs/assets/geth.html-3tGjut8Q.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-sY2_btqZ.js" as="script"><link rel="prefetch" href="/docs/assets/auto_route.html-9bdlwuS6.js" as="script"><link rel="prefetch" href="/docs/assets/get_it.html-35erpSdC.js" as="script"><link rel="prefetch" href="/docs/assets/i18n.html-L0HHpqJt.js" as="script"><link rel="prefetch" href="/docs/assets/json_serializable.html-v1uaW9We.js" as="script"><link rel="prefetch" href="/docs/assets/openid_client.html-WftXybHi.js" as="script"><link rel="prefetch" href="/docs/assets/provider.html-4ALHA7XI.js" as="script"><link rel="prefetch" href="/docs/assets/pull_to_refresh.html-m9hpeq9B.js" as="script"><link rel="prefetch" href="/docs/assets/qr.html-Ax3TgQlG.js" as="script"><link rel="prefetch" href="/docs/assets/speech_to_text.html-HATfSeES.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.layout.html-TWcc6uHP.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.common.html-K8uqP6Zt.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.box.html-8gOkaiac.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.scroll.html-87ZeCcBP.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.gesture.html-IelVWcAv.js" as="script"><link rel="prefetch" href="/docs/assets/0x06.builder.html-t80ZCRG6.js" as="script"><link rel="prefetch" href="/docs/assets/0x07.animation.html-ETgg9pj2.js" as="script"><link rel="prefetch" href="/docs/assets/0x09.navigtion.html-2mPoilpe.js" as="script"><link rel="prefetch" href="/docs/assets/0x10.material.html-32CGyFbn.js" as="script"><link rel="prefetch" href="/docs/assets/0x11.cupertino.html-9Y84B9GJ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-_Ff1V-7l.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-J17fbpwU.js" as="script"><link rel="prefetch" href="/docs/assets/animation.html-cLZknFWT.js" as="script"><link rel="prefetch" href="/docs/assets/architecture.html-hZz59IKc.js" as="script"><link rel="prefetch" href="/docs/assets/autolayout.html-iL5JynbG.js" as="script"><link rel="prefetch" href="/docs/assets/compiler.html-mmuToXGz.js" as="script"><link rel="prefetch" href="/docs/assets/dispatch.html-PleWUbGU.js" as="script"><link rel="prefetch" href="/docs/assets/lifecycle.html-hFxW5lB2.js" as="script"><link rel="prefetch" href="/docs/assets/media.html-Vj64t_TY.js" as="script"><link rel="prefetch" href="/docs/assets/modular.html-4gp_Jh_A.js" as="script"><link rel="prefetch" href="/docs/assets/notification.html-hrAE9LTo.js" as="script"><link rel="prefetch" href="/docs/assets/performance.html-_WclsbFQ.js" as="script"><link rel="prefetch" href="/docs/assets/respond-chain.html-HfYJPMpW.js" as="script"><link rel="prefetch" href="/docs/assets/reverse.html-WHA7kMp0.js" as="script"><link rel="prefetch" href="/docs/assets/thread.html-n9iLrodn.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-RjpkYFY_.js" as="script"><link rel="prefetch" href="/docs/assets/fastlane.html-XJf3x3cp.js" as="script"><link rel="prefetch" href="/docs/assets/ios-x.html-ARoBISKn.js" as="script"><link rel="prefetch" href="/docs/assets/macos.html-4xCGRMzw.js" as="script"><link rel="prefetch" href="/docs/assets/objective-c.html-J1fty9T4.js" as="script"><link rel="prefetch" href="/docs/assets/package.html-MwGyTKuK.js" as="script"><link rel="prefetch" href="/docs/assets/rxswift.html-JMd8hkkW.js" as="script"><link rel="prefetch" href="/docs/assets/swiftui.html-_C1tFBhR.js" as="script"><link rel="prefetch" href="/docs/assets/uikit.html-GLeT5F4_.js" as="script"><link rel="prefetch" href="/docs/assets/xcode.html-pmxheJ93.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--QTpN0AG.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-NLEwx5_Y.js" as="script"><link rel="prefetch" href="/docs/assets/sample.html-h-h_v0bb.js" as="script"><link rel="prefetch" href="/docs/assets/solution.html-7ul6gSSw.js" as="script"><link rel="prefetch" href="/docs/assets/tutorial.html-DBUewahQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html--g0G_hAk.js" as="script"><link rel="prefetch" href="/docs/assets/basic.html-kUROg63L.js" as="script"><link rel="prefetch" href="/docs/assets/concept-algorithm.html-MSqGU_UU.js" as="script"><link rel="prefetch" href="/docs/assets/data-structure.html-u2t3XPJO.js" as="script"><link rel="prefetch" href="/docs/assets/extension.html-wF7dKpGf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-cJ0IOuim.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-ucwihiQW.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-kEpxNwYE.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.generic.html-fhZUiKtE.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-KH7VWagw.js" as="script"><link rel="prefetch" href="/docs/assets/command.html-wNyq7gp-.js" as="script"><link rel="prefetch" href="/docs/assets/dart-x.html-NfczOzo6.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-UakvClem.js" as="script"><link rel="prefetch" href="/docs/assets/activiti.html-h-2yU3wD.js" as="script"><link rel="prefetch" href="/docs/assets/java-web.html-x5bAXPmr.js" as="script"><link rel="prefetch" href="/docs/assets/jvm.html-KQlq2JML.js" as="script"><link rel="prefetch" href="/docs/assets/scala.html--ilfXC0c.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-qAnfRX32.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-kSMk0JOx.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.generic.html-B6bx4qnl.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.io.html-hOYiNn4R.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.error.html-KZd2cu-_.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-eOsZXPka.js" as="script"><link rel="prefetch" href="/docs/assets/java-x.html-OVFXeexP.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-vtP9QiBo.js" as="script"><link rel="prefetch" href="/docs/assets/gson.html-bpXqCVkq.js" as="script"><link rel="prefetch" href="/docs/assets/guava.html-hKm0HoFV.js" as="script"><link rel="prefetch" href="/docs/assets/junit.html-FBT61dem.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9ib-0qf9.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-wv_VLruy.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-JyK31k_M.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.module.html-oJPbKLvP.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-npaIykl1.js" as="script"><link rel="prefetch" href="/docs/assets/javascript-x.html-1HlXX4BT.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-e95Bpa4X.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-WG_vfQ2v.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-J_o76LsQ.js" as="script"><link rel="prefetch" href="/docs/assets/0x03.module.html-nZRVghio.js" as="script"><link rel="prefetch" href="/docs/assets/0x04.io.html-_O9yb882.js" as="script"><link rel="prefetch" href="/docs/assets/0x05.error.html-NwdkYHAi.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-QpD6RIx1.js" as="script"><link rel="prefetch" href="/docs/assets/python-x.html-IOKdHpYu.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-hNjYxkeX.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-Xciz5_UY.js" as="script"><link rel="prefetch" href="/docs/assets/code-style.html-CjQbu_2e.js" as="script"><link rel="prefetch" href="/docs/assets/server.html-hB7rXNvc.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-EPgTVii8.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-HlFj-ucf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-SYG7W7Ww.js" as="script"><link rel="prefetch" href="/docs/assets/codable.html-XgR28h26.js" as="script"><link rel="prefetch" href="/docs/assets/swift-x.html-Lqv3UBDd.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-BzI-WG4U.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-4VNCuWTN.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-MNEnxrxL.js" as="script"><link rel="prefetch" href="/docs/assets/0x01.guide.html-yFshTz-Z.js" as="script"><link rel="prefetch" href="/docs/assets/0x02.object-oriented.html-1lieU6x9.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-18g78UFQ.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-j_4eKM-4.js" as="script"><link rel="prefetch" href="/docs/assets/shared_preferences.html-ej3P3HR-.js" as="script"><link rel="prefetch" href="/docs/assets/url_launcher.html-pcemazqA.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-dgQLPmaO.js" as="script"><link rel="prefetch" href="/docs/assets/runloop.html-o7rcIc1K.js" as="script"><link rel="prefetch" href="/docs/assets/NSObject.html-iLh5-83y.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-F1Q4Ack0.js" as="script"><link rel="prefetch" href="/docs/assets/associated-object.html-GsGWkJvk.js" as="script"><link rel="prefetch" href="/docs/assets/category.html-A0dUrBSK.js" as="script"><link rel="prefetch" href="/docs/assets/class.html-2MvfV-CO.js" as="script"><link rel="prefetch" href="/docs/assets/function.html-T6oes14c.js" as="script"><link rel="prefetch" href="/docs/assets/memory.html-rF-jasef.js" as="script"><link rel="prefetch" href="/docs/assets/message-forwarding.html-j7eFBH-G.js" as="script"><link rel="prefetch" href="/docs/assets/method.html-hOaHvL7d.js" as="script"><link rel="prefetch" href="/docs/assets/property.html-IhJPvpMF.js" as="script"><link rel="prefetch" href="/docs/assets/protocol.html-b8kwJK41.js" as="script"><link rel="prefetch" href="/docs/assets/runtime.html-XvxuKoVx.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-cvxhk7sK.js" as="script"><link rel="prefetch" href="/docs/assets/giscus-unEZQsJ0.js" as="script"><link rel="prefetch" href="/docs/assets/photoswipe.esm-mC0Qcr12.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/docs/"><img class="vp-nav-logo" src="/docs/logo.svg" alt="知识库"><!----><span class="vp-site-name hide-in-pad">知识库</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="👨🏻‍💻 程序员必备技能"><span class="title"><!---->👨🏻‍💻 程序员必备技能</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="数据结构 + 算法" class="vp-link nav-link nav-link" href="/docs/programmer/core/"><span class="font-icon icon fa-fw fa-sm fas fa-infinity" style=""></span>数据结构 + 算法<!----></a></li><li class="dropdown-item"><a aria-label="网络知识" class="vp-link nav-link nav-link" href="/docs/programmer/network/"><span class="font-icon icon fa-fw fa-sm fas fa-sitemap" style=""></span>网络知识<!----></a></li><li class="dropdown-item"><a aria-label="操作系统" class="vp-link nav-link nav-link" href="/docs/programmer/system/"><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span>操作系统<!----></a></li><li class="dropdown-item"><a aria-label="业务知识" class="vp-link nav-link nav-link" href="/docs/programmer/biz/"><span class="font-icon icon fa-fw fa-sm fas fa-business-time" style=""></span>业务知识<!----></a></li><li class="dropdown-item"><a aria-label="实用工具" class="vp-link nav-link nav-link" href="/docs/programmer/tool/"><span class="font-icon icon fa-fw fa-sm fas fa-screwdriver-wrench" style=""></span>实用工具<!----></a></li><li class="dropdown-item"><a aria-label="Awesome" class="vp-link nav-link nav-link" href="/docs/programmer/awesome/"><span class="font-icon icon fa-fw fa-sm fas fa-gift" style=""></span>Awesome<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="编程知识"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>编程知识</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><a aria-label="编程语言" class="vp-link nav-link nav-link" href="/docs/programming/lang/"><span class="font-icon icon fa-fw fa-sm fas fa-code" style=""></span>编程语言<!----></a></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="Swift" class="vp-link nav-link nav-link" href="/docs/programming/lang/swift/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Swift<!----></a></li><li class="dropdown-subitem"><a aria-label="Java" class="vp-link nav-link nav-link" href="/docs/programming/lang/java/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Java<!----></a></li><li class="dropdown-subitem"><a aria-label="Dart" class="vp-link nav-link nav-link" href="/docs/programming/lang/dart/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Dart<!----></a></li><li class="dropdown-subitem"><a aria-label="Python" class="vp-link nav-link nav-link" href="/docs/programming/lang/python.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Python<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><a aria-label="概念知识" class="vp-link nav-link nav-link" href="/docs/programming/topic/"><span class="font-icon icon fa-fw fa-sm fas fa-mug-saucer" style=""></span>概念知识<!----></a></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="编程范式" class="vp-link nav-link nav-link" href="/docs/programming/topic/paradigm.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>编程范式<!----></a></li><li class="dropdown-subitem"><a aria-label="编码规范" class="vp-link nav-link nav-link" href="/docs/programming/topic/code-style.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>编码规范<!----></a></li><li class="dropdown-subitem"><a aria-label="设计模式" class="vp-link nav-link nav-link" href="/docs/programming/topic/design-pattern.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>设计模式<!----></a></li><li class="dropdown-subitem"><a aria-label="密码学" class="vp-link nav-link nav-link" href="/docs/programming/topic/cryptology.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>密码学<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="前端"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-display" style=""></span>前端</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><a aria-label="客户端" class="vp-link nav-link nav-link" href="/docs/frontend/client/"><span class="font-icon icon fa-fw fa-sm fas fa-mobile" style=""></span>客户端<!----></a></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="iOS" class="vp-link nav-link nav-link" href="/docs/frontend/client/ios/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>iOS<!----></a></li><li class="dropdown-subitem"><a aria-label="Android" class="vp-link nav-link nav-link" href="/docs/frontend/client/android/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Android<!----></a></li><li class="dropdown-subitem"><a aria-label="Flutter" class="vp-link nav-link nav-link" href="/docs/frontend/client/flutter/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Flutter<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><a aria-label="Web 端" class="vp-link nav-link nav-link" href="/docs/frontend/web/"><span class="font-icon icon fa-fw fa-sm fas fa-globe" style=""></span>Web 端<!----></a></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="HMTL" class="vp-link nav-link nav-link" href="/docs/frontend/web/html/"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>HMTL<!----></a></li><li class="dropdown-subitem"><a aria-label="Vue" class="vp-link nav-link nav-link" href="/docs/frontend/web/vue.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Vue<!----></a></li><li class="dropdown-subitem"><a aria-label="React" class="vp-link nav-link nav-link" href="/docs/frontend/web/react.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>React<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="后端"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-cube" style=""></span>后端</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="服务器" class="vp-link nav-link nav-link" href="/docs/backend/server/"><span class="font-icon icon fa-fw fa-sm fas fa-server" style=""></span>服务器<!----></a></li><li class="dropdown-item"><a aria-label="数据库" class="vp-link nav-link nav-link" href="/docs/backend/database/"><span class="font-icon icon fa-fw fa-sm fas fa-database" style=""></span>数据库<!----></a></li><li class="dropdown-item"><a aria-label="服务框架" class="vp-link nav-link nav-link" href="/docs/backend/service/"><span class="font-icon icon fa-fw fa-sm fas fa-box-open" style=""></span>服务框架<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="热门技术"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-fire" style=""></span>热门技术</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="人工智能" class="vp-link nav-link nav-link" href="/docs/trending/ai/"><span class="font-icon icon fa-fw fa-sm fas fa-robot" style=""></span>人工智能<!----></a></li><li class="dropdown-item"><a aria-label="区块链" class="vp-link nav-link nav-link" href="/docs/trending/blockchain/"><span class="font-icon icon fa-fw fa-sm fas fa-boxes-stacked" style=""></span>区块链<!----></a></li><li class="dropdown-item"><a aria-label="其它技术" class="vp-link nav-link nav-link" href="/docs/trending/topic/"><span class="font-icon icon fa-fw fa-sm fas fa-eye" style=""></span>其它技术<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/naijoug/docs" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span><a aria-label="经典面试题" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/docs/interview/core/"><!---->经典面试题<!----></a><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span><a aria-label="iOS" class="vp-link nav-link active vp-sidebar-title nav-link active vp-sidebar-title" href="/docs/interview/ios/"><!---->iOS<!----></a><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="Objective-C" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/docs/interview/ios/0x01.objective-c.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Objective-C<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="设计理念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#设计理念"><!---->设计理念<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓OC、Java、Python 运行效率孰高" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc、java、python-运行效率孰高"><!---->❓OC、Java、Python 运行效率孰高<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 的动态性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-的动态性"><!---->❓OC 的动态性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 是如何保证系统升级后 ABI 的稳定性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-是如何保证系统升级后-abi-的稳定性"><!---->❓OC 是如何保证系统升级后 ABI 的稳定性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓id vs self vs super" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓id-vs-self-vs-super"><!---->❓id vs self vs super<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓id vs NSObject" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓id-vs-nsobject"><!---->❓id vs NSObject<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓id vs instancetype" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓id-vs-instancetype"><!---->❓id vs instancetype<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓id 为什么不能用点语法？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓id-为什么不能用点语法"><!---->❓id 为什么不能用点语法？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓nil vs Nil vs NULL vs NSNull" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nil-vs-nil-vs-null-vs-nsnull"><!---->❓nil vs Nil vs NULL vs NSNull<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓类簇的优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓类簇的优缺点"><!---->❓类簇的优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NSString" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#nsstring"><!---->NSString<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓OC 中的三种字符串？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-中的三种字符串"><!---->❓OC 中的三种字符串？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSString 如何计算字符的个数？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsstring-如何计算字符的个数"><!---->❓NSString 如何计算字符的个数？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NSArray" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#nsarray"><!---->NSArray<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓[[NSMutableArray alloc] init] 和 [NSMutableArray array] 有什么区别?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-nsmutablearray-alloc-init-和-nsmutablearray-array-有什么区别"><!---->❓[[NSMutableArray alloc] init] 和 [NSMutableArray array] 有什么区别?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSMutableArray 是怎么实现的，做增删操作的时候内存空间是怎么改变的，可以用别的方法实现吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsmutablearray-是怎么实现的-做增删操作的时候内存空间是怎么改变的-可以用别的方法实现吗"><!---->❓NSMutableArray 是怎么实现的，做增删操作的时候内存空间是怎么改变的，可以用别的方法实现吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NSDictionary" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#nsdictionary"><!---->NSDictionary<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓NSDictionary 大致实现原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsdictionary-大致实现原理"><!---->❓NSDictionary 大致实现原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSDictionary vs NSHashTable vs NSMapTable" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsdictionary-vs-nshashtable-vs-nsmaptable"><!---->❓NSDictionary vs NSHashTable vs NSMapTable<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSDictionary vs NSCache" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsdictionary-vs-nscache"><!---->❓NSDictionary vs NSCache<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓isEqual 和 hash 的关系？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓isequal-和-hash-的关系"><!---->❓isEqual 和 hash 的关系？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="拷贝" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#拷贝"><!---->拷贝<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓copy 和 mutableCopy 的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓copy-和-mutablecopy-的区别"><!---->❓copy 和 mutableCopy 的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓自定义类如何实现 copy 功能？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓自定义类如何实现-copy-功能"><!---->❓自定义类如何实现 copy 功能？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓自定义类如何实现 mutableCopy 功能？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓自定义类如何实现-mutablecopy-功能"><!---->❓自定义类如何实现 mutableCopy 功能？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓如何重写带 copy 关键字的 setter？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓如何重写带-copy-关键字的-setter"><!---->❓如何重写带 copy 关键字的 setter？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@property (copy) NSMutableArray *array; 这个写法正确吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-property-copy-nsmutablearray-array-这个写法正确吗"><!---->❓@property (copy) NSMutableArray *array; 这个写法正确吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓为什么不可变对象要用 copy？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓为什么不可变对象要用-copy"><!---->❓为什么不可变对象要用 copy？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="属性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#属性"><!---->属性<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓@property 属性是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-property-属性是什么"><!---->❓@property 属性是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@property 的默认关键字？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-property-的默认关键字"><!---->❓@property 的默认关键字？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@property 的底层实现？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-property-的底层实现"><!---->❓@property 的底层实现？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓assign、strong、weak、copy 区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓assign、strong、weak、copy-区别"><!---->❓assign、strong、weak、copy 区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSString 为什么使用 copy，可以使用 strong 吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsstring-为什么使用-copy-可以使用-strong-吗"><!---->❓NSString 为什么使用 copy，可以使用 strong 吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓assign 可以用于 OC 对象吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓assign-可以用于-oc-对象吗"><!---->❓assign 可以用于 OC 对象吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓nonnull 用过吗" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nonnull-用过吗"><!---->❓nonnull 用过吗<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@synthesize vs @dynamic" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-synthesize-vs-dynamic"><!---->❓@synthesize vs @dynamic<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@synthesize 合成实例变量的规则是什么？如果属性名为 foo，存在一个名为 _foo 的实例变量，还会自动合成新变量么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-synthesize-合成实例变量的规则是什么-如果属性名为-foo-存在一个名为-foo-的实例变量-还会自动合成新变量么"><!---->❓@synthesize 合成实例变量的规则是什么？如果属性名为 foo，存在一个名为 _foo 的实例变量，还会自动合成新变量么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓@synthesize 都有哪些使用场景？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-synthesize-都有哪些使用场景"><!---->❓@synthesize 都有哪些使用场景？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Block" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#block"><!---->Block<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓block vs delegate" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-vs-delegate"><!---->❓block vs delegate<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block vs 函数指针" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-vs-函数指针"><!---->❓block vs 函数指针<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 什么情况会发生循环引用？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-什么情况会发生循环引用"><!---->❓block 什么情况会发生循环引用？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓UIView 动画函数 block 版本是否需要处理循环引用？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓uiview-动画函数-block-版本是否需要处理循环引用"><!---->❓UIView 动画函数 block 版本是否需要处理循环引用？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 底层实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-底层实现"><!---->❓block 底层实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 内如何修改外部变量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-内如何修改外部变量"><!---->❓block 内如何修改外部变量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-在捕获自动变量-局部静态变量-全局变量-全局静态变量有什么区别"><!---->❓block 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 捕获外部局部变量实际上发生了什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-捕获外部局部变量实际上发生了什么"><!---->❓block 捕获外部局部变量实际上发生了什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-修改捕获变量除了用-block-还可以怎么做-有哪些局限性"><!---->❓block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 中修改 NSMutableArray 需不需要添加 __block" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-中修改-nsmutablearray-需不需要添加-block"><!---->❓block 中修改 NSMutableArray 需不需要添加 __block<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓__block vs __weak" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-block-vs-weak"><!---->❓__block vs __weak<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓__block 在 ARC 和非 ARC 有区别吗" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-block-在-arc-和非-arc-有区别吗"><!---->❓__block 在 ARC 和非 ARC 有区别吗<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓一个 int 变量用 __block 修饰与不修饰有区别吗" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓一个-int-变量用-block-修饰与不修饰有区别吗"><!---->❓一个 int 变量用 __block 修饰与不修饰有区别吗<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 如何进行内存管理的" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-如何进行内存管理的"><!---->❓block 如何进行内存管理的<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 一般使用 copy 修饰，可以使用 strong 吗，发生 copy 的时机" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-一般使用-copy-修饰-可以使用-strong-吗-发生-copy-的时机"><!---->❓block 一般使用 copy 修饰，可以使用 strong 吗，发生 copy 的时机<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓为什么在 block 外部使用 __weak 修饰的同时需要在内部使用 __strong 修饰" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓为什么在-block-外部使用-weak-修饰的同时需要在内部使用-strong-修饰"><!---->❓为什么在 block 外部使用 __weak 修饰的同时需要在内部使用 __strong 修饰<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 访问对象类型的 auto 变量时，在 ARC 和 MRC 下有什么区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-访问对象类型的-auto-变量时-在-arc-和-mrc-下有什么区别"><!---->❓block 访问对象类型的 auto 变量时，在 ARC 和 MRC 下有什么区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓block 中可以使用 KVC 来访问实例变量吗，可以使用 KVC 修改它的值吗" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓block-中可以使用-kvc-来访问实例变量吗-可以使用-kvc-修改它的值吗"><!---->❓block 中可以使用 KVC 来访问实例变量吗，可以使用 KVC 修改它的值吗<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#类"><!---->类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓+load 与 +initialize 区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-load-与-initialize-区别"><!---->❓+load 与 +initialize 区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓Designated Initializer 如何添加？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓designated-initializer-如何添加"><!---->❓Designated Initializer 如何添加？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 中的内省和反射，底层实现原理，应用场景有哪些" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-中的内省和反射-底层实现原理-应用场景有哪些"><!---->❓OC 中的内省和反射，底层实现原理，应用场景有哪些<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 如何实现多重继承" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-如何实现多重继承"><!---->❓OC 如何实现多重继承<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓静态方法是否能被重写" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓静态方法是否能被重写"><!---->❓静态方法是否能被重写<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="分类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#分类"><!---->分类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓Category vs Extension" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓category-vs-extension"><!---->❓Category vs Extension<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓NSObject 添加 Extension 会怎么样" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓nsobject-添加-extension-会怎么样"><!---->❓NSObject 添加 Extension 会怎么样<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓如果分类中添加与类相同的方法签名会发生什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓如果分类中添加与类相同的方法签名会发生什么"><!---->❓如果分类中添加与类相同的方法签名会发生什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓分类是如何实现的，它为什么会覆盖掉原来的方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓分类是如何实现的-它为什么会覆盖掉原来的方法"><!---->❓分类是如何实现的，它为什么会覆盖掉原来的方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓分类中有与主类相同的方法-如果想要调用主类中的方法如何处理"><!---->❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓两个分类的 load 方法的加载顺序" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓两个分类的-load-方法的加载顺序"><!---->❓两个分类的 load 方法的加载顺序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓两个分类的同名方法的加载顺序" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓两个分类的同名方法的加载顺序"><!---->❓两个分类的同名方法的加载顺序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓一个类中有个多个分类都实现了相同的方法-会调用哪个方法"><!---->❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓分类中为什么不能添加 @property" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓分类中为什么不能添加-property"><!---->❓分类中为什么不能添加 @property<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓分类的结构体里面有哪些成员" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓分类的结构体里面有哪些成员"><!---->❓分类的结构体里面有哪些成员<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓分类中如何添加属性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓分类中如何添加属性"><!---->❓分类中如何添加属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="消息发送" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#消息发送"><!---->消息发送<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="❓OC 是否支持方法重载" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-是否支持方法重载"><!---->❓OC 是否支持方法重载<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 中是如何通过 selector 找到对应的 IMP 地址" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-中是如何通过-selector-找到对应的-imp-地址"><!---->❓OC 中是如何通过 selector 找到对应的 IMP 地址<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓怎么保证自己的类一定能调用到自己写的方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓怎么保证自己的类一定能调用到自己写的方法"><!---->❓怎么保证自己的类一定能调用到自己写的方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 中的类方法和实例方法有什么本质区别和联系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-中的类方法和实例方法有什么本质区别和联系"><!---->❓OC 中的类方法和实例方法有什么本质区别和联系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓在类方法中是否可以使用 self" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓在类方法中是否可以使用-self"><!---->❓在类方法中是否可以使用 self<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓SEL、_cmd 是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓sel、-cmd-是什么"><!---->❓SEL、_cmd 是什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓OC 中对象消息发送的大致流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓oc-中对象消息发送的大致流程"><!---->❓OC 中对象消息发送的大致流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓向一个 nil 对象发送消息将会发生什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓向一个-nil-对象发送消息将会发生什么"><!---->❓向一个 nil 对象发送消息将会发生什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓向一个对象发送消息 [obj foo] 和 objc_msgSend() 函数之间有什么关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓向一个对象发送消息-obj-foo-和-objc-msgsend-函数之间有什么关系"><!---->❓向一个对象发送消息 [obj foo] 和 objc_msgSend() 函数之间有什么关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓一个对象向一个不存在的方法发送消息，消息是如何转发的" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓一个对象向一个不存在的方法发送消息-消息是如何转发的"><!---->❓一个对象向一个不存在的方法发送消息，消息是如何转发的<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓unrecognized selector 异常是如何发生，应该如何避免" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓unrecognized-selector-异常是如何发生-应该如何避免"><!---->❓unrecognized selector 异常是如何发生，应该如何避免<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓_objc_msgForward 函数是做什么的，直接调用它将会发生什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓-objc-msgforward-函数是做什么的-直接调用它将会发生什么"><!---->❓_objc_msgForward 函数是做什么的，直接调用它将会发生什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓C++ 调用虚方法与 OC 发消息有什么区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓c-调用虚方法与-oc-发消息有什么区别"><!---->❓C++ 调用虚方法与 OC 发消息有什么区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓消息转发机制和其他语言的消息机制优劣对比" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓消息转发机制和其他语言的消息机制优劣对比"><!---->❓消息转发机制和其他语言的消息机制优劣对比<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓在方法调用的时候-方法查询-动态解析-消息转发-之前做了什么"><!---->❓在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="❓下面代码能正常运行吗(如果能，输出是什么)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/docs/interview/ios/0x01.objective-c.html#❓下面代码能正常运行吗-如果能-输出是什么"><!---->❓下面代码能正常运行吗(如果能，输出是什么)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="Swift" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x02.swift.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Swift<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="UIKit" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x03.uikit.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>UIKit<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="KVC &amp; KVO" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x04.kvc-kvo.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>KVC &amp; KVO<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="通知机制" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x05.notification.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>通知机制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="Runtime" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x06.runtime.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Runtime<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="RunLoop" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x07.runloop.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>RunLoop<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="网络" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x08.network.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>网络<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="数据存储" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x09.store.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>数据存储<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="多线程" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x10.thread.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>多线程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="内存管理" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x11.memory.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>内存管理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="编译器" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x12.compiler.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>编译器<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="性能优化" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x13.optimization.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>性能优化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="架构设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x14.architecture.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>架构设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="音视频" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x15.media.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>音视频<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="其它知识点" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/docs/interview/ios/0x16.other.html"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>其它知识点<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span><a aria-label="Flutter" class="vp-link nav-link vp-sidebar-title nav-link vp-sidebar-title" href="/docs/interview/flutter/"><!---->Flutter<!----></a><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span>Objective-C</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/naijoug" target="_blank" rel="noopener noreferrer">naijoug</a></span><span property="author" content="naijoug"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-01-07T06:51:09.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 81 分钟</span><meta property="timeRequired" content="PT81M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#设计理念">设计理念</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc、java、python-运行效率孰高">❓OC、Java、Python 运行效率孰高</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-的动态性">❓OC 的动态性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-是如何保证系统升级后-abi-的稳定性">❓OC 是如何保证系统升级后 ABI 的稳定性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓id-vs-self-vs-super">❓id vs self vs super</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓id-vs-nsobject">❓id vs NSObject</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓id-vs-instancetype">❓id vs instancetype</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓id-为什么不能用点语法">❓id 为什么不能用点语法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nil-vs-nil-vs-null-vs-nsnull">❓nil vs Nil vs NULL vs NSNull</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓类簇的优缺点">❓类簇的优缺点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#nsstring">NSString</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-中的三种字符串">❓OC 中的三种字符串？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsstring-如何计算字符的个数">❓NSString 如何计算字符的个数？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#nsarray">NSArray</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-nsmutablearray-alloc-init-和-nsmutablearray-array-有什么区别">❓[[NSMutableArray alloc] init] 和 [NSMutableArray array] 有什么区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsmutablearray-是怎么实现的-做增删操作的时候内存空间是怎么改变的-可以用别的方法实现吗">❓NSMutableArray 是怎么实现的，做增删操作的时候内存空间是怎么改变的，可以用别的方法实现吗？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#nsdictionary">NSDictionary</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsdictionary-大致实现原理">❓NSDictionary 大致实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsdictionary-vs-nshashtable-vs-nsmaptable">❓NSDictionary vs NSHashTable vs NSMapTable</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsdictionary-vs-nscache">❓NSDictionary vs NSCache</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓isequal-和-hash-的关系">❓isEqual 和 hash 的关系？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#拷贝">拷贝</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓copy-和-mutablecopy-的区别">❓copy 和 mutableCopy 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓自定义类如何实现-copy-功能">❓自定义类如何实现 copy 功能？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓自定义类如何实现-mutablecopy-功能">❓自定义类如何实现 mutableCopy 功能？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓如何重写带-copy-关键字的-setter">❓如何重写带 copy 关键字的 setter？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-property-copy-nsmutablearray-array-这个写法正确吗">❓@property (copy) NSMutableArray *array; 这个写法正确吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓为什么不可变对象要用-copy">❓为什么不可变对象要用 copy？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#属性">属性</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-property-属性是什么">❓@property 属性是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-property-的默认关键字">❓@property 的默认关键字？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-property-的底层实现">❓@property 的底层实现？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓assign、strong、weak、copy-区别">❓assign、strong、weak、copy 区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsstring-为什么使用-copy-可以使用-strong-吗">❓NSString 为什么使用 copy，可以使用 strong 吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓assign-可以用于-oc-对象吗">❓assign 可以用于 OC 对象吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nonnull-用过吗">❓nonnull 用过吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-synthesize-vs-dynamic">❓@synthesize vs @dynamic</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-synthesize-合成实例变量的规则是什么-如果属性名为-foo-存在一个名为-foo-的实例变量-还会自动合成新变量么">❓@synthesize 合成实例变量的规则是什么？如果属性名为 foo，存在一个名为 _foo 的实例变量，还会自动合成新变量么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-synthesize-都有哪些使用场景">❓@synthesize 都有哪些使用场景？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#block">Block</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-vs-delegate">❓block vs delegate</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-vs-函数指针">❓block vs 函数指针</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-什么情况会发生循环引用">❓block 什么情况会发生循环引用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓uiview-动画函数-block-版本是否需要处理循环引用">❓UIView 动画函数 block 版本是否需要处理循环引用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-底层实现">❓block 底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-内如何修改外部变量">❓block 内如何修改外部变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-在捕获自动变量-局部静态变量-全局变量-全局静态变量有什么区别">❓block 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-捕获外部局部变量实际上发生了什么">❓block 捕获外部局部变量实际上发生了什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-修改捕获变量除了用-block-还可以怎么做-有哪些局限性">❓block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-中修改-nsmutablearray-需不需要添加-block">❓block 中修改 NSMutableArray 需不需要添加 __block</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-block-vs-weak">❓__block vs __weak</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-block-在-arc-和非-arc-有区别吗">❓__block 在 ARC 和非 ARC 有区别吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓一个-int-变量用-block-修饰与不修饰有区别吗">❓一个 int 变量用 __block 修饰与不修饰有区别吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-如何进行内存管理的">❓block 如何进行内存管理的</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-一般使用-copy-修饰-可以使用-strong-吗-发生-copy-的时机">❓block 一般使用 copy 修饰，可以使用 strong 吗，发生 copy 的时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓为什么在-block-外部使用-weak-修饰的同时需要在内部使用-strong-修饰">❓为什么在 block 外部使用 __weak 修饰的同时需要在内部使用 __strong 修饰</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-访问对象类型的-auto-变量时-在-arc-和-mrc-下有什么区别">❓block 访问对象类型的 auto 变量时，在 ARC 和 MRC 下有什么区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓block-中可以使用-kvc-来访问实例变量吗-可以使用-kvc-修改它的值吗">❓block 中可以使用 KVC 来访问实例变量吗，可以使用 KVC 修改它的值吗</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#类">类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-load-与-initialize-区别">❓+load 与 +initialize 区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓designated-initializer-如何添加">❓Designated Initializer 如何添加？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-中的内省和反射-底层实现原理-应用场景有哪些">❓OC 中的内省和反射，底层实现原理，应用场景有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-如何实现多重继承">❓OC 如何实现多重继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓静态方法是否能被重写">❓静态方法是否能被重写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#分类">分类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓category-vs-extension">❓Category vs Extension</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓nsobject-添加-extension-会怎么样">❓NSObject 添加 Extension 会怎么样</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓如果分类中添加与类相同的方法签名会发生什么">❓如果分类中添加与类相同的方法签名会发生什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓分类是如何实现的-它为什么会覆盖掉原来的方法">❓分类是如何实现的，它为什么会覆盖掉原来的方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓分类中有与主类相同的方法-如果想要调用主类中的方法如何处理">❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓两个分类的-load-方法的加载顺序">❓两个分类的 load 方法的加载顺序</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓两个分类的同名方法的加载顺序">❓两个分类的同名方法的加载顺序</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓一个类中有个多个分类都实现了相同的方法-会调用哪个方法">❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓分类中为什么不能添加-property">❓分类中为什么不能添加 @property</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓分类的结构体里面有哪些成员">❓分类的结构体里面有哪些成员</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓分类中如何添加属性">❓分类中如何添加属性</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#消息发送">消息发送</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-是否支持方法重载">❓OC 是否支持方法重载</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-中是如何通过-selector-找到对应的-imp-地址">❓OC 中是如何通过 selector 找到对应的 IMP 地址</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓怎么保证自己的类一定能调用到自己写的方法">❓怎么保证自己的类一定能调用到自己写的方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-中的类方法和实例方法有什么本质区别和联系">❓OC 中的类方法和实例方法有什么本质区别和联系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓在类方法中是否可以使用-self">❓在类方法中是否可以使用 self</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓sel、-cmd-是什么">❓SEL、_cmd 是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓oc-中对象消息发送的大致流程">❓OC 中对象消息发送的大致流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓向一个-nil-对象发送消息将会发生什么">❓向一个 nil 对象发送消息将会发生什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓向一个对象发送消息-obj-foo-和-objc-msgsend-函数之间有什么关系">❓向一个对象发送消息 [obj foo] 和 objc_msgSend() 函数之间有什么关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓一个对象向一个不存在的方法发送消息-消息是如何转发的">❓一个对象向一个不存在的方法发送消息，消息是如何转发的</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓unrecognized-selector-异常是如何发生-应该如何避免">❓unrecognized selector 异常是如何发生，应该如何避免</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓-objc-msgforward-函数是做什么的-直接调用它将会发生什么">❓_objc_msgForward 函数是做什么的，直接调用它将会发生什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓c-调用虚方法与-oc-发消息有什么区别">❓C++ 调用虚方法与 OC 发消息有什么区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓消息转发机制和其他语言的消息机制优劣对比">❓消息转发机制和其他语言的消息机制优劣对比</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓在方法调用的时候-方法查询-动态解析-消息转发-之前做了什么">❓在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#❓下面代码能正常运行吗-如果能-输出是什么">❓下面代码能正常运行吗(如果能，输出是什么)</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><!-- more --><h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><p><code>OC</code> 底层是使用 <code>C/C++</code> 实现。定一个继承 <code>NSObject</code> 的类，这个类底层使用 <code>C</code> 语言中的 <code>struct</code> 结构体来实现的。</p><h3 id="❓oc、java、python-运行效率孰高" tabindex="-1"><a class="header-anchor" href="#❓oc、java、python-运行效率孰高" aria-hidden="true">#</a> ❓<code>OC、Java、Python</code> 运行效率孰高</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>Objective-C</code>: 编译型语言，运行效率通常优于解释型语言。底层是基于 <code>C</code>，但是由于动态派发的特性会一定程度上影响效率。</p></li><li><p><code>Java</code>: 编译型语言，运行环境是 <code>JVM</code>(<code>Java</code> 虚拟机)，通过 <code>JIT</code>(Just In Time compiler)技术，<code>Java</code> 能将字节码实时地编译成机器码运行，因此运行效率<strong>较高</strong>，而且在大数据和 <code>Web</code> 服务领域表现优秀。</p></li><li><p><code>Python</code>: 是解释型语言，其运行效率<strong>较低</strong>，无法与编译型语言相比。但是 <code>Python</code> 的易读性、易写性以及丰富的第三方库，使它在科学计算、人工智能等领域得到了广泛的应用。</p></li></ul></details><h3 id="❓oc-的动态性" tabindex="-1"><a class="header-anchor" href="#❓oc-的动态性" aria-hidden="true">#</a> ❓<code>OC</code> 的动态性</h3><details class="hint-container details"><summary>💡</summary><p>首先理解两个“动态语言与静态语言”</p><p><code>OC</code> 的 <code>runtime</code> 文档中介绍中就详细写明了，<code>runtime</code> 的设计是为了将 <code>OC</code> 中的更多的处理延迟到编译后。</p><ul><li>动态类型 (<code>Dynamic typing</code>) : 编译时并不确定对象类型，在运行时才判断对象的类型。<code>OC</code> 中一切对象都可以用 <code>id</code> 指针指向。</li><li>动态绑定 (<code>Dynamic binding</code>) : 方法的调用也是运行时才决定，而并非编译时。</li><li>动态加载 (<code>Dynamic loading</code>) : 运行时可以动态加载其它模块或框架</li></ul></details><h3 id="❓oc-是如何保证系统升级后-abi-的稳定性" tabindex="-1"><a class="header-anchor" href="#❓oc-是如何保证系统升级后-abi-的稳定性" aria-hidden="true">#</a> ❓<code>OC</code> 是如何保证系统升级后 <code>ABI</code> 的稳定性</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>向后兼容（<code>Backward Compatibility</code>）：新版本的系统库在设计和更新时，会尽量保证向下兼容。</p></li><li><p>动态性（<code>Dynamic Nature</code>）：作为一种动态语言，<code>OC</code> 大量使用动态分发和运行时解析。这意味着很多事情在运行时才确定，例如方法的调用、对象的生成等。这种机制在维护 <code>ABI</code> 稳定性时有很大的灵活性，可以在运行时解析和处理一些可能的问题。</p></li><li><p>利用类和分类（<code>Class and Category</code>）：使用类和分类来模块化代码，使得代码逻辑更容易管理，也更利于维护 <code>ABI</code> 稳定性。在新增或者修改功能时，可以通过添加新的类或者分类，而不是修改旧的代码，这样就能保证旧的代码逻辑和 <code>ABI</code> 不被破坏。</p></li><li><p>接口过期标注(<code>API Deprecation</code>)：系统库在引入新的接口时，会把不推荐使用的旧接口标记为 <code>deprecated</code>，但不会立即删除，这样就可以保证依赖旧接口的代码在一段时间内可以正常运行。</p><p>以上这些都只能尽可能地保证 ABI 的稳定性，但并不能绝对地保证。因为系统升级往往会引入新的功能、新的架构，或者修复旧的 <code>bug</code>，这些都可能对 <code>ABI</code> 产生影响。所以，作为开发者在编写代码时，也需要注意兼容性，避免过度依赖可能会变动的接口和行为。</p></li></ul></details><h3 id="❓id-vs-self-vs-super" tabindex="-1"><a class="header-anchor" href="#❓id-vs-self-vs-super" aria-hidden="true">#</a> ❓<code>id</code> vs <code>self</code> vs <code>super</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>id</code>：一种数据类型，也叫做动态对象类型，所有的 <code>Objective-C</code> 对象都可以用 <code>id</code> 类型来接收。<code>id</code> 类型会忽略类型信息，可以给它发送任何消息，如果在运行时对象能够响应这个消息，则代码可以正常运行，否则会在运行时报错。</p></li><li><p><code>self</code>: 每个对象方法的隐含参数，它指向调用当前方法的对象。<code>self</code> 的数据类型也是 <code>id</code>，但它通常用来引用对象自己。可以用 <code>self</code> 来访问属性或者调用方法。</p></li><li><p><code>super</code>: 并不是一个指针，是一个编译器标识符，代表当前对象的父类。当你向 <code>super</code> 发送消息时，编译器会沿着方法的继承链向上寻找，直到找到对应的方法实现为止。这个机制可用于在子类中调用父类的同名方法，以实现代码的复用。</p></li></ul></details><h3 id="❓id-vs-nsobject" tabindex="-1"><a class="header-anchor" href="#❓id-vs-nsobject" aria-hidden="true">#</a> ❓<code>id</code> vs <code>NSObject</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>id</code>: 一个动态类型的对象指针，它可以指向任何类型的 <code>Objective-C</code> 对象。<code>id</code> 类型的对象可以接收任何消息而不会在编译期报错，运行期若无法响应则会引发异常。使用 <code>id</code> 类型可以编写出非常灵活的代码，但是也需要面对潜在的运行期错误。</p></li><li><p><code>NSObject</code>: 是所有 <code>Objective-C</code> 类的基类，定义了一些所有对象都能响应的基本方法，例如 -<code>init</code>、<code>retain</code>、<code>release</code> 等。如果一个对象类型声明为 <code>NSObject *</code>，只能给它发送 <code>NSObject</code> 类中定义的方法。如果试图发送其他消息，会得到一个编译错误。</p></li></ul></details><h3 id="❓id-vs-instancetype" tabindex="-1"><a class="header-anchor" href="#❓id-vs-instancetype" aria-hidden="true">#</a> ❓<code>id</code> vs <code>instancetype</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>id</code>：一个动态类型的对象指针，可以指向任何类型的 <code>Objective-C</code> 对象。使用 <code>id</code> 类型的变量可以调用任何方法，如果该对象的类实现了该方法，那么就会在运行时调用。缺点是编译器无法进行类型检查和自动补全。</p></li><li><p><code>instancetype</code>：一种特殊的类型，主要用于表示对象的实例，用在方法的返回类型中。与 <code>id</code> 类型不同，方法使用 <code>instancetype</code> 作为返回类型，那么编译器会认为该方法返回一个当前类的实例。这个特性可以帮助编译器进行更准确的类型检查，同时还能提供自动补全的支持。</p></li></ul></details><h3 id="❓id-为什么不能用点语法" tabindex="-1"><a class="header-anchor" href="#❓id-为什么不能用点语法" aria-hidden="true">#</a> ❓<code>id</code> 为什么不能用点语法？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>点语法是一种简化属性访问的语法。底层实际上是编译器做了一个转换操作，把点语法转换成相应的 <code>getter</code>（对于获取属性）或者 <code>setter</code>（对于设置属性）方法的调用。</p></blockquote><ul><li><p>明确类型的对象，编译器可以知道对象的类定义，知道该对象所拥有的属性和方法，所以在编译期可以正确地做出转换。</p></li><li><p><code>id</code> 类型的对象，编译器无法知道它的实际类型以及拥有的属性和方法，所以无法进行点语法的转换。</p></li></ul></details><h3 id="❓nil-vs-nil-vs-null-vs-nsnull" tabindex="-1"><a class="header-anchor" href="#❓nil-vs-nil-vs-null-vs-nsnull" aria-hidden="true">#</a> ❓<code>nil</code> vs <code>Nil</code> vs <code>NULL</code> vs <code>NSNull</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p>这些都是表示&quot;无&quot;或&quot;空&quot;的特定值</p></blockquote><ul><li><p><code>nil</code>：一个表示对象指针为空的特殊值。</p></li><li><p><code>Nil</code>：一个表示类指针为空的特殊值。</p></li><li><p><code>NULL</code>：一个表示未指向任何东西的原始指针的特殊值。正如你在任何纯<code>C</code>的代码和<code>Objective-C</code>代码中看到的，<code>NULL</code>通常指针表示&quot;没有东西&quot;或者是&quot;无&quot;。</p></li><li><p><code>NSNull</code>：一个表示空值的类，通常在不能使用<code>nil</code>的情况下表示空值。比如在<code>NSArray</code>或<code>NSDictionary</code>对象中，你不能直接使用<code>nil</code>，但你可以用一个<code>NSNull</code>对象来代表&quot;没有值&quot;的情况。</p></li></ul><p>这些都表示某种形式的&quot;无&quot;或&quot;空&quot;，但是每个在特定的情况下使用，并且可能有它们自己的行为和属性。</p></details><h3 id="❓类簇的优缺点" tabindex="-1"><a class="header-anchor" href="#❓类簇的优缺点" aria-hidden="true">#</a> ❓类簇的优缺点</h3><details class="hint-container details"><summary>💡</summary><blockquote><p>类簇（<code>Class Cluster</code>）是一种设计模式，在 <code>Objective-C</code> 的类库中有广泛的运用，例如<code>NSString</code>，<code>NSArray</code>，<code>NSDictionary</code>等都是类簇的例子。类簇将一些实现细节封装在内部，对外只提供一个简单的公共接口。</p></blockquote><ul><li><p>优点：</p><ul><li><p>封装：类簇将相关的子类放在同一个父类中，使得框架更加简洁，使用者无需熟悉大量类就能够做很多事情。</p></li><li><p>隐藏实现细节：对外只暴露抽象的接口，隐藏了具体实现的细节。这也保护了代码的稳定性，即使在实现过程中改变了相关的类或算法，对外接口的不变就保证了代码的稳定性。</p></li><li><p>代码的分层更加清晰：类簇模式将数据和操作数据的方法绑定在同一个对象上，使得类的分层关系更清楚。</p></li></ul></li><li><p>缺点：</p><ul><li><p>可扩展性差：由于类簇的具体实现不对外暴露，所以如果需要定制某些特殊的行为，扩展性就会变得很差。</p></li><li><p>创建子类困难：由于大部分方法在私有子类中实现，如果要创建类簇的子类并覆盖某些方法，可能需要实现大量的代码才能获得预期的行为。</p></li><li><p>维护难度大：由于类簇中包含了大量的私有子类，如果要修改或扩展代码，就需要对所有的子类进行处理，这会增加维护难度。</p></li></ul></li></ul></details><hr><h2 id="nsstring" tabindex="-1"><a class="header-anchor" href="#nsstring" aria-hidden="true">#</a> NSString</h2><h3 id="❓oc-中的三种字符串" tabindex="-1"><a class="header-anchor" href="#❓oc-中的三种字符串" aria-hidden="true">#</a> ❓<code>OC</code> 中的三种字符串？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>__NSCFConstantString</code> ：在编译时被创建的常量字符串对象，如<code>NSString *str = @&quot;Hello, World!&quot;</code>。这些对象会在编译时就被创建，并且在程序的整个生命周期中都不会被销毁。</p></li><li><p><code>__NSTaggedPointerString</code> ：使用 <code>Tagged Pointer</code> 技术来提高内存使用效率，通常用于存储较小的字符串数据。</p></li><li><p><code>__NSCFString</code> ：本质上是一个 <code>Core Foundation</code> 字符串的引用（<code>CFStringRef</code>），这种类型的字符串通常会在运行时程序动态创建的对象字符串。</p></li></ul></details><blockquote><p><code>Tagged Pointer</code> 了解吗？</p></blockquote><details class="hint-container details"><summary>💡</summary><blockquote><p><code>iOS 7</code> 之后 <code>Apple</code> 为了优化引入的一项技术。从字面意思上来看<code>Tagged Pointer</code>就是带有标签的指针。</p></blockquote><p>一般来说，在 <code>64-bit</code> 架构下，一个指针的值需要占用 <code>8 byte</code> 的内存空间；然而对于一些非常小的数据，比如 <code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code> 等，使用 <code>8 byte</code> 存储对象指针就显得非常浪费。为了解决这个问题，苹果引入了 <code>Tagged Pointer</code> 技术，通过标签直接将小的数据对象嵌入到指针中，这样对于小的数据对象，就无需额外的内存来存储了，能够显著提高内存的利用率。需要注意，一个对象是否使用 <code>Tagged Pointer</code> 是由系统决定的，不能人为控制。</p><p>具体到 <code>NSString</code> 这种场景中，如果字符串的内容非常短，那么它的实现方式可能就是 <code>Tagged Pointer</code>，直接将字符串内容存在指针中，提高了内存利用率。</p></details><h3 id="❓nsstring-如何计算字符的个数" tabindex="-1"><a class="header-anchor" href="#❓nsstring-如何计算字符的个数" aria-hidden="true">#</a> ❓<code>NSString</code> 如何计算字符的个数？</h3><details class="hint-container details"><summary>💡</summary><p>可以使用 <code>NSString</code> 的 <code>length</code> 属性来获取字符串长度，但这实际上返回的是字符串中 <code>Unicode</code> 编码的字符数量，并不是通常意义上的字符数量。例如，一个中文字符和一个 <code>emoji</code> 表情，可能都会被算作多个 <code>Unicode</code> 字符。</p><p>可以使用 <code>NSString</code> 的 <code>enumerateSubstringsInRange:options:usingBlock:</code> 方法，用 <code>NSStringEnumerationByComposedCharacterSequences</code> 选项来统计字符串的字符数量。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__block NSUInteger characterCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>myString enumerateSubstringsInRange<span class="token punctuation">:</span><span class="token function">NSMakeRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> myString<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
                           options<span class="token punctuation">:</span>NSStringEnumerationByComposedCharacterSequences
                        usingBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span>substring<span class="token punctuation">,</span> NSRange substringRange<span class="token punctuation">,</span> NSRange enclosingRange<span class="token punctuation">,</span> BOOL <span class="token operator">*</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    characterCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="nsarray" tabindex="-1"><a class="header-anchor" href="#nsarray" aria-hidden="true">#</a> NSArray</h2><h3 id="❓-nsmutablearray-alloc-init-和-nsmutablearray-array-有什么区别" tabindex="-1"><a class="header-anchor" href="#❓-nsmutablearray-alloc-init-和-nsmutablearray-array-有什么区别" aria-hidden="true">#</a> ❓<code>[[NSMutableArray alloc] init]</code> 和 <code>[NSMutableArray array]</code> 有什么区别?</h3><details class="hint-container details"><summary>详情</summary><ul><li><p>相同点：都是用来创建一个可变数组的。</p></li><li><p>不同点</p><ul><li>代码简洁度：<code>[NSMutableArray array]</code> 比 <code>[[NSMutableArray alloc] init]</code> 代码更简洁，更易于阅读和理解。</li><li>返回的对象所有权：<code>[[NSMutableArray alloc] init]</code> 返回的是一个引用计数为 1 的对象，而 <code>[NSMutableArray array]</code> 返回的是一个自动释放的对象（<code>autoreleased object</code>）。因此，如果在方法内创建了数组，然后需要返回这个数组，那么 <code>[NSMutableArray array]</code> 是一个更好的选择，因为它返回的对象会在方法结束后自动释放，不需要手动释放。如果是在方法内部创建数组，且数组在方法结束后就不再需要，那么 <code>[[NSMutableArray alloc] init]</code> 是一个更好的选择，因为它的引用计数为1，当不再需要它时，可以通过调用 <code>release</code> 方法将其释放。</li></ul></li></ul></details><h3 id="❓nsmutablearray-是怎么实现的-做增删操作的时候内存空间是怎么改变的-可以用别的方法实现吗" tabindex="-1"><a class="header-anchor" href="#❓nsmutablearray-是怎么实现的-做增删操作的时候内存空间是怎么改变的-可以用别的方法实现吗" aria-hidden="true">#</a> ❓<code>NSMutableArray</code> 是怎么实现的，做增删操作的时候内存空间是怎么改变的，可以用别的方法实现吗？</h3><details class="hint-container details"><summary>💡</summary><p><code>NSMutableArray</code> 的实现是由 Apple 的 <code>Foundation</code> 框架完成的，它是一个动态数组，可以增加和删除元素。具体的内部实现细节 Apple 没有公开，但我们可以推测它的内部工作原理是类似以下方式：</p><ol><li><p>在创建 <code>NSMutableArray</code> 时，会分配一段连续的内存空间，用来保存元素。当元素数量超过数组的容量时，<code>Foundation</code> 框架会创建一个新的、更大的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。</p></li><li><p>当从 <code>NSMutableArray</code> 中删除元素时，它并不会立即收缩内存空间。相反，被删除元素的位置会被标记为空闲，可以用来保存新添加的元素。只有当数组的空闲空间达到一定的阈值时，<code>Foundation</code> 框架才会创建一个新的、更小的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。</p></li></ol><p>关于第二个问题，肯定可以用别的方法来实现一个动态数组。例如，我们可以用 <code>C</code> 语言的动态内存分配函数 <code>malloc</code>、<code>realloc</code> 和 <code>free</code> 来实现一个动态数组。另外，我们也可以使用链表数据结构来实现类似 <code>NSMutableArray</code> 的功能，但是链表的随机访问性能较差，不适合需要频繁随机访问元素的场景。</p></details><hr><h2 id="nsdictionary" tabindex="-1"><a class="header-anchor" href="#nsdictionary" aria-hidden="true">#</a> NSDictionary</h2><h3 id="❓nsdictionary-大致实现原理" tabindex="-1"><a class="header-anchor" href="#❓nsdictionary-大致实现原理" aria-hidden="true">#</a> ❓<code>NSDictionary</code> 大致实现原理</h3><details class="hint-container details"><summary>💡</summary><p><code>NSDictionary</code> 是 <code>Objective-C</code> 中一个非常重要的类，它提供了一个以键值对形式存储对象的接口，是一种哈希表实现。</p><p>尽管 <code>Foundation</code> 框架的具体实现没有公开，但我们可以推测一下它的实现原理：</p><ol><li><p>哈希表：在哈希表中，哈希函数将每个键 (<code>key</code>) 映射到表中一个唯一的索引。通过该索引，存储的相关值 (<code>value</code>) 可以快速地被找到。这就是 <code>NSDictionary</code> 可以快速查找键对应值的原因。</p></li><li><p>碰撞处理：当两个或者更多的键映射到哈希表的同一个位置时，就会发生碰撞。通常情况下，有几种策略可以处理这种碰撞，比如链地址法，开放地址法等。不过具体 <code>Foundation</code> 使用哪种策略去处理碰撞我们并不清楚。</p></li><li><p>动态调整：随着数据的增加，为了保持操作的高效，哈希表可能需要进行扩容。扩容经常伴随着数据的重新哈希，为的就是保持哈希值均匀分布，保持优秀的查找效率。</p></li></ol></details><h3 id="❓nsdictionary-vs-nshashtable-vs-nsmaptable" tabindex="-1"><a class="header-anchor" href="#❓nsdictionary-vs-nshashtable-vs-nsmaptable" aria-hidden="true">#</a> ❓<code>NSDictionary</code> vs <code>NSHashTable</code> vs <code>NSMapTable</code></h3><details class="hint-container details"><summary>💡</summary><p><code>NSDictionary</code>，<code>NSHashTable</code> 和 <code>NSMapTable</code> 都是 <code>Objective-C</code> 中常用的集合类型，各有其特性和适用场景：</p><ol><li><p><code>NSDictionary</code>：存储键值对的集合，每个键都映射到一个值。对键进行<code>copy</code>操作，对值进行<code>retain</code>(强引用)操作。键必须要保持唯一。查找操作性能高效，时间复杂性为O(1)。</p></li><li><p><code>NSHashTable</code>：一个可以存储任意对象的集合，集合中的每个对象都是唯一的。该类提供了对对象强引用、弱引用的选项，可以更加灵活地进行内存管理。</p></li><li><p><code>NSMapTable</code>：和 <code>NSDictionary</code> 非常相似，但 <code>NSMapTable</code> 对键和值可以选择强引用或弱引用，比 <code>NSDictionary</code> 更加灵活。另外，<code>NSMapTable</code> 允许键和值为<code>nil</code>，而 <code>NSDictionary</code> 则不允许。</p></li></ol><p>在考虑使用哪一个时，视具体需求而定：</p><ul><li><p>当你需要按照键查找值，且对键和值的生命周期没有特殊要求时，使用 <code>NSDictionary</code>。</p></li><li><p>当你需要存储一组唯一对象，并且想要对对象的生命周期有更细粒度的控制时，使用 <code>NSHashTable</code>。</p></li><li><p>当你需要存储键值对对象，并且想要对键和值的生命周期有细粒度的控制，或者你需要在集合中存储<code>nil</code>对象时，使用 <code>NSMapTable</code>。</p></li></ul></details><blockquote><p>分别有哪些使用场景？</p></blockquote><details class="hint-container details"><summary>💡</summary><ol><li><p><code>NSDictionary</code>：<code>NSDictionary</code> 由于其高效的查找速度，广泛用于需要依据键查找值的场景。例如，配置文件的存储和读取，网络请求的参数封装，JSON 数据的解析等。</p></li><li><p><code>NSHashTable</code>：<code>NSHashTable</code> 适用于存储不需要重复的对象，并且对内存管理有一定要求的场景。例如，在缓存中存储对象但不引入强引用，防止内存无法释放的问题；或者在存储 <code>delegate</code> 对象时，避免引入循环引用。</p></li><li><p><code>NSMapTable</code>：<code>NSMapTable</code> 可以实现强引用和弱引用键值对，所以适用于一些特殊场景。例如，你想在不引入强引用的情况下缓存对象，或者你希望跟踪哪些对象引用了其它对象等。</p></li></ol><p>在实际开发中，正确地选择并使用这些集合可以帮助你更好地管理内存和提高程序性能。</p></details><h3 id="❓nsdictionary-vs-nscache" tabindex="-1"><a class="header-anchor" href="#❓nsdictionary-vs-nscache" aria-hidden="true">#</a> ❓<code>NSDictionary</code> vs <code>NSCache</code></h3><details class="hint-container details"><summary>💡</summary><p><code>NSDictionary</code> 和 <code>NSCache</code> 都是能够存储键值对的集合，但它们有一些主要的区别，使它们适用于不同的使用场景：</p><ol><li><p><code>NSDictionary</code> 是一个不可变的哈希表，其中的键值对都是强引用的。键是唯一的且不可变的。相比之下，<code>NSCache</code> 是一个可变的集合，其中的键值对都是强引用的，但有一个例外：键不是像 <code>NSDictionary</code> 管理那样通过 <code>copy</code> 管理，而是通过 <code>retain</code> 管理，因此键可以是可变的。</p></li><li><p>另一个重要的区别在于内存管理。<code>NSCache</code> 在系统内存不足时，会自动释放缓存的部分或全部数据以节省内存。这使得在处理大量数据时，<code>NSCache</code> 可以自动处理低内存警告，而 <code>NSDictionary</code> 则需要手动处理低内存警告。</p></li><li><p><code>NSCache</code> 支持通过 <code>NSDiscardableContent</code> 协议来控制缓存内容的生命周期。这样的对象在被缓存时，可以增加一个 <code>beginContentAccess</code> 之后配对的 <code>endContentAccess</code> 调用计数器。当对象的计数器为 0 时，那么这个对象就有可能被清出缓存。</p></li></ol><p>综上所述，<code>NSDictionary</code> 和 <code>NSCache</code> 的不同主要在于内存管理和可变性。实际上，<code>NSCache</code> 更类似一个优化了内存管理的 <code>NSMutableDictionary</code>，更适合用于存储大量会占据大量内存的对象，例如图片等。</p></details><blockquote><p><code>NSCache</code> 中缓存的对象，在什么时候被释放？</p></blockquote><details class="hint-container details"><summary>💡</summary><p><code>NSCache</code> 中缓存的对象被释放的时机取决于几个因素：</p><ol><li><p>内存压力：当操作系统触发低内存警告时，<code>NSCache</code> 会自动释放一些缓存的对象以节约内存。</p></li><li><p>缓存某个对象的 <code>NSCache</code> 实例被销毁时，该对象会被释放。</p></li><li><p>当缓存达到其极限时（这取决于你设置的缓存的数量和总成本的上限），<code>NSCache</code> 可能会开始移除一些对象。</p></li><li><p>如果缓存的对象实现了 <code>NSDiscardableContent</code> 协议，那么对象的释放还会取决于它的 <code>beginContentAccess</code> 和 <code>endContentAccess</code> 方法的调用计数。当这个计数为 0 并且内存压力较大时，对象可能被释放。</p></li></ol><p>这样的设计使 <code>NSCache</code> 非常适合用于缓存大量占用内存的对象（例如图片等）。因为它的自动内存管理机制可以防止应用因为低内存压力而崩溃，同时还能确保缓存的有效利用。</p></details><h3 id="❓isequal-和-hash-的关系" tabindex="-1"><a class="header-anchor" href="#❓isequal-和-hash-的关系" aria-hidden="true">#</a> ❓<code>isEqual</code> 和 <code>hash</code> 的关系？</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，<code>isEqual:</code> 和 <code>hash</code> 两个方法在很多场合都需要同时使用，比如在对自定义对象进行集合操作（存入 <code>NSSet</code>，作为 <code>NSDictionary</code> 的 Key 等）时。它们的关系可以这样理解：</p><ol><li><p><code>isEqual:</code> 方法是用来判断两个对象是否相等。如何判断对象的相等性，你可以在自定义类中重写这个方法来自定义判断规则。</p></li><li><p><code>hash</code> 方法返回一个无符号整数（<code>NSUInteger</code>）的哈希值，这个值被用于 <code>UITableView</code>、<code>NSSet</code>、<code>NSDictionary</code> 等集合类的操作以提升性能。对象的哈希值主要是通过对象的内容进行计算得出。</p></li><li><p><code>isEqual:</code>方法和 <code>hash</code> 方法需要保持一致，意思是当两个对象 <code>isEqual</code> 的返回值相等时，它们的 <code>hash</code> 方法返回值必须也相等。反过来并不一定，即如果两个对象的 <code>hash</code> 值相等，并不一定要求他们 <code>isEqual</code> 值也一定相等，因为不同的对象有可能产生相同的哈希值（通常被称为哈希冲突）。</p></li></ol><p>总结来说，如果你需要自定义对象及其相等性的规则，那么通常需要同时重载 <code>isEqual:</code> 和 <code>hash</code> 方法，并确保它们的行为是一致的。</p></details><hr><h2 id="拷贝" tabindex="-1"><a class="header-anchor" href="#拷贝" aria-hidden="true">#</a> 拷贝</h2><h3 id="❓copy-和-mutablecopy-的区别" tabindex="-1"><a class="header-anchor" href="#❓copy-和-mutablecopy-的区别" aria-hidden="true">#</a> ❓<code>copy</code> 和 <code>mutableCopy</code> 的区别？</h3><details class="hint-container details"><summary>💡</summary><p><code>copy</code> 和 <code>mutableCopy</code> 是 <code>Foundation</code> 框架 <code>NSObject</code> 类中定义的方法，被用来创建对象的拷贝，它们的区别如下：</p><ol><li><p><code>copy</code>：执行的是浅拷贝（也叫做指针拷贝），拷贝后的对象类型是不可变的。这意味着在实际操作中，<code>copy</code> 并没有开辟新的内存空间，而是拷贝对象持有的指针。因此原始对象和拷贝对象指向相同的内存地址。</p></li><li><p><code>mutableCopy</code>：执行的是深拷贝（也叫做内容拷贝），拷贝后的对象类型是可变的。这意味着在实际操作中，<code>mutableCopy</code> 会开辟一块新的内存空间，拷贝对象的值到这块新的内存空间。</p></li></ol><p>主要的差异是拷贝出来的对象可变性和持有数据的方式（指针拷贝或者内容拷贝）。需要注意的是，浅拷贝并不意味着拷贝出来的对象一定是不可变的，具体还需要看拷贝的源对象是什么类型。如果拷贝的源对象是不可变的，那么 <code>copy</code> 方法拷贝出来的对象也是不可变的；如果拷贝的源对象是可变的，那么 <code>copy</code> 方法拷贝出来的对象就是可变的。</p></details><h3 id="❓自定义类如何实现-copy-功能" tabindex="-1"><a class="header-anchor" href="#❓自定义类如何实现-copy-功能" aria-hidden="true">#</a> ❓自定义类如何实现 <code>copy</code> 功能？</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，如果需要支持拷贝功能，那么需要声明并实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 协议。这通常涉及重写 <code>copyWithZone:</code> 方法。</p><p>以一个简单的自定义类 <code>Person</code> 为例，假设它有两个属性 <code>name</code> 和 <code>age</code>：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Person <span class="token punctuation">:</span> NSObject <span class="token operator">&lt;</span>NSCopying<span class="token operator">&gt;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> NSUInteger age<span class="token punctuation">;</span>
<span class="token keyword">@end</span>
 
<span class="token keyword">@implementation</span> Person
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>copyWithZone<span class="token punctuation">:</span><span class="token punctuation">(</span>NSZone <span class="token operator">*</span><span class="token punctuation">)</span>zone <span class="token punctuation">{</span>
    Person <span class="token operator">*</span>copyPerson <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span> allocWithZone<span class="token punctuation">:</span>zone<span class="token punctuation">]</span>init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    copyPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>name copyWithZone<span class="token punctuation">:</span>zone<span class="token punctuation">]</span><span class="token punctuation">;</span>
    copyPerson<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> copyPerson<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，通过 <code>[xx copy]</code> 的语法就可以获取到 <code>Person</code> 的拷贝了。其中，<code>copyWithZone:</code> 方法创建了一个新的实例，然后复制了 <code>name</code> 和 <code>age</code> 属性。</p></details><h3 id="❓自定义类如何实现-mutablecopy-功能" tabindex="-1"><a class="header-anchor" href="#❓自定义类如何实现-mutablecopy-功能" aria-hidden="true">#</a> ❓自定义类如何实现 <code>mutableCopy</code> 功能？</h3><details class="hint-container details"><summary>💡</summary><p>以一个 <code>Person</code> 类为例，如果需要自定义类型实现 <code>mutableCopy</code>，需要遵循 <code>NSMutableCopying</code> 协议并实现 <code>mutableCopyWithZone:</code> 方法。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Person <span class="token punctuation">:</span> NSObject <span class="token operator">&lt;</span>NSMutableCopying<span class="token operator">&gt;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> NSUInteger age<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> Person
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>mutableCopyWithZone<span class="token punctuation">:</span><span class="token punctuation">(</span>NSZone <span class="token operator">*</span><span class="token punctuation">)</span>zone <span class="token punctuation">{</span>
    Person <span class="token operator">*</span>copyPerson <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span> allocWithZone<span class="token punctuation">:</span>zone<span class="token punctuation">]</span>init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    copyPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>name mutableCopyWithZone<span class="token punctuation">:</span>zone<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    copyPerson<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>  
    <span class="token keyword">return</span> copyPerson<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，声明 <code>Person</code> 类遵循 <code>NSMutableCopying</code> 协议，并实现其 <code>mutableCopyWithZone:</code> 方法。在该方法中，创建一个新的 <code>Person</code> 实例，然后逐个将原始对象的属性值复制到新的实例上。对于 <code>name</code> 属性，调用其 <code>mutableCopyWithZone:</code> 方法来得到一个可变副本。而对于 <code>age</code> 属性，由于它是一个基本数据类型，直接赋值即可。</p><p>记住，<code>mutableCopyWithZone:</code> 方法返回的应该是一个全新的实例，而不应该是原始对象自身，因为这样才是 <code>deep copy</code>, 克隆出来的对象和原对象没有任何影响。</p><p>同样的，还可将 <code>Person</code> 类遵循 <code>NSCopying</code> 协议，并实现其 <code>copyWithZone:</code> 方法，这样 <code>Person</code> 类就可以支持 <code>mutableCopy</code> 和 <code>copy</code> 操作了。</p></details><h3 id="❓如何重写带-copy-关键字的-setter" tabindex="-1"><a class="header-anchor" href="#❓如何重写带-copy-关键字的-setter" aria-hidden="true">#</a> ❓如何重写带 <code>copy</code> 关键字的 <code>setter</code>？</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，如果想要重写带 <code>copy</code> 关键字的 <code>setter</code> 方法，可以这样进行：</p><p>首先假设有一个属性：<code>@property (nonatomic, copy) NSString *name;</code></p><p>其重写的 <code>setter</code> 方法将会是这样：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setName<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>newName <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_name <span class="token operator">!=</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">[</span>_name release<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// MRC 下</span>
       _name <span class="token operator">=</span> <span class="token punctuation">[</span>newName copy<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>if(_name != newName)</code> 是为了防止传入的新值和旧值是同一个对象，如果是同一个对象而直接 <code>release</code> 掉，那么接下来进行 <code>copy</code> 操作就可能会出现问题。</p><p>接着 <code>[_name release]</code> 是为了释放掉旧值对象，因为重写 <code>setter</code> 通常是在改变属性值时进行的。</p><p>最后 <code>_name = [newName copy]</code> 是为了对新值对象进行 <code>copy</code> 操作，这样就能保证 <code>_name</code> 属性始终持有一个对应字符串的 <code>copy</code>。</p><p>记住，在释放旧值前，要先将新值 <code>copy</code> 或 <code>retain</code> 了，因为如果新值和旧值是同一个对象的话，你释放了旧值也就意味着释放了新值，这可能会导致 <code>unpredictable</code> 的后果。</p></details><h3 id="❓-property-copy-nsmutablearray-array-这个写法正确吗" tabindex="-1"><a class="header-anchor" href="#❓-property-copy-nsmutablearray-array-这个写法正确吗" aria-hidden="true">#</a> ❓<code>@property (copy) NSMutableArray *array;</code> 这个写法正确吗？</h3><details class="hint-container details"><summary>💡</summary><p>这个写法可以运行通过，但从代码规范和最佳实践来说，这并不是一个好的写法。</p><p>给一个属性添加 <code>copy</code> 标识时，这个属性的 <code>setter</code> 将会使用传入对象的 <code>copy</code> 方法来创建一个新的对象。然而，在 <code>Objective-C</code> 中，<code>copy</code> 方法对 <code>NSMutableArray</code> 实例调用将返回一个 <code>NSArray</code> 实例。这是由于 <code>copy</code> 策略总是返回一个不可变的副本。</p><p>所以，如果用 <code>@property (copy) NSMutableArray *array;</code> 这个写法，实际上得到的 <code>array</code> 是一个不可变数组 <code>NSArray</code>。在后续代码中尝试向这个“可变数组”(<code>NSMutableArray</code>) 中添加或删除元素时，将会导致运行时错误。</p><p>如果需要属性为一个可变数组并支持 <code>copy</code> 行为，需要手动实现属性的 <code>getter</code>和<code>setter</code>方法，并在<code>setter</code>方法中使用 <code>mutableCopy</code> 进行拷贝。</p><p>下面是一个例子来说明如何操作：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> MyClass <span class="token punctuation">:</span> NSObject
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> NSMutableArray <span class="token operator">*</span>array<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MyClass

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setArray<span class="token punctuation">:</span><span class="token punctuation">(</span>NSMutableArray <span class="token operator">*</span><span class="token punctuation">)</span>newArray <span class="token punctuation">{</span>
    <span class="token comment">// 这样可以保证每次设置新数组时都创建一个可变副本，而不是指向原始数组。</span>
    _array <span class="token operator">=</span> <span class="token punctuation">[</span>newArray mutableCopy<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓为什么不可变对象要用-copy" tabindex="-1"><a class="header-anchor" href="#❓为什么不可变对象要用-copy" aria-hidden="true">#</a> ❓为什么不可变对象要用 <code>copy</code>？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>第一，使用 <code>copy</code> 可以防止对象在外部被意外修改：</p><p>设想有一个类，这个类有一个公共的 <code>NSString</code> 属性，希望这个属性的值在设置后就不会被改变，如果你将该属性声明为 <code>strong</code> 属性，这个属性就可以被外部改变。例如：</p></li></ul><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">self</span><span class="token punctuation">.</span>myObject<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">@&quot;Original&quot;</span><span class="token punctuation">;</span>
NSMutableString <span class="token operator">*</span>nameString <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableString stringWithString<span class="token punctuation">:</span><span class="token string">@&quot;Change&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">self</span><span class="token punctuation">.</span>myObject<span class="token punctuation">.</span>name <span class="token operator">=</span> nameString<span class="token punctuation">;</span>
<span class="token punctuation">[</span>nameString appendString<span class="token punctuation">:</span><span class="token string">@&quot;Add&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Name: %@&quot;</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>myObject<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码将打印 &quot;ChangeAdd&quot;，因为 <code>nameString</code> 与 <code>myObject.name</code> 指向的是同一个对象。为了防止可能的外部访问改变对象，应该创建一份独立的副本，这可以通过声明该属性为 <code>copy</code> 来实现。</p><ul><li><p>第二，某些具有父子关系的类，子类对象赋值给用 <code>copy</code> 修饰的父类变量后，父类变量会变为原来的父类特性(里氏替换)。如：</p><p>假设将一个 <code>NSMutableString</code> 实例赋值给一个类型为 <code>NSString</code> 且用 <code>copy</code> 修饰的变量，那么这个变量就不再有 <code>NSMutableString</code> 的特性，而只有 <code>NSString</code> 的特性。所以从某种意义上说，用 <code>copy</code> 也是为了类型安全。</p></li></ul></details><hr><h2 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h2><h3 id="❓-property-属性是什么" tabindex="-1"><a class="header-anchor" href="#❓-property-属性是什么" aria-hidden="true">#</a> ❓<code>@property</code> 属性是什么？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@property</code> 是 <code>Objective-C</code> 中的一个关键字，用于声明一个属性。主要作用是为类的实例变量（属性）生成对应的访问器方法，即 <code>getter</code> 方法和 <code>setter</code> 方法。</p></blockquote><p><code>@property</code> 访问器</p><ul><li>原子性 : <code>atomic</code>、<code>nonatomic</code></li><li>读写性 : <code>readwrite</code>、<code>readonly</code></li><li>内存管理 : <code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code></li></ul><p><code>@property</code> 优点</p><ul><li>隔离性：可以封装实例变量的直接访问，将类的内部实现与外部接口隔离，提高数据的安全性。</li><li>可维护性：可以在 <code>getter</code> 和 <code>setter</code> 中添加特定的逻辑如设置新值时进行验证，获取值时返回一个计算后的值等，提高代码的可维护性。</li></ul><blockquote><p><code>class</code> 属性修饰器</p></blockquote><p>在 <code>Objective-C</code> 中，<code>class</code> 属性修饰符主要运用于定义一个类类型的属性，它的用途主要是标明一个<code>property</code> 的关联对象类型是一个类属性，而非一个实例。</p><p>以下是使用 <code>class</code> 属性修饰符的一个例子：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@property</span> <span class="token punctuation">(</span>class<span class="token punctuation">,</span> nonatomic<span class="token punctuation">,</span> readonly<span class="token punctuation">)</span> NSString <span class="token operator">*</span>appName<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这段代码中，<code>appName</code> 属性被定义为一个字符串，并且使用 <code>class</code> 关键字标识为类属性。这意味着这个属性不属于实例，而是属于类本身。</p><p>类属性在所有实例中保持一致，它们的所有权并不属于特定的实例，而是公共所有。类似于静态变量，类属性是由类直接管理并控制的。它能够在类的任何实例中被查询或修改。和其他属性一样，通过使用 <code>@property</code> 关键词定义的类属性准备好了<code>getter</code> 和 <code>setter</code> 方法，可以使用点语法来访问它。然而，不能使用实例来访问类属性，就像不能使用具体实例来调用静态方法一样。</p><p>需要注意的是 <code>class</code> 属性修饰符只能够用于类中，而不能够用于对象中。</p></details><h3 id="❓-property-的默认关键字" tabindex="-1"><a class="header-anchor" href="#❓-property-的默认关键字" aria-hidden="true">#</a> ❓<code>@property</code> 的默认关键字？</h3><details class="hint-container details"><summary>💡</summary><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token comment">// 基本数据类型 =&gt; 默认是: atomic, readwrite, assign</span>
<span class="token keyword">@property</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token comment">// 对象数据类型 =&gt; 默认是: atomic, readwrite, strong</span>
<span class="token keyword">@property</span> NSObject <span class="token operator">*</span>obj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓-property-的底层实现" tabindex="-1"><a class="header-anchor" href="#❓-property-的底层实现" aria-hidden="true">#</a> ❓<code>@property</code> 的底层实现？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@property</code> 是一个关键字，用于声明类的属性。声明一个属性时，编译器会自动生成一些代码，这就是 <code>@property</code> 的底层实现。</p></blockquote><ul><li><p>实例变量：<code>@property</code> 在默认情况下会自动合成一个带下划线前缀的实例变量。例如声明了一个名为 <code>foo</code> 的属性，编译器会自动生成一个名为 <code>_foo</code> 的实例变量。</p></li><li><p><code>getter</code> 和 <code>setter</code> 方法：会为属性自动生成 <code>getter</code> 和 <code>setter</code> 方法。</p></li><li><p>内存管理：指定的属性修饰符（<code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code> 等），编译器会在 <code>setter</code> 方法中生成相应的内存管理代码，比如引用计数的增加和减小，拷贝对象等。</p></li><li><p><code>KVO</code> 支持：<code>@property</code> 自动生成的 <code>getter</code> 和 <code>setter</code> 方法支持键值观察(<code>Key-Value Observing</code>)，允许其它对象观察和响应属性值的改变。</p><blockquote><p><code>runtime</code> 层面</p></blockquote><p>声明 <code>@property</code> 后，编译器会根据属性的特性在 <code>class_rw_t</code> 结构中的 <code>methods</code> 和 <code>properties</code> 中生成 <code>getter</code> 和 <code>setter</code> 方法以及相应的属性。然后在运行时，这些 <code>getter</code> 和 <code>setter</code> 方法以及属性被引入到 <code>objc_class</code> 的结构中。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
    Class isa<span class="token punctuation">;</span>              <span class="token comment">// metaclass 的指针</span>
    Class super_class<span class="token punctuation">;</span>      <span class="token comment">// 父类</span>
    cache_t cache<span class="token punctuation">;</span>          <span class="token comment">// 缓存</span>
    class_data_bits_t bits<span class="token punctuation">;</span> <span class="token comment">// 类的相关信息，包含了一个指向 class_rw_t 数据结构的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 可读写结构，存储运行时添加的类信息</span>
<span class="token keyword">struct</span> class_rw_t <span class="token punctuation">{</span>
    uint32_t flags<span class="token punctuation">;</span>
    uint32_t version<span class="token punctuation">;</span>
    <span class="token keyword">const</span> class_ro_t <span class="token operator">*</span>ro<span class="token punctuation">;</span>           <span class="token comment">// 只读结构体，保存编译时确定的类信息</span>
    method_array_t methods<span class="token punctuation">;</span>         <span class="token comment">// 方法列表</span>
    property_array_t properties<span class="token punctuation">;</span>    <span class="token comment">// 属性列表</span>
    protocol_array_t protocols<span class="token punctuation">;</span>     <span class="token comment">// 协议列表</span>
    Class firstSubclass<span class="token punctuation">;</span>
    Class nextSiblingClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="❓assign、strong、weak、copy-区别" tabindex="-1"><a class="header-anchor" href="#❓assign、strong、weak、copy-区别" aria-hidden="true">#</a> ❓<code>assign</code>、<code>strong</code>、<code>weak</code>、<code>copy</code> 区别？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>assign</code>：是赋值特性，简单设置变量，不更改引用计数。</p><blockquote><p>主要用在基本的数据类型（如 <code>int</code>、<code>float</code>）或 <code>C</code> 数据类型（如 结构体、数组）而不是对象。</p></blockquote></li><li><p><code>strong</code>（类似于：<code>retain</code>）：是所有权（owning）特性。</p><blockquote><p>采用 <code>ARC</code>（自动引用计数）环境下，编译器会自动在设置方法中插入 <code>retain</code> 调用，使对象的引用计数增加，从而表示当前对象拥有数据值。</p></blockquote></li><li><p><code>weak</code>：是非拥有关系（non-owning）特性，即弱引用。</p><blockquote><p>当用 <code>weak</code> 修饰对象时，被指向的对象引用计数不会增加，更重要的是，当对象被释放时，被 <code>weak</code> 修饰的变量会自动被置为 <code>nil</code>，防止野指针的出现。<code>weak</code> 修饰的属性适合在已经存在对对象的 <code>strong</code> 引用，或者对象之间存在相互循环引用的情况下使用。</p></blockquote></li><li><p><code>copy</code>：是拷贝特性。</p><blockquote><p>适合 <code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code> 等不可变对象。最重要的一点是：使用 <code>copy</code> 保持封装性，对象在内部可能需要一个数据的完整副本，并且把这个副本给外界使用，防止作为接口提供的对象的初始数据被改变。</p></blockquote></li></ul><p>选择哪种属性修饰符要视情况而定，如果数据是不可变的，那么选择 <code>assign</code> 或 <code>copy</code> 较好；如果数据是可变的，可以选择 <code>strong</code> 或 <code>weak</code>。</p></details><h3 id="❓nsstring-为什么使用-copy-可以使用-strong-吗" tabindex="-1"><a class="header-anchor" href="#❓nsstring-为什么使用-copy-可以使用-strong-吗" aria-hidden="true">#</a> ❓<code>NSString</code> 为什么使用 <code>copy</code>，可以使用 <code>strong</code> 吗？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>NSString</code> 使用 <code>copy</code> 是为了防止在赋值可变字符串时由于原字符串发生改变而引发非预期问题。</p></blockquote><ul><li><p><code>NSString</code> 的子类 <code>NSMutableString</code> 是可以变化的。如果使用 <code>strong</code> 并把一个 <code>NSMutableString</code> 实例赋值给 <code>NSString</code> 对象，然后改变该<code>NSMutableString</code> 实例，那么 <code>NSString</code> 实例也会随之改变。</p></li><li><p>如果使用 <code>copy</code>，当一个 <code>NSMutableString</code> 实例赋值给 <code>NSString</code> 对象时，实际上会复制一个不可变的副本。这样即使原字符串改变 <code>NSString</code> 实例也不会受影响。</p></li></ul></details><h3 id="❓assign-可以用于-oc-对象吗" tabindex="-1"><a class="header-anchor" href="#❓assign-可以用于-oc-对象吗" aria-hidden="true">#</a> ❓<code>assign</code> 可以用于 <code>OC</code> 对象吗？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>assign</code> 是一种属性修饰符，用于指定属性的赋值语义。<code>assign</code> 可以用于任何数据类型，包括 <code>Objective-C</code> 对象。但是，对于对象来说不推荐使用 <code>assign</code>。</p></blockquote><p>将 <code>assign</code> 用于 <code>Objective-C </code>对象时，其会生成一个设置器，其行为将传入的值赋值给实例变量，并不改变该对象的引用计数。如果该对象在其它地方被释放，那么这个引用就成了一个悬挂指针（或者说“野指针”），这将会引起程序在调用该对象时崩溃。</p><blockquote><p>在某些特定场景下，可能会选择使用 <code>assign</code>。例如，当需要创建一个 “弱引用并且不希望在对象被释放时自动设置为 <code>nil</code>” 时，<code>assign</code> 就会是个不错的选择，但是需要确保不会发生悬挂指针。</p></blockquote></details><h3 id="❓nonnull-用过吗" tabindex="-1"><a class="header-anchor" href="#❓nonnull-用过吗" aria-hidden="true">#</a> ❓<code>nonnull</code> 用过吗</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>nonnull</code> 关键字在 <code>Objective-C</code> 中的出现是为了更好地与 <code>Swift</code> 兼容。</p></blockquote></details><h3 id="❓-synthesize-vs-dynamic" tabindex="-1"><a class="header-anchor" href="#❓-synthesize-vs-dynamic" aria-hidden="true">#</a> ❓<code>@synthesize</code> vs <code>@dynamic</code></h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>@synthesize</code>：告诉编译器编译时自动创建 <code>getter/setter</code> 方法，如果没有手动实现的话。</p></li><li><p><code>@dynamic</code>：这个关键字告诉编译器,属性的 <code>getter</code> 和 <code>setter</code> 方法由自己实现，不自动生成（当然对于<code>@dynamic var</code>，编译器还是会默认添加其成员变量<code>_var</code>），如果没有手动实现 <code>setter/getter</code>，那么程序运行时，编译器发现找不到 <code>setter/getter</code> 就会崩溃。好处是可以在运行时动态绑定对象。</p></li></ul><blockquote><p><code>@dynamic</code> 常常和运行时函数 <code>class_addMethod</code> 配合使用，可以动态添加方法。最常见的应用是在 <code>Core Data</code> 的 <code>NSManagedObject</code> 子类中，<code>Core Data</code> 的属性经常被设置为 <code>@dynamic</code>，<code>NSManagedObject</code> 利用 <code>Core Data</code> 的底层存储访问这些属性，以便将对象的实际数据保存在磁盘上，而不是内存中。</p></blockquote></details><h3 id="❓-synthesize-合成实例变量的规则是什么-如果属性名为-foo-存在一个名为-foo-的实例变量-还会自动合成新变量么" tabindex="-1"><a class="header-anchor" href="#❓-synthesize-合成实例变量的规则是什么-如果属性名为-foo-存在一个名为-foo-的实例变量-还会自动合成新变量么" aria-hidden="true">#</a> ❓<code>@synthesize</code> 合成实例变量的规则是什么？如果属性名为 <code>foo</code>，存在一个名为 <code>_foo</code> 的实例变量，还会自动合成新变量么？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>@synthesize</code> 关键字用于手动指定需要 <code>@property</code> 属性对应的成员变量名称。</p></blockquote><p>属性名为 <code>foo</code>，同时已经实现了一个名为 <code>_foo</code> 的实例变量，那么在默认情况下（也就是没有使用 <code>@synthesize</code> 关键字来手动指定成员变量名），编译器不会再合成新的实例变量。因为编译器默认的命名规则是在属性名前加<code>_</code>作为成员变量名，如果已经存在这样的成员变量，编译器就不会再创建新的变量。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> MyClass <span class="token punctuation">:</span> NSObject
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> id foo<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MyClass <span class="token punctuation">{</span>
    id _foo<span class="token punctuation">;</span> <span class="token comment">// 不会再合成新的实例变量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用了 <code>@synthesize</code> 来指定了一个新的名称，那么编译器便会按照指定名称创建新的实例变量。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@implementation</span> MyClass
<span class="token keyword">@synthesize</span> foo <span class="token operator">=</span> myFoo<span class="token punctuation">;</span> <span class="token comment">// 创建一个名为 myFoo 的实例变量</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓-synthesize-都有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#❓-synthesize-都有哪些使用场景" aria-hidden="true">#</a> ❓<code>@synthesize</code> 都有哪些使用场景？</h3><details class="hint-container details"><summary>💡</summary><ul><li><p>设置实例变量名。<code>@synthesize</code>关键字允许手动改变自动生成的实例变量的名称。</p></li><li><p>协议属性自动合成。实现协议时，为了避免重复编写代码，可以使用 <code>@synthesize</code> 来自动合成协议中定义的属性。</p></li><li><p>不生成实例变量。当在类扩展 (<code>@interface MyClass()</code>) 或者父类中已经声明了属性的实例变量 <code>_foo</code>，此时在子类中如果 <code>@synthesize foo;</code>，则不会生成 <code>foo</code> 对应的实例变量。</p></li><li><p>生成实例变量。当在头文件或者类扩展（<code>@interface MyClass()</code>）中声明 <code>@property</code> 属性但没有 <code>@synthesize foo;</code>，则会自动生成 <code>_foo</code> 实例变量。如果在 <code>.m</code> 文件中声明 <code>@property</code> 属性但没有 <code>@synthesize foo;</code>，则不会自动合成属性的实例变量。</p><blockquote><p>在 <code>Xcode 4.4</code> 及以上版本中，默认已经开启了 <code>@synthesize</code> 自动生成，已经不需要显式地使用 <code>@synthesize</code>，除非在某些特殊情况下需要手动指定实例变量的名字。</p></blockquote></li></ul></details><hr><h2 id="block" tabindex="-1"><a class="header-anchor" href="#block" aria-hidden="true">#</a> Block</h2><h3 id="❓block-vs-delegate" tabindex="-1"><a class="header-anchor" href="#❓block-vs-delegate" aria-hidden="true">#</a> ❓<code>block</code> vs <code>delegate</code></h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 和 <code>delegate</code>(代理)都是 <code>iOS</code> 开发中用于实现逻辑回调的常用方式，但它们之间存在一些区别。</p><ol><li><p>定义方式：<code>block</code> 是一种特殊的数据类型，可以将一段代码封装到一个变量中，然后在需要的时候调用这个变量。而代理是一种设计模式，是通过 <code>protocol</code> 定义了一系列的方法，然后由其他类去实现这些方法。</p></li><li><p>使用场景：<code>block</code> 适合一些简单的逻辑处理，如动画回调，数组遍历等；代理通常用于处理复杂的交互，如 <code>TableView</code> 的数据源及代理方法，网络请求的回调等。</p></li><li><p>执行流程：<code>block</code> 在调用时是同一个函数或方法内部的，逻辑关系相对清晰，容易理解；而代理方法可能分散在代码的不同地方，使得调试和阅读代码稍微困难一些。</p></li><li><p>生命周期：<code>block</code> 有可能导致循环引用的问题；而 <code>delegate</code> 由于是 <code>weak</code> 引用，不会出现循环引用的问题。</p></li><li><p>排序：<code>block</code> 可以有多个且同时存在，顺序可以自由改变。而 <code>delegate</code> 通常只有一个，如果有多个，通常需要其他方式进行排序。</p></li></ol><p>总结来说，具体使用哪种方式，需要根据代码的复杂性，执行环境，对内存管理的要求等因素综合考虑。</p></details><h3 id="❓block-vs-函数指针" tabindex="-1"><a class="header-anchor" href="#❓block-vs-函数指针" aria-hidden="true">#</a> ❓<code>block</code> vs 函数指针</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>block</code>：一种特殊的数据类型，可以存储一段代码，并且这段代码可以在任何时候被执行。可以访问在声明他的那个作用域中定义的变量，这被称为“变量捕获”。</p></li><li><p>函数指针：函数指针是存储着函数地址的指针变量，本质上是一个地址值，也就是函数在内存中的起始地址。函数指针不能像 <code>block</code> 那样访问变量，只能通过传参的方式去使用外部的数据。</p></li></ul></details><h3 id="❓block-什么情况会发生循环引用" tabindex="-1"><a class="header-anchor" href="#❓block-什么情况会发生循环引用" aria-hidden="true">#</a> ❓<code>block</code> 什么情况会发生循环引用？</h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 会在以下情况下形成循环引用：</p><p>当在一个 <code>Objective-C</code> 对象的方法（或者属性）中引用了一个 <code>block</code>，而这个 <code>block</code> 中又引用了该对象（不论是直接引用还是间接引用）时，就会形成一个循环引用。这是由于 <code>block</code> 在捕获对象时默认为强引用，而对象本身又强引用了 <code>block</code>，形成了循环。</p><p>例如，以下代码就存在循环引用：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__strong <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> strongSelf <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token keyword">self</span><span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token punctuation">[</span>strongSelf doSomething<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>block</code> 引用了 <code>self</code>，而 <code>self</code> 又通过 <code>self.myBlock</code> 引用了 <code>block</code>，从而形成循环引用。</p><p>为了打破这个循环，通常采用弱化 <code>self</code> 的方式：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__weak <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token keyword">self</span><span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    __strong <span class="token keyword">typeof</span><span class="token punctuation">(</span>weakSelf<span class="token punctuation">)</span> strongSelf <span class="token operator">=</span> weakSelf<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>strongSelf doSomething<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里通过 <code>__weak typeof(self) weakSelf = self;</code> 创建了一个对 <code>self</code> 的弱引用，然后在 <code>block</code> 中使用这个弱引用，从而避免了循环引用。但在 <code>block</code> 中实际使用时，又通过 <code>__strong typeof(weakSelf) strongSelf = weakSelf;</code> 临时创建了一个对 <code>weakSelf</code> 的强引用，确保在 <code>block</code> 执行过程中不会出现 <code>weakSelf</code> 被意外释放的情况。</p></details><h3 id="❓uiview-动画函数-block-版本是否需要处理循环引用" tabindex="-1"><a class="header-anchor" href="#❓uiview-动画函数-block-版本是否需要处理循环引用" aria-hidden="true">#</a> ❓<code>UIView</code> 动画函数 <code>block</code> 版本是否需要处理循环引用？</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>UIView</code> 的动画函数 <code>block</code> 版本中使用 <code>self</code>，实际上不会造成引用循环。</p><p>因为这些动画 <code>block</code> 只会在动画结束后才被释放，而不是被 <code>self</code> 所拥有。另外，这种动画函数不会保持对动画 <code>block</code> 的长期持有，一般在动画结束后就会将其释放，因此也就不存在循环引用的问题。</p><p>所以在这种情况下，可以直接使用 <code>self</code> 而不用担心引发循环引用的问题。例如：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token punctuation">[</span>UIView animateWithDuration<span class="token punctuation">:</span><span class="token number">1.0</span> animations<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>myView<span class="token punctuation">.</span>alpha <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓block-底层实现" tabindex="-1"><a class="header-anchor" href="#❓block-底层实现" aria-hidden="true">#</a> ❓<code>block</code> 底层实现</h3><details class="hint-container details"><summary>💡</summary><p>在底层，<code>block</code> 是一个 <code>Objective-C</code> 对象，它的定义中包含了一个结构体和函数指针。</p><p>一个简化版的 <code>block</code> 的结构体可以这样描述：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">struct</span> Block_literal <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>isa<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> reserved<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>invoke<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> block_descriptor <span class="token operator">*</span>descriptor<span class="token punctuation">;</span>
    <span class="token comment">/* captured variables... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面的元素分别表示：</p><ul><li><code>isa</code>：指向对象的类型，所有 <code>Objective-C</code> 对象都有该变量。</li><li><code>flags</code> 和 <code>reserved</code>：提供关于 <code>block</code> 的一些信息，如 <code>block</code> 类型等。</li><li><code>invoke</code>：一个函数指针，指向进行调用的函数。</li><li><code>descriptor</code>：一个指向 <code>Block_descriptor</code> 结构的指针，其中包含相关信息。</li></ul><p>除此以外，结构体中还包含通过闭包捕获的变量。</p><p>以上是 <code>block</code> 的简化版的结构体描述，实际上 <code>block</code> 的底层实现要复杂的多，应用到了大量的内存管理技术。在 <code>Objective-C</code> 中，对 <code>block</code> 的内存管理方法为 <code>global</code>（全局块）、<code>stack</code>（栈块）和 <code>malloc</code>（堆块）。</p><p>在默认情况下，<code>Objective-C</code> 的编译器会根据情况适当地为 <code>block</code> 分配内存。</p><ul><li>当 <code>block</code> 没有捕获任何外部变量，或者仅使用了全局变量和静态变量时，它是一个 <code>global block</code>，存储在程序的全局数据区，其生命周期从创建到程序结束。</li><li>当 <code>block</code> 使用了外部的自动变量（包括 <code>ObjC</code> 对象和基本数据类型），在未进行 <code>copy</code> 操作的情况下，它是一个 <code>stack block</code>，存储在栈内存上，超出作用域即被销毁。</li><li>如果对 <code>block</code> 进行了 <code>copy</code> 操作，或者是用 <code>__block</code> 修饰的自动变量，那么这个 <code>block</code> 是一个 <code>malloc block</code>，存储在堆内存上，需要手动进行内存管理。</li></ul><p><a href="https://www.mikeash.com/pyblog/friday-qa-2009-08-14-practical-blocks.html" target="_blank" rel="noopener noreferrer">👉🏻<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></details><h3 id="❓block-内如何修改外部变量" tabindex="-1"><a class="header-anchor" href="#❓block-内如何修改外部变量" aria-hidden="true">#</a> ❓<code>block</code> 内如何修改外部变量</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，如果想在 <code>block</code> 内部访问和修改 <code>block</code> 外部的变量，需要在变量前加上 <code>__block</code> 修饰符，如下：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__block <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">myBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Num: %d&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里输出 &quot;Num: 1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，<code>num</code> 变量前面加上了 <code>__block</code> 修饰符，所以可以在 <code>block</code> 内部被修改。<code>myBlock</code> 被调用后，<code>num</code> 的值被改变为 1，因此 <code>NSLog</code> 可以打印出 &quot;Num: 1&quot;。</p><p>如果不加 <code>__block</code> 修饰符，编译器会报错，因为 <code>block</code> 默认捕获变量的值，而不是变量本身，因此不能修改这个变量的值。加了 <code>__block</code> 后，<code>block</code> 将捕获变量本身，使得可以在 <code>block</code> 内部修改该变量。</p></details><h3 id="❓block-在捕获自动变量-局部静态变量-全局变量-全局静态变量有什么区别" tabindex="-1"><a class="header-anchor" href="#❓block-在捕获自动变量-局部静态变量-全局变量-全局静态变量有什么区别" aria-hidden="true">#</a> ❓<code>block</code> 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别</h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 对自动变量、局部静态变量、全局变量、全局静态变量的捕获方式是不同的：</p><ol><li><p>自动变量（auto variables）：这是在方法或函数中常见的局部变量，如 <code>int num = 10</code>。这种变量在 <code>block</code> 中默认以值传递形式捕获，即 <code>block</code> 捕获的是值，而不是变量本身。如果要在 <code>block</code> 中修改局部变量的值，必须在定义变量时加上 <code>__block</code> 修饰符。</p></li><li><p>局部静态变量、全局变量、全局静态变量：这些变量在 <code>block</code> 中以指针形式捕获，即 <code>block</code> 捕获的是对这些变量的指针。这意味着，可以在 <code>block</code> 中直接修改这些变量的值，不需要加 <code>__block</code> 修饰符。</p></li></ol><p>以下是个简单代码示例：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">int</span> globalVar <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> staticGlobalVar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> staticVar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    __block <span class="token keyword">int</span> blockVar <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;localVar: %d&quot;</span><span class="token punctuation">,</span> localVar<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 1</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;staticVar: %d&quot;</span><span class="token punctuation">,</span> staticVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;blockVar: %d&quot;</span><span class="token punctuation">,</span> blockVar<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 3</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;globalVar: %d&quot;</span><span class="token punctuation">,</span> globalVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;staticGlobalVar: %d&quot;</span><span class="token punctuation">,</span> staticGlobalVar<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 5</span>

        <span class="token comment">// localVar++;              // Error! &quot;Variable is not assignable (missing __block type specifier)&quot;</span>
        staticVar<span class="token operator">++</span><span class="token punctuation">;</span>
        blockVar<span class="token operator">++</span><span class="token punctuation">;</span>
        globalVar<span class="token operator">++</span><span class="token punctuation">;</span>
        staticGlobalVar<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">myBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;staticVar after block: %d&quot;</span><span class="token punctuation">,</span> staticVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;blockVar after block: %d&quot;</span><span class="token punctuation">,</span> blockVar<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 4</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;globalVar after block: %d&quot;</span><span class="token punctuation">,</span> globalVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;staticGlobalVar after block: %d&quot;</span><span class="token punctuation">,</span> staticGlobalVar<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 6</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓block-捕获外部局部变量实际上发生了什么" tabindex="-1"><a class="header-anchor" href="#❓block-捕获外部局部变量实际上发生了什么" aria-hidden="true">#</a> ❓<code>block</code> 捕获外部局部变量实际上发生了什么</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，<code>block</code> 可以捕获其外部的局部变量，使得这些外部变量可以在 <code>block</code> 的执行体内部被访问到。捕获的过程其实是在 <code>block</code> 被创建时发生的。<code>block</code> 会创建对应的变量的 &quot;拷贝&quot;，这个拷贝的过程会考虑变量的类型：</p><ol><li><p>对于基本数据类型变量，比如 <code>int、float，block</code> 会复制其值，也就是在 <code>heap</code>(堆) 应用一段内存，将外部的变量值复制一份到这个内存上。</p></li><li><p>对于对象类型变量，<code>block</code> 会保留该对象，并复制对象指针。这个过程也被称为引用捕获。这样 <code>block</code> 对象可以在稍后的时间里随时引用到这个变量。</p></li></ol><p>然而，像上面所说的，<code>block</code> 捕获到的是外部局部变量的副本，所以不能改变外部的局部变量。如果想在 <code>block</code> 内修改外部局部变量，则需要在定义局部变量时加上 <code>__block</code> 修饰符。</p><p><code>__block</code> 关键字可以用于解决 <code>block</code> 内部无法修改外部变量的问题。这是因为，当捕获一个 <code>__block</code> 变量时，<code>block</code> 内部会保留这个 <code>__block</code> 变量。在堆上创建的 <code>block</code>，会在 <code>heap</code> 中维护一个 <code>__block</code> 变量的结构体，这个结构体中包含了 <code>__block</code> 变量的地址和其值，这样 <code>block</code> 就可以通过操作这个结构体来修改 <code>__block</code> 变量的值。</p></details><blockquote><p>如果 使用 <code>__block</code> 捕获了局部变量，这个 <code>block</code> 作为返回值 <code>return</code> 了，这个局部变量释放了，怎么办？</p></blockquote><details class="hint-container details"><summary>💡</summary><p>在使用 <code>__block</code> 捕获局部变量的同时，如果这个 <code>block</code> 作为返回值返回，那么这个局部变量就会被 <code>block</code> 捕获到，并且它的生命周期就延长到了 <code>block</code> 生命周期结束为止。也就是说，这个局部变量不会在离开定义它的作用域时释放，而是将在 <code>block</code> 被释放时才释放。</p><p>注意一点，正常情况下 <code>block</code> 是分配在栈上的，栈上的 <code>block</code> 在离开作用域后就会被销毁。但是如果这个 <code>block</code> 被赋值给了一个强引用的变量，或者被返回出去的话，就需要将栈上的 <code>block</code> 复制到堆上，这样 <code>block</code> 的生命周期就会得到延长，直到没有强引用指向它为止。</p><p>同时，对于使用 <code>__block</code> 修饰的局部变量，这个变量的存储地址会从栈复制到堆上。所以，返回的 <code>block</code> 中捕获的是移动到堆上的 <code>__block</code> 变量的地址，这也确保了返回后，能够正确地访问和修改这个 <code>__block</code> 变量。</p></details><h3 id="❓block-修改捕获变量除了用-block-还可以怎么做-有哪些局限性" tabindex="-1"><a class="header-anchor" href="#❓block-修改捕获变量除了用-block-还可以怎么做-有哪些局限性" aria-hidden="true">#</a> ❓<code>block</code> 修改捕获变量除了用 <code>__block</code> 还可以怎么做？有哪些局限性？</h3><details class="hint-container details"><summary>💡</summary><p>如果希望在 <code>block</code> 中修改一个捕获变量，除了用 <code>__block</code>，可以使用 <code>__strong</code> 或者创建一个可修改的对象，如 <code>NSMutableArray</code> 或 <code>NSMutableDictionary</code>，然后在 <code>block</code> 中修改该对象的内容。但是，这并不能改变原始变量的值，只是改变了它所引用的对象的内容。</p><p>例如：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSMutableArray <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableArray array<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token punctuation">[</span>array addObject<span class="token punctuation">:</span><span class="token string">@&quot;Object&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">myBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，并没有修改 <code>array</code> 这个变量本身，而是修改了它所引用的对象的内容。也就是说，不是改变 <code>array</code> 这个指针所指向的地址，而是改变了这个指针所指向的内存中的内容。</p><p>此种方式来达到 <code>block</code> 内部修改变量的效果的局限性在于，只有可变的引用类型（比如 <code>NSMutableArray</code>）可以使用此方法，基本数据类型或者不可变的引用类型无法使用此方法在 <code>block</code> 中进行修改。与使用 <code>__block</code> 相比也更加的不直观。</p></details><h3 id="❓block-中修改-nsmutablearray-需不需要添加-block" tabindex="-1"><a class="header-anchor" href="#❓block-中修改-nsmutablearray-需不需要添加-block" aria-hidden="true">#</a> ❓<code>block</code> 中修改 <code>NSMutableArray</code> 需不需要添加 <code>__block</code></h3><details class="hint-container details"><summary>💡</summary><p>不需要。在 <code>Objective-C</code> 中，<code>NSMutableArray</code> 是一个引用类型的对象，即使不使用 <code>__block</code>，也可以在 <code>block</code> 内部添加、删除或修改 <code>NSMutableArray</code> 的元素。因为修改的是 <code>NSMutableArray</code> 对象的内容，而不是 <code>NSMutableArray</code> 变量本身。</p><p>例如，可以这么写：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSMutableArray <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableArray array<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token punctuation">[</span>array addObject<span class="token punctuation">:</span><span class="token string">@&quot;Hello, World&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">myBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：[&quot;Hello, World&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码在 <code>block</code> 中向 <code>array</code> 添加了一个字符串，然后打印 <code>array</code> 的内容。注意，这里并没有修改 <code>array</code> 这个变量本身，只修改了它所引用的对象的内容。所以，无需添加 <code>__block</code> 修饰符。</p><p>但是，如果希望在 <code>block</code> 中修改 <code>array</code> 这个变量（比如使其指向一个全新的 <code>NSMutableArray</code> 对象），那就需要使用 <code>__block</code> 了。例如：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__block NSMutableArray <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableArray array<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    array <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableArray array<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>array addObject<span class="token punctuation">:</span><span class="token string">@&quot;Hello, World&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">myBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：[&quot;Hello, World&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓-block-vs-weak" tabindex="-1"><a class="header-anchor" href="#❓-block-vs-weak" aria-hidden="true">#</a> ❓<code>__block</code> vs <code>__weak</code></h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，经常使用 <code>__block</code> 和 <code>__weak</code> 这两个修饰符来修饰变量。尽管它们的用法看起来相似，但它们的作用和使用场景却有所不同。</p><ol><li><p><code>__block</code>：它用于允许在 <code>block</code> 中改变变量的值。在 <code>Objective-C</code> 中，<code>__block</code> 是存储类型说明符，用于修饰一个变量，让该变量能在 <code>block</code> 中被读取和写入。如果没有 <code>__block</code>，那么 <code>block</code> 就不能修改该变量的值。</p></li><li><p><code>__weak</code>：它用于创建一个弱引用。在 <code>Objective-C</code> 中，弱引用是一种特殊类型的引用，它不会增加被引用对象的引用计数。这样可以解决对象互相引用，形成引用循环的问题。在处理 <code>block</code> 对象引用 <code>self</code> 时，通常会先创建一个弱引用的 <code>self</code>，然后在 <code>block</code> 中使用这个弱引用，从而避免引用循环。</p></li></ol><p>在使用这两个修饰词来修饰变量时，需要根据需求和实际使用场景来选择。如果希望在 <code>block</code> 中改变一个变量的值，应该使用 <code>__block</code>。而如果想避免引用循环，应该使用 <code>__weak</code>。</p></details><h3 id="❓-block-在-arc-和非-arc-有区别吗" tabindex="-1"><a class="header-anchor" href="#❓-block-在-arc-和非-arc-有区别吗" aria-hidden="true">#</a> ❓<code>__block</code> 在 <code>ARC</code> 和非 <code>ARC</code> 有区别吗</h3><details class="hint-container details"><summary>💡</summary><p><code>__block</code> 在 <code>ARC</code>（Automatic Reference Counting）和非 <code>ARC</code> 环境下有区别。</p><p>在非 <code>ARC</code> 环境下，<code>__block</code> 不会改变对象的所有权。也就是说，如果有一个 <code>__block</code> 修饰的对象，<code>block</code> 不会为这个对象增加引用计数。因此，如果在 <code>block</code> 执行后，原来的对象被释放了，那么 <code>block</code> 内的这个对象就变成了悬浮指针。</p><p>在 <code>ARC</code> 环境下，<code>__block</code> 有另外一种行为。它会保留 <code>block</code> 中使用到的对象。也就是说，如果有一个 <code>__block</code> 修饰的对象，当 <code>block</code> 执行时，就会增加这个对象的引用计数。因此，在 <code>ARC</code> 下，可以安全地在 <code>block</code> 中引用 <code>__block</code> 修饰的对象，而不必担心它会被提前释放。</p><p>为了在两种环境下都能安全使用，我们一般会选择 <code>__weak</code> 代替 <code>__block</code> 来避免循环引用，特别是在引用 <code>self</code> 或者其成员变量的时候。</p></details><h3 id="❓一个-int-变量用-block-修饰与不修饰有区别吗" tabindex="-1"><a class="header-anchor" href="#❓一个-int-变量用-block-修饰与不修饰有区别吗" aria-hidden="true">#</a> ❓一个 <code>int</code> 变量用 <code>__block</code> 修饰与不修饰有区别吗</h3><details class="hint-container details"><summary>💡</summary><p>对于一个 <code>int</code> 类型的变量，使用 <code>__block</code> 修饰与否是有区别的。</p><p>如果一个变量被 <code>__block</code> 修饰，那么它可以在 <code>block</code> 内部被更改。如果没有被 <code>__block</code> 修饰，那么在 <code>block</code> 内部是无法更改这个变量的，它在 <code>block</code> 中会被视为常量。</p><p>例如，对于以下代码：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 这里会报错，因为 value 在 block 内部不能被更改</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 如果需要在 `block` 内部更改一个变量的值，那么这个变量必须使用 `__block` 修饰。</span>
__block <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 这里可以正常运行，value 在 block 内部可以被更改</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓block-如何进行内存管理的" tabindex="-1"><a class="header-anchor" href="#❓block-如何进行内存管理的" aria-hidden="true">#</a> ❓<code>block</code> 如何进行内存管理的</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，<code>block</code> 的内存管理默认分为三个级别：<code>_NSConcreteGlobalBlock</code>、<code>_NSConcreteStackBlock</code>、<code>_NSConcreteMallocBlock</code>。</p><ol><li><p><code>__NSConcreteGlobalBlock__</code>：属于全局区，类似于全局变量，生命周期从应用开始直到应用结束。</p></li><li><p><code>__NSConcreteStackBlock__</code>：存放在栈内存中，当超出其作用域后就会被自动销毁。</p></li><li><p><code>__NSConcreteMallocBlock__</code>：存放在堆内存中，需要手动管理其内存，可以通过 <code>retain</code> 来增加其引用计数，通过 <code>release</code> 来减少其引用计数，当引用计数为 0 时，<code>block</code> 会被销毁。</p></li></ol><p>在使用 <code>ARC</code> (Automatic Reference Counting) 时，对 <code>block</code> 的内存管理会简化许多。当 <code>block</code> 中引用到了外部变量时，<code>block</code> 将会自动从栈复制到堆中（有复制行为的 <code>block</code> 都会进入堆区），并且在引用计数为 0 后会自动销毁，不需要手动管理。</p><p>但要注意的一点是，对于 <code>block</code> 内部应用到的对象，如果不加特殊处理，是会形成强引用的，因此可能会导致引用循环并引发内存泄漏。为了防止这种情况，经常使用 <code>__weak</code> 来修饰引用的对象，避免产生循环引用。</p></details><h3 id="❓block-一般使用-copy-修饰-可以使用-strong-吗-发生-copy-的时机" tabindex="-1"><a class="header-anchor" href="#❓block-一般使用-copy-修饰-可以使用-strong-吗-发生-copy-的时机" aria-hidden="true">#</a> ❓<code>block</code> 一般使用 <code>copy</code> 修饰，可以使用 <code>strong</code> 吗，发生 <code>copy</code> 的时机</h3><details class="hint-container details"><summary>💡</summary><p><code>block</code> 使用 <code>copy</code> 修饰是为了保持 <code>block</code> 的引用计数的正确。<code>block</code> 本身是在堆栈上分配的，<code>copy</code> 操作将其复制到堆上，可以保证 <code>block</code> 在方法返回后不被销毁，保证其正确执行。</p><p>虽然也可以使用 <code>strong</code> 来修饰 <code>block</code>，但是这样做并不会将 <code>block</code> 从栈复制到堆。因此，如果 <code>block</code> 捕获了方法内部的变量，当方法返回后，这些变量都已经被释放，可能会导致程序崩溃。</p><p><code>copy</code> 操作一般发生在把 <code>block</code> 作为属性进行设置的时候，这个时候赋值方法（<code>setter</code>）会进行 <code>copy</code> 操作。也可以手动调用 <code>copy</code> 方法来进行操作。</p><p>总的来说，将 <code>block</code> 属性用 <code>copy</code> 修饰，能够更好地管理其内存，并确保其正确执行。</p></details><h3 id="❓为什么在-block-外部使用-weak-修饰的同时需要在内部使用-strong-修饰" tabindex="-1"><a class="header-anchor" href="#❓为什么在-block-外部使用-weak-修饰的同时需要在内部使用-strong-修饰" aria-hidden="true">#</a> ❓为什么在 <code>block</code> 外部使用 <code>__weak</code> 修饰的同时需要在内部使用 <code>__strong</code> 修饰</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>block</code> 中使用 <code>__weak</code> 修饰符是为了防止循环引用。由于 <code>block</code> 会捕获其内部使用的变量，如果 <code>block</code> 内部访问了 <code>self</code> 或其成员变量，那么会形成循环引用，导致内存泄漏。而使用 <code>__weak</code> 修饰符可以将 <code>self</code> 或成员变量变成弱引用，从而避免循环引用。</p><p>然而，使用 <code>__weak</code> 修饰符也会有其不足之处：在 <code>block</code> 执行期间，若弱引用的对象被释放了，那么 <code>block</code> 内部对该对象的访问就会失效。为了避免这种情况，就需要在 <code>block</code> 内部使用 <code>__strong</code> 修饰符将弱引用变量提升为强引用。</p><p>这样做可以保证在 <code>block</code> 执行期间，这个被提升的强引用变量所指向的对象不会被释放，保证了 <code>block</code> 执行过程中对象的访问安全。而在 <code>block</code> 执行完毕后，强引用也会随之释放，和在 <code>block</code> 外部保持指向对象的弱引用并不存在循环引用问题。</p><p>以下是一个典型的例子：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__weak <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> doSomethingWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{</span>
    __strong <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> strongSelf <span class="token operator">=</span> weakSelf<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>strongSelf doSomethingElse<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">// 在此处，若 self 在 block 执行期间释放，由于存在 strongSelf 的强引用，self 所指向的对象不会被释放。</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，会先创建一个 <code>weakSelf</code> 的弱引用，然后在 <code>block</code> 中将其提升为 <code>strongSelf</code> 的强引用。这样可以保证 <code>self</code> 在 <code>block</code> 执行期间不会被释放，从而避免了访问无效对象的风险。</p></details><h3 id="❓block-访问对象类型的-auto-变量时-在-arc-和-mrc-下有什么区别" tabindex="-1"><a class="header-anchor" href="#❓block-访问对象类型的-auto-变量时-在-arc-和-mrc-下有什么区别" aria-hidden="true">#</a> ❓<code>block</code> 访问对象类型的 <code>auto</code> 变量时，在 <code>ARC</code> 和 <code>MRC</code> 下有什么区别</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>MRC</code> 和 <code>ARC</code> 下，<code>block</code> 访问对象类型的 <code>auto</code> 变量时，有一些不同。</p><ul><li><p>在 <code>MRC</code> 下，<code>block</code> 只是简单地进行指针拷贝，不会对对象进行 <code>retain</code> 操作，这会导致可能的对象释放错误。</p></li><li><p>在 <code>ARC</code> 下，编译器会自动进行内存管理，在 <code>block</code> 被创建时，会对它所捕获的对象发送一次 <code>retain</code> 消息，同时在 <code>block</code> 被释放时，发送一次 <code>release</code> 消息。</p></li></ul></details><h3 id="❓block-中可以使用-kvc-来访问实例变量吗-可以使用-kvc-修改它的值吗" tabindex="-1"><a class="header-anchor" href="#❓block-中可以使用-kvc-来访问实例变量吗-可以使用-kvc-修改它的值吗" aria-hidden="true">#</a> ❓<code>block</code> 中可以使用 <code>KVC</code> 来访问实例变量吗，可以使用 <code>KVC</code> 修改它的值吗</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>block</code> 中使用 <code>KVC</code>(Key-Value Coding) 访问和修改实例变量，必须注意以下两点：</p><ol><li><p>被访问的实例变量是否存在对应的访问器方法(<code>getter</code> 和 <code>setter</code>)。</p></li><li><p>被访问的实例变量在类的接口中是否有定义，或者有无 <code>@property</code> 声明。</p></li></ol><p>如果满足以上条件，可以在 <code>block</code> 中使用 <code>KVC</code> 来访问和修改实例变量。</p><p>例如：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>__weak <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token keyword">self</span><span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token comment">// 使用KVC访问实例变量</span>
    NSInteger value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>weakSelf valueForKey<span class="token punctuation">:</span><span class="token string">@&quot;someValue&quot;</span><span class="token punctuation">]</span> integerValue<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 使用KVC修改实例变量</span>
    <span class="token punctuation">[</span>weakSelf setValue<span class="token punctuation">:</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> forKey<span class="token punctuation">:</span><span class="token string">@&quot;someValue&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><hr><h2 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h2><h3 id="❓-load-与-initialize-区别" tabindex="-1"><a class="header-anchor" href="#❓-load-与-initialize-区别" aria-hidden="true">#</a> ❓<code>+load</code> 与 <code>+initialize</code> 区别</h3><details class="hint-container details"><summary>💡</summary><p>这两个都是类方法，可以从下面几个方面去对比两者的区别</p><ul><li><p>调用时机</p><ul><li><code>+load</code> : 这是在运行时加载时，进行触发调用。</li><li><code>+initialize</code> : 会在类第一次使用时，进行触发调用。</li></ul></li><li><p>调用次数</p><ul><li><code>+load</code> : 只会在运行时加载时，调用一次。</li><li><code>+initialize</code> : 第一次调用时，调用一次。</li></ul></li><li><p>调用父类</p><ul><li><code>+load</code> : 不会调用父类的 <code>+load</code></li><li><code>+initialize</code> : 如果当前类没有</li></ul></li><li><p>手动调用</p><ul><li><code>+load</code> : 不能手动调用，运行时进行调用的。手动调用会触发异常。</li><li><code>+initialize</code> : 可以手动调用。</li></ul></li></ul></details><blockquote><p>❓<code>+load</code> 的调用顺序</p></blockquote><details class="hint-container details"><summary>💡</summary><ul><li><code>+load</code> 方法调用顺序与编译连接顺序有关。</li><li>不同类之间的<code>+load</code>方法的调用顺序不能确定，取决于编译连接顺序。</li><li>如果父类、子类和分类都实现了 <code>+load</code> 方法，<code>+load</code> 方法的调用顺序是：先调用父类的<code>+load</code>，再调用子类的<code>+load</code>，最后调用分类的<code>+load</code>。</li></ul></details><h3 id="❓designated-initializer-如何添加" tabindex="-1"><a class="header-anchor" href="#❓designated-initializer-如何添加" aria-hidden="true">#</a> ❓<code>Designated Initializer</code> 如何添加？</h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>NS_DESIGNATED_INITIALIZER</code> 是一个宏，用于向编译器标明这个是<code> Designated Initializer</code>。主要目的就是明确指定初始化方法，并帮助我们遵守初始化方法的基本规则：所有的初始化方法最终都应该通过调用同一类中的一个指定初始化方法来完成初始化。</p></blockquote><p><code>NS_DESIGNATED_INITIALIZER</code> 这个宏不是必须的。但加上这个宏可以明确指出哪个是指定初始化方法，有助于提高代码的可读性。另外，如果你在使用 <code>Xcode</code> 开发，并且启用了一些警告选项，没有使用 <code>NS_DESIGNATED_INITIALIZER</code> 宏来标记指定初始化方法可能会导致 <code>Xcode</code> 发出警告信息。</p><p><code>NS_DESIGNATED_INITIALIZER</code> 这个宏的工作原理是，如果你的类中的某个初始化方法使用了这个宏，但是这个方法并没有调用同类中的其他使用了这个宏的初始化方法，或者调用了父类中使用了这个宏的初始化方法，那么编译器就会发出一个警告。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> MyClass <span class="token punctuation">:</span> NSObject
<span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>initWithMyParameter<span class="token punctuation">:</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>myParameter NS_DESIGNATED_INITIALIZER<span class="token punctuation">;</span>
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> MyClass
<span class="token operator">-</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>initWithMyParameter<span class="token punctuation">:</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>myParameter <span class="token punctuation">{</span>
    <span class="token comment">// 先调用父类的 init</span>
    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">super</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化操作...</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="❓oc-中的内省和反射-底层实现原理-应用场景有哪些" tabindex="-1"><a class="header-anchor" href="#❓oc-中的内省和反射-底层实现原理-应用场景有哪些" aria-hidden="true">#</a> ❓<code>OC</code> 中的内省和反射，底层实现原理，应用场景有哪些</h3><details class="hint-container details"><summary>💡</summary><p><code>Objective-C</code> 中的内省和反射是基于其动态的特性实现的，底层依赖于 <code>runtime</code> 系统。</p><ul><li><p>内省是面向对象编程中的一种能力，允许程序检查对象的类型或属性。可以通过系统提供的各种 <code>API</code>（如<code>isKindOfClass:</code>,<code>respondsToSelector:</code>,等方法）来实现内省。</p></li><li><p>反射是指程序能够观察和修改自身结构和行为的一种能力。反射主要依赖于系统提供的 <code>API</code>，如<code>NSClassFromString</code>,<code>NSStringFromClass</code>,<code>NSSelectorFromString</code>, <code>NSStringFromSelector</code>等函数。</p></li></ul><p>底层实现原理： <code>Objective-C</code> 对象中都有一个 <code>isa</code> 指针指向对象所属的类，这个类中存储了类的方法列表、属性列表，并且如果类继承自其他类，那么这个类还会通过 <code>superclass</code> 指针找到其父类，这样层层递推，形成了一条类链，利用这条链条就可以检查和操作对象的行为和结构。</p><p>应用场景：</p><ol><li>数据和模型的自动映射，例如 <code>JSON</code> 数据转 <code>Model</code> 对象，通常需要写大量的映射代码。利用内省我们可以在运行时获取对象的属性信息，从而实现自动映射。</li><li>在运行时动态地添加类，方法，属性。例如可以在运行时给一个类添加属性或方法，或者修改方法的实现等。</li><li>在面向切面编程（<code>AOP</code>）中，经常需要运行时修改对象的行为。</li><li>在执行单元测试时，可以利用反射机制来动态地调用需要测试的方法。</li></ol></details><h3 id="❓oc-如何实现多重继承" tabindex="-1"><a class="header-anchor" href="#❓oc-如何实现多重继承" aria-hidden="true">#</a> ❓<code>OC</code> 如何实现多重继承</h3><details class="hint-container details"><summary>💡</summary><p><code>Objective-C</code> 并不直接支持多重继承（即一个子类可以拥有多个父类的属性和方法）。但提供了几种方法可以实现类似多重继承的效果：</p><ol><li><p><strong>协议（Protocol）</strong>：<code>OC</code> 中的协议类似于其他语言中的接口，可以定义一组方法和属性，然后由类去实现。一个类可以同时实现多个协议，这就实现了类似多重继承的效果，只是实现协议的类需要自己实现协议中定义的所有方法。</p></li><li><p><strong>组合</strong>：组合是指在一个类中包含其他类的实例作为成员变量，借此可以使用其他类的功能，间接实现多重继承的效果。例如，类A包含类B和类C的实例，那么类A就可以使用类B和类C的功能。</p></li><li><p><strong>分类（Category）</strong>：分类是一种使得现有类增加方法的方式，是在运行时决议的。可以通过创建分类，将其他类的方法引入，实现类似多继承的效果。但是分类不能添加新的实例变量。</p></li><li><p><strong>消息转发（Message Forwarding）</strong>：这是 <code>Objective-C</code> 的动态特性，允许将一个方法调用转发给其他对象进行处理。如果某个类无法响应某个消息，允许我们在运行时将这个消息转发给另一个能处理这个消息的对象。</p></li></ol><p>注意，以上方式只能部分模拟多重继承，并不能完全替代多重继承，在使用时应根据具体需求和情况选择最合适的方式。</p></details><h3 id="❓静态方法是否能被重写" tabindex="-1"><a class="header-anchor" href="#❓静态方法是否能被重写" aria-hidden="true">#</a> ❓静态方法是否能被重写</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>Objective-C</code> 中，通常所说的 &quot;静态方法&quot; 实际上是指&quot;类方法&quot;，用 &quot;+&quot; 符号来声明。这种方法是可以被子类重写的。也就是说，如果在子类中重写了一个已经在父类中定义的类方法，那么当你用子类来调用这个类方法的时候，实际上执行的是子类中的版本，这就是方法重写。所以，&quot;静态方法&quot;是可以被子类重写的。</p><p>然而这和其他一些语言如 <code>Java</code> 或 <code>C++</code> 中的静态方法是不一样的。在 <code>Java</code> 或<code> C++</code> 中，声明为 <code>static</code> 的方法是不能被子类重写的。</p></details><hr><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2><h3 id="❓category-vs-extension" tabindex="-1"><a class="header-anchor" href="#❓category-vs-extension" aria-hidden="true">#</a> ❓<code>Category</code> vs <code>Extension</code></h3><details class="hint-container details"><summary>💡</summary><blockquote><p><code>Category</code>(类别)：<code>Objective-C</code> 的一个特性，提供了一种给已存在类添加方法的机制.</p></blockquote><ul><li><code>Category</code> : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。</li><li><code>Extension</code> : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。</li></ul></details><h3 id="❓nsobject-添加-extension-会怎么样" tabindex="-1"><a class="header-anchor" href="#❓nsobject-添加-extension-会怎么样" aria-hidden="true">#</a> ❓<code>NSObject</code> 添加 <code>Extension</code> 会怎么样</h3><details class="hint-container details"><summary>💡</summary><p>向 <code>NSObject</code> 添加 <code>Extension</code>(类别)会使 <code>Extension</code> 中的方法对继承自 <code>NSObject</code> 的所有对象可见和可用。这会对项目产生全局性的影响。</p><p><code>Extension</code> 可以用来添加新的方法到现有的类中，但它没有自己的实例变量，所以不能存储新的状态。在使用 <code>Extension</code> 时，需要注意以下几点：</p><ul><li>如果你覆盖已有的方法，所有继承自 <code>NSObject</code> 的对象都会受到影响，可能出现无法预知的结果。</li><li>如果添加的新方法与其他库或者框架定义的方法发生冲突，同样可能导致问题。</li></ul><p>因此，虽然往 <code>NSObject</code> 添加 <code>Extension</code> 可以快速为所有对象添加功能，但需要谨慎使用，尽量避免覆盖现有的方法或者添加可能与其他方法发生冲突的方法。同时，由于该范围非常广，必要时最好选择子类化或协议等方式实现。</p><p>另外，如果只是想在项目内全局使用某些通用方法，可以考虑创建一个 <code>NSObject</code> 的子类，然后让需要使用这些方法的类继承自这个子类，这样就不会影响到不需要这些方法的类。</p></details><h3 id="❓如果分类中添加与类相同的方法签名会发生什么" tabindex="-1"><a class="header-anchor" href="#❓如果分类中添加与类相同的方法签名会发生什么" aria-hidden="true">#</a> ❓如果分类中添加与类相同的方法签名会发生什么</h3><details class="hint-container details"><summary>💡</summary><p>当一个 <code>OC</code> 的类别（<code>Category</code>）和主类都定义了相同签名的方法时，运行时系统会优先调用类别的方法，而忽略主类中的同名方法。这是因为在运行时的方法解析过程中，分类的方法会被先于主类方法加入到方法列表中。</p><p>在代码中，如果主类和分类都实现了同一个方法，那么分类的方法会覆盖掉主类中的方法，也就是说，在方法调用时，实际上执行的是分类中的方法。</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> MyClass <span class="token punctuation">:</span> NSObject
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MyClass
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;print in MyClass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token keyword">@interface</span> <span class="token function">MyClass</span> <span class="token punctuation">(</span>MyCategory<span class="token punctuation">)</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print<span class="token punctuation">;</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> <span class="token function">MyClass</span> <span class="token punctuation">(</span>MyCategory<span class="token punctuation">)</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;print in MyCategory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token comment">// 调用时</span>
MyClass <span class="token operator">*</span>myClass <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>MyClass alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>myClass print<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 输出：print in MyCategory</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种特性在某些情况下非常有用，可以实现方法的替换和拦截等。但也需要格外注意，如果不小心覆盖了主类本身的重要方法，可能会造成程序的异常。</p></details><h3 id="❓分类是如何实现的-它为什么会覆盖掉原来的方法" tabindex="-1"><a class="header-anchor" href="#❓分类是如何实现的-它为什么会覆盖掉原来的方法" aria-hidden="true">#</a> ❓分类是如何实现的，它为什么会覆盖掉原来的方法</h3><details class="hint-container details"><summary>💡</summary><p><code>Objective-C</code> 中的分类 (<code>Category</code>) 实质上是对一个存在的类添加额外的方法，而不改变它的声明和定义。分类是在运行时通过 <code>Objective-C</code> 的动态性质合并到类上的，这使得可以随意地向任何类添加方法。</p><p>底层实现：是一个 <code>objc_category</code> 结构体，它包含了类名(<code>name</code>)、类(<code>cls</code>)、类别中所有方法的列表(<code>method_list</code>)、类别的协议列表(<code>protocol_list</code>)、类别中所有的属性列表(<code>property_list</code>)。</p><p>加载过程：在程序运行时的 <code>load</code> 阶段进行的，所有类和分类的 <code>+load</code> 方法（如果有）被调用。在调用 <code>+load</code> 方法之前，<code>runtime</code> 会先将分类的方法、协议、属性合并到类的数据结构中。这个过程中，分类的方法被放在了原来类方法列表的前面，所以在类和分类中有相同方法名的方法的时候，分类的方法会被优先调用，原类的方法被覆盖。</p><p>分类的本质：在编译阶段，每一个分类会被编译成一个特殊的结构体（如 <code>_category_t</code>），其中包含了分类名，分类所在类的名字，以及分类中所有添加的方法的列表。在程序启动的时候，这个结构有一个初始化函数会被自动调用。在这个函数中，分类中的方法会被添加到类的方法列表中。因此可以在分类中添加新的方法。</p><p>分类中的方法会覆盖掉原来的方法，主要是因为分类的方法被添加到方法列表的顺序优先级更高。在 <code>Objective-C</code> 查找方法实现的时候，是按照方法在列表中的顺序，从前往后查找的，当找到第一个匹配的方法时，就停止查找，并且调用这个方法。因此，如果分类中的方法与原类中的方法同名，分类中的方法就会被优先调用，从而覆盖掉原来的方法。</p></details><h3 id="❓分类中有与主类相同的方法-如果想要调用主类中的方法如何处理" tabindex="-1"><a class="header-anchor" href="#❓分类中有与主类相同的方法-如果想要调用主类中的方法如何处理" aria-hidden="true">#</a> ❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理</h3><details class="hint-container details"><summary>💡</summary><p>如果分类中的方法与主类的方法名称相同，由于运行时会优先调用分类的方法，所以通常无法直接调用到主类中的方法。不过有一种间接的办法可以实现。可以在分类方法内部通过 <code>NSInvocation</code> 或 <code>methodSignatureForSelector:</code> 和 <code>forwardInvocation:</code> 的方式调用主类的原方法。</p><p>下面是 <code>NSInvocation</code> 实现的例子：</p><div class="language-objectivec line-numbers-mode" data-ext="objectivec"><pre class="language-objectivec"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;MyClass.h&quot;</span></span>

<span class="token keyword">@implementation</span> <span class="token function">MyClass</span> <span class="token punctuation">(</span>MyCategory<span class="token punctuation">)</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>print <span class="token punctuation">{</span>
    <span class="token comment">// 获取主类原方法</span>
    SEL origSel <span class="token operator">=</span> <span class="token keyword">@selector</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Method origMethod <span class="token operator">=</span> <span class="token function">class_getInstanceMethod</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">self</span> class<span class="token punctuation">]</span><span class="token punctuation">,</span> origSel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 构建 NSInvocation</span>
    NSInvocation <span class="token operator">*</span>inv <span class="token operator">=</span> <span class="token punctuation">[</span>NSInvocation invocationWithMethodSignature<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token keyword">self</span> methodSignatureForSelector<span class="token punctuation">:</span>origSel<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>inv setSelector<span class="token punctuation">:</span>origSel<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>inv setTarget<span class="token punctuation">:</span><span class="token keyword">self</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 调用 NSInvocation</span>
    <span class="token punctuation">[</span>inv invoke<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 获取返回值</span>
    NSString <span class="token operator">*</span>returnValue<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>inv getReturnValue<span class="token punctuation">:</span><span class="token operator">&amp;</span>returnValue<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> returnValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，仅当主类方法和分类方法没有强制要求的执行顺序时才可以这样做，否则可能会破坏类的封装性并导致不明确的行为。如果代码常常需要这么做，那可能是设计有问题，应该考虑重构代码以避免这种情况。</p></details><h3 id="❓两个分类的-load-方法的加载顺序" tabindex="-1"><a class="header-anchor" href="#❓两个分类的-load-方法的加载顺序" aria-hidden="true">#</a> ❓两个分类的 <code>load</code> 方法的加载顺序</h3><details class="hint-container details"><summary>💡</summary><p>类和分类中的 <code>+load</code> 方法会在类或分类被加载到运行时时调用。对于同一个类的不同分类，各自的 <code>+load</code> 方法的调用顺序与编译顺序有关，最后编译的分类的 <code>+load</code> 方法会被先调用。</p><p>但是要注意，虽然编译顺序是影响 <code>+load</code> 方法调用顺序的因素之一，但不是唯一的决定因素。在一个复杂的项目中，编译顺序可能会受到 <code>Xcode</code> 编译设置、文件名字母序、<code>Xcode</code> 版本、甚至 <code>Mac</code> 系统版本的影响。因此，关于这个问题，Apple 官方文档建议不要依赖于 <code>+load</code> 方法的调用顺序。如果项目中多个 <code>+load</code> 方法之间有依赖关系，那么可能需要仔细设计代码，以避免因 <code>+load</code> 方法调用顺序引起的问题。</p></details><h3 id="❓两个分类的同名方法的加载顺序" tabindex="-1"><a class="header-anchor" href="#❓两个分类的同名方法的加载顺序" aria-hidden="true">#</a> ❓两个分类的同名方法的加载顺序</h3><details class="hint-container details"><summary>💡</summary><p>编译器按照 <code>.m</code> 文件编译顺序来加载分类，如果存在多个分类都实现了同一方法，那么顺序是&quot;编译顺序的逆序&quot;，也就是说最后编译的分类会首先被加载，同名方法就会被最后编译的那个分类所覆盖。</p><p>需要注意的是，依赖于这种顺序来设计代码是很不稳定的，因为当其他开发者操作或更改了文件的编译顺序，可能会导致相关代码的运行出问题。此外，互相覆盖的设计也会降低代码的可读性和维护性。所以最好避免在多个分类中都实现同一方法，以保证代码的稳定运行。</p></details><h3 id="❓一个类中有个多个分类都实现了相同的方法-会调用哪个方法" tabindex="-1"><a class="header-anchor" href="#❓一个类中有个多个分类都实现了相同的方法-会调用哪个方法" aria-hidden="true">#</a> ❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法</h3><details class="hint-container details"><summary>💡</summary><p>当一个类有多个分类（<code>Category</code>），并且这些分类都实现了相同的方法时，会优先调用最后编译的分类中的方法。这是因为 <code>Objective-C</code> 在运行时加载分类的顺序是根据编译的顺序，最后编译的分类的方法会被放到方法列表的最前面，从而覆盖掉其他同名方法。</p><p>但是具体调用哪个方法并不是确定的，因为分类的编译顺序可能会因为项目配置的改变而改变，比如编译选项的修改、文件名的修改等。所以，实际开发中并不建议在不同的分类中实现相同的方法，这可能会引起不可预见的 <code>bug</code>。如果需要在分类中添加方法，应确保新添加的方法与主类和其他分类的方法不冲突。</p></details><h3 id="❓分类中为什么不能添加-property" tabindex="-1"><a class="header-anchor" href="#❓分类中为什么不能添加-property" aria-hidden="true">#</a> ❓分类中为什么不能添加 <code>@property</code></h3><details class="hint-container details"><summary>💡</summary><p><code>@property</code>会告诉编译器我们在类中声明了一个属性。默认情况下，编译器会生成一个后备存储（实例变量），并且为属性生成 <code>getter</code> 和 <code>setter</code> 方法。然而，对于分类（<code>Category</code>），一旦对象在运行时被注册，就不能再动态地添加实例变量。</p><p>从 <code>runtime</code> 角度来看， 这是由于类型的数据布局已经在编译阶段确定并且注册到了 <code>Objective-C</code> 的 <code>runtime</code> 系统中，而分类是在运行时被加载，所以无法更改基类的数据布局，也就无法添加实例变量。</p><p>具体来说，类结构体 <code>struct objc_class</code> 中的<code>ivar_list</code>（实例变量列表）是确定的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">objc_class</span> <span class="token punctuation">{</span>
    Class isa<span class="token punctuation">;</span>
    Class super_class<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">long</span> version<span class="token punctuation">;</span>
    <span class="token keyword">long</span> info<span class="token punctuation">;</span>
    <span class="token keyword">long</span> instance_size<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">objc_ivar_list</span> <span class="token operator">*</span>ivars<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而分类结构体 <code>struct category_t</code> 中只有方法列表，协议列表和属性列表，并没有实例变量列表：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">category_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token class-name">classref_t</span> cls<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>instanceMethods<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>classMethods<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">protocol_list_t</span> <span class="token operator">*</span>protocols<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">property_list_t</span> <span class="token operator">*</span>instanceProperties<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以在 <code>Objective-C</code> 分类中不能添加实例变量，也就不能添加带有自动生成的 <code>getter</code> 和 <code>setter</code> 的 <code>@property</code>。但是可以在分类中声明属性，并通过对已有的实例变量手动编写 <code>getter</code> 和 <code>setter</code>，或者使用关联对象(<code>Associated Objects</code>)来模拟实例变量。</p><p>总的来说，之所以不能在分类中添加 <code>@property</code>，是因为在编译器层面和 <code>runtime</code> 层面上，<code>Objective-C</code> 的设计都不允许动态地向类中添加实例变量。</p></details><h3 id="❓分类的结构体里面有哪些成员" tabindex="-1"><a class="header-anchor" href="#❓分类的结构体里面有哪些成员" aria-hidden="true">#</a> ❓分类的结构体里面有哪些成员</h3><details class="hint-container details"><summary>💡</summary><p>每个 <code>Category</code> 都对应着一个结构体 <code>category_t</code>。这个结构体的定义（在 <code>objc-runtime-new.h</code> 中）如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">category_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token class-name">classref_t</span> cls<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>instanceMethods<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>classMethods<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">protocol_list_t</span> <span class="token operator">*</span>protocols<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">property_list_t</span> <span class="token operator">*</span>instanceProperties<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">category_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构体中的字段包含以下内容：</p><ul><li><code>name</code>：分类的名字。</li><li><code>cls</code>：分类所属的类。</li><li><code>instanceMethods</code>：分类中新增的实例方法列表。</li><li><code>classMethods</code>：分类中新增的类方法列表。</li><li><code>protocols</code>：分类实现的协议列表。</li><li><code>instanceProperties</code>：分类中新增的实例属性列表。</li></ul><p>因此，可以在分类中声明和实现新的实例方法和类方法，实现新的协议，以及添加新的实例属性。</p><p>需要注意的是，虽然可以在分类中声明和实现新的属性，但是不能使用 <code>@synthesize</code> 来生成存取方法，也无法生成实例变量。你只能手动实现 <code>getter</code> 和 <code>setter</code> 来操作已存在的实例变量，或者使用关联对象（<code>Associated Object</code>）来模拟实例变量。</p></details><h3 id="❓分类中如何添加属性" tabindex="-1"><a class="header-anchor" href="#❓分类中如何添加属性" aria-hidden="true">#</a> ❓分类中如何添加属性</h3><details class="hint-container details"><summary>💡</summary><p>可以使用关联对象（<code>Associated Objects</code>）让分类拥有“伪属性”。</p><p>分类（<code>Category</code>）的定义中并不支持直接添加属性（<code>instance variable</code>）。但可以通过关联对象（<code>Associative References</code>）机制实现给分类添加属性。</p><p>以下是一个例子，演示如何给一个分类添加一个属性：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;NSObject+Property.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>objc<span class="token operator">/</span>runtime<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>MyKey <span class="token operator">=</span> <span class="token operator">&amp;</span>MyKey<span class="token punctuation">;</span>

<span class="token keyword">@implementation</span> <span class="token function">NSObject</span> <span class="token punctuation">(</span>Property<span class="token punctuation">)</span>
<span class="token comment">// getter</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>myProperty <span class="token punctuation">{</span>
  <span class="token comment">// `objc_getAssociatedObject` 用于取关联对象。</span>
  <span class="token comment">//  - 首个参数是要存取的对象</span>
  <span class="token comment">//  - 第二个参数是键，我们用一个静态常量 `MyKey` 作为键（每个关联到对象的键必须全局唯一）</span>
  <span class="token keyword">return</span> <span class="token function">objc_getAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> MyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// setter</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setMyProperty<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>myProperty <span class="token punctuation">{</span>
  <span class="token comment">// `objc_setAssociatedObject` 第三个参数是存储的值，第四个参数是关联策略</span>
  <span class="token comment">// `OBJC_ASSOCIATION_COPY_NONATOMIC`，表示这是一个 copy ，非原子操作的特性</span>
  <span class="token function">objc_setAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> MyKey<span class="token punctuation">,</span> myProperty<span class="token punctuation">,</span> OBJC_ASSOCIATION_COPY_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，定义了一个 <code>NSObject</code> 的分类并为它添加了一个 <code>myProperty</code> 属性。</p><p>通过关联对象可以间接实现在分类中&quot;添加&quot;属性，这也是 <code>Objective-C</code> 动态的特性之一。</p></details><hr><h2 id="消息发送" tabindex="-1"><a class="header-anchor" href="#消息发送" aria-hidden="true">#</a> 消息发送</h2><h3 id="❓oc-是否支持方法重载" tabindex="-1"><a class="header-anchor" href="#❓oc-是否支持方法重载" aria-hidden="true">#</a> ❓<code>OC</code> 是否支持方法重载</h3><details class="hint-container details"><summary>💡</summary><p><code>OC</code> 不支持方法重载。方法重载指的是在同一个类里面，方法名字相同，但参数不同的多个方法。</p><p><code>OC</code> 是一种动态类型语言，其方法的调用不是在编译期决定的，而是在运行时决定的。<code>OC</code> 使用消息派发机制，方法调用更依赖于方法的唯一性，如果有多个方法名字完全相同（即使参数类型不同），编译器和运行时系统就无法准确找到你要调用的方法。</p></details><h3 id="❓oc-中是如何通过-selector-找到对应的-imp-地址" tabindex="-1"><a class="header-anchor" href="#❓oc-中是如何通过-selector-找到对应的-imp-地址" aria-hidden="true">#</a> ❓<code>OC</code> 中是如何通过 <code>selector</code> 找到对应的 <code>IMP</code> 地址</h3><details class="hint-container details"><summary>💡</summary><p>通过 <code>selector</code> 找到对应的 <code>IMP</code>（Implementation）的过程：</p><ol><li><p><strong>查找类方法列表：</strong> 当向一个对象发送一条消息，运行时系统首先会在该对象的类的方法列表中查找与这个 <code>selector</code> 相对应的方法。如果找到，那么就直接调用这个方法的实现。在这个步骤中，<code>selector</code> 会被映射到其对应方法的 <code>IMP</code>。</p></li><li><p><strong>从父类中查找：</strong> 如果在对象的类的方法列表中没有找到对应的方法，那么运行时系统会在该类的父类中查找，如果在父类中找到，同样直接调用对应的 <code>IMP</code>。这个过程会一直沿着类的继承链查找，直到 <code>NSObject</code>。</p></li><li><p><strong>调用动态方法解析：</strong> 如果在整个继承链上都没有找到对应的方法，那么运行时系统会给你一个“补救”的机会，即会调用该类的 <code>+resolveInstanceMethod:</code> 或 <code>+resolveClassMethod:</code> 方法（取决于是实例方法还是类方法）。你可以在此方法中为对应的 <code>selector</code> 动态添加实现。</p></li><li><p><strong>消息转发：</strong> 如果 <code>+resolveInstanceMethod:</code> 或 <code>+resolveClassMethod:</code> 返回 <code>NO</code> 或者没有被重写，那么运行时就会启动完整消息转发，此时会调用 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code> 方法。你还可以在这个方法内将消息转发给能响应此消息的其他对象。</p></li><li><p><strong>抛出异常：</strong> 如果以上步骤都没有找到并执行相应的方法，那么运行时系统就会抛出 <code>unrecognized selector</code> 异常。</p></li></ol><p>这个过程包含了运行时系统的很多动态特性，使得我们能在运行时动态地处理对象的行为。</p></details><h3 id="❓怎么保证自己的类一定能调用到自己写的方法" tabindex="-1"><a class="header-anchor" href="#❓怎么保证自己的类一定能调用到自己写的方法" aria-hidden="true">#</a> ❓怎么保证自己的类一定能调用到自己写的方法</h3><details class="hint-container details"><summary>💡</summary><p>分类（<code>Category</code>）是一种可以为已存在的类添加新方法的方式。同时，分类中的方法会替换掉原来类中同名的方法。此特性在一些情况下可能引起不确定的行为，比如可能无意间覆盖掉你写的方法。</p><p>若要阻止自己写的方法被分类覆盖，可以考虑以下方法：</p><ol><li><p><strong>方法命名规范：</strong> 尽可能为方法命名时，添加前缀。这样可以避免和系统默认的方法或他人写的分类中的方法冲突。</p></li><li><p><strong>使用子类化代替分类：</strong> 如果你控制的类可能被其他开发者使用，那么建议使用子类代替分类。这样，即使有人创建了同名的分类，也不会对原类产生影响。</p></li><li><p><strong>在源代码级别进行检查：</strong> 在项目编译的时候，通过检查操作来警告和暴露任何重定义的方法。</p></li></ol><p>但是，以上的方式并不能 <code>100%</code> 的避免在运行时被覆盖的情况，因为 <code>Objective-C</code> 是一种动态类型的语言，它允许在运行时添加或替换方法。这种动态性是 <code>Objective-C</code> 的一大特性，但同时也可能带来风险。所以编程时应该遵循良好的开发习惯，避免不必要的麻烦。</p></details><h3 id="❓oc-中的类方法和实例方法有什么本质区别和联系" tabindex="-1"><a class="header-anchor" href="#❓oc-中的类方法和实例方法有什么本质区别和联系" aria-hidden="true">#</a> ❓<code>OC</code> 中的类方法和实例方法有什么本质区别和联系</h3><details class="hint-container details"><summary>💡</summary><p>在 <code>runtime</code> 层面，类方法和实例方法有一些本质的区别：</p><p><strong>存储的位置：</strong></p><p>实例方法列表存储在类对象（<code>Class</code>）中，而类方法列表存储在元类对象（<code>Meta-Class</code>）中。</p><p><strong>调用者：</strong></p><p>实例方法由实例对象调用，即 <code>[instanceObject exampleMethod];</code>，其中 <code>exampleMethod</code> 是实例对象的方法；类方法由类对象调用，即 <code>[ClassObject exampleMethod];</code>，其中 <code>exampleMethod</code> 是类方法。</p><p><strong>方法查找过程：</strong></p><p>调用实例方法时，<code>runtime</code> 系统会在类的方法列表中查找这个方法；调用类方法时，<code>runtime</code> 系统会在元类的方法列表中查找这个方法。</p><p><strong>self 指针：</strong></p><p>在实例方法和类方法中，<code>self</code> 指针的含义是不同的。在实例方法中，<code>self</code> 指向调用这个方法的实例对象；而在类方法中，<code>self</code> 指向调用这个方法的类对象。</p><p><strong>能访问的变量：</strong></p><p>实例方法可以访问实例变量和静态变量，而类方法只能访问静态变量。</p></details><h3 id="❓在类方法中是否可以使用-self" tabindex="-1"><a class="header-anchor" href="#❓在类方法中是否可以使用-self" aria-hidden="true">#</a> ❓在类方法中是否可以使用 <code>self</code></h3><details class="hint-container details"><summary>💡</summary><p>可以在类方法中使用 <code>self</code>。但在类方法中，<code>self</code> 表示的是类对象本身，而不是类的实例。这意味着不能用 <code>self</code> 来访问实例变量，只能用它来调用其他类方法。</p><p>例如：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>aClassMethod <span class="token punctuation">{</span>
    <span class="token comment">// 这里的self是类对象本身</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> anotherClassMethod<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>anotherClassMethod</code> 会被正确地调用，因为 <code>self</code> 在这里代表类对象。</p><p>但是，不能在类方法中使用 <code>self</code> 来访问实例变量或调用实例方法，因为在类方法中没有实例来调用它们。尝试这样做会在编译时出错。</p><p>总的来说，<code>self</code> 在类方法中指的是类对象本身，用来调用其他类方法；在实例方法中指的是调用该方法的实例对象，用来访问实例变量或调用实例方法。</p></details><h3 id="❓sel、-cmd-是什么" tabindex="-1"><a class="header-anchor" href="#❓sel、-cmd-是什么" aria-hidden="true">#</a> ❓<code>SEL</code>、<code>_cmd</code> 是什么</h3><details class="hint-container details"><summary>💡</summary><ul><li><p><code>SEL</code>： 是一个表示方法的类型，实际上是一个字符串，不同的方法对应不同的 <code>SEL</code> 。例如 <code>SEL methodSEL = @selector(methodName);</code></p></li><li><p><code>_cmd</code>：是一个隐藏的参数，表示当前调用的方法的 <code>SEL</code>。每个方法的实现的第二个参数<code>_cmd</code>，它是一个 <code>SEL</code> 类型的，即当前方法的选择器。</p></li></ul><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>someMethod <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> <span class="token function">NSStringFromSelector</span><span class="token punctuation">(</span>_cmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;someMethod&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，_cmd 被用来输出当前方法的名称。通常情况下，可能不需要直接使用 _cmd，但它在调试，特别是在动态方法解析（<code>dynamic method resolution</code>）时非常有用。</p></details><h3 id="❓oc-中对象消息发送的大致流程" tabindex="-1"><a class="header-anchor" href="#❓oc-中对象消息发送的大致流程" aria-hidden="true">#</a> ❓<code>OC</code> 中对象消息发送的大致流程</h3><details class="hint-container details"><summary>💡</summary><p>对象消息发送主要包含以下步骤：</p><ol><li><p><strong>消息发送者：</strong> 当调用一个 <code>Objective-C</code> 对象的方法时，实际上是向这个对象发送了一条消息。例如，<code>[object methodWithParameter:parameter];</code>，这里的 <code>object</code> 是消息的接受者，<code>methodWithParameter:</code> 是消息的选择器（<code>SEL</code>，<code>Selector</code>）。</p></li><li><p><strong>动态绑定：</strong> 不是在编译的时候决定函数地址，而是在运行时根据接收者和选择器找到对应的函数实现。</p></li><li><p><strong>寻找接受者：</strong> 明确了消息的接收者后，会在对应的类以及其父类中查找这个方法的实现。如果在消息接收者的类中找不到响应的方法，则继续往它的父类中寻找。</p></li><li><p><strong>消息转发：</strong> 如果到了根类（一般是 <code>NSObject</code> ）都没有找到方法实现，那么就会进入对象的 <code>doesNotRecognizeSelector:</code> 方法，进入此方法就算出错了，未对此方法做处理的话程序会 <code>crash</code>。不过，<code>NSObject</code> 提供了最后挽救的机会，走进消息转发机制，可以指定一个新的接受者来响应这条消息。如果消息转发也没有处理，就真的会 <code>crash</code> 了。</p></li></ol><p>这些步骤大大增加了<code> Objective-C</code> 的灵活性，让代码具有更好的扩展性和维护性。即使一个对象没有实现某个方法，也不会在编译阶段报错，而会在运行时进入消息转发阶段，提供了处理未实现方法的机会。</p></details><h3 id="❓向一个-nil-对象发送消息将会发生什么" tabindex="-1"><a class="header-anchor" href="#❓向一个-nil-对象发送消息将会发生什么" aria-hidden="true">#</a> ❓向一个 <code>nil</code> 对象发送消息将会发生什么</h3><details class="hint-container details"><summary>💡</summary><p>向 <code>nil</code> 对象发送消息是安全的，不会导致程序崩溃。这一特性是 <code>Objective-C</code> 语言中的一项重要特性，使其在处理对象的空态时更加灵活。</p><p>对一个 <code>nil</code> 对象发送消息，下面是可能会发生的情况：</p><ol><li><p><strong>方法返回非对象类型：</strong> 如果该消息是一个返回非对象类型的方法（例如 <code>int</code>，<code>float</code>，<code>struct</code> 等），会返回零值（0，0.0，相应类型的零值等）。</p></li><li><p><strong>方法返回对象类型：</strong> 如果该消息是一个返回对象的方法，那么将会返回 <code>nil</code>。</p></li><li><p><strong>方法不返回值（例如 void 类型）：</strong> 如果该消息是一个不返回值的方法，那么什么都不会发生。</p></li></ol><p>这种特性使得可以在不检查一个对象是否为 <code>nil</code> 的情况下向它发送消息，这通常能使代码更加简洁。反过来，如果在其他语言（例如 <code>Java</code> 或 <code>C#</code>）那样，在向对象发送消息之前总是先检查它是否为 <code>nil</code>，那么可能会编写出很多不必要的代码。然而，注意这并不意味着可以忽略 <code>nil</code> 检查，在某些情况下，<code>nil</code> 检查仍然是必要的。</p><p>需要注意的是，向一个 <code>nil</code> 对象发送消息会返回 <code>nil</code> 或零值，但是在某些情况下，这可能会隐藏程序中的错误，如果密切注意这一点，这一特性可以使代码更加简洁和强大。</p></details><h3 id="❓向一个对象发送消息-obj-foo-和-objc-msgsend-函数之间有什么关系" tabindex="-1"><a class="header-anchor" href="#❓向一个对象发送消息-obj-foo-和-objc-msgsend-函数之间有什么关系" aria-hidden="true">#</a> ❓向一个对象发送消息 <code>[obj foo]</code> 和 <code>objc_msgSend()</code> 函数之间有什么关系</h3><details class="hint-container details"><summary>💡</summary><p><code>[obj foo]</code> 这种语义实际上是在运行时通过调用 <code>objc_msgSend(obj, @selector(foo))</code> 来实现的。</p><p>方法(<code>methods</code>)的调用被称为向一个对象发送消息。当使用方括号语法向对象发送消息时，如 <code>[obj foo]</code>，实际上运行时系统会将其转化为 <code>objc_msgSend()</code> 函数的调用。</p><p><code>objc_msgSend()</code> 是 <code>runtime</code> 库中的函数，接受两个以上的参数。第一个参数(<code>receiver</code>)是要发送消息的对象，第二个参数(<code>selector</code>)是要发送的消息(<code>method</code>)。例如，<code>objc_msgSend(obj, @selector(foo))</code> 就是向 <code>obj</code> 对象发送名为 <code>foo</code> 的消息。</p><p><code>Objective-C</code> 中的方法调用实际上是基于运行时的消息传递机制。将类和实例的方法调用抽象化为对特定对象发送特定消息，通过动态的消息分派机制找到并执行对应的方法实现。这种特性也是 <code>OC</code> 动态特性的基础。</p></details><h3 id="❓一个对象向一个不存在的方法发送消息-消息是如何转发的" tabindex="-1"><a class="header-anchor" href="#❓一个对象向一个不存在的方法发送消息-消息是如何转发的" aria-hidden="true">#</a> ❓一个对象向一个不存在的方法发送消息，消息是如何转发的</h3><details class="hint-container details"><summary>💡</summary><p>一个对象接收到一个不存在的方法时，将通过以下步骤进行消息转发：</p><ol><li><p>动态方法解析（<code>Dynamic Method Resolution</code>） 运行时系统会调用 <code>+resolveInstanceMethod:</code>（对于类方法是 <code>+resolveClassMethod:</code>）。在这个阶段，可以为这个类动态添加一个方法。如果此方法返回 <code>YES</code>，那么运行时系统会重新发送消息。</p></li><li><p>备援接收者（<code>Backup Receiver</code>） 如果第一步未处理消息（即 <code>+resolveInstanceMethod:</code> 返回 <code>NO</code>），系统会调用 <code>-forwardingTargetForSelector:</code> 方法，可以返回一个替代的对象。这个方法返回了一个实例后，系统会把这条消息发送给这个实例。</p></li><li><p>完整消息转发（<code>Complete Message Forwarding</code>） 如果 <code>-forwardingTargetForSelector:</code> 返回了 <code>nil</code>，运行时就会进入完整的消息转发阶段。首先会发送 <code>-methodSignatureForSelector:</code> 消息来获取方法的返回和参数类型。然后会发送 <code>-forwardInvocation:</code> 消息。可以在 <code>-forwardInvocation:</code> 中自行处理消息，或者转发给其他对象处理。</p></li><li><p>消息转发失败 如果在 <code>-forwardInvocation:</code> 中未处理消息，那么运行时会调用 <code>-doesNotRecognizeSelector:</code> 方法， 默认会抛出异常。</p></li></ol><p>需要注意的是，消息转发虽然强大，但由于需要经过多次查找，性能开销较大。当频繁调用时应用程序的运行效率会受到很大影响。因此，应该仅在需要动态处理未知消息时才会使用消息转发。</p></details><h3 id="❓unrecognized-selector-异常是如何发生-应该如何避免" tabindex="-1"><a class="header-anchor" href="#❓unrecognized-selector-异常是如何发生-应该如何避免" aria-hidden="true">#</a> ❓<code>unrecognized selector</code> 异常是如何发生，应该如何避免</h3><details class="hint-container details"><summary>💡</summary><p><code>unrecognized selector</code> 异常是一个常见运行时错误，当向一个对象发送它不能响应的消息时，就会抛出这个异常。</p><p>当调用一个对象的方法时，实际上是在向这个对象发送一条消息。运行时系统会在对象的类及其所有的父类中寻找与这个消息对应的方法。如果找到这个方法，就会调用它。如果在最底层的父类（通常是 <code>NSObject</code>）中也找不到这个方法，那么就会抛出 <code>unrecognized selector</code> 异常。</p><p>避免 <code>unrecognized selector</code> 异常的方法有以下几种：</p><ul><li><strong>检查对象是否能响应此消息：</strong> 在向对象发送消息之前，使用 <code>respondsToSelector:</code> 方法检查这个对象是否能响应这个消息。</li></ul><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>obj respondsToSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>obj foo<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>使用异常处理：</strong> <code>Objective-C</code> 提供了异常处理语句 <code>@try、@catch、@finally</code>。可以将可能抛出异常的代码放在 <code>@try</code> 块中，将处理异常的代码放在 <code>@catch</code> 块中。</p></li><li><p><strong>消息转发：</strong> 如果一个对象无法识别引发异常的方法，那么在引发异常之前，会先调用这个对象的 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code> 方法，可以在这个方法里面向其他能响应此消息的对象发送该消息。这就相当于将此消息转发给其他对象。</p></li></ul></details><h3 id="❓-objc-msgforward-函数是做什么的-直接调用它将会发生什么" tabindex="-1"><a class="header-anchor" href="#❓-objc-msgforward-函数是做什么的-直接调用它将会发生什么" aria-hidden="true">#</a> ❓<code>_objc_msgForward</code> 函数是做什么的，直接调用它将会发生什么</h3><details class="hint-container details"><summary>💡</summary><p><code>_objc_msgForward</code> 是运行时系统中用于对消息进行转发（<code>Message Forwarding</code>）的函数。</p><p>当向一个对象发送一条消息，运行时系统会在该对象的类以及其父类链中查找是否有可以响应这条消息的方法。如果没有找到的话，运行时系统会调用 <code>_objc_msgForward</code> 函数进行消息转发。</p><p>一般不会直接调用 <code>_objc_msgForward</code> 函数。因为这个函数是由运行时系统在需要进行消息转发时自动调用的。</p><p>如果直接调用 <code>_objc_msgForward</code>，那么一般而言，这将会引起 <code>unrecognized selector</code> 异常，因为这个函数的作用就是处理不能识别的选择器（即方法）。如果手动调用它，系统会在尝试进行消息转发时找不到能响应此消息的对象或方法，从而引发异常。基本上，直接调用 <code>_objc_msgForward</code> 而没有适当的转发目标和处理机制，是没有意义的。</p></details><h3 id="❓c-调用虚方法与-oc-发消息有什么区别" tabindex="-1"><a class="header-anchor" href="#❓c-调用虚方法与-oc-发消息有什么区别" aria-hidden="true">#</a> ❓<code>C++</code> 调用虚方法与 <code>OC</code> 发消息有什么区别</h3><details class="hint-container details"><summary>💡</summary><p><code>C++</code> 虚方法和 <code>Objective-C</code> 发消息是两种不同编程语言的两种不同的机制，它们在工作原理和应用场景上都有一些不同。</p><p><strong>C++ 虚方法：</strong> 是 <code>C++</code> 支持多态性的一种方式。在 <code>C++</code> 中，如果一个父类指针指向派生类对象，并通过该指针调用虚函数，那么调用的将是派生类中的虚函数实现。这是通过 <code>C++</code> 的虚函数表（<code>vtable</code>）来实现的，虚函数表是在编译期确定的。</p><p><strong>Objective-C 发消息：</strong> 是 <code>Objective-C</code> 进行方法调用的方式。它会在运行时动态地确定应该调用对象的哪个方法。当给 <code>Objective-C</code> 对象发送消息时，运行时系统会搜索接收者的类以及所有父类的方法列表，找到第一个可以响应该消息的方法并调用。</p><p>这两种机制的主要区别：</p><ul><li><p><strong>动态性：</strong> <code>Objective-C</code> 的消息发送更具有动态性，因为它在运行时确定方法调用，而 <code>C++</code> 的虚函数在编译时已经确定。</p></li><li><p><strong>灵活性：</strong> <code>Objective-C</code> 的消息发送机制允许在运行时为对象动态添加方法，这使得 <code>Objective-C </code>具有更高的灵活性。</p></li><li><p><strong>性能：</strong> 由于 <code>C++</code> 的虚函数调用是在编译期就已经确定，因此它的性能上优于 <code>Objective-C</code> 的动态消息发送。</p></li><li><p><strong>安全性：</strong> <code>C++</code> 的类型检查更为严格，因此调用虚方法要比 <code>Objective-C</code> 发送消息更安全，后者如果发送了对象无法响应的消息就会在运行时崩溃。</p></li></ul></details><h3 id="❓消息转发机制和其他语言的消息机制优劣对比" tabindex="-1"><a class="header-anchor" href="#❓消息转发机制和其他语言的消息机制优劣对比" aria-hidden="true">#</a> ❓消息转发机制和其他语言的消息机制优劣对比</h3><details class="hint-container details"><summary>💡</summary><p>消息转发机制是一种非常强大的动态特性，在一些其他的面向对象编程语言中，并没有类似的功能。下面我们从几个方面来分析 <code>Objective-C</code> 消息转发机制和其他语言的消息机制的优劣。</p><ul><li><p><strong>动态性</strong>：消息转发机制可以在运行时动态地处理未知的消息。而其他一些语言，如 <code>C++</code>, <code>Java</code>, <code>C#</code> 等，在编译期间就已经确定了方法的调用，并不能在运行时动态地处理未知的消息。</p></li><li><p><strong>灵活性</strong>：消息转发可以不仅仅是转发给其他对象，甚至可以动态地为类生成新的方法。这在很多其他语言中是无法做到的。</p></li><li><p><strong>性能</strong>：消息转发机制相对于其他语言的消息机制，如 <code>C++</code> 的虚函数，性能上会稍差一些。因为 <code>Objective-C</code> 是在运行时通过查找类的方法列表来确定方法调用，而不是在编译时就确定。</p></li><li><p><strong>安全性</strong>：消息转发机制如果使用不当，可能会产生一些难以发现的错误。例如，如果错误地转发了消息，可能会导致运行时崩溃。而其他一些语言，如 <code>Java</code>, <code>C#</code>, 是在编译期就检查了方法的调用，相对来说更加安全。</p></li></ul></details><h3 id="❓在方法调用的时候-方法查询-动态解析-消息转发-之前做了什么" tabindex="-1"><a class="header-anchor" href="#❓在方法调用的时候-方法查询-动态解析-消息转发-之前做了什么" aria-hidden="true">#</a> ❓在方法调用的时候，<code>方法查询-&gt; 动态解析-&gt; 消息转发</code> 之前做了什么</h3><details class="hint-container details"><summary>💡</summary><p>仅当通过发送消息调用方法失败的时候，才会启动方法查找（<code>method lookup</code>）、动态解析（<code>dynamic resolution</code>）和消息转发（<code>message forwarding</code>）这些步骤。在这之前，已经经过了一系列过程：</p><ol><li><p><strong>消息发送</strong>：实际上是调用了运行时库中的 <code>objc_msgSend</code> 函数。方法的调用者（即消息的接收者）和方法选择器（<code>selector</code>）都作为 <code>objc_msgSend</code> 的参数。</p></li><li><p><strong>查找对象的类</strong>：<code>objc_msgSend</code> 需要知道对象的类信息，以便在类的方法列表里查找可以响应该消息的方法。对象内部有一个指针指向它的类，<code>objc_msgSend</code> 可以通过这个指针获取对象的类。</p></li><li><p><strong>缓存查找</strong>：<code>Objective-C</code> 运行时系统为了优化性能，已经将一部分方法的调用结果缓存起来，所以 <code>objc_msgSend</code> 会先从缓存中查找 <code>selector</code> 对应的方法实现。如果缓存中有，则直接调用该方法结束查找流程；如果没有，进入下一步。</p></li><li><p><strong>方法列表查找</strong>：<code>objc_msgSend</code> 会在对象的类的方法列表中搜索 <code>selector</code> 对应的方法。如果找到，则调用该方法，将方法结果添加到缓存中，并结束查找流程。</p></li></ol><p>如果经过上述步骤仍然找不到可以响应消息的方法，运行时系统就会启动方法查询、动态解析等步骤，尝试在运行时解决这个问题。</p></details><h3 id="❓下面代码能正常运行吗-如果能-输出是什么" tabindex="-1"><a class="header-anchor" href="#❓下面代码能正常运行吗-如果能-输出是什么" aria-hidden="true">#</a> ❓下面代码能正常运行吗(如果能，输出是什么)</h3><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> Person <span class="token punctuation">:</span> NSObject 
<span class="token keyword">@property</span><span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span>copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span> 
<span class="token keyword">@end</span>
<span class="token keyword">@implementation</span> Person
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>speak <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;My name is:%@&quot;</span><span class="token punctuation">,</span><span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> ViewController
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewDidLoad <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> viewDidLoad<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    id cls <span class="token operator">=</span> <span class="token punctuation">[</span>Person class<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token operator">&amp;</span>cls<span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span>__bridge id<span class="token punctuation">)</span>obj speak<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>💡</summary><p>这段代码可以正常运行，其输出将是 <code>My name is:(null)</code>。</p><p>在这段代码中 <code>id cls = [Person class];</code>这行代码是获取 <code>Person</code> 类。然后 <code>void *obj = &amp;cls;</code> 这行代码是获取了指向 <code>cls</code> 的指针，所以 <code>obj</code> 指向的是一个 <code>Person</code> 类的对象，而不是 <code>Person</code> 类的实例。然后 <code>[(__bridge id)obj speak];</code> 这行代码就是发送一个消息给 <code>obj</code>，所以最终调用的是 <code>Person</code> 类的 <code>speak</code> 方法。</p><p>但是这里需要注意的是，并没有给 <code>name</code> 属性赋值，所以当打印 <code>name</code> 属性的时候，它的值是 <code>nil</code>，也就是 <code>(null)</code>。</p></details></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/naijoug/docs/edit/main/src/interview/ios/0x01.objective-c.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: naijoug@outlook.com">naijoug</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><!----><a aria-label="Swift" class="vp-link nav-link next nav-link next" href="/docs/interview/ios/0x02.swift.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Swift<span class="font-icon icon fa-fw fa-sm fas fa-hashtag" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2024 naijoug</div></footer></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-SX6jYwBY.js" defer></script>
  </body>
</html>

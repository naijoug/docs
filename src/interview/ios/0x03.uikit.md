---
title: UIKit
icon: hashtag

index: true

---

<!-- more -->

------

## UIKit

### ❓`iOS` 从点击程序图标到展示界面完成，这个启动流程说一下

::: details 💡

在 iOS 系统中，应用启动的过程大致可以分为以下几步：

1. 用户点击应用图标后，系统会启动 `Launchd` 进程。`Launchd` 通过查找应用的 `info.plist` 文件找到 `main` 函数所在的位置，开始执行 `main` 函数。

2. 在 `main` 函数中，会执行 `UIApplicationMain` 函数。这个函数会创建应用代理对象（`AppDelegate`），创建主线程 `RunLoop`，以及设置 `UIApplication` 对象，并将 `UIApplication` 对象的代理设置为应用代理对象。

3. `UIApplication` 对象在接收到 `didFinishLaunchingWithOptions` 事件后，进入事件循环。在这个过程中，系统初始化了 `UIApplication` 和 `AppDelegate`，然后触发 `UIApplicationDelegate` 的 `application:didFinishLaunchingWithOptions` 方法。

4. 在 `AppDelegate` 的 `application:didFinishLaunchingWithOptions` 方法中，通常我们会加载并配置应用启动时需要的各种数据和状态，同时这里也会启动 `rootViewController`。系统会将设置的主 `window` 的 `rootViewController` 的 `view` 添加到 `window` 中，并且显示出来。

5. 系统将启动画面逐渐淡出，显示应用主界面。

6. 主 `RunLoop` 开始运行，开始接收并处理用户触摸及各种系统时间。

至此，应用启动过程基本结束。剩下就是主 `RunLoop` 处理时间，等待接收用户的输入操作。

:::

### ❓了解的 `UIKit` 结构

::: details 💡

UIKit 这个框架提供了在 iOS 中开发图形化、事件驱动的应用所需要的所有基础工具和基础结构。以下是主要的组件：

1. UIWindow:
    一个 iOS 应用通常会有一个或多个 UIWindow，这是展示 UIViews 的地方，是 UIView 的最顶层容器。它通常与设备的屏幕一样大小。

2. UIView 和 UIViewController:
    UIView 是 iOS 中的基础组件，负责绘制和布局界面元素，处理与用户交互的事件。UIViewControllers 每个 UIKit 的对应一个 UIView，它管理着 UIView 的生命周期，负责处理用户交互和视图切换等逻辑。

3. 控件：
    UIKit 提供了一组预封装的常见 UI 元素组件，如按钮（UIButton）、标签（UILabel）、滚动视图（UIScrollView）、表格视图（UITableView）、集合视图（UICollectionView）等。

4. 图形和动画:
    UIKit 提供了一套强大的 2D 图形和动画框架，包括基础的画图 API、复杂的形状和路径、渐变、屏幕刷新和动画等。

5. 文本处理:
    UIKit 提供了一套强大的文本处理和布局系统。不仅提供了基础的 UILabel 用于显示文本，还有 UITextField、UITextView 等用于文本输入，以及 NSLayoutManager 和 NSTextContainer 等高级 API 用于复杂的文本布局。

6. 触摸事件处理:
    UIKit 提供了一套事件处理机制，包括触摸事件、手势识别等，非常方便地可以让我们对用户的交互作出响应。

7. 响应者链：
    UIKit 针对 UI 事件提供了响应者链的机制，当一个事件产生后，通过响应者链，逐层寻找可以处理该事件的对象。比如触屏事件，先从最上层的 view 开始，如果该 view 不能处理，则逐层向上传递至其父 view，直到找到可以处理该事件的对象。

8. 自动布局：
    利用 UIKit 框架的自动布局系统，开发者可以创建灵活且响应的界面布局。开发者可以使用 AutoLayout 和 UIStackView 来布局界面。
    
9. CoreAnimation:
    UIKit 的绚丽动画效果就是 Core Animation 提供支持。我们可以通过他构建具有复杂视觉效果的动画，例如在两个视图状态之间平滑过渡，或者是在屏幕上移动、缩放、旋转视图。

10. Alert 和 Action Sheet:
    UIKit 提供了 UIAlertController 来显示警告框和动作表，以便在适当的时机提醒用户或由用户做出决定。
    
除此之外，UIKit 还有导航和标签栏控制器、拾取视图、弹簧加载行为、刷新控件、Popover 视图等众多组件。

:::

### ❓`UIScene` 了解吗

::: details 💡

`UIScene` 是在 iOS 13 中引入的一种新的应用生命周期模型，它提供了管理应用 UI 以及该 UI 如何响应系统和用户事件的更细粒度的方式。

在 iOS 13 以前，iOS 应用由单一的 UIWindow 实例进行管理，并且该 UIWindow 实例存在于整个应用的生命周期中。AppDelegate 要负责所有 UI 设置以及与应用生命周期相关的事件。

而 `UIScene` 则是对此进行了优化，每一个 `UIScene` 实例代表应用 UI 的一个单一实例。当应用在前台运行时，可以有多个 `UIScene` 实例，从而实现多窗口的多任务管理。例如在 iPadOS 上，用户可以开启多个窗口。

每个 `Scene` 由一个 `Scene Delegate` 来进行管理，各种 UI 设置以及和场景（Scene）生命周期相关的事件都由 `Scene Delegate` 来处理。就像原来 `AppDelegate` 处理应用级别的事件一样，`Scene Delegate` 负责处理和特定 `Scene` 相关的事件。只有当进行 App 级别的事件处理，譬如接收远程消息通知，处理后台下载任务，这些工作才会交给 `AppDelegate` 去完成。

这样的设计，使得在做一些 UI 设置以及响应生命周期事件时，更加的清晰和方便，同时也带来了更好的多任务管理能力。

:::

> `SceneDelegate` 详细说说

::: details 💡

SceneDelegate 是从 iOS 13 开始引入的一个新的代理模型，用于处理和 UI Scene Session 相关的事件，并控制和管理与其关联的 Scene。

我们可以在 SceneDelegate 中处理以下一些事件：

1. `func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)` 方法：这个方法是在创建新的 scene 时被调用，相当于 AppDelegate 中的 `application:didFinishLaunchingWithOptions:` 方法。我们通常会在该方法中设置窗口和根视图控制器。

2. `func sceneDidDisconnect(_ scene: UIScene)` 方法：当 scene 与 app 断开连接时候调用。发生在 scene 进入后台并且系统决定需要释放 scene 时。

3. `func sceneDidBecomeActive(_ scene: UIScene)` 方法：当 scene 进入活跃状态或者进入前台时调用，对应的是 AppDelegate 中的 `applicationDidBecomeActive:` 方法。

4. `func sceneWillResignActive(_ scene: UIScene)` 方法：当 scene 准备进入非活跃状态或者进入后台时调用，对应的是 AppDelegate 中的 `applicationWillResignActive:` 方法。

5. `func sceneWillEnterForeground(_ scene: UIScene)` 方法：当 scene 从后台恢复到前台时调用，对应的是 AppDelegate 中的 `applicationWillEnterForeground:` 方法。

6. `func sceneDidEnterBackground(_ scene: UIScene)` 方法：当 scene 进入后台时调用，对应的是 AppDelegate 中的 `applicationDidEnterBackground:` 方法。

7. `func stateRestorationActivity(for scene: UIScene)` 方法: 应用状态恢复时调用的方法，用以保存应用的当前状态。

上述方法基本涵盖了 Scene 的生命周期，可用于管理和响应与 Scene 相关的各种事件。

:::

### ❓`applicationWillEnterForeground` 和 `applicationDidBecomeActive` 都会在哪些场景下被调用

::: details 💡

这两个方法是iOS应用生命周期管理中非常重要的部分，他们的调用主要取决于应用的状态转换。下面是他们被调用的一些常见情况：

1. 用户通过主屏幕点击图标打开应用：
这种情况下首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

2. 应用在后台，通过通知或者系统打开应用：
也是先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

3. 应用从后台切换到前台：
这种情况下，两个函数的调用顺序和之前一样，首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

4. 应用内部弹出系统视图，例如电话，信息，分享等视图，视图消失后：
这个情况下只会调用 `applicationDidBecomeActive`，`applicationWillEnterForeground` 不会被调用，因为应用实际上并没有进入后台，只是暂时失去了焦点。

综上所述，`applicationWillEnterForeground` 和 `applicationDidBecomeActive` 一般是成对出现的，但在一些特殊情况下（例如应用内部弹出系统视图），可能只有 `applicationDidBecomeActive` 被调用。

:::

### ❓`UITableView` 的 `delegate` 和 `dataSource` 代理有什么区别

::: details 💡

`UITableView` 的 `delegate` 和 `dataSource` 是两个非常重要的组件，它们都是 `UITableView` 正常工作的必要条件，但作用是不同的。

`dataSource` 主要是向 `UITableView` 提供数据，例如数据源中有多少个 section，每个 section 有多少行，以及每一行的具体内容等等。`dataSource` 必须实现下面两个方法：

- `func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int`：设置每个 section 中的 row 数量。
- `func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell`：提供具体的 cell。

这两个方法是 `UITableViewDataSource` 协议的必要方法，没有这两个方法，`UITableView` 就没办法正常工作。

而 `delegate` 主要是处理 `UITableView` 的视觉效果以及与用户的交互，例如设置 header 和 footer、设置 cell 的高度、处理 cell 的选择和取消选择等等。例如：

- `func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat`：设置 cell 的高度。
- `func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)`：处理 cell 的选择事件。

这些方法都不是必须的，不过如果我们想要更加细致地控制 `UITableView` 的外观和行为，就需要实现这些方法。

总的来说，`dataSource` 是设置和提供数据，`delegate` 是控制外观和处理用户交互。

:::

### ❓`UICollectionView` 自定义布局如何处理

::: details 💡

要自定义 `UICollectionView` 的布局，首先需要创建一个 `UICollectionViewLayout` 或 `UICollectionViewFlowLayout` 的子类，然后重写其中与布局相关的一些方法。

以下是一些最重要的需要重写的方法：

- `prepare()`: 在这个方法中计算出所有 cell 和视图的位置。当布局被无效化并需要更新的时候，会首先调用该方法。

- `layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]?`: 这个方法返回的是在给定矩形中所有 cell 和视图的布局属性。这个方法负责提供一个布局属性数组，数组中的数据表示了对应位置的 cell 的排布和样式。

- `layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes?`: 这个方法返回的是对应于路径的所有项目的布局属性，也就是在 collection view 中指定位置的 cell 的排布和样式。

- `collectionViewContentSize: CGSize`: 这个方法返回的是整个 collectionView 的内容的宽度和高度。collectionView 会使用这个尺寸来配置自己的内容大小，从而实现滚动。

创建了自定义布局类之后，就可以在创建 `UICollectionView` 的时候，将这个布局类的对象作为参数传入 `UICollectionView` 的初始化方法中，这样创建出来的 `UICollectionView` 将会按照我们自定义的方式进行布局。

:::

### ❓`UIViewController` 的生命周期

::: details 💡

`UIViewController` 的生命周期包含多个阶段，主要涉及到以下几个方法：

1. `loadView()`: 这个方法是用来创建或加载视图控制器的视图层次结构。是视图控制器生命周期的起始。大部分时间，我们不需要去重写或者直接调用它。

2. `viewDidLoad()`: 这个方法会在视图控制器的视图被装载后调用。您可以在该方法中实现任何额外的初始化工作。

3. `viewWillAppear(_:)`: 这个方法会在视图控制器的视图被添加到窗口并且即将显示出来的时候调用。

4. `viewDidAppear(_:)`: 这个方法会在视图控制器的视图已经显示出来之后调用。

5. `viewWillDisappear(_:)`: 这个方法会在视图控制器的视图即将从窗口中移除或者被覆盖而消失的时候调用。

6. `viewDidDisappear(_:)`: 这个方法会在视图控制器的视图已经消失、被移除或覆盖的时候调用。

这些方法主要用于处理视图和数据加载、更新、释放等相关工作，以及执行某些与动画和过渡相关的操作。通过在这些方法中添加自定义的代码，您可以改变应用的行为和性能。

:::

### ❓`loadView` 的作用

::: details 💡

`loadView()` 是 UIViewController 的一个生命周期方法，它在访问控制器的 `view` 属性时，如果该属性当前为 `nil`，则会被系统自动调用。

`loadView()` 用于创建并加载视图控制器的主视图（即 `self.view`）。通常情况下，我们并不需要重写这个方法，因为默认的实现能够处理大部分常规的初始化需求。比如，如果控制器在 Storyboard 中定义，那么 `loadView()` 会加载和设置来自 Storyboard 的视图。如果有一个同名的 nib 文件，它会加载和设置来自该 nib 文件的视图。

然而，在我们需要以编程方式创建视图，或者提供自定义的视图加载机制时，我们可以通过重写 `loadView()` 方法来实现。在重写的 `loadView()` 中，你需要手动创建一个 `UIView` 对象或其子类的实例，并赋值给控制器的 `view` 属性。

注意：
* 当你重写 `loadView()` 方法时，不需要调用 `super`，并且在方法的最后要确保 `self.view` 不为 `nil`。
* 除非有特殊需求，否则不建议重写 `loadView()` 方法。对于大部分情况，我们可以在 `viewDidLoad()` 方法中做视图的初始化配置和其他设置，这更为常见。

:::

### ❓没有使用 `IB` 时，也没有重写` loadView()` 这个 `viewController.view` 如何创建的

::: details 💡

如果没有使用 Interface Builder（IB）来创建和管理视图，并且也没有重写 `loadView()` 方法，那么在 `UIViewController` 的 `loadView()` 方法中会默认创建一个 `UIView` 实例，然后赋值给 `self.view`。

简单的说，`loadView()` 方法的默认实现会创建一个空的 `UIView` 实例。这就是为什么即使你没有使用 `IB` 并且没有重写 `loadView()` 方法，仍然可以在 `viewDidLoad()` 或者其他生命周期的方法中访问到 `self.view` 并进行一些例如添加子视图，修改背景色等操作。

总的来说，无论是使用 `IB` （storyboard 或 xib），还是重写 `loadView()` 来自行创建视图，还是直接采用默认的实现，`UIViewController` 都会确保当其视图被访问时有一个 `UIView` 的实例被创建并赋值给 `self.view`。

:::


### ❓在 `init` 方法里面设置背景颜色，会生效吗

::: details 💡

对于 `UIView` 来说，如果你在使用 `initWithFrame:` 初始化方法来创建视图，那么在 `init` 方法中设置背景色是生效的。但是如果你是在 `Interface Builder`（即`storyboard` 或者 `xib`）中创建的视图，这个时候初始化方法是 `initWithCoder:`，同时设置视图属性大多放在 `awakeFromNib` 方法中。

对于 `UIViewController` 来说，由于控制器的视图 `view` 在 `init` 方法调用时还没有被加载，所以在`init`方法里设置背景颜色是不会生效的。你需要在 `viewDidLoad` 或者 `loadView` 这样的方法之后设置，这个时候视图已经被初始化并加载完成了。

总的来说，设置背景颜色是否生效，取决于何时设置和何时初始化和加载视图，应确保在视图初始化和加载完成后设置颜色。

:::

### ❓自定义导航跳转如何实现

::: details 💡

自定义导航跳转主要涉及两点，自定义动画及自定义转场方式。下面是实现过程:

1.定义一个类遵循 `UIViewControllerAnimatedTransitioning` 协议，编写自定义的动画逻辑。

代码示例:
```swift 
class CustomTransition: NSObject, UIViewControllerAnimatedTransitioning {
    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
        return 1.0 // 返回动画时长
    }
    
    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
        // 这里编写你的动画逻辑
        
        // 获取到待呈现的视图
        if let toView = transitionContext.view(forKey: .to) {
            // 添加到容器视图中
            transitionContext.containerView.addSubview(toView)
            
            // 编写动画逻辑, 以下是一个简单的淡入淡出动画
            toView.alpha = 0.0
            UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: { 
                toView.alpha = 1.0
            }) { (_) in
                // 动画结束时，一定要调用 completeTransition 方法
                transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
            }
        }
    }
}
```

2. 在视图控制器中指定转场代理，并在代理方法中返回自定义的转场动画对象。

代码示例:
```swift
class ViewController: UIViewController, UINavigationControllerDelegate {
    let customTransition = CustomTransition()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // 指定代理
        navigationController.delegate = self
    }
    
    func navigationController(_ navigationController: UINavigationController,
                              animationControllerFor operation: UINavigationController.Operation,
                              from fromVC: UIViewController,
                              to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return customTransition
    }
}
```
注意：记住要在准备要使用自定义转场的控制器里指定代理，并返回你的自定义动画。

以上就实现了自定义导航栏跳转动画。

:::

------

## UIView

### ❓`UIView` & `CALayer` 是什么关系？ 

::: details

每个`UIView`都有一个对应的`CALayer`，称之为 `UIView` 的 backing layer（背部层）。`UIView` 和 `CALayer` 之间是互相关联的，`UIView` 负责处理触摸事件，而 `CALayer` 负责显示视图的内容。

- `UIView`：视图的基类，负责处理用户交互（例如触摸事件），也负责管理子视图（包括添加、删除、遍历子视图）。可以使用 `UIView` 的子类（如`UILabel`，`UIButton`等）创建特定的用户界面，也可以创建自定义视图来绘制复杂的界面。

- `CALayer`：是核心动画库(`Core Animation`)中的类，它负责呈现视图的内容。`UIView` 将很多渲染任务委派给 `CALayer`，例如视图的边框、圆角、阴影、图片等都是由 `CALayer` 来绘制和渲染的。此外 `CALayer` 还负责处理动画效果。

:::

> 为什么要这样设计？

::: details

  这是由于iOS系统的历史原因。在早期的iOS版本中，只有 `CALayer`，并没有 `UIView`，所有的界面渲染和动画都需要通过手动控制 `CALayer` 来完成。
  
  后来，苹果引入了 `UIView`，用以简化界面的创建和管理，并将一些低层的渲染和动画任务委派给 `CALayer`。
  
  这样的设计使得开发者可以更高效地创建和管理用户界面，同时也保持了对底层渲染和动画的高级控制能力。

:::

### ❓`UIControl` vs `UIResponder`

::: details 💡

UIControl 和 UIResponder 都是 iOS 中UIKit框架的一部分。它们之间的大致关系是 UIControl 继承自UIView，而UIView又继承自 UIResponder，这说明 UIControl 和 UIView 都是 UIResponder。

- UIResponder 是处理和响应事件的基类，它定义了接收和处理事件的接口。实际上，UIApplication、UIView和UIViewController 都是继承自 UIResponder，都可以响应并处理事件。例如当一个触摸事件发生时，iOS会把事件交给最先接触到的 UIView （也就是被用户触摸的那个），然后沿着响应链向上分发，直到有 UIResponder 子类处理这个事件。

- UIControl 是继承自 UIView，并且添加了一些控制特性的类，用于响应用户交互。UIControl 提供了一种机制，允许你在特定事件发生时发送消息给指定的目标。比如UIButton、UISlider、UISwitch等都是 UIControl 的子类。你可以为这些子类设置 target-action 来响应用户的交互事件。

总体来说，UIResponder 负责处理事件，而 UIControl 在此基础上添加了更多用户交互的特性。

:::

### ❓`UIButton` 继承链

::: details 💡

> 继承链 : `UIButton` -> `UIControl` -> `UIView` -> `UIResponder` -> `NSObject`

1. `NSObject` 是所有 Objective-C 类的基类，提供了对象的基本行为特征和特性。

2. `UIResponder` 是 iOS 事件传递体系中的一个重要组成部分，此类提供了一种机制来处理和路由在应用程序中发生的触摸事件、手势识别、远程控制等事件。

3. `UIView` 是基本的展示视图和处理视图相关事件的类，几乎所有的 UI 元素都是直接或间接继承自 `UIView`，此类提供了一种机制以支持在其矩形区域内绘制、布局和处理事件。

4. `UIControl` 是 `UIView` 的一个直接子类，是一些具有目标-动作机制的 UI 元素的基类，比如按钮(`UIButton`)、滑块(`UISlider`)等，能够响应用户的交互行为并向感兴趣的目标发送讯息。

5. `UIButton` 是 `UIControl` 的一个子类，主要用来制作按钮。它在父类 `UIControl` 的基础上又添加了一些按钮特有的行为，比如按钮的标题、图片等。

:::

### ❓根据 `UIControl` 实现 `UIButton`

```swift
protocol ButtonProtocol {
    func setTitle(_ title: String);
    func setTitleColor(_ titleColor: UIColor);
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets);
    func setImage(_ image: UIImage);
    func setBackgroundImage(_ image: UIImage);
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets);
}

class MyButton: UIControl, ButtonProtocol { 
    // todo
}
```

::: details

在实现 `UIButton` 的同时，我们不能忘记，`UIButton`本质上是一个视图（对象），因此它应该包含一些像视图、标签、图片视图等子视图。在您的实例中，看起来要求 `MyButton` 能够具有设置标题、标题颜色、标题边距、题图像、背景图像以及图像边距的能力。那么，带着这些需求，我们来实现一下：

```swift
class MyButton: UIControl, ButtonProtocol {
    
    let titleLabel: UILabel = {
        let label = UILabel()
        label.textAlignment = .center
        return label
    }()
    
    let imageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    let backgroundImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleToFill
        return imageView
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.addSubview(backgroundImageView)
        self.addSubview(imageView)
        self.addSubview(titleLabel)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        backgroundImageView.frame = self.bounds
    }
    
    func setTitle(_ title: String){
        titleLabel.text = title
    }
    
    func setTitleColor(_ titleColor: UIColor) {
        titleLabel.textColor = titleColor
    }
    
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets){
        titleLabel.frame = self.bounds.inset(by: edgeInsets)
    }
    
    func setImage(_ image: UIImage) {
        imageView.image = image
    }
    
    func setBackgroundImage(_ image: UIImage) {
        backgroundImageView.image = image
    }
    
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets) {
        imageView.frame = self.bounds.inset(by: edgeInsets)
    }
    
}
```

- 为了处理背景图像，标题和图像，我们需要三个子视图：一个背景图像视图、一个图像视图和一个标签。
- `setTitleEdgeInsets` 和 `setImageEdgeInsets` 方法只需要调整 titleLabel 和 imageView 的 frame 即可。
- 别忘了在 `layoutSubviews()` 中设置 `backgroundImageView` 的 frame，以保证其总是充满整个视图。

当然，请注意，“实现 `UIButton`”需要更多的特性和设置，例如处理高亮状态和禁用状态，添加点击事件等。这里仅仅是一个简单的示例，按照特定需求，可以进行进一步的扩展和完善。

:::

------

## 布局

### ❓`viewWillLayoutSubView` 的作用

::: details 💡

`viewWillLayoutSubviews` 是 UIViewController 的一个生命周期方法，该方法在视图控制器的视图即将布局其子视图时被调用。这通常发生在视图的尺寸发生改变之后，例如设备的方向发生改变，或者视图被添加到父视图中并且父视图需要调整子视图的位置或大小。

在 `layoutSubviews` 之前调用 `viewWillLayoutSubviews`，因此这是在预计的布局之前，可以进行一些特定的设置或者变化。

注意，因为 `viewWillLayoutSubviews` 能被多次调用，因此需要避免在该方法中进行一些不必要的高开销计算或者更新操作。

`viewWillLayoutSubviews` 的主要用途之一是提供了一个时机，允许您在更改子视图的大小或位置之前进行一些额外的配置，也可以在此方法中进行一些必要的布局更新。

:::

### ❓`layoutSubviews` 那些情况下会触发

::: details 💡

  > `layoutSubviews` 在 iOS 的 UIView 的生命周期中，是负责布局及排版子视图的方法。

  - 在初始化 `UIView` 并添加到界面上时，系统会自动调用 `layoutSubviews` 方法进行子视图的布局。
  - 当 `UIView` 的 `bounds` 发生变化，如改变宽高、旋转设备时，系统会调用 `layoutSubviews`。
  - 当直接调用 `UIView` 的 `setNeedsLayout`或者 `layoutIfNeeded` 方法时，系统会调用 `layoutSubviews`。
    * `setNeedsLayout` 会标记当前视图被标记为需要重新布局，然后在接下来的更新周期中，调用 `layoutSubviews` 对标记进行重新布局
    * `layoutIfNeeded` 则会立即对视图进行重新布局，通常在动画的 `block` 内使用
  - 当视图的某个子视图的 `frame` 被显式地修改，也会触发父视图的 `layoutSubviews`。
  - 添加或者删除子视图的时候，也会触发父视图的 `layoutSubviews`。

:::

### ❓`drawRect` 有使用过吗，调用时机，会有性能影响吗

::: details 💡

`drawRect:` 是一个 `UIView` 类的方法，用于在视图的矩形区域进行绘制。如果你的自定义视图需要展示一些特殊的展示效果，比如绘制一些自定义的形状、渐变、阴影等，就可以重写这个方法完成这些绘制。

调用时机：

`drawRect:` 方法并不是时时刻刻都在调用，它的调用时机主要是视图第一次加载和视图的内容需要重绘时。也就是说当 `UIView` 准备好进行绘制操作的时候，系统会自动调用 `drawRect:` 方法。视图渲染的过程中可能会遇到以下两个方面的原因需要调用 `drawRect:`
1. 视图第一次出现在屏幕上时，会调用一次 `drawRect:` 方法进行视图的渲染。
2. 调用了 `setNeedsDisplay` 或者 `setNeedsDisplayInRect:` 方法后，系统会在下一个绘制周期中调用 `drawRect:` 方法进行视图的重绘。

性能影响：

由于 `drawRect:` 方法会占用大量 CPU 资源进行图形的绘制，因此过度使用或者不合理使用 `drawRect:` 方法会导致 CPU 使用率上升，从而影响应用的性能。为了避免性能问题，有以下几个注意事项：

- 避免在 `drawRect:` 方法中进行复杂的计算或者耗时的操作，这会降低绘制的效率。
- 不要主动直接调用 `drawRect:`，而是应当通过 `setNeedsDisplay` 或 `setNeedsDisplayInRect:` 让系统来决定何时调用 `drawRect:`。
- 如果可能，尽量减少绘制的区域。你可以通过 `setNeedsDisplayInRect:` 只重绘视图中改变的那部分区域，而不是整个视图。
- 考虑使用 Core Animation 或者直接操作 CALayer，而不是使用 `drawRect:`，以提高性能。因为 Core Animation 运行在专门的绘图线程，而不是主线程上，所以它的性能要优于 `drawRect:`。
- 如果视图是静态的，即一旦被绘制就不会改变，那么可以使用 `shouldRasterize` 属性来缓存视图的绘制结果，以提高性能。

:::

### ❓`layoutIfNeeded` vs `setNeedsLayout`

::: details 💡

`layoutIfNeeded` 和 `setNeedsLayout` 是 UIView 的两个方法，都涉及到视图的布局更新，但是使用场景和触发方式不同。

- `setNeedsLayout`: 这个方法被调用后，并不会立即触发重新布局。它标记了视图的布局需要更新，然后在下一次视图更新周期（通常是下一次 run loop），系统会自动调用 `layoutSubviews` 方法来进行实际的布局更新。如果期间多次调用 `setNeedsLayout`，实际上 `layoutSubviews` 只会被调用一次。

- `layoutIfNeeded`: 这个方法则会立刻触发视图的布局更新，调用这个方法后，系统会立即执行布局更新，包括调用 `layoutSubviews` 方法。这个方法通常用于需要立即更新视图布局的情况，比如在 UIView 的动画块中。

总的来说，`setNeedsLayout` 是标记需要重新布局，具体要等到下一个更新周期自动触发，而 `layoutIfNeeded` 则是立刻触发重新布局。

:::

### ❓`AutoLayout` 的原理，性能如何

::: details 💡

`AutoLayout` 的原理：

AutoLayout 通过制定一组约束来描述用户界面中的一些布局关系和尺寸属性。这些约束代表了视图与其他视图的相对位置关系、视图自身的尺寸以及视图的尺寸和父视图之间的相对关系等等。然后使用数学算法计算出满足所有约束条件下视图的最优位置和大小。

当屏幕尺寸、视图层次、约束条件以及设备方向等条件改变时，系统可以自动的通过算法重新计算并调整视图的位置和尺寸。因此，AutoLayout 提供了强大的工具，让开发者能够设计出能在各种尺寸和条件下都能良好显示的界面。

性能：

使用 AutoLayout 可以省去很多手动计算和调整布局的工作，大大提高了开发效率，同样在处理各种设备尺寸和方向变化时，可以保持良好的界面显示。

但是，AutoLayout 的性能并不总是最佳的。因为满足约束条件需要通过数学计算，并且复杂的界面和大量的约束可能使得这个计算过程变得复杂和耗时，特别是在一些动态改变约束和布局的情况下。

总的来说，AutoLayout 是一个功能强大，使用方便的布局工具，适合大多数情况下使用。但如果面临一些复杂和高效能需求的界面，可能需要考虑其他的布局方式，比如手动布局或使用第三方布局库。

:::

### ❓`Masonry` 的约束应该写在哪里

::: details 💡

`Masonry` 是一个轻量级的布局框架，采用链式编程的方式，让我们的 AutoLayout 使用变得更加简单。我们通常在初始化视图和更新视图布局的地方使用 `Masonry`。

在 UIKit 中，你可以把 `Masonry` 的约束写在以下地方：

1. 对于 `UIView`，你可以在初始化方法 `init` 或者 `initWithFrame:` 中设置约束。例如：

    ```objective-c
    - (instancetype)init {
        self = [super init];
        if (self) {
            [self setupViews];
            [self setupConstraints];
        }
        return self;
    }
    ```

    在 `setupViews` 方法中完成子视图的添加，在 `setupConstraints` 中设置 Masonry 的约束。

2. 对于 `UIViewController`，你可以在 `viewDidLoad` 方法中设置视图约束。例如：

    ```objective-c
    - (void)viewDidLoad {
        [super viewDidLoad];
        [self setupViews];
        [self setupConstraints];
    }
    ```

3. 如果你的视图布局会在运行时动态改变，那可以在 `updateViewConstraints` 方法中更新约束。例如：

    ```objective-c
    - (void)updateViewConstraints {
        [super updateViewConstraints];
        // 更新 Masonry 的约束
    }
    ```

不论在哪里设置约束，都必须确保在设置约束的时候，视图已经被添加到其父视图上，否则会导致约束无法正确设置。

总的来说，Masonry 的约束应该写在视图初始化或者布局更新的地方，确保视图已经被正确添加，并且在需要的时候可以更新约束。

:::

### ❓`sizeToFit`、`sizeThatFits` 了解吗

::: details 💡

`sizeToFit` 和 `sizeThatFits` 是 UIKit 中 UIView 的两个方法，涉及到视图的尺寸调整。

- `sizeToFit`：这是一个无参数的方法，调用这个方法会使得视图的 frame 变为能刚好包裹住它的子视图的大小。具体的行为依赖于视图的 `sizeThatFits:` 方法的实现。注意，这个方法并不会修改视图的位置，只会影响到视图的大小。

- `sizeThatFits:`：这个方法需要一个参数，表示期望的尺寸。然后这个方法返回一个适合视图及其子视图的大小。这个方法并不会改变视图的实际大小，需要调用者根据返回的大小来更新视图的 frame。

一般来说，视图的默认行为是返回一个等于当前视图大小或者等于传入参数的值，具体取决于子视图的要求。如果你的自定义视图有特殊的需求，你可以重写 `sizeThatFits:` 方法来实现特定的尺寸调整行为。

总的来说，`sizeToFit` 和 `sizeThatFits:` 都是用来调整视图尺寸的方法，但具体的行为取决于具体视图的 `sizeThatFits:` 的实现。

:::

### ❓`intrinsicContentSize` 使用过吗

::: details 💡

  `intrinsicContentSize` 是`UIView`的一个属性，它表示一个视图的自然大小或者说内在大小。举例来说，对于一个UILabel，它的`intrinsicContentSize`就是刚好能包裹住它所包含的文本的大小。

这个属性在使用`AutoLayout`进行布局的时候非常有用。一些需要根据内容自适应大小的控件，比如UILabel、UIButton等，都可以通过设置`intrinsicContentSize`来告诉布局系统它们需要的空间大小。

你可以通过重写这个属性的getter方法来提供自定义的大小。需要注意的是，当视图的内在内容改变，可能会影响到`intrinsicContentSize`时，你需要调用`invalidateIntrinsicContentSize`方法来通知布局系统`intrinsicContentSize`发生了变化，这样布局系统就会在下一个布局循环中重新计算布局。

总的来说，`intrinsicContentSize`是在使用AutoLayout进行布局时，用于表示视图自适应内容大小的一个重要属性。

:::

------

## 渲染

### ❓`iOS` 中界面渲染机制？

::: details 💡

iOS 的界面渲染机制涉及到的主要技术包括 Core Animation 和 OpenGL/ Metal。

1. Core Animation：是 Mac OS X 和 iOS 中用于实现图形渲染和动画的一种技术。它主要通过硬件加速来实现高效的绘图和动画效果。在 Core Animation 中，所有的界面元素都是呈现在一个叫做图层（layer）的概念上。每个 UIView 都有一个 CALayer 实例作为 backing layer，UIView 的内容和样式都是通过这个图层来显示的。

2. OpenGL/ Metal：OpenGL ES 是一个专门用于嵌入式系统（如智能手机或游戏机等）的 2D/3D 绘图 API，而 Metal 则是 Apple 的一种低层次、高效率的图形和计算技术。这些技术都是直接运行在 GPU 上，用于处理复杂且性能要求较高的图形计算和渲染。

在绘制一个 UIView 时，系统将按照以下步骤进行：

1. 创建一个 bitmap context。
2. UIView 会调用 `-drawRect:` 方法进行绘制操作（如果这个 UIView 重写了这个方法的话）。
3. 接下来会处理这个 UIView 的 subviews，将每个 subview 的内容递归的绘制到 bitmap context 中。
4. bitmap context 上的内容将会被复制到 backing layer 的寄宿图片上。
5. backing layer 和其他的图层一起被提交到 GPU 进行渲染。最后的渲染结果将会显示在屏幕上。

这个过程在每一帧都会执行，通常帧率为 60FPS，即每秒 60 次。如果在一帧的时间内（大约 16.7ms）无法完成渲染，就会出现丢帧的现象，导致用户界面卡顿。

所以在开发中，我们要尽可能地优化界面渲染，比如避免使用复杂的视图层级、避免在 `-drawRect:` 中做复杂的绘制操作、尽量使用合适的图层属性而不是自定义绘制等等，以提高界面的流畅度。

:::

### ❓`UI` 的渲染步骤？

::: details 💡

在 iOS 中，UI 的渲染步骤主要包括以下几个阶段：

1. **布局阶段**：在这个阶段，UIKit 会计算出所有的视图的大小和位置。这个过程涉及到 AutoLayout 和 Core Animation，视图的位置和大小会被更新，同时所有的视图约束也会得到满足。对于 UIView，这一步涉及到了 `layoutSubviews` 方法。

2. **显示阶段**：在这个阶段，所有需要的视图都会被调用 drawRect: 方法进行绘制。这里会调用 Core Graphics 来进行实际的绘制操作，在视图的 layer 上生成一张 bitmap 图片代表这个视图。

3. **准备阶段**：这一步主要是将所有的 Core Animation 动画提交给渲染服务器。

4. **渲染阶段**：
   - 这一步会进行事务的提交，所有的 layer tree 结构会在主线程中拷贝一份到渲染线程。
   - 然后，渲染线程会将视图的 layer tree 全部转换为 OpenGL 命令或者 Metal 命令，最后将其提交给 GPU。
   - GPU 会进行实际的绘制操作，包括光栅化、混合等步骤，最后将渲染结果显示到屏幕上。
   
在整个渲染过程中，对 CPU 和 GPU 的使用是需要权衡的。对于由 CPU 进行的布局和显示工作，如果过于复杂，可能导致帧率下降，因为 CPU 无法在每帧刷新的时间限制内完成所有工作。对于 GPU 来说，过于复杂的渲染操作也可能导致性能问题，比如复杂的渲染效果或者过深的视图层次都可能导致 GPU 无法及时完成渲染。

总结一下，UIKit 布局 => Display => Prepare => Core Animation 提交事务 => GPU 渲染。整个过程如果在 16.7ms 之内完成，就能保证界面动画的流畅性。如果超过这个时间，就会出现丢帧卡顿现象。所以在开发中要尽量优化布局和渲染过程，避免过于复杂的操作。

:::

### ❓视图打包流程？

::: details 💡

“视图打包流程”一词也许不太常见，但它通常被用来解释在UIKit和Core Animation框架中试图在屏幕上显示视图时的一系列操作。流程主要包括以下步骤：

1. **布局**：首先，应用程序需要确定视图的位置和大小。它可以使用Auto Layout约束，或者开发人员可以通过编写代码来手动设置frame和bounds值。

2. **绘图**：在布局完成后，接下来就需要将视图绘制到bitmap中。这是通过调用每个view的drawRect方法完成的。此步骤产生一个bitmap，之后将被赋值给视图的layer。

3. **合成**：一旦所有的视图都被绘制到bitmap中，下一步就是将这些单独的视图合成为一张完整的、包含所有视图的图像。这个步骤称为图层树的合成，由Core Animation的图层树管理。

4. **渲染**：最后，完整的图像将会被发送到渲染服务器进行渲染。此过程会在GPU上进行，将bitmap图像转化为可以在设备屏幕上显示的像素。完成这个步骤后，用户就可以在设备上看到这个视图了。

这个过程在每一次屏幕刷新时，比如60FPS的情况下的每一帧，都会执行一次。如果任何步骤无法在一帧的时间里完成，这就会导致屏幕刷新速度下降，用户可能会看到卡顿或者掉帧现象。因此，对布局和绘制代码进行优化以减少他们的执行时间是非常重要的。

:::

### ❓什么是屏幕渲染？

::: details 💡

  | 渲染类型 | 说明
  | --- | ---
  | CPU 渲染 | 简单视图 CPU 渲染可能高于 GPU (不需要创建缓冲区和上下文切换)
  | GPU 渲染 | GPU 浮点运算能力强于 CPU，所以 GPU 渲染效率高于 CPU

  * **屏幕渲染**(On-Screen Rendering) : 在当前屏幕的缓冲区进行渲染。优点：不需要创建新的缓存，也不需要进行上下文切换，性能较好；缺点：缓存大小受限制，无法进行复杂的操作。
  * **离屏渲染**(Off-Screen Rendering) : GPU 在当前屏幕外，新开辟了一个缓冲区进行图片的渲染和合成。渲染完成之后再放入当前屏幕的缓冲区。这个过程需要 CPU 调度，将任务分配给 GPU 进行渲染然后再将渲染结果返回，需要进行上下文切换和内存读写等操作，对性能影响较大。
  
:::
  
### ❓哪些场景可以触发离屏渲染？
  
::: details 💡

  离屏渲染的意思是，图形或文字无法在当前屏幕缓冲区完成渲染，需要额外创建一个图形缓冲区进行操作，完成后再加载到当前屏幕缓冲区显示。

  `iOS` 以下几种场景会触发离屏渲染：

  - 使用阴影效果：如果给 `UIView` 添加阴影效果，会触发离屏渲染。如果可以的话，使用 `shadowPath` 来指定阴影路径，可以避免离屏渲染。
    > `layer.shadowXXX`
   
  - 使用圆角效果：对 `UIView` 的图层进行圆角裁剪(`cornerRadius`)时，如果同时设置了 `masksToBounds` 也会触发离屏渲染。
    > `layer.masksToBounds = true & layer.cornerRadius > 0`
   
  - 使用遮罩(mask)：`CALayer` 的 `mask` 属性可以设置遮罩，给视图层添加遮罩也会触发离屏渲染。
    > `layer.mask`
   
  - 使用光栅化：`shouldRasterize` 属性可以将图层缓存为位图并在 `GPU` 中重用，但这同时也会触发离屏渲染。
    > `layer.shouldRasterize = true`
   
  - 抗锯齿：设置视图的 `layer` 的 `allowsEdgeAntialiasing` 属性为 `true` 会触发离屏渲染。因为抗锯齿需要对视图的边缘像素进行额外的计算和混合，这些操作不能在当前屏幕的缓冲区完成，因此需要离屏渲染。所以，在大部分情况下，如果不是对视觉效果有非常高要求，通常不推荐开启抗锯齿，因为这会增加GPU压力，降低性能。
    > `layer.allowsEdgeAntialiasing = true`

  - 不透明度：设置视图的 `alpha` 值本身不会触发离屏渲染。但是有一种场景需要注意，那就是对有子视图的视图设置 `alpha` 值，并且该视图的 `opaque` 属性为 `true` 时，可能会造成额外的离屏渲染。这是因为系统需要先单独绘制这个视图和它的子视图到一个临时的缓冲区，然后将这个临时的缓冲区以指定的 `alpha` 值（也就是透明度）绘制到屏幕上。因此，为了避免这种离屏渲染，当你需要设置视图的`alpha` 值时，应该设置它的 `opaque` 属性为 `false`。
    > `opacity & opaque = true`

  离屏渲染对系统资源消耗比较大，因为它需要创建新的缓冲区，进行上下文切换，最后再把缓冲区的内容载入到屏幕缓冲区。如果在一个视图中使用过多的离屏渲染，可能会导致性能问题，所以在开发过程中需要尽量避免触发离屏渲染。

:::

------

## 图片

### ❓`imageName` vs `imageWithContentsOfFile`

::: details 💡

`UIImage` 的 `imageName:` 和 `imageWithContentsOfFile:` 是两种不同的方法，用于从应用的bundle中加载图片。这两个方法在使用上有许多区别。

- `imageName:` 方法是用于从应用的主bundle中加载图片的，它会自动根据设备的屏幕类型（比如，Retina屏幕）来选择合适的图片（比如，自动选择@2x和@3x的图片）。这个方法也会自动地对加载的图片进行缓存，所以如果你使用该方法多次加载同一张图片，实际上只会加载一次，剩下的调用会直接从缓存中获取图片。这就意味着这个方法在加载大量重复图片时，处理速度会很快。

- `imageWithContentsOfFile:` 方法则是直接从指定的文件路径中加载图片，它并不会根据屏幕类型来自动选择图片，也不会对加载的图片进行缓存。意味着每次调用这个方法时，系统都会从磁盘中读取图片数据，这可能会花费更多的时间。如果你想要加载一次性使用并且不需要缓存的大图片，这个方法可能会更适合。

总的来说，`imageName:` 更适合用来加载经常使用的小图片，而 `imageWithContentsOfFile:` 则更适合加载一次性使用的大图片。

:::

### ❓多个相同的图片，会重复加载吗

::: details 💡

如果你使用`UIImage`的`init(named:)`或`imageNamed:`方法来创建一个图片对象，这个方法会先在缓存中查找是否已经存在相同的图片。如果缓存中存在，那么就会直接从缓存中返回，而不会重新加载。因此，这个方法在加载相同图片时不需要加载多次，会直接从缓存中读取，性能更好。

但是，如果你使用`UIImage`的`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法来加载图片，那么每次调用都会从文件中重新读取，即使在前面已经加载过同一个文件的图片。这是因为这种方法不会使用系统的图片缓存。

因此，如果你有多个相同的图片需要加载，且这些图片会频繁使用，那么推荐使用`init(named:)`或`imageNamed:`方法，利用系统的缓存机制，避免重复加载图片，提升性能。如果你的图片仅用一次，或者图片文件非常大，不适合放入缓存，那么可以考虑使用`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法。

:::

### ❓如何高性能的给 `UIImageView` 加圆角

::: details 💡

给UIImageView添加圆角有多种方式，但并非所有方法都是高效的。一些常见的方式可能会引入性能问题，例如直接修改视图的.layer.cornerRadius属性，因为这会导致离屏渲染，影响到性能。

以下是一种高效的给UIImageView添加圆角的方法，该方法使用了Core Graphics框架：

1. 首先，确定好圆角半径。

2. 创建一个CGRect，其尺寸与UIImageView的frame匹配。

3. 创建一个CGMutablePath，并将该路径添加到一个CAShapeLayer。

4. 将这个CAShapeLayer设置为UIImageView的遮罩层。

以下是Swift代码的例子：

```swift
let imageView = UIImageView(image: UIImage(named: "example"))
let radius: CGFloat = 10.0

let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: imageView.frame.size)
let path = UIBezierPath(roundedRect: rect, cornerRadius: radius)

let maskLayer = CAShapeLayer()
maskLayer.path = path.cgPath

imageView.layer.mask = maskLayer
```

这种方式不会导致离屏渲染，只会在合成阶段发生，因此比直接修改视图的 `.layer.cornerRadius` 属性更为高效。

:::

### ❓`UITableView` 中的图片加载逻辑

::: details 💡

在`UITableView`中加载图片是一个常见的需求，但如果处理不当，可能会导致性能问题。以下是一种标准的、高效的图片加载逻辑：

1. **异步获取**：图片获取过程需要在后台线程中进行，避免阻塞主线程。对于网络图片，可以使用如SDWebImage等优秀的图片加载库来进行异步图片下载和缓存。

2. **复用Cell**：在`UITableView`中，由于Cell的复用机制，在`tableView(_:cellForRowAt:)`方法中设置图片时，必须确保你设置的图片是当前IndexPath的图片。

3. **占位图**：在加载图片时，先显示一个占位图，等图片加载完成后再替换。这样能够避免出现空白。

4. **取消无效加载**：在复用Cell的情况下，由于滚动速度快，当前行已经滚出屏幕，但此时图片可能刚下载好，这时候如果还进行赋值，就会出现图片错位。所以我们需要对图片的设置增加有效性验证，验证当前Cell对应的IndexPath是否已经变化。

例如，使用SDWebImage在Swift中实现如下：

```swift
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    let cell = tableView.dequeueReusableCell(withIdentifier: "CellId", for: indexPath) as! CustomCell
    
    let imageUrl = imageUrls[indexPath.row] // imageUrls是放置图片URL的数组
    cell.imageView.sd_setImage(with: URL(string: imageUrl), placeholderImage: UIImage(named: "placeholder"))
    
    return cell
}
```

注意：这种方式适用于图片数量不是太多（比如几百张以内）的情况。如果你的表格视图需要显示大量的图片，你可能需要实现更复杂的图片管理方案，例如预加载、图片解压缩、离屏渲染优化等。

:::

### ❓`bitmap` 的结构

::: details 💡

位图（Bitmap）是一种将图像根据每个像素点分别存储和表示的方式。位图由许多称为像素的矩阵组成，每个像素表示一个点的颜色。

一个Bitmap的基本组成结构包括：

1. 位图文件头（Bitmap File Header）：包含位图文件的类型、大小和处理方式的信息。
2. 位图信息头（Bitmap Information Header）：包含位图的尺寸、颜色、压缩方式等图像的详细信息。
3. 颜色表（Color Table）：包含整个图像可能使用的所有颜色信息。
4. 像素数据（Pixel Data）：真正的位图数据，记录了位图中每一个像素的颜色信息。

我们是按位图文件头、位图信息头、颜色表的顺序来一一存储的，而像素数据中每个像素的总位数决定了图像可以显示的颜色数目，也被称为“色深”（Color depth）。例如色深为24的图像（也就是24位图像），每个像素用24位存储，可以显示大约1,677万种颜色。

Bitmap有着良好的图像效果和兼容性，但与矢量图形相比，其缺点是文件相对较大，且如果将位图进行放大操作，可能会出现失真和马赛克现象。

:::

### ❓图片是什么时候解码的，如何优化

::: details 💡

在iOS中，当图片被显示在屏幕上时，图片的解码操作通常是在渲染前由`GPU`进行的。然后，解码后的位图像素被存储在内存中，用于显示。此过程可能会对性能产生影响，尤其是在滚动动画或切换动画等场景中。

如果希望优化图片解码，有一种常用的方法是对图片进行预解码。预解码是在主线程渲染前，提前在后台线程将图片解码，而不是等待`GPU` 在显示的时候进行解码。在其进行解码的过程中，CPU的压力会提高，但同时可以降低GPU负载，避免在渲染过程中进行解码导致的帧数下降。

在Objective-C和Swift中，可以通过使用Core Graphics 的API来对图片进行预解码。具体过程是使用`CGImage`创建一个`CGBitmapContext`，然后将图片绘制到这个context中。这样，当图片第一次显示在屏幕上时，就无需再进行解码操作。

预解码的代码可能如下（Swift）：

```swift
func predecode(image originalImage: UIImage) -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(originalImage.size, true, originalImage.scale)
    guard let context = UIGraphicsGetCurrentContext() else { return nil }
    originalImage.draw(at: .zero)
    let decodedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decodedImage
}
```

由于预解码会增加CPU压力和内存消耗，所以需要在合适的时机进行，比如在后台线程，用户滚动列表的滑动减速或者停止的时候，或者在图片将要显示之前的闲暇时间。务必要避免在用户滑动列表的过程中进行预解码，因为这个时候进行预解码可能会导致卡顿。另外，过多的预解码也可能导致内存暴涨，所以需要权衡当下的需求和设备性能。

:::

### ❓图片渲染怎么优化

::: details 💡

优化图片渲染是一门科学，下面有几点常见的优化技巧：

1. **图片大小适配**：尽量保持加载的图片大小接近于它在设备屏幕上的显示大小。如果一个很小的`UIImageView`需要显示一个非常大的图片，那么这张图片在显示之前需要被缩放。如果图片实际尺寸过大，会导致额外的内存使用和解压缩成本。

2. **图片预解码**：图片在渲染到屏幕之前，需要被解码成位图。这个操作会在图片第一次显示时进行，并且可能会产生一定的性能消耗。可以通过预解码（在后台线程提前进行解码）的方式把这个消耗提前。

3. **使用正确的图片格式**：不同的图片格式有不同的解压缩性能。例如，对于静态图片，PNG和JPEG是常见的格式。通常，JPEG格式的图片解压缩速度会比PNG 快，但是PNG对透明度的支持更好。

4. **避免透明像素**：如果一张图片包含透明像素，那么在混合像素时GPU负担会更重。如果你的图片不需要透明度，最好选择不带alpha通道的图片格式，如JPG。

5. **后台线程加载和准备图片**：为了避免阻塞主线程，一定要在后台线程进行图片的加载、解压缩和其他准备工作。

6. **利用图片缓存**：频繁地从磁盘加载图像是一种昂贵的操作。使用图片缓存可以避免频繁地加载同一张图片。

7. **合理设置图片分辨率**：@2x 和 @3x 的图片分辨率分别是原始尺寸的2倍和3倍，根据设备屏幕的特性选择合理的图片分辨率，避免不必要的内存消耗。

以上的一些诀窍可以根据具体情况灵活运用，优化图片的加载和渲染。

:::

### ❓图片怎么显示的，以及图片缓冲区

::: details 💡

图片在屏幕上显示的流程主要经过以下步骤：

1. **加载**：首先从磁盘或网络上将二进制数据加载入内存，这些二进制数据描述了图像信息。

2. **解码**：加载完毕后，图像会被解码成位图（bitmap）。位图是一种非常详细的矩阵，其中每个单元（像素）记录了在对应位置的颜色信息。因此，位图的大小通常比原始的图像文件要大。

3. **渲染**：渲染图片就是将位图中的每个像素翻译成屏幕上的每个点，这个过程通常由GPU（图形处理器）完成。

至于图片缓冲区，通常我们会通过一些图像库（如SDWebImage）的帮助，将常用图片保存在内存中以备快速访问。这就是所谓的图片缓冲区，也叫做图片缓存。

图片缓存的目的是提高性能和减少网络或磁盘I/O的使用。当应用程序需要显示一张图片时，它首先查看缓存，如果缓存中有这张图片，就直接用缓存中的图片，避免了从网络或磁盘上加载。如果缓存中没有，就必须从网络或磁盘加载，加载后的图片会被保存到缓存中，以便下次使用。

请注意，任何缓存策略都需要考虑内存使用和过期策略。缓存太多图片会消耗大量内存，可能影响应用程序的性能或触发内存警告。同时，缓存中的图片可能会过时，应定期清除不再需要的图片。

:::

### ❓如何用 `UIImageView` 显示超大分辨率的图，如何支持缩放

::: details 💡

`UIKit` 提供了一个叫做 `UIScrollView` 的组件，它支持在iOS设备上进行滚动和缩放操作。如果我们希望显示一张大图并支持缩放，应该把 `UIImageView` 作为 `UIScrollView` 的子视图。以下是一个简单的例子：

```swift
class ViewController: UIViewController, UIScrollViewDelegate {
    var imageView: UIImageView!
    var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        // 创建一个 UIScrollView 实例
        scrollView = UIScrollView(frame: view.bounds)
        // 设定 zoom 缩放的最小\最大倍数
        scrollView.minimumZoomScale = 1.0
        scrollView.maximumZoomScale = 6.0

        // 加载一张大图(up to you)
        let image = UIImage(named: "LargeImageName")    
        imageView = UIImageView(image: image)
        imageView.frame = CGRect(x: 0, y: 0, width: image?.size.width ?? 0, height: image?.size.height ?? 0)
        
        //将 ImageView 添加到 ScrollView 中 
        scrollView.addSubview(imageView)
        scrollView.contentSize = imageView.bounds.size
        
        //设置代理
        scrollView.delegate = self

        //添加 ScrollView 到主视图中
        view.addSubview(scrollView)
    }

    func viewForZooming(in scrollView: UIScrollView) -> UIView? {
        return imageView
    }  
}  
```

在以上代码中，在启动的时候我们初始化一个 UIScrollView 并设定其最大和最小缩放比例。然后，我们加载那张大图，创建UIImageView实例并把它放到UIScrollView的视图中。在用户使用手势进行缩放操作的时候，UIScrollView就会通知代理（delegate）来进行缩放操作。在这种情况下，代理就是我们这个 ViewController 实例。

然后，我们需要实现 UIScrollViewDelegate方法 viewForZooming(in:)，当 UIScrollView需要知道应该缩放或滚动哪个视图的时候，就会调用这个方法。在这个方法中我们返回 UIImageView。这样，用户就可以通过平移、捏合手势来滚动和缩放图片了。

这个方法虽然在大部分情况下可以工作，但是对于极其大的图片还是可能有内存问题。如需处理这种情况，可能需要使用像 CATiledLayer 这样的技术，它可以分块渲染视图，而不是一次性渲染整个大图。但这将会涉及更多复杂的编程技术。

:::

### ❓如何将一张内存极大的图片可以像地图一样的加载出来

::: details 💡

处理极大图片（比如说地图）时，加载整张大图到内存通常是不可行的，因为将会占用太大内存，而手机设备的内存是有限的。为了处理这个问题，通常的做法是分块加载和显示图片——只把当前需要显示在屏幕上的那一部分加载到内存。当用户滚动或缩放图片时，就加载新的部分，同时释放不再需要的部分。这就是所谓的 "切片"（tiling）技术。

在iOS中，你可以使用`CATiledLayer`来实现图片的切片加载。`CATiledLayer`是一种特殊的`CALayer`，它将内容分成多个小的矩形块或"切片"，并且只在需要的时候绘制这些切片。当提供内容时，你只需画出指定的矩形区域即可，其它区域则由Core Animation自动处理。此外，`CATiledLayer`甚至支持多级别的细节，这使得你可以非常容易地实现复杂的地图或图片浏览器功能。

要注意的是，`CATiledLayer`的使用相对复杂，它需要你自己管理图片资源并根据需要进行绘制。不过，也有许多库（比如MapKit）或者教程可以帮助你开始。

另外，一些图片浏览器库，如FastImageCache，也可以处理大图，它实现了自己的切片和缓存机制。

无论你选择哪种方式，都应注意内存管理，并合理地在需要的时候清理不再需要的资源。

:::

------

## 动画

### ❓`UIKit Animation` vs `Core Animation`

::: details 💡

`UIKit Animation` 和 `Core Animation` 都是iOS框架的一部分，用于动画效果，但他们的主要用途和使用的方式是不同的。

**UIKit Animation**:
UIKit Animation 是在一个更高的抽象层进行编程操作。您可以简单的使用 UIView 类的动画方法，如 `UIView.animate(withDuration:animations:)`，轻松实现许多动画，如移动、旋转、改变透明度、改变颜色等。以下是一个简单的例子，将一个视图在2秒内从屏幕左边移到右边：

```swift
UIView.animate(withDuration: 2) {
    view.frame.origin.x = self.view.frame.width - view.frame.width
}
```
UIKit动画编写简单，且支持很多常见效果。但如果需要更复杂的动画效果，可能就需要使用CoreAnimation了。

**Core Animation**:
Core Animation提供了更底层和更强大的动画控制。与UIKit动画相比，它可以实现更复杂的动画，如复杂的转换，3D效果，关键帧动画等。例如，以下是一个使用CoreAnimation创建关键帧动画的代码：

```swift
// 创建一个CAKeyframeAnimation实例
let animation = CAKeyframeAnimation(keyPath: "position")

//设置关键帧
animation.values = [NSValue(cgPoint: CGPoint(x: 50, y: 50)),
                    NSValue(cgPoint: CGPoint(x: 100, y: 100)),
                    NSValue(cgPoint: CGPoint(x: 50, y: 150))]

// 动画时间
animation.duration = 2

// 将动画添加到视图层
view.layer.add(animation, forKey: nil)
```
这个动画会使视图在2秒内沿着预定的路径移动.

总的来说，对于大多数简单场景，UIKit动画已经足够用了。但是对于复杂动画，或者需要更精确地控制动画时序和动画过程的情况，CoreAnimation会是一个更好的选择。

:::

### ❓`UIKit Animation` vs `UI Dynamics`

::: details 💡

`UIKit Animation`和`UI Dynamics`都是在UIKit框架中创建动画的两种主要技术，但它们的使用场景和工作原理是不一样的。

**UIKit Animation**
UIKit Animation主要用于创建简单，直观和以时间为基础的动画。例如，如果你想在2秒内移动一个视图从A点到B点或改变视图的大小，颜色等，那么UIKit动画就非常适合。此外，它提供的API也相对简单，轻松上手。

```swift
UIView.animate(withDuration: 1) {
    view.backgroundColor = .blue
    view.frame.size = CGSize(width: 100, height: 100)
}
```
以上的动画会在1秒内改变视图的背景颜色和大小。

**UI Dynamics**
另一方面，UI Dynamics提供了一种创建物理基础的模拟动画的方法。这意味着你可以为视图创建如弹力，碰撞，重力这样的物理特性的动画。当你希望你的视图的动画看起来“感觉像现实世界中的物体那样移动”，那么UI Dynamics是你的好选择。

例如，下面是一个创建重力行为的代码片段：

```swift
let gravity = UIGravityBehavior(items: [myView])
animator = UIDynamicAnimator(referenceView: view)
animator.addBehavior(gravity)
```
在以上的例子中，我们创建了一个`UIGravityBehavior` ，并将其添加到`UIDynamicAnimator`中，myView视图会根据重力方向进行动画模拟。

总的来说，如果你正在寻找创建物理模拟动画，UI Dynamics是一个非常强大的工具。如果只是需要基本的时间驱动动画，UIKit Animation就已经足够了。

:::

### ❓隐式动画 vs 显示动画

::: details 💡

隐式动画和显示动画是在Core Animation框架中用来描述动画类型的两个术语。

**隐式动画**
在Core Animation中，隐式动画是默认的动画类型。当修改CALayer的可动画属性时，系统会自动创建并运行动画——这就是所谓的隐式动画。例如，我们可以简单地修改一个图层的位置或背景颜色，Core Animation会自动为这个改变创建并应用动画：

```swift
layer.position = CGPoint(x: 200, y: 200)
```

在上面的代码示例中，图层的位置会以动画的形式移动到新位置，而不是立即跳到那里。

**显示动画**
与隐式动画相比，显示动画需要明确地创建一个CAAnimation对象，设置它的属性，然后将它添加到图层。显示动画给了开发者对动画行为更精细的控制，包括动画的时间线和动画的进度曲线等。例如，以下代码展示了如何创建一个显示动画来修改图层的位置：

```swift
let animation = CABasicAnimation(keyPath: "position")
animation.fromValue = NSValue(cgPoint: CGPoint(x: 100, y: 100))
animation.toValue = NSValue(cgPoint: CGPoint(x: 200, y: 200))
animation.duration = 1
layer.add(animation, forKey: nil)
```

这个动画会在1秒内将图层的位置从(100, 100)移动到(200, 200)。

总的来说，隐式动画适用于简单和常规的动画，而显示动画则适用于需要更复杂和定制的动画效果的情况。

:::

### ❓做一些基于 `CALayer` 的动画时，有时需要设置 `layer` 的锚点来配合动画，需要注意什么

::: details 💡

CALayer的锚点或`anchorPoint`属性决定了图层的哪一点会被放在`position`所指的位置，也就是图层的旋转，缩放等变换动画都是围绕这个点进行的。其默认值为(0.5, 0.5)，代表图层的中心点。

当我们需要修改锚点时，需要注意以下几点：

1. **位置变化**：锚点的改变会导致图层的位置移动，因为系统会自动将图层的anchorPoint放到图层的position所指的位置。因此，当你改变锚点时，可能会看到图层“跳跃”到新位置。如果你不希望图层移动，那么就需要在改变anchorPoint后，相应地调整图层的position。

    ```swift
    layer.anchorPoint = CGPoint(x: 0, y: 0)  
    layer.position = CGPoint(x: 0, y: 0)
    ```
   
2. **布局影响**：如果有基于图层的`Auto Layout`约束，改变`anchorPoint`可能会破坏这些约束。
   
3. **动画影响**：由于图层的旋转，缩放等变化动画都是围绕`anchorPoint`进行的，修改此点也会影响这些动画的表现。

4. **几何形状**：需要注意的是，`anchorPoint`的值的范围是在[0,1]之间，表示在图层的大小中的相对位置，而不是具体的像素点。

总的来说，在修改图层的`anchorPoint`时，最佳做法是首先考虑将会产生哪些影响，然后适当调整图层的位置或者其他属性，以符合你的期待。

:::

### ❓`Core Animation` 的实现原理

::: details 💡

Core Animation的实现原理非常复杂，但基本概念并不难理解。

在iOS的绘图体系中，每个UIView都对应的有一个CALayer对象（称为 backing layer或层），UIView负责处理用户的交互，而CALayer负责处理内容的绘制和动画。实际上，当你移动、旋转或改变UIView的其他属性时，你实际上是在操作它对应的CALayer。

Core Animation的工作原理基于一个重要的假设：像素在一帧到下一帧之间不会改变。为了提高性能，Core Animation使用了一种称为“图层树”的数据结构。图层树是由多个CALayer对象组成的层次结构，每个CALayer都包含一个位图，该图包含了其对应的UIView的内容，你的所有UIView的内容在内存中都有一份映射，这就是它的位图。当一个动画开始时，Core Animation会在动画的每一帧利用之前的位图，并应用变换矩阵，生成动画过程中的每一帧的图像，然后发送到GPU进行渲染。

Core Animation还使用了许多优化技术来提高性能，例如硬件加速，这是因为GPU在位图合成和插值计算上非常擅长；后台线程渲染，这允许CPU在动画执行时继续进行其他工作。

总的来说，Core Animation的实现原理主要基于图层树，位图和GPU硬件加速。所有的动画，并不是实时计算和渲染的，而是预先生成好的位图，通过GPU渲染出动画效果，所以能够高效且流畅地运行。

:::

### ❓`Core Animation` 实现交互效果(比如让动画播放一半, 点击让它停止)

::: details 💡

要使用Core Animation来实现交互（如在动画过程中点击停止），我们需要访问和控制当前正在进行的动画。以下是一个示例，说明了如何使用CAAnimation和CALayer的presentationLayer属性来暂停和恢复动画：

```swift
var isPaused = false  // 用于追踪动画是否已暂停

func toggleAnimation() {
    let layer = self.myView.layer
    if isPaused {
        // 恢复动画
        let pausedTime = layer.timeOffset
        layer.speed = 1.0
        layer.timeOffset = 0.0
        layer.beginTime = 0.0
        let timeSincePause = layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime
        layer.beginTime = timeSincePause
    } else {
        // 暂停动画
        let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)
        layer.speed = 0.0
        layer.timeOffset = pausedTime
    }
    isPaused = !isPaused
}
```

在上面的代码中，我们使用了CALayer的timeOffset和speed属性来暂停和恢复动画。当speed为0时，动画将停止；将timeOffset设置为当前的媒体时间将“定格”动画在当前帧。要恢复动画，我们将speed重置为1，并调整beginTime以跳过我们暂停时的时间。

要在动画进行时点击停止，你只需要在相应的手势识别器或touch事件处理方法中调用此toggleAnimation()方法即可。

:::

------

## 事件分发

### ❓响应者链条，一个视图不响应的原因

::: details 💡

响应者链条（Responder Chain）是 iOS 中用来处理界面的 touch、motion、键盘事件的机制。每个事件有一个接收者，叫做第一响应者 (First Responder)，由 UIApplication 管理。如果该对象不能处理这个事件，那么它会沿着响应者链向上查找可以处理这个事件的响应者。

一个 UIView 可能在以下情形中无法响应事件：

1. `userInteractionEnabled` 属性被设置为 `false`。默认情况下，所有 UIView 对象的 `userInteractionEnabled` 属性为 `true`。但是如果手动设置为 `false`，这个视图和它的所有子视图都不能再响应用户的操作。
2. 视图隐藏或者透明度极低。视图的 `hidden` 属性设为 `YES` 或者 `alpha` 的值小于 0.01，这个视图除非成为第一响应者，否则对事件无响应。
3. 视图被其它视图遮挡。如果视图 A 被视图 B 完全或者部分遮挡，并且覆盖部分位于用户点击的位置，那么这个事件将被视图 B 捕获。
4. 视图超出超视图 bounds。当视图自身超出其父视图的区域范围，超出部分不再响应事件。
5. 视图不在视图层级中。如果视图还未被添加（或被移除）到视图层级中，那么它将不能响应事件。

:::

### ❓用户点击屏幕上按钮，整个过程讲一下

::: details 💡

  iOS 系统用户点击屏幕上的按钮大致过程如下：

  - 当用户触摸屏幕时，硬件会将触摸事件转化为一个或一系列的 `UITouch` 对象，并将它们与一次特定的事件(`UIEvent`对象)关联起来。系统会将触摸事件派发给对应的 `UIApplication` 对象。

  - `UIApplication` 对象接收到触摸事件后，会将事件传递给合适的 `UIWindow` 对象。`UIWindow` 对象再将其分发给正在显示的、并且能够响应事件的 `UIView` 对象。 

  - 如果此 `UIView` 对象就是我们所点击的视图(如：按钮 `UIButton` 对象)，那么此按钮会接收到此点击事件。

  - `UIButton` 对象接收到手势事件后，便会根据事件类型来调用对应的方法。

  - 若 `UIButton` 对象存在 `UIControl` 事件（比如 `TouchUpInside`）并且挂接有对应的 Action（函数方法），那么系统就会执行这个 Action。

:::

### ❓事件响应链（Event Responder Chain） 这个详细的讲讲

::: details 💡

  `Event Responder Chain` 事件响应链 : 是指当某一个事件发生，如触摸事件、系统事件等，这个事件会从一个对象传递到另一个对象的链式机制。

  当手指触摸屏幕时，`UIKit` 会创建一个包含了触摸的所有信息的事件对象，并会将该事件对象发送给视图层级中最前面的视图对象，即被触摸的视图。
  如果该视图不能处理该事件，那系统就会将事件传递给它的上一级视图，也就是它的 `superview`；
  如果上级视图也不能处理，那就接着向上传递，直到传递给窗口，再接着传递给 `UIApplication`，最后传递给 `UIApplication` 的代理。
  
  这样从一个对象向另一个对象传递的链式过程就是事件响应链。

  详细的事件传递流程如下：

  - 如果一个视图是用户交互禁用的（`userInteractionEnabled = false`），或是隐藏的（`hidden = true`），或者是透明的(`alpha = 0`), 那么这个视图和他的子视图就无法成为第一响应者，也就接收不到任何事件。

  - 如果当前视图无法处理接收到的事件或者消息，那么它会将这个事件或消息传递给自己的 `superview`，如此往复，如果都处理不了的话，那么最后会传递给 `UIWindow` 对象。

  - 如果 `UIWindow` 对象也无法处理接收的事件或消息，那么就会传递给 `UIApplication` 对象。

  - 最后由 `UIApplication` 将事件或消息传递给应用程序的代理对象（也就是通常所说的`AppDelegate`）。

  这种设计机制可以保证所有的事件或消息都能得到处理，并且事件或消息的处理是有优先级的，即由具体的视图优先处理，若其无法处理再逐级上报，直到找到可以处理的对象。且每一个响应者都可以选择向上层的响应者传递事件，以便于上层响应者做一些统一的处理。

:::

### ❓叠在一起的两个 `View` 哪个会响应

::: details 💡

两个View叠在一起哪个响应取决于视图的层次结构和z轴的高度。

在iOS中，如果两个视图A和B叠在一起，那么对事件的响应权取决于这两个视图在其父视图中的添加顺序。UIView的子视图是按照数组的顺序存放的，后添加的子视图会在数组的后面，而响应事件的优先级则是从数组的后面向前遍历的。所以如果视图A是后添加到其父视图中，那么视图A会遮挡住视图B，并捕获并处理用户的触摸事件。

另外，如果为视图设置了zPosition，可以改变视图在z轴上的位置，zPosition值越大，视图越靠前，更可能接收到事件。

总的来说，被后添加或zPosition值更大的视图更可能响应事件。当然，这也取决于视图的userInteractionEnabled、hidden、alpha等属性，这些属性可能会阻止视图响应事件。

:::

> 如果不想让上面的 `View` 响应，怎么解决

::: details 💡

如果你不想让上面的View响应触摸事件，你可以使用以下方法：

1. 设置`userInteractionEnabled`属性为`false`。这将禁用用户在上面的视图上的交互，把事件传递到它下面的视图。

```swift
topView.userInteractionEnabled = false
```

2. 重载上面视图的`hitTest:withEvent:`方法。这个方法的使用有点复杂，它的目的是找到能响应事件的最佳视图。你可以重写这个方法，让它返回下面的视图：

```swift
override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    let hitView = super.hitTest(point, with: event)
    if hitView == self {
        return underlyingView
    }
    return hitView
}
```

3. 重写视图的`pointInside:withEvent:`方法，此方法用于检查触摸点是否在视图内。如果点在上面的视图外，触摸事件就会传递给它的底层视图：

```swift
override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
    // 在这里检查点是否在你想要的区域内
}
```

请注意，这些方法可能需要根据具体应用场景进行调整。

:::

> 如果两个 `View` 都要响应呢

::: details 💡

如果你想让两个重叠的视图都响应同一触摸事件，那么你可能需要一个稍微不同的策略，这就涉及到事件的传递和响应者链。预设的UIKit行为中，一旦一种事件被一个视图接收并且处理，那么这个事件就会停止导航到视图层级。但是，你可以覆盖这种行为。

1. 自定义UIView子类并重写`hitTest`方法或者`pointInside:withEvent:`方法来决定哪个视图需要处理接收到的触摸事件。
2. 在一个父视图中进行触摸事件的处理并在适当的时候传递给子视图。

下面就是重写hitTest:withEvent:方法的一个例子：

```swift
override func hitTest(point: CGPoint, withEvent event: UIEvent?) -> UIView? {
    let view = super.hitTest(point, withEvent: event)
    if view == self {
        return otherView;
    }
    return view
}
```

在此代码中，如果触摸事件始于该视图，我们改为返回otherView作为需要接收事件的视图。

还可以在你的控制器中使用手势识别器(gesture recognizers)，可以更好地处理较为复杂的触摸交互问题，或者在触摸开始响应方法touchesBegan中，对不同的视图各自处理。

需要注意的是，确保所有的view的 userInteractionEnabled 均为true，否则是无法接收到触摸事件的。

:::

### ❓`hitTest` 和 `pointInside` 的关系

::: details 💡

`hitTest:withEvent:`和`pointInside:withEvent:`都是UIKit框架圆形事件系统的一部分，它们经常一起使用来确定某个触摸事件应该由哪个视图处理。

以下是这两个函数的常见用法和它们之间的关系：

1. `hitTest:withEvent:`是我们用来确定触摸事件应该由哪个子视图处理的方法。当用户触摸屏幕时，UIKit会询问顶级视图来找出正确的视图处理事件。它会调用`hitTest:withEvent:`，把触摸点的坐标和触摸事件作为参数传入。

2. `hitTest:withEvent:` 方法的实现通常会调用 `pointInside:withEvent:` 来检查触摸点是否在视图的bounds内。如果 `pointInside:withEvent:` 返回 `true`，那么 `hitTest:withEvent:` 就会返回这个视图，表示这个视图可以接收并处理这个触摸事件。
   
3. 如果视图是一个容器视图，并且包含其他子视图，`hitTest:withEvent:` 的实现通常会遍历所有的子视图，并且这个遍历通常是按照反序进行（也就是从顶层子视图到底层子视图）。对于每个子视图，都会调用 `hitTest:withEvent:`。如果这个方法返回了一个非 `nil` 的视图，那么遍历就会立即停止，并且这个被返回的视图会被认为是最合适处理这次触摸事件的视图。
   
4. 如果 `pointInside:withEvent:` 对所有子视图都返回 `false`，那么 `hitTest:withEvent:` 也就会返回 `nil`，表示这个视图和它的子视图都没有接收这次触摸事件。

根据这些步骤，我们可以得到以下的结论：`pointInside:withEvent:` 方法用于检测触摸点是否在视图内，而 `hitTest:withEvent:` 则用于找到一个最合适处理事件的子视图。所以说，`hitTest：withEvent:` 是根据 `pointInside:withEvent:` 的结果来决定返回哪个视图的。具体会返回哪个视图，取决于 `pointInside:withEvent:` 在检测触摸点是否在视图范围内时的结果。

:::

### ❓`hitTest` 有重写吗

::: details 💡

是的，`hitTest:withEvent:` 可以在子类中重新实现，以更改触摸事件处理的默认行为。默认的实现会遍历视图层次结构，找出在给定点的视图，而你可以通过重写这个方法来定制这一行为。

例如，下面的代码将扩大了一个视图的触摸区域：

```swift
override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    let biggerRect = self.bounds.insetBy(dx: -30, dy: -30)
    return biggerRect.contains(point) ? self : nil 
}
```

在这个例子中，新的 `hitTest:withEvent:` 实现使得即使用户点击了这个视图的范围外面，只要在扩大后的范围之内，这个视图仍然会接收到触摸事件。

当然，需要在设计时考虑清楚，避免重写`hitTest:withEvent:`后导致视图层次内的其他视图由于触摸事件的分发问题而出现预期外的行为。

:::

### ❓使用 `Method Swizzling` 父 `View` 的 `touchBegin` 的方法, 会对子 `View` 造成什么影响

::: details 💡

Method Swizzling，又称方法交换，是 Objective-C 的运行时特性。这种特性允许我们交换方法的实现，这样在执行特定方法时，实际上会执行另一个方法。

如果你在父View中使用Method Swizzling来交换`touchesBegan:withEvents:`方法的实现，那么当你点击父View或其子View时，实际上调用的将是你交换后的方法。这会影响到子View原本应有的行为。

例如你可能会遇到这样的问题：

1. 如果你在新的方法实现中没有调用原始方法，那么在点击视图时，原始的touchesBegan:withEvent:方法中的行为就不会执行，可能会失去一些应有的效果或者触摸反馈。

2. 如果你在新的方法实现中改变了触摸事件的处理方式，可能会影响到子View的交互响应。例如如果你做了一些拦截处理，那么子View可能会无法收到触摸事件。

所以，当你需要在触摸事件处理方法中使用 Method Swizzling时，通常需要在新的方法实现中调用原始方法，以确保符合预期的行为。同时，你需要仔细评估和测试这种实现对于整个视图层次可能造成的影响。

:::

------

## 算法

### ❓寻找最近的公共 `View`

::: details 💡

你可以通过以下方式实现寻找两个子视图最近的公共父视图的函数：

```swift
func findNearestCommonAncestor(view1: UIView, view2: UIView) -> UIView? {
    var currentView: UIView? = view1
    while let view = currentView {
        if view2.isDescendant(of: view) {
            return view
        }
        currentView = view.superview
    }
    return nil
}
```

这个函数首先从第一个视图开始，检查第二个视图是否是第一个视图的后代。如果是，就返回当前的视图。如果不是，就继续检查第一个视图的父视图。

最后需要注意的是，`findCommonSuperviewWithView:` 这个函数本身并没有考虑如果两个视图处在不同窗口或者不同视图层级的情况，这种情况需要额外处理。

:::

### ❓打印一个 `View` 的所有子 `View`，要求分层打印

::: details 💡

树的层序遍历问题

在 Swift 中，可以利用队列(Queue)来实现树的层次遍历。以下是一个实现比:

```swift
func printSubviewsInLevelOrder(for view: UIView) {
    var queue = [UIView]()
    queue.append(view)
    while !queue.isEmpty {
        var count = queue.count // 当前层数量
        var levelViews = [UIView]() // 当前层视图
        while (count > 0) {
            let levelView = queue.removeFirst()
            levelViews.append(levelView)
            count -= 1
            // 将当前层视图子视图继续加入队列
            for subview in levelView.subviews {
                queue.append(subview)
            }
        }
        print(levelViews) // 打印当前层视图   
    }
}
```

以上就是使用 Swift 对 View 进行层次遍历的代码, 这样可以按照从上到下，从左到右的顺序打印出所有子 view。

:::



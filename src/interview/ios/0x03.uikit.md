---
title: UIKit
icon: hashtag

index: true

---

<!-- more -->

## reference

- [](✅)[2020-12-14 iOS | 响应链及手势识别](https://juejin.cn/post/6905914367171100680)
- [](✅)[2020-11-13 iOS | 事件传递及响应链](https://juejin.cn/post/6894518925514997767)
- [2015-12-08 如何正确地写好一个界面](http://oncenote.com/2015/12/08/How-to-build-UI/)
- [2015-05-25 如何设计一个 iOS 控件?(iOS 控件完全解析)](https://www.codingtour.com/posts/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-ios-%E6%8E%A7%E4%BB%B6-ios-%E6%8E%A7%E4%BB%B6%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/)
- [2015-05-17 优化`UITableViewCell`高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)
- [2014-12-25 `UIScrollView` 实践经验](https://tech.glowing.com/cn/practice-in-uiscrollview)

------

## UIKit

### ❓`iOS` 的应用程序有几种状态

::: details 💡

  - **Not running（未运行）**：应用程序尚未启动，或者系统或用户已将其终止。

  - **Inactive（不活跃）**：应用程序正在前台运行，但无法接收事件（如来电或用户锁定设备导致的应用程序转至后台）。

  - **Active（活跃）**：应用程序正在前台运行并接收事件。这也是正常的、应用程序接收和处理事件的状态。

  - **Background（后台）**：应用程序在后台并正在运行代码。大多数应用程序会进入这种状态并在进入挂起状态之前停止。

  - **Suspended（挂起）**：应用程序在后台但不运行代码。系统会自动将应用程序移至此状态而不提供通知。当挂起时，应用程序仍留在内存中，但不执行任何代码。
    
:::

> ❓退到后台代码是否可以执行，双击home键，代码是否可以执行

::: details 💡
    
  - 退到后台之后，应用程序进入Background状态，此时代码是可以执行的。但系统会对后台运行的时间有限制（这主要是为了优化电池寿命和效能），一般情况下，在应用进入后台后的几分钟内，应用将被系统挂起。但是在这个时间段内或者通过申请背景执行时间的方式，是可以继续执行代码的。

  - 双击home键后应用进入后台，但不会直接进入挂起状态。所以短时间内是可以执行代码的，但如果长期无操作，应用程序会被系统挂起，此时无法执行代码。
    
:::

### ❓了解的 `UIKit` 结构

::: details 💡

> `UIKit` 这个框架提供了在 `iOS` 中开发图形化、事件驱动的应用所需要的所有基础工具和基础结构。

主要组件：

  - `UIWindow`
    > 通常会有一个或多个 `UIWindow`，这是展示 `UIView` 的地方，是 `UIView` 的最顶层容器。它通常与设备的屏幕一样大小。

  - `UIView` 和 `UIViewController`
    > `UIView` 是 `iOS` 中的基础组件，负责绘制和布局界面元素，处理与用户交互的事件。`UIViewController` 对应一个 `UIView`，它管理着 `UIView` 的生命周期，负责处理用户交互和视图切换等逻辑。

  - 控件
    > `UIKit` 提供了一组预封装的常见 `UI` 元素组件，如按钮（`UIButton`）、标签（`UILabel`）、滚动视图（`UIScrollView`）、表格视图（`UITableView`）、集合视图（`UICollectionView`）等。

  - 文本处理
    > `UIKit` 提供了一套强大的文本处理和布局系统。不仅提供了基础的 `UILabel` 用于显示文本，还有 `UITextField`、`UITextView` 等用于文本输入，以及 `NSLayoutManager` 和 `NSTextContainer` 等高级 `API` 用于复杂的文本布局。

  - 图形和动画
    > `UIKit` 提供了一套强大的 `2D` 图形和动画框架，包括基础的画图 `API`、复杂的形状和路径、渐变、屏幕刷新和动画等。

  - `CoreAnimation`
    > `UIKit` 的绚丽动画效果就是 `Core Animation` 提供支持。可以构建具有复杂视觉效果的动画，例如在两个视图状态之间平滑过渡，或者是在屏幕上移动、缩放、旋转视图。

  - 触摸事件处理
    > `UIKit` 提供了一套事件处理机制，包括触摸事件、手势识别等，非常方便地可以让我们对用户的交互作出响应。

  - 响应者链
    > `UIKit` 针对 `UI` 事件提供了响应者链的机制，当一个事件产生后，通过响应者链，逐层寻找可以处理该事件的对象。比如触屏事件，先从最上层的 `view` 开始，如果该 `view` 不能处理，则逐层向上传递至其父 `view`，直到找到可以处理该事件的对象。

  - 自动布局
    > 利用 `UIKit` 框架的自动布局系统，开发者可以创建灵活且响应的界面布局。开发者可以使用 `AutoLayout` 和 `UIStackView` 来布局界面。
    
:::

### ❓`UIScene` 了解吗

::: details 💡

  > `UIScene` 是在 `iOS 13` 中引入的一种新的应用生命周期模型，它提供了管理应用 `UI` 以及该 `UI` 如何响应系统和用户事件的更细粒度的方式。

  在 `iOS 13` 以前，`iOS` 应用由单一的 `UIWindow` 实例进行管理，并且该 `UIWindow` 实例存在于整个应用的生命周期中。`AppDelegate` 要负责所有 `UI` 设置以及与应用生命周期相关的事件。

  `iOS 13` 以后 `UIScene` 则是对此进行了优化，每一个 `UIScene` 实例代表应用 `UI` 的一个单一实例。当应用在前台运行时，可以有多个 `UIScene` 实例，从而实现多窗口的多任务管理。例如在 `iPadOS` 上，用户可以开启多个窗口。

  每个 `Scene` 由一个 `Scene Delegate` 来进行管理，各种 `UI` 设置以及和场景（Scene）生命周期相关的事件都由 `Scene Delegate` 来处理。就像原来 `AppDelegate` 处理应用级别的事件一样，`Scene Delegate` 负责处理和特定 `Scene` 相关的事件。只有当进行 `App` 级别的事件处理，譬如接收远程消息通知，处理后台下载任务，这些工作才会交给 `AppDelegate` 去完成。

  这样的设计，使得在做一些 `UI` 设置以及响应生命周期事件时，更加的清晰和方便，同时也带来了更好的多任务管理能力。

:::

> `SceneDelegate` 详细说说

::: details 💡

  > `SceneDelegate` 是从 `iOS 13` 开始引入的一个新的代理模型，用于处理和 `UI Scene Session` 相关的事件，并控制和管理与其关联的 `Scene`。

  `SceneDelegate` 中处理以下一些事件：

  - `func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)` 方法：这个方法是在创建新的 `scene` 时被调用，相当于 `AppDelegate` 中的 `application:didFinishLaunchingWithOptions:` 方法。通常会在该方法中设置窗口和根视图控制器。

  - `func sceneDidDisconnect(_ scene: UIScene)` 方法：当 `scene` 与 `app` 断开连接时候调用。发生在 `scene` 进入后台并且系统决定需要释放 `scene` 时。

  - `func sceneDidBecomeActive(_ scene: UIScene)` 方法：当 `scene` 进入活跃状态或者进入前台时调用，对应的是 `AppDelegate` 中的 `applicationDidBecomeActive:` 方法。

  - `func sceneWillResignActive(_ scene: UIScene)` 方法：当 `scene` 准备进入非活跃状态或者进入后台时调用，对应的是 `AppDelegate` 中的 `applicationWillResignActive:` 方法。

  - `func sceneWillEnterForeground(_ scene: UIScene)` 方法：当 `scene` 从后台恢复到前台时调用，对应的是 `AppDelegate` 中的 `applicationWillEnterForeground:` 方法。

  - `func sceneDidEnterBackground(_ scene: UIScene)` 方法：当 `scene` 进入后台时调用，对应的是 `AppDelegate` 中的 `applicationDidEnterBackground:` 方法。

  - `func stateRestorationActivity(for scene: UIScene)` 方法: 应用状态恢复时调用的方法，用以保存应用的当前状态。

:::

### ❓`applicationWillEnterForeground` 和 `applicationDidBecomeActive` 都会在哪些场景下被调用

::: details 💡

调用场景：

  - 用户通过主屏幕点击图标打开应用：
    > 这种情况下首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用在后台，通过通知或者系统打开应用：
    > 也是先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用从后台切换到前台：
    > 这种情况下，两个函数的调用顺序和之前一样，首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用内部弹出系统视图，例如电话，信息，分享等视图，视图消失后：
    > 这个情况下只会调用 `applicationDidBecomeActive`，`applicationWillEnterForeground` 不会被调用，因为应用实际上并没有进入后台，只是暂时失去了焦点。

:::

### ❓`iOS` 怎么检测图层混合

::: details 💡

检查图层混合（`Layer Blending`）方法：

  - 使用 `Xcode` 的 `Debug View Hierarchy`。
    > 点击 `Xcode Debug Area` 的 `Debug View Hierarchy` 按钮，会显示 `App` 当前的界面层级结构。在这个工具里，你可以检查图层混合问题。在界面右侧有一个 `3D` 效果的开关以及一个调整深度值的滑杆，通过它们可以更好地观察各个视图的在 `3D` 空间中的位置关系。

  - 使用 `Instruments` 的 `Core Animation` 工具。
    > `Instruments`的 `Core Animation` 工具是一种主要用于检测图形性能的强大工具。在该工具中，可以打开 `Color Blended Layers` 来检查图层混合问题。

  - 使用 `Quartz Debug` 工具：是苹果的一个调试工具，如果安装了 `Xcode`，在 `Developer Tools` 文件夹里就会有这个工具。
    > 打开 `Quartz Debug` 后，在工具栏选择 `Tools -> Show Debug Options`，然后在弹出的窗口中选择 `Color Blended Layers`。这会将需要混合的部分以红色显示，不需要混合的部分以绿色显示。

  - 使用第三方工具如 `Reveal`。
    > `Reveal` 是一款强大的 `iOS` 应用 `UI` 检查工具。它可以能够在运行时查看和修改 `UI`，这对于查找和解决图层混合有很大帮助。

:::

------

## UIView

### ❓`UIView` & `CALayer` 是什么关系

::: details

  每个`UIView`都有一个对应的`CALayer`，称之为 `UIView` 的 `backing layer`（背部层）。`UIView` 和 `CALayer` 之间是互相关联的，`UIView` 负责处理触摸事件，而 `CALayer` 负责显示视图的内容。

  - `UIView`：视图的基类，负责处理用户交互（例如触摸事件），也负责管理子视图（包括添加、删除、遍历子视图）。可以使用 `UIView` 的子类（如`UILabel`，`UIButton`等）创建特定的用户界面，也可以创建自定义视图来绘制复杂的界面。

  - `CALayer`：是核心动画库(`Core Animation`)中的类，它负责呈现视图的内容。`UIView` 将很多渲染任务委派给 `CALayer`，例如视图的边框、圆角、阴影、图片等都是由 `CALayer` 来绘制和渲染的。此外 `CALayer` 还负责处理动画效果。

:::

> 为什么要这样设计？

::: details

  这是由于 `iOS` 系统的历史原因。在早期的 `iOS` 版本中，只有 `CALayer`，并没有 `UIView`，所有的界面渲染和动画都需要通过手动控制 `CALayer` 来完成。
  
  后来，苹果引入了 `UIView`，用以简化界面的创建和管理，并将一些低层的渲染和动画任务委派给 `CALayer`。
  
  这样的设计使得开发者可以更高效地创建和管理用户界面，同时也保持了对底层渲染和动画的高级控制能力。

:::

### ❓在一个视图的正中间实现一个正方形的红色视图有几种方式

::: details 💡

  - 使用代码布局：
    > 可以通过手动设置 `frame` 或者使用 `AutoLayout` 来完成。以下是使用Swift语言的示例：

    ::: code-tabs

    @tab 手动设置 frame
    ```swift 
    let squareView = UIView()
    squareView.backgroundColor = .red
    let sideLength: CGFloat = 100.0 // 正方形的边长
    squareView.frame = CGRect(x: (view.bounds.width - sideLength) / 2,
                              y: (view.bounds.height - sideLength) / 2,
                              width: sideLength,
                              height: sideLength)
    view.addSubview(squareView)
    ```
    
    @tab AutoLayout:
    ```swift
    let squareView = UIView()
    squareView.backgroundColor = .red
    squareView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(squareView)
    
    NSLayoutConstraint.activate([
        squareView.centerXAnchor.constraint(equalTo: view.centerXAnchor),
        squareView.centerYAnchor.constraint(equalTo: view.centerYAnchor),
        squareView.widthAnchor.constraint(equalToConstant: 100),
        squareView.heightAnchor.constraint(equalTo: squareView.widthAnchor)
    ])
    ```

  - 使用 `Interface Builder`:

    * 在 `Interface Builder` 中，可以先将一个 `UIView` 拖拽到画布中，并设置它的背景色为红色。
    * 选中这个视图后，打开 `Utilities`- `Size Inspector`，在 `Width` 和 `Height` 中输入相同的值（比如100）来设置正方形的大小。
    * 然后在 `Utilities` - `Attributes Inspector`，点击 `+` 按钮添加两个中心对齐约束 `Align Center X to: Superview` 和 `Align Center Y to: Superview`。
    
:::

### ❓直接用 `UILabel` 和自己用`drawRect:` 画 `UILabel`，哪个性能好，为什么

::: details 💡

> 性能和内存使用都是需要考虑在相应上下文环境下的，因此，这个问题并没有一个绝对的答案。通常情况下，使用 `UIKit` 组件（如 `UILabel`）的性能和内存使用都被优化得很好，除非有特别的需求，一般推荐直接使用这些组件，而不是自己实现。

性能方面：
  直接使用 `UILabel` 的性能通常更好。因为 `UILabel` 由系统提供并进行了高度优化，包括文本缓存、文本渲染等部分。另一方面 `drawRect:` 方法是在每次重绘时调用，如果不恰当的使用，可能会导致 `CPU` 负担增大，性能下降。

:::

> 哪个占用的内存少，为什么

::: details 💡

  如果在 `drawRect:` 中只是简单地绘制文本，可能会比 `UILabel` 占用更少的内存，因为 `UILabel` 需要保持一些状态和元数据。但这种差异通常非常小，不必过于关注。如果在 `drawRect:` 方法中执行了复杂的绘图代码或者创建了大量的临时对象，那么实际的内存占用可能会比 `UILabel` 更大。

:::

### UIControl

#### ❓`UIControl` vs `UIResponder`

::: details 💡

> 继承链：`UIControl` -> `UIView` -> `UIResponder`

  - `UIResponder` 是处理和响应事件的基类，它定义了接收和处理事件的接口。实际上，`UIApplication`、`UIView`和`UIViewController` 都是继承自 `UIResponder`，都可以响应并处理事件。例如当一个触摸事件发生时，`iOS` 会把事件交给最先接触到的 `UIView` （也就是被用户触摸的那个），然后沿着响应链向上分发，直到有 `UIResponder` 子类处理这个事件。

  - `UIControl` 是继承自 `UIView`，并且添加了一些控制特性的类，用于响应用户交互。`UIControl` 提供了一种机制，允许你在特定事件发生时发送消息给指定的目标。比如 `UIButton`、`UISlider`、`UISwitch` 等都是 `UIControl` 的子类。可以为这些子类设置 `target-action` 来响应用户的交互事件。

总结：`UIResponder` 负责处理事件，而 `UIControl` 在此基础上添加了更多用户交互的特性。

:::

#### ❓`UIButton` 继承链

::: details 💡

> 继承链 : `UIButton` -> `UIControl` -> `UIView` -> `UIResponder` -> `NSObject`

  - `NSObject` 是所有 `Objective-C` 类的基类，提供了对象的基本行为特征和特性。

  - `UIResponder` 是 `iOS` 事件传递体系中的一个重要组成部分，此类提供了一种机制来处理和路由在应用程序中发生的触摸事件、手势识别、远程控制等事件。

  - `UIView` 是基本的展示视图和处理视图相关事件的类，几乎所有的 `UI` 元素都是直接或间接继承自 `UIView`，此类提供了一种机制以支持在其矩形区域内绘制、布局和处理事件。

  - `UIControl` 是 `UIView` 的一个直接子类，是一些具有 `target-action` 机制的 `UI` 元素的基类，比如按钮(`UIButton`)、滑块(`UISlider`)等，能够响应用户的交互行为并向感兴趣的目标发送讯息。

  - `UIButton` 是 `UIControl` 的一个子类，主要用来制作按钮。它在父类 `UIControl` 的基础上又添加了一些按钮特有的行为，比如按钮的标题、图片等。

:::

#### ❓根据 `UIControl` 实现 `UIButton`

```swift
protocol ButtonProtocol {
    func setTitle(_ title: String);
    func setTitleColor(_ titleColor: UIColor);
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets);
    func setImage(_ image: UIImage);
    func setBackgroundImage(_ image: UIImage);
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets);
}

class MyButton: UIControl, ButtonProtocol { 
    // todo
}
```

::: details

  `UIButton`本质上是一个视图（对象），因此它应该包含一些像视图、标签、图片视图等子视图。要求 `MyButton` 能够具有设置标题、标题颜色、标题边距、题图像、背景图像以及图像边距的能力。

```swift
class MyButton: UIControl, ButtonProtocol {
    
    let titleLabel: UILabel = {
        let label = UILabel()
        label.textAlignment = .center
        return label
    }()
    
    let imageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    let backgroundImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleToFill
        return imageView
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.addSubview(backgroundImageView)
        self.addSubview(imageView)
        self.addSubview(titleLabel)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        backgroundImageView.frame = self.bounds
    }
    
    func setTitle(_ title: String){
        titleLabel.text = title
    }
    
    func setTitleColor(_ titleColor: UIColor) {
        titleLabel.textColor = titleColor
    }
    
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets){
        titleLabel.frame = self.bounds.inset(by: edgeInsets)
    }
    
    func setImage(_ image: UIImage) {
        imageView.image = image
    }
    
    func setBackgroundImage(_ image: UIImage) {
        backgroundImageView.image = image
    }
    
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets) {
        imageView.frame = self.bounds.inset(by: edgeInsets)
    }
    
}
```

  - 为了处理背景图像，标题和图像，需要三个子视图：一个背景图像视图、一个图像视图和一个标签。
  
  - `setTitleEdgeInsets` 和 `setImageEdgeInsets` 方法只需要调整 `titleLabel` 和 `imageView` 的 `frame` 即可。

  - 在 `layoutSubviews()` 中设置 `backgroundImageView` 的 `frame`，以保证其总是充满整个视图。

  注意：“实现 `UIButton`” 需要更多的特性和设置，例如处理高亮状态和禁用状态，添加点击事件等。按照特定需求，可以进行进一步的扩展和完善。

:::

------

## UIScrollView

### UIScrollView

#### ❓自己如何设计一个系统的 `UIScrollView`

::: details 💡

> 设计一个类似`UIScrollView`的滚动视图系统其实涉及到很多方面，包括但不限于内容的布局、滚动的实现、滚动事件的处理、滚动条的显示等等。

一个简单的设计：

  - 自定义一个视图容器，这个类似于 `UIScrollView` 的实例。
    * 存放全部内容：这就需要一个比视图容器大的视图空间（内容视图），并位置在容器中。
    * 捕获并处理滚动事件：使用触摸事件（如 `iOS` 的 `touchBegan`, `touchMoved` 等）跟踪用户的手势，并据此来改变内容视图的位置。
    * 根据内容的滚动来显示滚动条：可以添加两个子视图作为水平和垂直滚动条，在内容滚动时改变它们的位置和长度。

  - 实现滚动的一种基本方法是在接收到滚动事件后，改变内容视图的位置（比如其在 `iOS` 中的 `frame.origin`）。
  
  - 如果要添加滚动的弹性和/或惯性，可能会稍微复杂一些，需要在处理滚动事件时添加一些额外的计算。

:::

### UITableView

#### ❓`UITableView` 的 `delegate` 和 `dataSource` 代理有什么区别

::: details 💡

- `dataSource` 主要是向 `UITableView` 提供数据。

  例如数据源中有多少个 `section`，每个 `section` 有多少行，以及每一行的具体内容等等。`dataSource` 必须实现下面两个方法：

    * `func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int`：设置每个 section 中的 row 数量。
    * `func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell`：提供具体的 cell。

  这两个方法是 `UITableViewDataSource` 协议的必要方法，没有这两个方法，`UITableView` 就没办法正常工作。

- `delegate` 主要是处理 `UITableView` 的视觉效果以及与用户的交互。

  例如设置 `header` 和 `footer`、设置 `cell` 的高度、处理 `cell` 的选择和取消选择等等。

    * `func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat`：设置 cell 的高度。
    * `func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)`：处理 cell 的选择事件。

  这些方法都不是必须的，不过如果我们想要更加细致地控制 `UITableView` 的外观和行为，就需要实现这些方法。

总的来说，`dataSource` 是设置和提供数据，`delegate` 是控制外观和处理用户交互。

:::

#### ❓`UItableview` 的 `reuse` 原理

::: details 💡

> `UITableView` 的重用机制是为了提高列表滚动的性能。在 `iOS` 开发中，如果列表包含大量的 `cell`，那么无止尽地创建新的 `UITableViewCell` 对象将消耗过多的内存，且过于频繁的内存分配和释放也会影响性能。重用机制使得在滚动大型列表时仍能保持流畅且内存使用率低，实现了列表的高性能渲染。

  基本原理：对于屏幕外的 `UITableViewCell` 对象，不直接释放，而是将其放入 `UITableView` 的重用池中，当屏幕需要将 `UITableViewCell` 显示出来时，优先在重用池中寻找可重用的 `UITableViewCell` 如果找到，则取出，更新内容后使用；如果未找到，才创建新的 `UITableViewCell`。

:::

#### ❓`prepareForReuse` 作用

::: details 💡

> `prepareForReuse` 是 `UITableViewCell` 的一个方法，当 `cell` 被加入到 `UITableView` 的复用队列（`reuse queue`）之前（即 `cell` 将被复用进行显示新的数据前）会被调用。

  这个方法是用来在一个 `cell` 被复用之前，把这个 `cell` 的状态复原或者更新到一个新的状态。复原的内容可以包括例如取消选中效果、隐藏或显示内部的视图、歇后语行为等。

```swift
class CustomTableViewCell: UITableViewCell {

	override func prepareForReuse() {
	    super.prepareForReuse() // 这一句一定要写，用于执行父类的 prepareForReuse 逻辑

	    // 在 reuse 前，将内部的某些状态重置或初始化
	    self.imageView?.image = nil
	    self.textLabel?.text = nil
	    self.backgroundColor = .white
	}
}
```

注意：在此方法中不应该做过于复杂和耗时的操作，不然会影响cell的复用效率，从而影响界面的流畅度。

:::

#### ❓`UITableView` 如果要删除某个 `Cell` 的动画会怎么设计和实现

::: details 💡

  - 删除 `Cell`
    > 删除 `UITableView` 中的一个 `Cell` 需要执行两部分操作：一是删除数据源中对应的数据项，二是更新视图以反映这一变化。

    ```swift
    // 1> 删除数据源
    self.dataArray.remove(at: indexPath.row)
    // 2> 更新视图
    tableView.beginUpdates()
    tableView.deleteRows(at: [indexPath], with: .fade)
    tableView.endUpdates()
    ```

  - 动画效果
    > 在 `deleteRows(at:with:)` 方法中， `with` 参数就是用来指定动画效果的。

    - `.fade`：当插入或删除时，`Cell` 会自动淡出或淡入。
    - `.right` 或 `.left` ：当插入或删除时，`Cell` 会从右边或左边划入或划出。
    - `.top` 或 `.bottom`： 当插入或删除时，`Cell` 会从顶部或底部滑入或滑出。
    - `.none` ：无动画效果。
    
:::

#### ❓怎么判定两个 `Cell` 相同

::: details 💡

判断两个 `UITableViewCell` 相同可以从两个方面来判断：
    
  - 视觉：视觉上的判断主要是看 `UITableViewCell` 的内容是否一模一样，包括文字，图片，颜色和排列的形式等。
    
  - 数据：如果两个 `Cell` 所对应的数据不一样，那就不能认为这两个 `Cell` 是一样的。比如在一些带有选中功能的列表中，即使两个 `Cell` 都显示为 "Option A"，但是一个被选中，另一个没被选中，那么它们的数据层面就是不同的。
    
    ```swift
    class MyCellModel: NSObject {
        var text: String
        var image: UIImage
        
        init(text: String, image: UIImage) {
            self.text = text
            self.image = image
        }
        
        // 重写 isEqual 方法来实现，来判断 Cell 的模型数据一样
        override func isEqual(_ object: Any?) -> Bool {
            guard let other = object as? MyCellModel else {
                return false
            }
            return self.text == other.text && self.image == other.image
        }
    }
    ```
    
:::

#### ❓`reuse` 队列长度怎么调整，属性名是什么

::: details 💡

> `UITableView` 的 `reuse` 队列长度是由系统自动管理的，无法由开发者手动调整。当 `UITableView` 需要显示一个新的 `Cell` 时，它首先会检查 `reuse` 队列中是否有可重用的 `Cell`。如果有，`UITableView` 将会用这个 `Cell`，并从队列中移除。如果没有，`UITableView` 将会生成新的 `Cell`。当某个 `Cell` 不再被显示（例如用户滑动 `UITableView` 使得该 `Cell` 滑出屏幕）时，该 `Cell` 就会自动被加入到 `reuse` 队列中。

:::

#### ❓每个 `Cell` 如果都有倒计时怎么办，独立的倒计时怎么做

::: details 💡


```swift
// 1> 定义一个全局的定时器，例如每秒触发一次
private lazy var timer = {
  return Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(timerDidFire), userInfo: nil, repeats: true)
}()

// 2> 根据定时器触发，更新每个 Cell 倒计时数据
@objc private func timerDidFire() {
  for (i, countdown) in countdownList.enumerated() {
    // 更新countdown
    countdownList[i] = countdown - 1
  }
  // 刷新TableView
  tableView.reloadData()
}

// 3> 对每个 Cell 进行更新
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
  cell.textLabel?.text = "\(countdownList[indexPath.row])"
  return cell
}
```

:::

#### ❓`Cell` 进入 `reuse` 池，然后重新被激活了，计时器逻辑怎么处理

::: details 💡

```swift
// 从数据源获取倒计时，然后设置到 Cell 中
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: "CountdownCell", for: indexPath) as! CountdownCell
  cell.countdownTime = durationArray[indexPath.row]
  return cell
}

// 倒计时 Cell
class CountdownCell: UITableViewCell {
    
  var countdownTime: Int {
    didSet {
      // 停止原有的倒计时
      countdownTimer.invalidate()
      // 开始新的倒计时
      countdownTimer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(updateCountdown), userInfo: nil, repeats: true)
    }
  }

  private var countdownTimer: Timer!

  @objc private func updateCountdown() {
    countdownTime -= 1
    // 更新 Cell 的 UI
  }
  
  // 将原有的倒计时停止，避免重复计时
  override func prepareForReuse() {
    super.prepareForReuse()
    countdownTimer?.invalidate()
    countdownTimer = nil
  }
}
```

:::

### UICollectionView

#### ❓`UICollectionView` 自定义布局如何处理

::: details 💡

  自定义 `UICollectionView` 的布局，首先需要创建一个 `UICollectionViewLayout` 或 `UICollectionViewFlowLayout` 的子类，然后重写其中与布局相关的一些方法。

  - `prepare()`
    > 在这个方法中计算出所有 `cell` 和视图的位置。当布局被无效化并需要更新的时候，会首先调用该方法。

  - `layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]?`
    > 这个方法返回的是在给定矩形中所有 cell 和视图的布局属性。这个方法负责提供一个布局属性数组，数组中的数据表示了对应位置的 cell 的排布和样式。

  - `layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes?`
    > 这个方法返回的是对应于路径的所有项目的布局属性，也就是在 `UICollectionView` 中指定位置的 `cell` 的排布和样式。

  - `collectionViewContentSize: CGSize`
    > 这个方法返回的是整个 `UICollectionView` 的内容的宽度和高度。 `UICollectionView` 会使用这个尺寸来配置自己的内容大小，从而实现滚动。

  创建了自定义布局类之后，就可以在创建 `UICollectionView` 的时候，将这个布局类的对象作为参数传入 `UICollectionView` 的初始化方法中，这样创建出来的 `UICollectionView` 将会按照我们自定义的方式进行布局。

:::

------

## UIViewController

### ❓`UIViewController` 的生命周期

::: details 💡

  - `loadView()`: 这个方法是用来创建或加载视图控制器的视图层次结构。是视图控制器生命周期的起始。一般不需要去重写或者直接调用它。

  - `viewDidLoad()`: 这个方法会在视图控制器的视图被装载后调用。可以在该方法中实现任何额外的初始化工作。

  - `viewWillAppear(_:)`: 这个方法会在视图控制器的视图被添加到窗口并且即将显示出来的时候调用。

  - `viewDidAppear(_:)`: 这个方法会在视图控制器的视图已经显示出来之后调用。

  - `viewWillDisappear(_:)`: 这个方法会在视图控制器的视图即将从窗口中移除或者被覆盖而消失的时候调用。
  
  -`viewDidDisappear(_:)`: 这个方法会在视图控制器的视图已经消失、被移除或覆盖的时候调用。

:::

### ❓`UIViewController` 只 `new` 而没用到的时候，`UIViewController` 的 `view` 是否加载了，如果没有加载那什么时候加载

::: details 💡

> 在 `UIViewController` 的生命周期中，其视图（`View`）并不是在 `UIViewController` 被初始化(`alloc/init`) 的时候立刻加载的。当首次访问 `UIViewController` 的 `view` 属性（如`self.view、viewController.view` 等）的时候，才会触发 `view` 的加载，调用 `UIViewController` 的 `loadView` 方法。

```swift
// 创建了一个新的 UIViewController，但是并不会加载 view
let viewController = UIViewController()
// 1> 访问 view 属性，会触发 view 的加载
let view = viewController.view
// 2> 将这个 UIViewController 添加到另外一个 UIViewController 时，也会触发view的加载
self.present(viewController, animated: true, completion: nil)
```

:::

### ❓`loadView` 的作用

::: details 💡

  > `loadView()` 是 UIViewController 的一个生命周期方法，它在访问控制器的 `view` 属性时，如果该属性当前为 `nil`，则会被系统自动调用。

  `loadView()` 用于创建并加载视图控制器的主视图（即 `self.view`）。通常情况下，并不需要重写这个方法，因为默认的实现能够处理大部分常规的初始化需求。比如，如果控制器在 `Storyboard` 中定义，那么 `loadView()` 会加载和设置来自 `Storyboard` 的视图。如果有一个同名的 `nib` 文件，它会加载和设置来自该 `nib` 文件的视图。

  在需要以编程方式创建视图，或者提供自定义的视图加载机制时，可以通过重写 `loadView()` 方法来实现。在重写的 `loadView()` 中，需要手动创建一个 `UIView` 对象或其子类的实例，并赋值给控制器的 `view` 属性。

注意：
  - 重写 `loadView()` 方法时，不需要调用 `super`，并且在方法的最后要确保 `self.view` 不为 `nil`。
  - 除非有特殊需求，否则不建议重写 `loadView()` 方法。对于大部分情况，可以在 `viewDidLoad()` 方法中做视图的初始化配置和其他设置，这更为常见。

:::

### ❓没有使用 `IB` 时，也没有重写` loadView()` 这个 `viewController.view` 如何创建的

::: details 💡

  如果没有使用 `Interface Builder（IB）`来创建和管理视图，并且也没有重写 `loadView()` 方法，那么在 `UIViewController` 的 `loadView()` 方法中会默认创建一个 `UIView` 实例，然后赋值给 `self.view`。
    
  总的来说，无论是使用 `IB` （storyboard 或 xib），还是重写 `loadView()` 来自行创建视图，还是直接采用默认的实现，`UIViewController` 都会确保当其视图被访问时有一个 `UIView` 的实例被创建并赋值给 `self.view`。

:::

### ❓在 `init` 方法里面设置背景颜色，会生效吗

::: details 💡
    
  - 对于 `UIView` 来说，如果在使用 `initWithFrame:` 初始化方法来创建视图，那么在 `init` 方法中设置背景色是生效的。但是如果在 `Interface Builder`（即`storyboard` 或者 `xib`）中创建的视图，这个时候初始化方法是 `initWithCoder:`，同时设置视图属性大多放在 `awakeFromNib` 方法中。

  - 对于 `UIViewController` 来说，由于控制器的视图 `view` 在 `init` 方法调用时还没有被加载，所以在`init`方法里设置背景颜色是不会生效的。需要在 `viewDidLoad` 或者 `loadView` 这样的方法之后设置，这个时候视图已经被初始化并加载完成了。
  
:::

### ❓自定义导航跳转如何实现

::: details 💡

自定义导航跳转主要涉及两点，自定义动画及自定义转场方式。

  - 定义一个类遵循 `UIViewControllerAnimatedTransitioning` 协议，编写自定义的动画逻辑。

    ```swift 
    class CustomTransition: NSObject, UIViewControllerAnimatedTransitioning {
        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return 1.0 // 返回动画时长
        }
        
        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            // 这里编写你的动画逻辑
            
            // 获取到待呈现的视图
            if let toView = transitionContext.view(forKey: .to) {
                // 添加到容器视图中
                transitionContext.containerView.addSubview(toView)
                
                // 编写动画逻辑, 以下是一个简单的淡入淡出动画
                toView.alpha = 0.0
                UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: { 
                    toView.alpha = 1.0
                }) { (_) in
                    // 动画结束时，一定要调用 completeTransition 方法
                    transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
                }
            }
        }
    }
    ```

  - 在视图控制器中指定转场代理，并在代理方法中返回自定义的转场动画对象。

    ```swift
    class ViewController: UIViewController, UINavigationControllerDelegate {
        let customTransition = CustomTransition() // 初始化自定义转场动画
        
        override func viewDidLoad() {
            super.viewDidLoad()
            // 指定代理
            navigationController.delegate = self
        }
        
        func navigationController(_ navigationController: UINavigationController,
                                  animationControllerFor operation: UINavigationController.Operation,
                                  from fromVC: UIViewController,
                                  to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
            return customTransition
        }
    }
    ```

:::

------

## 布局

### 尺寸

#### ❓`sizeToFit`、`sizeThatFits` 了解吗

::: details 💡

  > `sizeToFit` 和 `sizeThatFits` 是 `UIKit` 中 `UIView` 的两个方法，涉及到视图的尺寸调整。

- `sizeToFit`：这是一个无参数的方法，调用这个方法会使得视图的 `frame` 变为能刚好包裹住它的子视图的大小。具体的行为依赖于视图的 `sizeThatFits:` 方法的实现。
    > 这个方法并不会修改视图的位置，只会影响到视图的大小。

- `sizeThatFits:`：这个方法需要一个参数，表示期望的尺寸。然后这个方法返回一个适合视图及其子视图的大小。
    > 这个方法并不会改变视图的实际大小，需要调用者根据返回的大小来更新视图的 `frame`。

一般来说，视图的默认行为是返回一个等于当前视图大小或者等于传入参数的值，具体取决于子视图的要求。如果你的自定义视图有特殊的需求，你可以重写 `sizeThatFits:` 方法来实现特定的尺寸调整行为。

总的来说，`sizeToFit` 和 `sizeThatFits:` 都是用来调整视图尺寸的方法，但具体的行为取决于具体视图的 `sizeThatFits:` 的实现。

:::

#### ❓`intrinsicContentSize` 使用过吗

::: details 💡

  > `intrinsicContentSize` 是`UIView`的一个属性，它表示一个视图的自然大小或者说内在大小。
  
  举例来说，对于一个 `UILabel` 的 `intrinsicContentSize` 就是刚好能包裹住它所包含的文本的大小。

  这个属性在使用 `AutoLayout` 进行布局的时候非常有用。一些需要根据内容自适应大小的控件，比如 `UILabel`、`UIButton` 等，都可以通过设置 `intrinsicContentSize` 来告诉布局系统它们需要的空间大小。

  可以通过重写这个属性的 `getter` 方法来提供自定义的大小。需要注意的是，当视图的内在内容改变，可能会影响到`intrinsicContentSize` 时，需要调用 `invalidateIntrinsicContentSize` 方法来通知布局系统 `intrinsicContentSize` 发生了变化，这样布局系统就会在下一个布局循环中重新计算布局。

总的来说，`intrinsicContentSize` 是在使用 `AutoLayout` 进行布局时，用于表示视图自适应内容大小的一个重要属性。

:::

### 布局视图

#### ❓`layoutSubviews` 那些情况下会触发

::: details 💡

  > `layoutSubviews` 在 `iOS` 的 `UIView` 的生命周期中，是负责布局及排版子视图的方法。

  - 在初始化 `UIView` 并添加到界面上时，系统会自动调用 `layoutSubviews` 方法进行子视图的布局。
  - 当 `UIView` 的 `bounds` 发生变化，如改变宽高、旋转设备时，系统会调用 `layoutSubviews`。
  - 当直接调用 `UIView` 的 `setNeedsLayout`或者 `layoutIfNeeded` 方法时，系统会调用 `layoutSubviews`。
    * `setNeedsLayout` 会标记当前视图被标记为需要重新布局，然后在接下来的更新周期中，调用 `layoutSubviews` 对标记进行重新布局
    * `layoutIfNeeded` 则会立即对视图进行重新布局，通常在动画的 `block` 内使用
  - 当视图的某个子视图的 `frame` 被显式地修改，也会触发父视图的 `layoutSubviews`。
  - 添加或者删除子视图的时候，也会触发父视图的 `layoutSubviews`。

:::

#### ❓`viewWillLayoutSubView` 的作用

::: details 💡

  > `viewWillLayoutSubviews` 是 `UIViewController` 的一个生命周期方法，该方法在视图控制器的视图即将布局其子视图时被调用。这通常发生在视图的尺寸发生改变之后，例如设备的方向发生改变，或者视图被添加到父视图中并且父视图需要调整子视图的位置或大小。

  在 `layoutSubviews` 之前调用 `viewWillLayoutSubviews`，因此这是在预计的布局之前，可以进行一些特定的设置或者变化。

  注意，因为 `viewWillLayoutSubviews` 能被多次调用，因此需要避免在该方法中进行一些不必要的高开销计算或者更新操作。

  `viewWillLayoutSubviews` 的主要用途之一是提供了一个时机，允许在更改子视图的大小或位置之前进行一些额外的配置，也可以在此方法中进行一些必要的布局更新。

:::

#### ❓`layoutIfNeeded` vs `setNeedsLayout`

::: details 💡

> `layoutIfNeeded` 和 `setNeedsLayout` 是 `UIView` 的两个方法，都涉及到视图的布局更新，但是使用场景和触发方式不同。

  - `setNeedsLayout`: 这个方法被调用后，并不会立即触发重新布局。
    > 它标记了视图的布局需要更新，然后在下一次视图更新周期（通常是下一次 `RunLoop`），系统会自动调用 `layoutSubviews` 方法来进行实际的布局更新。如果期间多次调用 `setNeedsLayout`，实际上 `layoutSubviews` 只会被调用一次。

  - `layoutIfNeeded`: 这个方法则会立刻触发视图的布局更新。
    > 调用这个方法后，系统会立即执行布局更新，包括调用 `layoutSubviews` 方法。这个方法通常用于需要立即更新视图布局的情况，比如在 `UIView` 的动画块中。

总结：`setNeedsLayout` 是标记需要重新布局，具体要等到下一个更新周期自动触发，而 `layoutIfNeeded` 则是立刻触发重新布局。

:::

### 绘制视图

#### ❓`drawRect` 有使用过吗，调用时机，会有性能影响吗

::: details 💡

  > `drawRect:` 是一个 `UIView` 类的方法，用于在视图的矩形区域进行绘制。如果自定义视图需要展示一些特殊的展示效果，比如绘制一些自定义的形状、渐变、阴影等，就可以重写这个方法完成这些绘制。

- 调用时机
    > `drawRect:` 方法并不是时时刻刻都在调用，它的调用时机主要是视图第一次加载和视图的内容需要重绘时。也就是说当 `UIView` 准备好进行绘制操作的时候，系统会自动调用 `drawRect:` 方法。

    * 视图第一次出现在屏幕上时，会调用一次 `drawRect:` 方法进行视图的渲染。
    * 调用了 `setNeedsDisplay` 或者 `setNeedsDisplayInRect:` 方法后，系统会在下一个绘制周期中调用 `drawRect:` 方法进行视图的重绘。

- 性能影响
    > 由于 `drawRect:` 方法会占用大量 `CPU` 资源进行图形的绘制，因此过度使用或者不合理使用 `drawRect:` 方法会导致 `CPU` 使用率上升，从而影响应用的性能。
    
    * 避免在 `drawRect:` 方法中进行复杂的计算或者耗时的操作，这会降低绘制的效率。
    * 不要主动直接调用 `drawRect:`，而是应当通过 `setNeedsDisplay` 或 `setNeedsDisplayInRect:` 让系统来决定何时调用 `drawRect:`。
    * 如果可能，尽量减少绘制的区域。可以通过 `setNeedsDisplayInRect:` 只重绘视图中改变的那部分区域，而不是整个视图。
    * 考虑使用 `Core Animation` 或者直接操作 `CALayer`，而不是使用 `drawRect:`，以提高性能。因为 `Core Animation` 运行在专门的绘图线程，而不是主线程上，所以它的性能要优于 `drawRect:`。
    * 如果视图是静态的，即一旦被绘制就不会改变，那么可以使用 `shouldRasterize` 属性来缓存视图的绘制结果，以提高性能。

:::

#### ❓`setNeedsDisplay` vs `setNeedsLayout`

::: details 💡

  - `setNeedsDisplay`：调用此方法会标记视图为脏的，这会导致系统在下一个绘图周期中调用视图的 `drawRect:` 方法来重绘视图。
    > 通常在视图的内容发生改变时，调用此方法来请求系统重绘视图。

  - `setNeedsLayout`：调用此方法会标记视图为需要重新布局，这会导致系统在下一个更新周期中调用视图的`layoutSubviews` 方法来重新布局视图的子视图。
    > 通常在视图的尺寸或位置发生改变时，调用此方法来请求系统重新布局视图。

总结：`setNeedsDisplay` 和 `setNeedsLayout` 是异步的和非阻塞性的。`setNeedsDisplay` 请求系统重新绘制视图，而 `setNeedsLayout` 则请求系统重新布局视图的子视图。它们通常在视图的状态发生改变时被调用，以确保视图的外观和布局总是最新的。

:::

#### ❓`mask` 属性如何实现蒙层的

::: details 💡

> `UIView` 的 `mask` 属性可以用来实现蒙层效果。`mask` 是一个 `UIView` 对象，它的 `color` 属性定义了父 `View` 的遮罩效果。`mask` 中的不透明部分对父视图进行了截取，而透明部分会将父视图隐藏掉。

```objc
UIView *parentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
parentView.backgroundColor = [UIColor redColor];

UIView *maskView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
maskView.backgroundColor = [UIColor blackColor];

(parentView.mask = maskView;)
```

在上述代码中，我们创建了两个 `UIView` 对象：parentView 和 maskView。parentView 是我们需要添加蒙层效果的视图，而 maskView 就是我们的蒙层视图。通过设置 parentView 的 mask 属性为 maskView，我们就可以实现对 parentView 一半区域的遮罩效果。

为了使用非黑白蒙层，可以使用 CALayer 的 mask 属性，并设置 CALayer 上的具体图形。这样就可以实现更丰富的遮罩效果。

同样的原理也可用于 UIImageView，UIButton 等其它 UIKit UI 控件。

:::

### 自动布局

#### ❓`AutoLayout` 的底层实现

::: details 💡

> `AutoLayout` 是 `Apple` 为 `iOS` 和 `macOS` 开发的一种界面布局系统，它使用一套比较复杂的线性不等式自动计算和调整视图控件的位置和尺寸。它的目标是让开发者能够创建自适应不同屏幕尺寸和设备方向的界面。

  在底层，`AutoLayout` 是通过创建和解决约束来实现的。约束是一种规则，用于定义视图之间的关系，例如一个视图的宽度约束可能规定它要比另一个视图宽两倍。`AutoLayout` 系统负责收集所有的约束，然后找出满足所有规则的解，即每个视图的正确位置和尺寸。

  `AutoLayout` 使用了一个叫做 `Cassowary` 的算法来解决约束，这是一种线性约束解决器，目前被广泛用在各种应用中，如动画、游戏和实时模拟中。
    
:::

#### ❓`AutoLayout` 的原理，性能如何

::: details 💡

- 原理：
    > `AutoLayout` 通过制定一组约束来描述用户界面中的一些布局关系和尺寸属性。这些约束代表了视图与其他视图的相对位置关系、视图自身的尺寸以及视图的尺寸和父视图之间的相对关系等等。然后使用数学算法计算出满足所有约束条件下视图的最优位置和大小。
    
    > 当屏幕尺寸、视图层次、约束条件以及设备方向等条件改变时，系统可以自动的通过算法重新计算并调整视图的位置和尺寸。因此，`AutoLayout` 提供了强大的工具，让开发者能够设计出能在各种尺寸和条件下都能良好显示的界面。

- 性能：
    > 使用 `AutoLayout` 可以省去很多手动计算和调整布局的工作，大大提高了开发效率，同样在处理各种设备尺寸和方向变化时，可以保持良好的界面显示。但是，`AutoLayout` 的性能并不总是最佳的。因为满足约束条件需要通过数学计算，并且复杂的界面和大量的约束可能使得这个计算过程变得复杂和耗时，特别是在一些动态改变约束和布局的情况下。

总结：`AutoLayout` 是一个功能强大，使用方便的布局工具，适合大多数情况下使用。但如果面临一些复杂和高效能需求的界面，可能需要考虑其他的布局方式，比如手动布局或使用第三方布局库。

:::

#### ❓`Masonry` 的约束应该写在哪里

::: details 💡

  > `Masonry` 是一个轻量级的布局框架，采用链式编程的方式，让 `AutoLayout` 使用变得更加简单。通常在初始化视图和更新视图布局的地方使用 `Masonry`。

可以把 `Masonry` 的约束写在以下地方：

- 对于 `UIView` 可以在初始化方法 `init` 或者 `initWithFrame:` 中设置约束。

    ```objc
    - (instancetype)init {
        self = [super init];
        if (self) {
            [self setupViews];      // 完成子视图的添加
            [self setupConstraints];// 设置 Masonry 的约束
        }
        return self;
    }
    ```

- 对于 `UIViewController` 可以在 `viewDidLoad` 方法中设置视图约束。

    ```objc
    - (void)viewDidLoad {
        [super viewDidLoad];
        [self setupViews];
        [self setupConstraints];
    }
    ```

- 如果视图布局会在运行时动态改变，那可以在 `updateViewConstraints` 方法中更新约束。

    ```objc
    - (void)updateViewConstraints {
        [super updateViewConstraints];
        // 更新 Masonry 的约束
    }
    ```

:::

#### ❓有左右两个 `UILable`，要让左边内容全部展示，怎么布局

::: details 💡

> `setContentCompressionResistancePriority` 和 `setContentHuggingPriority` 是两个用于处理 `AutoLayout`系 统如何确定用户界面的空间分配的不同方法。

  - `setContentCompressionResistancePriority`: 这种优先级决定了在空间不足的情况下，视图是否愿意减少其大小。
    > 如果视图的 `Compression Resistance` 优先级较高，它就不愿意缩小自己的大小，因此可能导致其他优先级低的视图要缩小自己的大小。换句话说，该优先级值更高的视图会尽量保留其原始大小，甚至可能导致其他视图被压缩。

  - `setContentHuggingPriority`: 这种优先级决定了在空间充足的情况下，视图是否愿意增加其大小。
    > 如果视图的 `Hugging` 优先级较高，它就不愿意增大自己的大小，因此可能导致其他优先级低的视图要增大自己的大小。换句话说，该优先级值更高的视图会尽量保持紧凑，不愿意占用额外的空间，甚至可能放大其他视图的大小。

总结：`setContentCompressionResistancePriority` 控制视图在空间不足时的表现，`setContentHuggingPriority` 控制视图在空间充足时的表现。这两个优先级可以帮助你更深入地控制具有动态内容大小的视图的表现，以得到符合期望的用户界面布局。

```swift
let leftLabel = UILabel()
leftLabel.text = "Left Label Full Text"
leftLabel.numberOfLines = 0 // 如果希望支持多行的话
// 设置左边压缩阻力优先级高，保证内容全部显示
leftLabel.setContentCompressionResistancePriority(.defaultHigh, for: .horizontal)

let rightLabel = UILabel()
rightLabel.text = "Right Label Text"
// 设置右边压缩阻力优先级低，内容会为压缩
rightLabel.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)

let stackView = UIStackView(arrangedSubviews: [leftLabel, rightLabel])
stackView.axis = .horizontal
stackView.spacing = 10
```
:::

------

## 图片

### 图片读取

#### ❓`Images.xcassets` 和直接用图片有什么不一样

::: details 💡
  
  - 组织: `Images.xcassets` 可以更方便的管理和组织图片资源。在`Images.xcassets`中，可以创建各种不同类型的 `asset`（例如`App`图标，`Launch Images`，以及通用的图片等）并且可以为每一个 `asset` 创建多种尺寸的图片以适应不同的设备和显示屏。
  
  - 自动适应：`Images.xcassets` 可以为一个图片资源提供多种不同的版本（`1x, 2x, 3x`），然后系统会根据设备自动选择合适的图片使用，而如果直接使用图片文件，则需要你手动管理这一部分。
  
  - 优化：`Images.xcassets` 能够自动优化应用的大小。
    > 例如，如果应用安装在一个只支持 `1x` 分辨率的设备上，那么只有 `1x` 版本的图片会被包含在应用安装包中，`2x` 和 `3x` 版本的图片不会被包含。同样如果使用了 `App Thinning` 功能，它会根据设备，移除不需要的资源，以减少应用的大小。
  
  - 使用效果：`Images.xcassets` 从代码中获取图片只需要图片的名字，而直接使用图片文件的话，需要知道图片的完整文件名，包括扩展名，这方面 `Images.xcassets` 更为方便。
  
总结：使用 `Images.xcassets` 可以更好地管理和组织你的图片资源，它为图片提供了多分辨率支持，并且可以帮助优化应用的大小。如果直接使用图片文件，可能会导致组织混乱，更难以支持多个分辨率，且可能会浪费存储空间。

:::

#### ❓`imageName` vs `imageWithContentsOfFile`

::: details 💡

`UIImage` 的 `imageName:` 和 `imageWithContentsOfFile:` 是两种不同的方法，用于从应用的 `bundle` 中加载图片。

  - `imageName:` 方法是用于从应用的 `主 bundle` 中加载图片的，它会自动根据设备的屏幕类型（比如，`Retina`屏幕）来选择合适的图片（比如，自动选择 `@2x` 或 `@3x` 的图片）。
    > 这个方法也会自动地对加载的图片进行缓存，所以如果你使用该方法多次加载同一张图片，实际上只会加载一次，剩下的调用会直接从缓存中获取图片。这就意味着这个方法在加载大量重复图片时，处理速度会很快。

  - `imageWithContentsOfFile:` 方法则是直接从指定的文件路径中加载图片，它并不会根据屏幕类型来自动选择图片，也不会对加载的图片进行缓存。
    > 每次调用这个方法时，系统都会从磁盘中读取图片数据，这可能会花费更多的时间。如果想要加载一次性使用并且不需要缓存的大图片，这个方法可能会更适合。

总结：`imageName:` 更适合用来加载经常使用的小图片，而 `imageWithContentsOfFile:` 则更适合加载一次性使用的大图片。

:::

#### ❓多个相同的图片，会重复加载吗

::: details 💡

  如果使用`UIImage`的`init(named:)`或`imageNamed:`方法来创建一个图片对象，这个方法会先在缓存中查找是否已经存在相同的图片。如果缓存中存在，那么就会直接从缓存中返回，而不会重新加载。因此，这个方法在加载相同图片时不需要加载多次，会直接从缓存中读取，性能更好。

  如果使用`UIImage`的`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法来加载图片，那么每次调用都会从文件中重新读取，即使在前面已经加载过同一个文件的图片。这是因为这种方法不会使用系统的图片缓存。

因此，如果有多个相同的图片需要加载，且这些图片会频繁使用，那么推荐使用`init(named:)`或`imageNamed:`方法，利用系统的缓存机制，避免重复加载图片，提升性能。如果图片仅用一次，或者图片文件非常大，不适合放入缓存，那么可以考虑使用`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法。

:::

### 图片处理

#### ❓如何高性能的给 `UIImageView` 加圆角

::: details 💡

 给 `UIImageView` 添加圆角有多种方式，但并非所有方法都是高效的。一些常见的方式可能会引入性能问题，例如直接修改视图的 `.layer.cornerRadius` 属性，因为这会导致离屏渲染，影响到性能。

以下是一种高效的给 `UIImageView` 添加圆角的方法，该方法使用了 `Core Graphics` 框架：

```swift
let imageView = UIImageView(image: UIImage(named: "example"))
// 圆角半径
let radius: CGFloat = 10.0 
// 创建一个CGRect，其尺寸与 UIImageView 的 frame 匹配
let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: imageView.frame.size) 
// 创建一个 CGMutablePath，并将该路径添加到一个 CAShapeLayer
let path = UIBezierPath(roundedRect: rect, cornerRadius: radius)
let maskLayer = CAShapeLayer()
maskLayer.path = path.cgPath
// 将这个 CAShapeLayer 设置为 UIImageView 的遮罩层
imageView.layer.mask = maskLayer
```

这种方式不会导致离屏渲染，只会在合成阶段发生，因此比直接修改视图的 `.layer.cornerRadius` 属性更为高效。

:::

### 图片渲染

#### ❓图片解码发生的时机是什么

::: details 💡

> 在 `iOS` 中，图片解码的时机通常在将图片用于绘制前，如在 `UIImageView` 的 `setImage` 函数中，或者在自行调用绘制的过程中。

  系统默认在载入图片时(通过 `[UIImage imageNamed:]` 或者 `UIImage(contentsOfFile:)` 等方法)，并不会立即解码图片，而是将压缩的图片数据保存在内存中。当将这个 `UIImage` 实例赋值到 `UIImageView` 或者通过其他方式进行绘制时，会在绘制循环中对其进行解码。

  这种延迟解码帮助系统尽可能的节省内存。这样，系统就可以更智能地管理其 `RAM`。例如，如果加载了一张图片但是从来没有使用它，那么系统就不会花费时间和资源去进行解码。

总结：`UIImage` 只负责管理图片数据，至于这些数据何时解压缩成位图，取决于何时实际绘制这个 `UIImage`。

:::

#### ❓图片怎么显示的，以及图片缓冲区

::: details 💡

图片在屏幕上显示流程：

  - **加载**：首先从磁盘或网络上将二进制数据加载入内存，这些二进制数据描述了图像信息。

  - **解码**：加载完毕后，图像会被解码成位图（`bitmap`）。位图是一种非常详细的矩阵，其中每个单元（像素）记录了在对应位置的颜色信息。因此，位图的大小通常比原始的图像文件要大。

  - **渲染**：渲染图片就是将位图中的每个像素翻译成屏幕上的每个点，这个过程通常由 `GPU`（图形处理器）完成。

> 图片缓冲区，通常会通过一些图像库（如`SDWebImage`）的帮助，将常用图片保存在内存中以备快速访问。这就是所谓的图片缓冲区，也叫做图片缓存。

  图片缓存的目的是提高性能和减少网络或磁盘 `I/O` 的使用。当应用程序需要显示一张图片时，它首先查看缓存，如果缓存中有这张图片，就直接用缓存中的图片，避免了从网络或磁盘上加载。如果缓存中没有，就必须从网络或磁盘加载，加载后的图片会被保存到缓存中，以便下次使用。

注意：任何缓存策略都需要考虑内存使用和过期策略。缓存太多图片会消耗大量内存，可能影响应用程序的性能或触发内存警告。同时，缓存中的图片可能会过时，应定期清除不再需要的图片。

:::

#### ❓图片渲染怎么优化

::: details 💡

  > 优化图片渲染是一门科学

  - 图片本身
    * **避免透明像素**：如果一张图片包含透明像素，那么在混合像素时 `GPU` 负担会更重。如果图片不需要透明度，最好选择不带 `alpha` 通道的图片格式，如 `JPG`。
    * **使用正确的图片格式**：不同的图片格式有不同的解压缩性能。
        > 例如，对于静态图片，`PNG` 和 `JPEG` 是常见的格式。通常，`JPEG` 格式的图片解压缩速度会比 `PNG` 快，但是 `PNG` 对透明度的支持更好。

  - 图片获取
    * **后台线程加载和准备图片**：为了避免阻塞主线程，一定要在后台线程进行图片的加载、解压缩和其他准备工作。
    * **利用图片缓存**：频繁地从磁盘加载图像是一种昂贵的操作。使用图片缓存可以避免频繁地加载同一张图片。
    * **合理设置图片分辨率**：`@2x` 和 `@3x` 的图片分辨率分别是原始尺寸的2倍和3倍，根据设备屏幕的特性选择合理的图片分辨率，避免不必要的内存消耗。
    
  - 图片加载
    * **图片预解码**：图片在渲染到屏幕之前，需要被解码成位图。
        > 这个操作会在图片第一次显示时进行，并且可能会产生一定的性能消耗。可以通过预解码（在后台线程提前进行解码）的方式把这个消耗提前。
    * **图片大小适配**：尽量保持加载的图片大小接近于它在设备屏幕上的显示大小。
        > 如果一个很小的 `UIImageView` 需要显示一个非常大的图片，那么这张图片在显示之前需要被缩放。如果图片实际尺寸过大，会导致额外的内存使用和解压缩成本。

:::

#### ❓图片是什么时候解码的，如何优化

::: details 💡

  当图片被显示在屏幕上时，图片的解码操作通常是在渲染前由 `GPU` 进行的。然后，解码后的位图像素被存储在内存中，用于显示。此过程可能会对性能产生影响，尤其是在滚动动画或切换动画等场景中。

  如果希望优化图片解码，有一种常用的方法是对图片进行预解码。预解码是在主线程渲染前，提前在后台线程将图片解码，而不是等待 `GPU` 在显示的时候进行解码。在其进行解码的过程中，`CPU` 的压力会提高，但同时可以降低 `GPU` 负载，避免在渲染过程中进行解码导致的帧数下降。

  可以通过使用 `Core Graphics` 的 `API` 来对图片进行预解码。具体过程是使用 `CGImage` 创建一个 `CGBitmapContext`，然后将图片绘制到这个 `context` 中。这样，当图片第一次显示在屏幕上时，就无需再进行解码操作。

```swift
// 预解码
func predecode(image originalImage: UIImage) -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(originalImage.size, true, originalImage.scale)
    guard let context = UIGraphicsGetCurrentContext() else { return nil }
    originalImage.draw(at: .zero)
    let decodedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decodedImage
}
```

  由于预解码会增加 `CPU` 压力和内存消耗，所以需要在合适的时机进行，比如在后台线程，用户滚动列表的滑动减速或者停止的时候，或者在图片将要显示之前的闲暇时间。务必要避免在用户滑动列表的过程中进行预解码，因为这个时候进行预解码可能会导致卡顿。另外，过多的预解码也可能导致内存暴涨，所以需要权衡当下的需求和设备性能。

:::

### 大图渲染

#### ❓如何用 `UIImageView` 显示超大分辨率的图，如何支持缩放

::: details 💡

  `UIScrollView` 支持在 `iOS` 设备上进行滚动和缩放操作。如果希望显示一张大图并支持缩放，应该把 `UIImageView` 作为 `UIScrollView` 的子视图。

```swift
class ViewController: UIViewController, UIScrollViewDelegate {
    var imageView: UIImageView!
    var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        // 创建一个 UIScrollView 实例
        scrollView = UIScrollView(frame: view.bounds)
        // 设定 zoom 缩放的最小/最大倍数
        scrollView.minimumZoomScale = 1.0
        scrollView.maximumZoomScale = 6.0

        // 加载一张大图(up to you)
        let image = UIImage(named: "LargeImageName")    
        imageView = UIImageView(image: image)
        imageView.frame = CGRect(x: 0, y: 0, width: image?.size.width ?? 0, height: image?.size.height ?? 0)
        
        //将 ImageView 添加到 ScrollView 中 
        scrollView.addSubview(imageView)
        scrollView.contentSize = imageView.bounds.size
        
        //设置代理
        scrollView.delegate = self

        //添加 ScrollView 到主视图中
        view.addSubview(scrollView)
    }

    func viewForZooming(in scrollView: UIScrollView) -> UIView? {
        return imageView // 返回需要缩放的视图
    }  
}  
```

  对于极其大的图片还是可能有内存问题。如需处理这种情况，可能需要使用像 `CATiledLayer` 这样的技术，它可以分块渲染视图，而不是一次性渲染整个大图。
  
  由于 `UIImageView` 通过 `UIImage` 加载图片，是一次性将图片加载到内存，超大图片会引发内存不足的的问题。所以这个时候不能一次全部加载，需要使用分治思想，将图片像素点分块加载，只加载可视区域像素点。使用 `Tile Rendering` 的解决方案，类似家庭装修贴地砖的方式，先将图片像素按照一定的大小分割成 `Tile`，然后根据图片显示区域渲染。`CATiledLayer` 是一种适用于处理大量数据的渲染的 layer，适合处理这种情况。
  
  缩放功能可以通过将 `UIImageView` 嵌套在 `UIScrollView` 里面，根据缩放的代理回调，进行 `Tile` 的重新绘制。

:::

#### ❓如何将一张内存极大的图片可以像地图一样的加载出来

::: details 💡

  处理极大图片（比如说地图）时，加载整张大图到内存通常是不可行的，因为将会占用太大内存，而手机设备的内存是有限的。为了处理这个问题，通常的做法是分块加载和显示图片——只把当前需要显示在屏幕上的那一部分加载到内存。当用户滚动或缩放图片时，就加载新的部分，同时释放不再需要的部分。这就是所谓的 “切片”（tiling）技术。

  可以使用 `CATiledLayer` 来实现图片的切片加载。
  
  > `CATiledLayer` 是一种特殊的 `CALayer`，它将内容分成多个小的矩形块或"切片"，并且只在需要的时候绘制这些切片。当提供内容时，只需画出指定的矩形区域即可，其它区域则由 `Core Animation` 自动处理。此外，`CATiledLayer` 甚至支持多级别的细节，这使得可以非常容易地实现复杂的地图或图片浏览器功能。

注意：`CATiledLayer`的使用相对复杂，它需要自行管理图片资源并根据需要进行绘制。`MapKit` 就是使用这种技术。另外，一些图片浏览器库，如 `FastImageCache`，也可以处理大图，它实现了自己的切片和缓存机制。

:::

------

## 动画

### UIKit 动画

#### ❓`UIKit Animation` vs `Core Animation`

::: details 💡

  - **UIKit Animation**: 一个更高的抽象层进行编程操作。
    > 可以简单的使用 `UIView` 类的动画方法，如 `UIView.animate(withDuration:animations:)`，轻松实现许多动画，如移动、旋转、改变透明度、改变颜色等。

    ```swift
    // 将一个视图在2秒内从屏幕左边移到右边
    UIView.animate(withDuration: 2) {
        view.frame.origin.x = self.view.frame.width - view.frame.width
    }
    ```

  - **Core Animation**: 提供了更底层和更强大的动画控制。
    > 与 `UIKit` 动画相比，它可以实现更复杂的动画，如复杂的转换，3D效果，关键帧动画等。

    ```swift
    // 使用 Core Animation 创建关键帧动画：使视图在2秒内沿着预定的路径移动
    
    // 创建一个 CAKeyframeAnimation 实例
    let animation = CAKeyframeAnimation(keyPath: "position")
    // 设置关键帧
    animation.values = [NSValue(cgPoint: CGPoint(x: 50, y: 50)),
                        NSValue(cgPoint: CGPoint(x: 100, y: 100)),
                        NSValue(cgPoint: CGPoint(x: 50, y: 150))]
    // 动画时间
    animation.duration = 2
    // 将动画添加到视图层
    view.layer.add(animation, forKey: nil)
    ```

:::

#### ❓`UIKit Animation` vs `UI Dynamics`

::: details 💡

  - **UIKit Animation**：主要用于创建简单，直观和以时间为基础的动画。
    
    ```swift
    // 在1秒内改变视图的背景颜色和大小
    UIView.animate(withDuration: 1) {
        view.backgroundColor = .blue
        view.frame.size = CGSize(width: 100, height: 100)
    }
    ```

  - **UI Dynamics**：一种创建物理基础的模拟动画的方法。
    > 可以为视图创建如弹力，碰撞，重力这样的物理特性的动画。当希望视图的动画看起来 “感觉像现实世界中的物体那样移动” 那么 `UI Dynamics` 是最好的选择。
    
    ```swift
    // 视图会根据重力方向进行动画模拟
    let gravity = UIGravityBehavior(items: [myView])  // 创建重力行为
    animator = UIDynamicAnimator(referenceView: view)
    animator.addBehavior(gravity)
    ```

:::

### 核心动画

#### ❓隐式动画 vs 显示动画

::: details 💡

> 隐式动画和显示动画是在 `Core Animation` 框架中用来描述动画类型的两个术语。

  - **隐式动画**：默认的动画类型。
    > 当修改 `CALayer` 的可动画属性时，系统会自动创建并运行动画——这就是所谓的隐式动画。

    ```swift
    // 图层的位置会以动画的形式移动到新位置，而不是立即跳到那里
    layer.position = CGPoint(x: 200, y: 200)
    ```

  - **显示动画**：明确地创建一个 `CAAnimation` 对象，设置它的属性，然后将它添加到图层。显示动画给了开发者对动画行为更精细的控制，包括动画的时间线和动画的进度曲线等。

    ```swift
    // 在1秒内将图层的位置从(100, 100)移动到(200, 200)
    let animation = CABasicAnimation(keyPath: "position")
    animation.fromValue = NSValue(cgPoint: CGPoint(x: 100, y: 100))
    animation.toValue = NSValue(cgPoint: CGPoint(x: 200, y: 200))
    animation.duration = 1
    layer.add(animation, forKey: nil)
    ```

总结：隐式动画适用于简单和常规的动画，而显示动画则适用于需要更复杂和定制的动画效果的情况。

:::

#### ❓做一些基于 `CALayer` 的动画时，有时需要设置 `layer` 的锚点来配合动画，需要注意什么

::: details 💡

 `CALayer` 的锚点 (`anchorPoint`) 属性决定了图层的哪一点会被放在 `position` 所指的位置，也就是图层的旋转，缩放等变换动画都是围绕这个点进行的。其默认值为(0.5, 0.5)，代表图层的中心点。

修改锚点注意点：

  - **位置变化**：锚点的改变会导致图层的位置移动，因为系统会自动将图层的 `anchorPoint` 放到图层的 `position` 所指的位置。因此，当改变锚点时，可能会看到图层 “跳跃” 到新位置。

    ```swift
    // 如果不希望图层移动，那么就需要在改变 anchorPoint 后，相应地调整图层的 position
    layer.anchorPoint = CGPoint(x: 0, y: 0)  
    layer.position = CGPoint(x: 0, y: 0)
    ```

  - **布局影响**：如果有基于图层的 `Auto Layout` 约束，改变 `anchorPoint` 可能会破坏这些约束。
   
  - **动画影响**：由于图层的旋转，缩放等变化动画都是围绕 `anchorPoint` 进行的，修改此点也会影响这些动画的表现。

  - **几何形状**：`anchorPoint` 的值的范围是在 `[0, 1]` 之间，表示在图层的大小中的相对位置，而不是具体的像素点。

:::

#### ❓`Core Animation` 的实现原理

::: details 💡

工作原理：

  - 图层树（`Layer Tree`）: 所有可见内容的模型，每一个 `UIView` 都有一个对应的 `CALayer`。图层树中的元素可以改变，这包括它们的位置、大小、内容等等。

  - 呈现树（`Presentation Tree`）: 当前屏幕上显示的内容的近似模型。它代表了图层树在任何给定的时间点的可视状态。

  - 渲染树（`Render Tree`）: 这是 `Core Animation` 来创建屏幕上实际像素的模型。渲染树包含了图层树的复制品，并添加了如阴影、形状等等内容。

  在动画过程中 `Core Animation` 会在各个帧之间对图层树的改变进行插值，并更新呈现树和渲染树，然后把最后的结果渲染到屏幕上。这个过程中会尽量复用尽可能多的像素，减少重绘的数量，从而提高动画的流畅度和性能。

:::

#### ❓`Core Animation` 实现交互效果(比如让动画播放一半, 点击让它停止)

::: details 💡

要使用 `Core Animation` 来实现交互（如在动画过程中点击停止），需要访问和控制当前正在进行的动画。

```swift
var isPaused = false  // 用于追踪动画是否已暂停

func toggleAnimation() {
    let layer = self.myView.layer
    if isPaused {
        // 恢复动画
        let pausedTime = layer.timeOffset
        layer.speed = 1.0
        layer.timeOffset = 0.0
        layer.beginTime = 0.0
        let timeSincePause = layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime
        layer.beginTime = timeSincePause
    } else {
        // 暂停动画
        let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)
        layer.speed = 0.0
        layer.timeOffset = pausedTime
    }
    isPaused = !isPaused
}
```

:::

------

## 渲染

### ❓`UI` 的渲染步骤

::: details 💡

`UI` 的渲染步骤：

  - **布局阶段**：`UIKit` 会计算出所有的视图的大小和位置。这个过程涉及到 `AutoLayout` 和 `Core Animation`，视图的位置和大小会被更新，同时所有的视图约束也会得到满足。对于 `UIView`，这一步涉及到了 `layoutSubviews` 方法。

  - **显示阶段**：所有需要的视图都会被调用 `drawRect:` 方法进行绘制。这里会调用 `Core Graphics` 来进行实际的绘制操作，在视图的 `layer` 上生成一张 `bitmap` 图片代表这个视图。

  - **准备阶段**：这一步主要是将所有的 `Core Animation` 动画提交给渲染服务器。

  - **渲染阶段**：
    * 这一步会进行事务的提交，所有的 `layer tree` 结构会在主线程中拷贝一份到渲染线程。
    * 然后，渲染线程会将视图的 `layer tree` 全部转换为 `OpenGL` 命令或者 `Metal` 命令，最后将其提交给 `GPU`。
    * `GPU` 会进行实际的绘制操作，包括光栅化、混合等步骤，最后将渲染结果显示到屏幕上。
   
  在整个渲染过程中，对 `CPU` 和 `GPU` 的使用是需要权衡的。对于由 `CPU` 进行的布局和显示工作，如果过于复杂，可能导致帧率下降，因为 `CPU` 无法在每帧刷新的时间限制内完成所有工作。对于 `GPU` 来说，过于复杂的渲染操作也可能导致性能问题，比如复杂的渲染效果或者过深的视图层次都可能导致 `GPU` 无法及时完成渲染。

总结：`UIKit 布局` => `Display` => `Prepare` => `Core Animation 提交事务` => `GPU 渲染`。整个过程如果在 16.7ms 之内完成，就能保证界面动画的流畅性。如果超过这个时间，就会出现丢帧卡顿现象。所以在开发中要尽量优化布局和渲染过程，避免过于复杂的操作。

:::

### ❓什么是屏幕渲染

::: details 💡
  
  | 渲染类型 | 说明
  | --- | ---
  | `CPU` 渲染 | 简单视图 `CPU` 渲染可能高于 `GPU` (不需要创建缓冲区和上下文切换)
  | `GPU` 渲染 | `GPU` 浮点运算能力强于 `CPU`，所以 `GPU` 渲染效率高于 `CPU`

  * **屏幕渲染**(On-Screen Rendering) : 在当前屏幕的缓冲区进行渲染。
    > 优点：不需要创建新的缓存，也不需要进行上下文切换，性能较好；缺点：缓存大小受限制，无法进行复杂的操作。
    
  * **离屏渲染**(Off-Screen Rendering) : `GPU` 在当前屏幕外，新开辟了一个缓冲区进行图片的渲染和合成。
    > 渲染完成之后再放入当前屏幕的缓冲区。这个过程需要 `CPU` 调度，将任务分配给 `GPU` 进行渲染然后再将渲染结果返回，需要进行上下文切换和内存读写等操作，对性能影响较大。
  
:::
  
### ❓哪些场景可以触发离屏渲染
  
::: details 💡

  > 离屏渲染：图形或文字无法在当前屏幕缓冲区完成渲染，需要额外创建一个图形缓冲区进行操作，完成后再加载到当前屏幕缓冲区显示。

`iOS` 以下几种场景会触发离屏渲染：

  - 使用阴影效果：如果给 `UIView` 添加阴影效果，会触发离屏渲染。如果可以的话，使用 `shadowPath` 来指定阴影路径，可以避免离屏渲染。
    > `layer.shadowXXX`
   
  - 使用圆角效果：对 `UIView` 的图层进行圆角裁剪(`cornerRadius`)时，如果同时设置了 `masksToBounds` 也会触发离屏渲染。
    > `layer.masksToBounds = true & layer.cornerRadius > 0`
   
  - 使用遮罩(mask)：`CALayer` 的 `mask` 属性可以设置遮罩，给视图层添加遮罩也会触发离屏渲染。
    > `layer.mask`
   
  - 使用光栅化：`shouldRasterize` 属性可以将图层缓存为位图并在 `GPU` 中重用，但这同时也会触发离屏渲染。
    > `layer.shouldRasterize = true`
   
  - 抗锯齿：设置视图的 `layer` 的 `allowsEdgeAntialiasing` 属性为 `true` 会触发离屏渲染。因为抗锯齿需要对视图的边缘像素进行额外的计算和混合，这些操作不能在当前屏幕的缓冲区完成，因此需要离屏渲染。所以，在大部分情况下，如果不是对视觉效果有非常高要求，通常不推荐开启抗锯齿，因为这会增加GPU压力，降低性能。
    > `layer.allowsEdgeAntialiasing = true`
  
  - 不透明度：设置视图的 `alpha` 值本身不会触发离屏渲染。但是有一种场景需要注意，那就是对有子视图的视图设置 `alpha` 值，并且该视图的 `opaque` 属性为 `true` 时，可能会造成额外的离屏渲染。这是因为系统需要先单独绘制这个视图和它的子视图到一个临时的缓冲区，然后将这个临时的缓冲区以指定的 `alpha` 值（也就是透明度）绘制到屏幕上。因此，为了避免这种离屏渲染，当你需要设置视图的`alpha` 值时，应该设置它的 `opaque` 属性为 `false`。
    > `opacity & opaque = true`

  离屏渲染对系统资源消耗比较大，因为它需要创建新的缓冲区，进行上下文切换，最后再把缓冲区的内容载入到屏幕缓冲区。如果在一个视图中使用过多的离屏渲染，可能会导致性能问题，所以在开发过程中需要尽量避免触发离屏渲染。

:::

------

## 事件响应

### ❓用户点击屏幕上按钮，整个过程讲一下

::: details 💡

  - 当用户触摸屏幕时，硬件会将触摸事件转化为一个或一系列的 `UITouch` 对象，并将它们与一次特定的事件(`UIEvent`对象)关联起来。系统会将触摸事件派发给对应的 `UIApplication` 对象。

  - `UIApplication` 对象接收到触摸事件后，会将事件传递给合适的 `UIWindow` 对象。`UIWindow` 对象再将其分发给正在显示的、并且能够响应事件的 `UIView` 对象。 

  - 如果此 `UIView` 对象就是所点击的视图(如：按钮 `UIButton` 对象)，那么此按钮会接收到此点击事件。

  - `UIButton` 对象接收到手势事件后，便会根据事件类型来调用对应的方法。
  
  - 若 `UIButton` 对象存在 `UIControl` 事件（比如 `TouchUpInside`）并且挂接有对应的 `Action`（函数方法），那么系统就会执行这个 `Action`。

:::

### 响应链

#### ❓第一响应者是谁

::: details 💡

> "第一响应者"：指当前接收并处理用户事件或者用户输入的对象，例如触摸事件、键盘输入等等。可以成为第一响应者的对象主要有 `UIView`、`UIViewController` 以及其子类。

  🌰 当用户在一个文本框（`UITextField`）中输入文本的时候，这个文本框就是第一响应者，因为它是当前接收并处理键盘输入的对象。

  同一个时间点上，只能有一个对象是第一响应者。第一响应者可以通过调用 `resignFirstResponder` 方法来放弃第一响应者的身份，同时其他对象可以通过调用 `becomeFirstResponder` 方法来成为新的第一响应者。
    
  `UIResponder` 是负责处理触摸事件、运动事件（如摇晃设备等）以及远程控制事件的基类，`UIView` 和 `UIViewController` 都是 `UIResponder` 的子类。所以，应用中的各种交互和操作的响应，都是由经过了一系列响应者对象链条的传递和处理来完成的，称为 `responder chain` 第一响应者就是这个链条的起点。

:::

#### ❓`UIView` 和 `UIResponse` 的关系是什么

::: details 💡

> 继承关系，`UIView` 是 `UIResponder`的子类。

  - `UIResponder`是一个抽象的基类，它为处理和转发触摸事件、运动事件（例如：摇晃设备）、远程控制事件（例如：耳机控制）等提供了基本的行为。所有能够处理上述事件的类，如 `UIView`、`UIViewController`，甚至 `UIApplication` 都是 `UIResponder` 的子类。

  - `UIView` 是 `iOS` 界面元素中最核心的一个类，它继承自 `UIResponder`，所以 `UIView` 除了具有显示视图的功能之外，同时也能够接收并处理用户的触摸事件，或者将它转发出去。

总结：`UIView` 是一个既可以视觉呈现，又可以接收和处理用户触摸事件的类，这种特性就是由于继承了 `UIResponder` 而来。

:::

#### ❓如何通过一个 `UIView` 如何快速拿到显示它的控制器

::: details 💡

> 在 `iOS` 开发中，`UIView` 没有直接的属性或者方法可以获取到其所在的 `UIViewController`。但可以通过响应者链条（`Responder Chain`）遍历获取到当前 `View` 的 `controller`。

::: code-tabs

@objc
```objc
@implementation UIView (ViewController)
- (UIViewController *)viewController {
    UIResponder *responder = self;
    while ((responder = [responder nextResponder])) {
        if ([responder isKindOfClass: [UIViewController class]]) {
            return (UIViewController *)responder;
        }
    }
    return nil;
}
@end
```

@tab swift
```swift
extension UIView {
    var viewController: UIViewController? {
        var next: UIResponder? = self
        while next != nil {
            next = next?.next
            if let vc = next as? UIViewController {
                return vc
            }
        }
        return nil
    }
}
```

:::

#### ❓传递链 vs 响应链

::: details 💡
  
  - 事件传递链：一次用户交互（比如点击、滑动等）触发的事件会从顶级视图开始，沿着视图层级结构传递，直到有视图响应该事件，这就构成了一条事件传递链。
    > 事件的传递顺序为：`UIWindow --> 顶部视图 --> 子视图 --> ...直到找到能够处理此事件的最合适的视图`
  
    * 当用户触摸屏幕产生一个触摸事件，事件首先会被发送到 `UIApplication` 对象。
    * `UIApplication` 对象会将事件发送给 `keyWindow`，这是传递链的顶层。
    * `UIWindow` 对象会判断是否需要自身处理该事件，如果需要处理，事件就停止传递，进入响应链进行处理。否则，`UIWindow` 对象会将事件传递给它的子视图。
    * 子视图按从上到下的顺序依次接收事件，检查是否需要自己来处理。如果需要，它就停止传递并进行处理。否则，继续向它的子视图传递。
    * 最后，这个过程不断递归，直到找到一个能处理此事件的视图或所有可能的视图都被检查过。
    * 如果没有任何视图处理这个事件，事件将会被丢弃。
  
  - 事件响应链(`Event Responder Chain`)：一旦有视图开始响应事件，那么这个事件就会从这个视图开始，沿着 `UIKit` 框架的响应者链条向上传递，至于响应者链条的结束位置，取决于当前视图的 `nextResponder` 是谁，最后会到达 `UIApplication`，如果 `UIApplication` 也不能处理该事件，那么事件将被丢弃。
    > 事件的响应顺序为：`响应视图 --> 父视图 --> ... --> 控制器 --> UIWindow --> UIApplication --> 丢弃`
    
:::

#### ❓响应者链条，一个视图不响应的原因

::: details 💡

  > 响应者链条（`Responder Chain`）是 `iOS` 中用来处理界面的 `touch`、`motion`、键盘事件的机制。每个事件有一个接收者，叫做第一响应者 (`First Responder`)，由 `UIApplication` 管理。如果该对象不能处理这个事件，那么它会沿着响应者链向上查找可以处理这个事件的响应者。

一个视图不响应的原因：

  - `userInteractionEnabled` 属性被设置为 `false`。
    > 默认情况下，所有 `UIView` 对象的 `userInteractionEnabled` 属性为 `true`。但是如果手动设置为 `false`，这个视图和它的所有子视图都不能再响应用户的操作。
  
  - 视图隐藏或者透明度极低
    > 视图的 `hidden` 属性设为 `YES` 或者 `alpha` 的值小于 0.01，这个视图除非成为第一响应者，否则对事件无响应。
  
  - 视图被其它视图遮挡。
    > 如果视图 A 被视图 B 完全或者部分遮挡，并且覆盖部分位于用户点击的位置，那么这个事件将被视图 B 捕获。
  
  - 视图超出超视图 `bounds`。
    > 当视图自身超出其父视图的区域范围，超出部分不再响应事件。

  - 视图不在视图层级中。
    > 如果视图还未被添加（或被移除）到视图层级中，那么它将不能响应事件。
    
:::

#### ❓叠在一起的两个 `View` 哪个会响应

::: details 💡

  - 视图的层次结构：如果两个视图A和B叠在一起，那么对事件的响应权取决于这两个视图在其父视图中的添加顺序。
    > `UIView` 的子视图是按照数组的顺序存放的，后添加的子视图会在数组的后面，而响应事件的优先级则是从数组的后面向前遍历的。所以如果视图A是后添加到其父视图中，那么视图A会遮挡住视图B，并捕获并处理用户的触摸事件。
    
  - z 轴的高度：如果为视图设置了`layer.zPosition`，可以改变视图在z轴上的位置，`zPosition` 值越大，视图越靠前，更可能接收到事件。

:::

> ❓如果不想让上面的 `View` 响应，怎么解决

::: details 💡

  - 设置`userInteractionEnabled`属性为`false`。
    > 这将禁用用户在上面的视图上的交互，把事件传递到它下面的视图。

    ```swift
    topView.userInteractionEnabled = false
    ```

  - 重载上面视图的 `hitTest:withEvent:` 方法。
    > 它的目的是找到能响应事件的最佳视图。你可以重写这个方法，让它返回下面的视图。

    ```swift
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        let hitView = super.hitTest(point, with: event)
        if hitView == self {
            return beneathView
        }
        return hitView
    }
    ```

  - 重写视图的 `pointInside:withEvent:` 方法，此方法用于检查触摸点是否在视图内。
    > 如果点在上面的视图外，触摸事件就会传递给它的底层视图。

    ```swift
    override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        // 在这里检查点是否在你想要的区域内
    }
    ```

:::

> ❓如果两个 `View` 都要响应呢

::: details 💡

  - 自定义 `UIView` 子类并重写 `hitTest` 方法或者 `pointInside:withEvent:` 方法来决定哪个视图需要处理接收到的触摸事件。

  - 在一个父视图中进行触摸事件的处理并在适当的时候传递给子视图。

    ```swift
    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -> UIView? {
        let view = super.hitTest(point, withEvent: event)
        if view == self {
            return otherView;
        }
        return view
    }
    ```

:::

### hitTest

#### ❓`hitTest` 和 `pointInside` 的关系

::: details 💡

  - `hitTest:withEvent:` 是用来确定触摸事件应该由哪个子视图处理的方法。
    > 当用户触摸屏幕时，`UIKit` 会询问顶级视图来找出正确的视图处理事件。它会调用 `hitTest:withEvent:` 把触摸点的坐标和触摸事件作为参数传入。

  - `hitTest:withEvent:` 方法的实现通常会调用 `pointInside:withEvent:` 来检查触摸点是否在视图的 `bounds` 内。
    > 如果 `pointInside:withEvent:` 返回 `true`，那么 `hitTest:withEvent:` 就会返回这个视图，表示这个视图可以接收并处理这个触摸事件。
   
  - 如果视图是一个容器视图，并且包含其他子视图，`hitTest:withEvent:` 的实现通常会遍历所有的子视图，并且这个遍历通常是按照反序进行（也就是从顶层子视图到底层子视图）。
    
    * 对于每个子视图，都会调用 `hitTest:withEvent:`。如果这个方法返回了一个非 `nil` 的视图，那么遍历就会立即停止，并且这个被返回的视图会被认为是最合适处理这次触摸事件的视图。
    * 如果 `pointInside:withEvent:` 对所有子视图都返回 `false`，那么 `hitTest:withEvent:` 也就会返回 `nil`，表示这个视图和它的子视图都没有接收这次触摸事件。
  

:::

#### ❓`hitTest` 有重写吗

::: details 💡

  `hitTest:withEvent:` 可以在子类中重新实现，以更改触摸事件处理的默认行为。默认的实现会遍历视图层次结构，找出在给定点的视图，可以通过重写这个方法来定制这一行为。

```swift
// 扩大了一个视图的触摸区域
override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    let biggerRect = self.bounds.insetBy(dx: -30, dy: -30)
    return biggerRect.contains(point) ? self : nil 
}
```

:::

### 情景题

#### ❓A 的子视图 B，B 里有一个按钮 C，C 的显示范围超出了 B，点击超出范围的 B 会有响应吗

::: details 💡
  
  视图的用户交互区域默认只限制在其范围内，也就是说，如果一个子视图的部分被绘制在其父视图的范围之外，那么只有在子视图范围内的部分能接收到用户的触摸事件。

  按钮 C 的一部分超出了其父视图 B 的范围，那么对于这部分超出范围的区域，即使用户点击了，也不会触发按钮 C 的点击事件。也就是说，当点击超出 B 视图范围的 C 按钮部分时，按钮 C 不会响应。
    
  注：有一种例外情况，即当父视图重写了 `-(UIView *)hitTest:withEvent:` 或者 `- (BOOL)pointInside:withEvent:` 方法，可以让超出父视图范围的子视图接收到触摸事件。在默认情况下，一个视图只能在其 `frame` 之内接收和响应用户的触摸事件。但如果重写了上述方法，就可以手动改变这个行为。
  
:::

------

## 算法

### ❓寻找最近的公共 `View`

::: details 💡

```swift
// 寻找两个子视图最近的公共父视图
func findNearestCommonAncestor(view1: UIView, view2: UIView) -> UIView? {
    var currentView: UIView? = view1
    while let view = currentView { // 递归视图的父视图
        // 判断 view2 是否为当前遍历父视图的后代视图，如果是就是公共父视图
        if view2.isDescendant(of: view) { 
            return view
        }
        currentView = view.superview
    }
    return nil
}
```

:::

### ❓打印一个 `View` 的所有子 `View`，要求分层打印

::: details 💡

> 树的层序遍历问题

```swift
// 队列(Queue)来实现树的层次遍历
func printSubviewsInLevelOrder(for view: UIView) {
    var queue = [UIView]()
    queue.append(view)
    while !queue.isEmpty {
        var count = queue.count // 当前层数量
        var levelViews = [UIView]() // 当前层视图
        while (count > 0) {
            let levelView = queue.removeFirst()
            levelViews.append(levelView)
            count -= 1
            // 将当前层视图子视图继续加入队列
            for subview in levelView.subviews {
                queue.append(subview)
            }
        }
        print(levelViews) // 打印当前层视图   
    }
}
```

:::



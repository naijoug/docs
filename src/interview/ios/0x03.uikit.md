---
title: UIKit
icon: hashtag

index: true

---

<!-- more -->

------

## UIKit

### ❓了解的 `UIKit` 结构

::: details 💡

`UIKit` 这个框架提供了在 `iOS` 中开发图形化、事件驱动的应用所需要的所有基础工具和基础结构。以下是主要的组件：

- `UIWindow`
    > 通常会有一个或多个 `UIWindow`，这是展示 `UIView` 的地方，是 `UIView` 的最顶层容器。它通常与设备的屏幕一样大小。

- `UIView` 和 `UIViewController`
    > `UIView` 是 `iOS` 中的基础组件，负责绘制和布局界面元素，处理与用户交互的事件。`UIViewController` 对应一个 `UIView`，它管理着 `UIView` 的生命周期，负责处理用户交互和视图切换等逻辑。

- 控件
    > `UIKit` 提供了一组预封装的常见 `UI` 元素组件，如按钮（`UIButton`）、标签（`UILabel`）、滚动视图（`UIScrollView`）、表格视图（`UITableView`）、集合视图（`UICollectionView`）等。

- 文本处理
    > `UIKit` 提供了一套强大的文本处理和布局系统。不仅提供了基础的 `UILabel` 用于显示文本，还有 `UITextField`、`UITextView` 等用于文本输入，以及 `NSLayoutManager` 和 `NSTextContainer` 等高级 `API` 用于复杂的文本布局。

- 图形和动画
    > `UIKit` 提供了一套强大的 `2D` 图形和动画框架，包括基础的画图 `API`、复杂的形状和路径、渐变、屏幕刷新和动画等。

- CoreAnimation
    > `UIKit` 的绚丽动画效果就是 `Core Animation` 提供支持。可以构建具有复杂视觉效果的动画，例如在两个视图状态之间平滑过渡，或者是在屏幕上移动、缩放、旋转视图。

- 触摸事件处理
    > `UIKit` 提供了一套事件处理机制，包括触摸事件、手势识别等，非常方便地可以让我们对用户的交互作出响应。

- 响应者链
    > `UIKit` 针对 `UI` 事件提供了响应者链的机制，当一个事件产生后，通过响应者链，逐层寻找可以处理该事件的对象。比如触屏事件，先从最上层的 `view` 开始，如果该 `view` 不能处理，则逐层向上传递至其父 `view`，直到找到可以处理该事件的对象。

- 自动布局
    > 利用 `UIKit` 框架的自动布局系统，开发者可以创建灵活且响应的界面布局。开发者可以使用 `AutoLayout` 和 `UIStackView` 来布局界面。

:::

### ❓`UIScene` 了解吗

::: details 💡

  > `UIScene` 是在 `iOS 13` 中引入的一种新的应用生命周期模型，它提供了管理应用 `UI` 以及该 `UI` 如何响应系统和用户事件的更细粒度的方式。

  在 `iOS 13` 以前，`iOS` 应用由单一的 `UIWindow` 实例进行管理，并且该 `UIWindow` 实例存在于整个应用的生命周期中。`AppDelegate` 要负责所有 `UI` 设置以及与应用生命周期相关的事件。

  `iOS 13` 以后 `UIScene` 则是对此进行了优化，每一个 `UIScene` 实例代表应用 `UI` 的一个单一实例。当应用在前台运行时，可以有多个 `UIScene` 实例，从而实现多窗口的多任务管理。例如在 `iPadOS` 上，用户可以开启多个窗口。

  每个 `Scene` 由一个 `Scene Delegate` 来进行管理，各种 `UI` 设置以及和场景（Scene）生命周期相关的事件都由 `Scene Delegate` 来处理。就像原来 `AppDelegate` 处理应用级别的事件一样，`Scene Delegate` 负责处理和特定 `Scene` 相关的事件。只有当进行 `App` 级别的事件处理，譬如接收远程消息通知，处理后台下载任务，这些工作才会交给 `AppDelegate` 去完成。

  这样的设计，使得在做一些 `UI` 设置以及响应生命周期事件时，更加的清晰和方便，同时也带来了更好的多任务管理能力。

:::

> `SceneDelegate` 详细说说

::: details 💡

  > `SceneDelegate` 是从 `iOS 13` 开始引入的一个新的代理模型，用于处理和 `UI Scene Session` 相关的事件，并控制和管理与其关联的 `Scene`。

  `SceneDelegate` 中处理以下一些事件：

- `func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)` 方法：这个方法是在创建新的 `scene` 时被调用，相当于 `AppDelegate` 中的 `application:didFinishLaunchingWithOptions:` 方法。通常会在该方法中设置窗口和根视图控制器。

- `func sceneDidDisconnect(_ scene: UIScene)` 方法：当 `scene` 与 `app` 断开连接时候调用。发生在 `scene` 进入后台并且系统决定需要释放 `scene` 时。

- `func sceneDidBecomeActive(_ scene: UIScene)` 方法：当 `scene` 进入活跃状态或者进入前台时调用，对应的是 `AppDelegate` 中的 `applicationDidBecomeActive:` 方法。

- `func sceneWillResignActive(_ scene: UIScene)` 方法：当 `scene` 准备进入非活跃状态或者进入后台时调用，对应的是 `AppDelegate` 中的 `applicationWillResignActive:` 方法。

- `func sceneWillEnterForeground(_ scene: UIScene)` 方法：当 `scene` 从后台恢复到前台时调用，对应的是 `AppDelegate` 中的 `applicationWillEnterForeground:` 方法。

- `func sceneDidEnterBackground(_ scene: UIScene)` 方法：当 `scene` 进入后台时调用，对应的是 `AppDelegate` 中的 `applicationDidEnterBackground:` 方法。

- `func stateRestorationActivity(for scene: UIScene)` 方法: 应用状态恢复时调用的方法，用以保存应用的当前状态。

:::

### ❓`applicationWillEnterForeground` 和 `applicationDidBecomeActive` 都会在哪些场景下被调用

::: details 💡

这两个方法是 `iOS` 应用生命周期管理中非常重要的部分，调用主要取决于应用的状态转换。

下面是被调用的一些常见情况：

  - 用户通过主屏幕点击图标打开应用：
    > 这种情况下首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用在后台，通过通知或者系统打开应用：
    > 也是先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用从后台切换到前台：
    > 这种情况下，两个函数的调用顺序和之前一样，首先调用 `applicationWillEnterForeground`，之后紧接着调用 `applicationDidBecomeActive`。

  - 应用内部弹出系统视图，例如电话，信息，分享等视图，视图消失后：
    > 这个情况下只会调用 `applicationDidBecomeActive`，`applicationWillEnterForeground` 不会被调用，因为应用实际上并没有进入后台，只是暂时失去了焦点。

:::

### ❓`iOS` 怎么检测图层混合

::: details 💡

检查图层混合（`Layer Blending`）方法：

  - 使用 `Xcode` 的 `Debug View Hierarchy`。
    > 点击 `Xcode Debug Area` 的 `Debug View Hierarchy` 按钮，会显示 `App` 当前的界面层级结构。在这个工具里，你可以检查图层混合问题。在界面右侧有一个 `3D` 效果的开关以及一个调整深度值的滑杆，通过它们可以更好地观察各个视图的在 `3D` 空间中的位置关系。

  - 使用 `Instruments` 的 `Core Animation` 工具。
    > `Instruments`的 `Core Animation` 工具是一种主要用于检测图形性能的强大工具。在该工具中，可以打开 `Color Blended Layers` 来检查图层混合问题。

  - 使用 `Quartz Debug` 工具：是苹果的一个调试工具，如果安装了 `Xcode`，在 `Developer Tools` 文件夹里就会有这个工具。
    > 打开 `Quartz Debug` 后，在工具栏选择 `Tools -> Show Debug Options`，然后在弹出的窗口中选择 `Color Blended Layers`。这会将需要混合的部分以红色显示，不需要混合的部分以绿色显示。

  - 使用第三方工具如 `Reveal`。
    > `Reveal` 是一款强大的 `iOS` 应用 `UI` 检查工具。它可以能够在运行时查看和修改 `UI`，这对于查找和解决图层混合有很大帮助。

:::

------

## UIView

### ❓`UIView` & `CALayer` 是什么关系

::: details

  每个`UIView`都有一个对应的`CALayer`，称之为 `UIView` 的 `backing layer`（背部层）。`UIView` 和 `CALayer` 之间是互相关联的，`UIView` 负责处理触摸事件，而 `CALayer` 负责显示视图的内容。

- `UIView`：视图的基类，负责处理用户交互（例如触摸事件），也负责管理子视图（包括添加、删除、遍历子视图）。可以使用 `UIView` 的子类（如`UILabel`，`UIButton`等）创建特定的用户界面，也可以创建自定义视图来绘制复杂的界面。

- `CALayer`：是核心动画库(`Core Animation`)中的类，它负责呈现视图的内容。`UIView` 将很多渲染任务委派给 `CALayer`，例如视图的边框、圆角、阴影、图片等都是由 `CALayer` 来绘制和渲染的。此外 `CALayer` 还负责处理动画效果。

:::

> 为什么要这样设计？

::: details

  这是由于 `iOS` 系统的历史原因。在早期的 `iOS` 版本中，只有 `CALayer`，并没有 `UIView`，所有的界面渲染和动画都需要通过手动控制 `CALayer` 来完成。
  
  后来，苹果引入了 `UIView`，用以简化界面的创建和管理，并将一些低层的渲染和动画任务委派给 `CALayer`。
  
  这样的设计使得开发者可以更高效地创建和管理用户界面，同时也保持了对底层渲染和动画的高级控制能力。

:::

### UIControl

#### ❓`UIControl` vs `UIResponder`

::: details 💡

> 继承链：`UIControl` -> `UIView` -> `UIResponder`

- `UIResponder` 是处理和响应事件的基类，它定义了接收和处理事件的接口。实际上，`UIApplication`、`UIView`和`UIViewController` 都是继承自 `UIResponder`，都可以响应并处理事件。例如当一个触摸事件发生时，`iOS` 会把事件交给最先接触到的 `UIView` （也就是被用户触摸的那个），然后沿着响应链向上分发，直到有 `UIResponder` 子类处理这个事件。

- `UIControl` 是继承自 `UIView`，并且添加了一些控制特性的类，用于响应用户交互。`UIControl` 提供了一种机制，允许你在特定事件发生时发送消息给指定的目标。比如 `UIButton`、`UISlider`、`UISwitch` 等都是 `UIControl` 的子类。可以为这些子类设置 `target-action` 来响应用户的交互事件。

总体来说，`UIResponder` 负责处理事件，而 `UIControl` 在此基础上添加了更多用户交互的特性。

:::

#### ❓`UIButton` 继承链

::: details 💡

> 继承链 : `UIButton` -> `UIControl` -> `UIView` -> `UIResponder` -> `NSObject`

- `NSObject` 是所有 `Objective-C` 类的基类，提供了对象的基本行为特征和特性。

- `UIResponder` 是 `iOS` 事件传递体系中的一个重要组成部分，此类提供了一种机制来处理和路由在应用程序中发生的触摸事件、手势识别、远程控制等事件。

- `UIView` 是基本的展示视图和处理视图相关事件的类，几乎所有的 `UI` 元素都是直接或间接继承自 `UIView`，此类提供了一种机制以支持在其矩形区域内绘制、布局和处理事件。

- `UIControl` 是 `UIView` 的一个直接子类，是一些具有 `target-action` 机制的 `UI` 元素的基类，比如按钮(`UIButton`)、滑块(`UISlider`)等，能够响应用户的交互行为并向感兴趣的目标发送讯息。

- `UIButton` 是 `UIControl` 的一个子类，主要用来制作按钮。它在父类 `UIControl` 的基础上又添加了一些按钮特有的行为，比如按钮的标题、图片等。

:::

#### ❓根据 `UIControl` 实现 `UIButton`

```swift
protocol ButtonProtocol {
    func setTitle(_ title: String);
    func setTitleColor(_ titleColor: UIColor);
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets);
    func setImage(_ image: UIImage);
    func setBackgroundImage(_ image: UIImage);
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets);
}

class MyButton: UIControl, ButtonProtocol { 
    // todo
}
```

::: details

  `UIButton`本质上是一个视图（对象），因此它应该包含一些像视图、标签、图片视图等子视图。要求 `MyButton` 能够具有设置标题、标题颜色、标题边距、题图像、背景图像以及图像边距的能力。

```swift
class MyButton: UIControl, ButtonProtocol {
    
    let titleLabel: UILabel = {
        let label = UILabel()
        label.textAlignment = .center
        return label
    }()
    
    let imageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleAspectFit
        return imageView
    }()
    
    let backgroundImageView: UIImageView = {
        let imageView = UIImageView()
        imageView.contentMode = .scaleToFill
        return imageView
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.addSubview(backgroundImageView)
        self.addSubview(imageView)
        self.addSubview(titleLabel)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        backgroundImageView.frame = self.bounds
    }
    
    func setTitle(_ title: String){
        titleLabel.text = title
    }
    
    func setTitleColor(_ titleColor: UIColor) {
        titleLabel.textColor = titleColor
    }
    
    func setTitleEdgeInsets(_ edgeInsets: UIEdgeInsets){
        titleLabel.frame = self.bounds.inset(by: edgeInsets)
    }
    
    func setImage(_ image: UIImage) {
        imageView.image = image
    }
    
    func setBackgroundImage(_ image: UIImage) {
        backgroundImageView.image = image
    }
    
    func setImageEdgeInsets(_ edgeInsets: UIEdgeInsets) {
        imageView.frame = self.bounds.inset(by: edgeInsets)
    }
    
}
```

  - 为了处理背景图像，标题和图像，需要三个子视图：一个背景图像视图、一个图像视图和一个标签。
  
  - `setTitleEdgeInsets` 和 `setImageEdgeInsets` 方法只需要调整 `titleLabel` 和 `imageView` 的 `frame` 即可。

  - 在 `layoutSubviews()` 中设置 `backgroundImageView` 的 `frame`，以保证其总是充满整个视图。

  注意：“实现 `UIButton`” 需要更多的特性和设置，例如处理高亮状态和禁用状态，添加点击事件等。按照特定需求，可以进行进一步的扩展和完善。

:::

### ❓`UITableView` 的 `delegate` 和 `dataSource` 代理有什么区别

::: details 💡

- `dataSource` 主要是向 `UITableView` 提供数据。

  例如数据源中有多少个 `section`，每个 `section` 有多少行，以及每一行的具体内容等等。`dataSource` 必须实现下面两个方法：

    * `func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int`：设置每个 section 中的 row 数量。
    * `func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell`：提供具体的 cell。

  这两个方法是 `UITableViewDataSource` 协议的必要方法，没有这两个方法，`UITableView` 就没办法正常工作。

- `delegate` 主要是处理 `UITableView` 的视觉效果以及与用户的交互。

  例如设置 `header` 和 `footer`、设置 `cell` 的高度、处理 `cell` 的选择和取消选择等等。

    * `func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat`：设置 cell 的高度。
    * `func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)`：处理 cell 的选择事件。

  这些方法都不是必须的，不过如果我们想要更加细致地控制 `UITableView` 的外观和行为，就需要实现这些方法。

总的来说，`dataSource` 是设置和提供数据，`delegate` 是控制外观和处理用户交互。

:::

### ❓`UICollectionView` 自定义布局如何处理

::: details 💡

  自定义 `UICollectionView` 的布局，首先需要创建一个 `UICollectionViewLayout` 或 `UICollectionViewFlowLayout` 的子类，然后重写其中与布局相关的一些方法。

  - `prepare()`
    > 在这个方法中计算出所有 `cell` 和视图的位置。当布局被无效化并需要更新的时候，会首先调用该方法。

  - `layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]?`
    > 这个方法返回的是在给定矩形中所有 cell 和视图的布局属性。这个方法负责提供一个布局属性数组，数组中的数据表示了对应位置的 cell 的排布和样式。

  - `layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes?`
    > 这个方法返回的是对应于路径的所有项目的布局属性，也就是在 `UICollectionView` 中指定位置的 `cell` 的排布和样式。

  - `collectionViewContentSize: CGSize`
    > 这个方法返回的是整个 `UICollectionView` 的内容的宽度和高度。 `UICollectionView` 会使用这个尺寸来配置自己的内容大小，从而实现滚动。

  创建了自定义布局类之后，就可以在创建 `UICollectionView` 的时候，将这个布局类的对象作为参数传入 `UICollectionView` 的初始化方法中，这样创建出来的 `UICollectionView` 将会按照我们自定义的方式进行布局。

:::

------

## UIViewController

### ❓`UIViewController` 的生命周期

::: details 💡

  - `loadView()`: 这个方法是用来创建或加载视图控制器的视图层次结构。是视图控制器生命周期的起始。一般不需要去重写或者直接调用它。

  - `viewDidLoad()`: 这个方法会在视图控制器的视图被装载后调用。可以在该方法中实现任何额外的初始化工作。

  - `viewWillAppear(_:)`: 这个方法会在视图控制器的视图被添加到窗口并且即将显示出来的时候调用。

  - `viewDidAppear(_:)`: 这个方法会在视图控制器的视图已经显示出来之后调用。

  - `viewWillDisappear(_:)`: 这个方法会在视图控制器的视图即将从窗口中移除或者被覆盖而消失的时候调用。
  
  -`viewDidDisappear(_:)`: 这个方法会在视图控制器的视图已经消失、被移除或覆盖的时候调用。

:::

### ❓`loadView` 的作用

::: details 💡

  > `loadView()` 是 UIViewController 的一个生命周期方法，它在访问控制器的 `view` 属性时，如果该属性当前为 `nil`，则会被系统自动调用。

  `loadView()` 用于创建并加载视图控制器的主视图（即 `self.view`）。通常情况下，并不需要重写这个方法，因为默认的实现能够处理大部分常规的初始化需求。比如，如果控制器在 `Storyboard` 中定义，那么 `loadView()` 会加载和设置来自 `Storyboard` 的视图。如果有一个同名的 `nib` 文件，它会加载和设置来自该 `nib` 文件的视图。

  在需要以编程方式创建视图，或者提供自定义的视图加载机制时，可以通过重写 `loadView()` 方法来实现。在重写的 `loadView()` 中，需要手动创建一个 `UIView` 对象或其子类的实例，并赋值给控制器的 `view` 属性。

注意：
* 重写 `loadView()` 方法时，不需要调用 `super`，并且在方法的最后要确保 `self.view` 不为 `nil`。
* 除非有特殊需求，否则不建议重写 `loadView()` 方法。对于大部分情况，可以在 `viewDidLoad()` 方法中做视图的初始化配置和其他设置，这更为常见。

:::

### ❓没有使用 `IB` 时，也没有重写` loadView()` 这个 `viewController.view` 如何创建的

::: details 💡

  如果没有使用 `Interface Builder（IB）`来创建和管理视图，并且也没有重写 `loadView()` 方法，那么在 `UIViewController` 的 `loadView()` 方法中会默认创建一个 `UIView` 实例，然后赋值给 `self.view`。
    
  总的来说，无论是使用 `IB` （storyboard 或 xib），还是重写 `loadView()` 来自行创建视图，还是直接采用默认的实现，`UIViewController` 都会确保当其视图被访问时有一个 `UIView` 的实例被创建并赋值给 `self.view`。

:::

### ❓在 `init` 方法里面设置背景颜色，会生效吗

::: details 💡
    
  - 对于 `UIView` 来说，如果在使用 `initWithFrame:` 初始化方法来创建视图，那么在 `init` 方法中设置背景色是生效的。但是如果在 `Interface Builder`（即`storyboard` 或者 `xib`）中创建的视图，这个时候初始化方法是 `initWithCoder:`，同时设置视图属性大多放在 `awakeFromNib` 方法中。

  - 对于 `UIViewController` 来说，由于控制器的视图 `view` 在 `init` 方法调用时还没有被加载，所以在`init`方法里设置背景颜色是不会生效的。需要在 `viewDidLoad` 或者 `loadView` 这样的方法之后设置，这个时候视图已经被初始化并加载完成了。
  
:::

### ❓自定义导航跳转如何实现

::: details 💡

自定义导航跳转主要涉及两点，自定义动画及自定义转场方式。

  - 定义一个类遵循 `UIViewControllerAnimatedTransitioning` 协议，编写自定义的动画逻辑。

    ```swift 
    class CustomTransition: NSObject, UIViewControllerAnimatedTransitioning {
        func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
            return 1.0 // 返回动画时长
        }
        
        func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
            // 这里编写你的动画逻辑
            
            // 获取到待呈现的视图
            if let toView = transitionContext.view(forKey: .to) {
                // 添加到容器视图中
                transitionContext.containerView.addSubview(toView)
                
                // 编写动画逻辑, 以下是一个简单的淡入淡出动画
                toView.alpha = 0.0
                UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: { 
                    toView.alpha = 1.0
                }) { (_) in
                    // 动画结束时，一定要调用 completeTransition 方法
                    transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
                }
            }
        }
    }
    ```

  - 在视图控制器中指定转场代理，并在代理方法中返回自定义的转场动画对象。

    ```swift
    class ViewController: UIViewController, UINavigationControllerDelegate {
        let customTransition = CustomTransition() // 初始化自定义转场动画
        
        override func viewDidLoad() {
            super.viewDidLoad()
            // 指定代理
            navigationController.delegate = self
        }
        
        func navigationController(_ navigationController: UINavigationController,
                                  animationControllerFor operation: UINavigationController.Operation,
                                  from fromVC: UIViewController,
                                  to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
            return customTransition
        }
    }
    ```

:::

------

## 布局

### 尺寸

#### ❓`sizeToFit`、`sizeThatFits` 了解吗

::: details 💡

  > `sizeToFit` 和 `sizeThatFits` 是 `UIKit` 中 `UIView` 的两个方法，涉及到视图的尺寸调整。

- `sizeToFit`：这是一个无参数的方法，调用这个方法会使得视图的 `frame` 变为能刚好包裹住它的子视图的大小。具体的行为依赖于视图的 `sizeThatFits:` 方法的实现。
    > 这个方法并不会修改视图的位置，只会影响到视图的大小。

- `sizeThatFits:`：这个方法需要一个参数，表示期望的尺寸。然后这个方法返回一个适合视图及其子视图的大小。
    > 这个方法并不会改变视图的实际大小，需要调用者根据返回的大小来更新视图的 `frame`。

一般来说，视图的默认行为是返回一个等于当前视图大小或者等于传入参数的值，具体取决于子视图的要求。如果你的自定义视图有特殊的需求，你可以重写 `sizeThatFits:` 方法来实现特定的尺寸调整行为。

总的来说，`sizeToFit` 和 `sizeThatFits:` 都是用来调整视图尺寸的方法，但具体的行为取决于具体视图的 `sizeThatFits:` 的实现。

:::

#### ❓`intrinsicContentSize` 使用过吗

::: details 💡

  > `intrinsicContentSize` 是`UIView`的一个属性，它表示一个视图的自然大小或者说内在大小。
  
  举例来说，对于一个 `UILabel` 的 `intrinsicContentSize` 就是刚好能包裹住它所包含的文本的大小。

  这个属性在使用 `AutoLayout` 进行布局的时候非常有用。一些需要根据内容自适应大小的控件，比如 `UILabel`、`UIButton` 等，都可以通过设置 `intrinsicContentSize` 来告诉布局系统它们需要的空间大小。

  可以通过重写这个属性的 `getter` 方法来提供自定义的大小。需要注意的是，当视图的内在内容改变，可能会影响到`intrinsicContentSize` 时，需要调用 `invalidateIntrinsicContentSize` 方法来通知布局系统 `intrinsicContentSize` 发生了变化，这样布局系统就会在下一个布局循环中重新计算布局。

总的来说，`intrinsicContentSize` 是在使用 `AutoLayout` 进行布局时，用于表示视图自适应内容大小的一个重要属性。

:::

### 布局视图

#### ❓`layoutSubviews` 那些情况下会触发

::: details 💡

  > `layoutSubviews` 在 `iOS` 的 `UIView` 的生命周期中，是负责布局及排版子视图的方法。

  - 在初始化 `UIView` 并添加到界面上时，系统会自动调用 `layoutSubviews` 方法进行子视图的布局。
  - 当 `UIView` 的 `bounds` 发生变化，如改变宽高、旋转设备时，系统会调用 `layoutSubviews`。
  - 当直接调用 `UIView` 的 `setNeedsLayout`或者 `layoutIfNeeded` 方法时，系统会调用 `layoutSubviews`。
    * `setNeedsLayout` 会标记当前视图被标记为需要重新布局，然后在接下来的更新周期中，调用 `layoutSubviews` 对标记进行重新布局
    * `layoutIfNeeded` 则会立即对视图进行重新布局，通常在动画的 `block` 内使用
  - 当视图的某个子视图的 `frame` 被显式地修改，也会触发父视图的 `layoutSubviews`。
  - 添加或者删除子视图的时候，也会触发父视图的 `layoutSubviews`。

:::

#### ❓`viewWillLayoutSubView` 的作用

::: details 💡

  > `viewWillLayoutSubviews` 是 `UIViewController` 的一个生命周期方法，该方法在视图控制器的视图即将布局其子视图时被调用。这通常发生在视图的尺寸发生改变之后，例如设备的方向发生改变，或者视图被添加到父视图中并且父视图需要调整子视图的位置或大小。

  在 `layoutSubviews` 之前调用 `viewWillLayoutSubviews`，因此这是在预计的布局之前，可以进行一些特定的设置或者变化。

  注意，因为 `viewWillLayoutSubviews` 能被多次调用，因此需要避免在该方法中进行一些不必要的高开销计算或者更新操作。

  `viewWillLayoutSubviews` 的主要用途之一是提供了一个时机，允许在更改子视图的大小或位置之前进行一些额外的配置，也可以在此方法中进行一些必要的布局更新。

:::

#### ❓`layoutIfNeeded` vs `setNeedsLayout`

::: details 💡

> `layoutIfNeeded` 和 `setNeedsLayout` 是 `UIView` 的两个方法，都涉及到视图的布局更新，但是使用场景和触发方式不同。

  - `setNeedsLayout`: 这个方法被调用后，并不会立即触发重新布局。
    > 它标记了视图的布局需要更新，然后在下一次视图更新周期（通常是下一次 `RunLoop`），系统会自动调用 `layoutSubviews` 方法来进行实际的布局更新。如果期间多次调用 `setNeedsLayout`，实际上 `layoutSubviews` 只会被调用一次。

  - `layoutIfNeeded`: 这个方法则会立刻触发视图的布局更新。
    > 调用这个方法后，系统会立即执行布局更新，包括调用 `layoutSubviews` 方法。这个方法通常用于需要立即更新视图布局的情况，比如在 `UIView` 的动画块中。

总结：`setNeedsLayout` 是标记需要重新布局，具体要等到下一个更新周期自动触发，而 `layoutIfNeeded` 则是立刻触发重新布局。

:::

### 绘制视图

#### ❓`drawRect` 有使用过吗，调用时机，会有性能影响吗

::: details 💡

  > `drawRect:` 是一个 `UIView` 类的方法，用于在视图的矩形区域进行绘制。如果自定义视图需要展示一些特殊的展示效果，比如绘制一些自定义的形状、渐变、阴影等，就可以重写这个方法完成这些绘制。

- 调用时机
    > `drawRect:` 方法并不是时时刻刻都在调用，它的调用时机主要是视图第一次加载和视图的内容需要重绘时。也就是说当 `UIView` 准备好进行绘制操作的时候，系统会自动调用 `drawRect:` 方法。

    * 视图第一次出现在屏幕上时，会调用一次 `drawRect:` 方法进行视图的渲染。
    * 调用了 `setNeedsDisplay` 或者 `setNeedsDisplayInRect:` 方法后，系统会在下一个绘制周期中调用 `drawRect:` 方法进行视图的重绘。

- 性能影响
    > 由于 `drawRect:` 方法会占用大量 `CPU` 资源进行图形的绘制，因此过度使用或者不合理使用 `drawRect:` 方法会导致 `CPU` 使用率上升，从而影响应用的性能。
    
    * 避免在 `drawRect:` 方法中进行复杂的计算或者耗时的操作，这会降低绘制的效率。
    * 不要主动直接调用 `drawRect:`，而是应当通过 `setNeedsDisplay` 或 `setNeedsDisplayInRect:` 让系统来决定何时调用 `drawRect:`。
    * 如果可能，尽量减少绘制的区域。可以通过 `setNeedsDisplayInRect:` 只重绘视图中改变的那部分区域，而不是整个视图。
    * 考虑使用 `Core Animation` 或者直接操作 `CALayer`，而不是使用 `drawRect:`，以提高性能。因为 `Core Animation` 运行在专门的绘图线程，而不是主线程上，所以它的性能要优于 `drawRect:`。
    * 如果视图是静态的，即一旦被绘制就不会改变，那么可以使用 `shouldRasterize` 属性来缓存视图的绘制结果，以提高性能。

:::

#### ❓`setNeedsDisplay` vs `setNeedsLayout`

::: details 💡

  - `setNeedsDisplay`：调用此方法会标记视图为脏的，这会导致系统在下一个绘图周期中调用视图的 `drawRect:` 方法来重绘视图。
    > 通常在视图的内容发生改变时，调用此方法来请求系统重绘视图。

  - `setNeedsLayout`：调用此方法会标记视图为需要重新布局，这会导致系统在下一个更新周期中调用视图的`layoutSubviews` 方法来重新布局视图的子视图。
    > 通常在视图的尺寸或位置发生改变时，调用此方法来请求系统重新布局视图。

总结：`setNeedsDisplay` 和 `setNeedsLayout` 是异步的和非阻塞性的。`setNeedsDisplay` 请求系统重新绘制视图，而 `setNeedsLayout` 则请求系统重新布局视图的子视图。它们通常在视图的状态发生改变时被调用，以确保视图的外观和布局总是最新的。

:::

### 自动布局

#### ❓`AutoLayout` 的原理，性能如何

::: details 💡

- 原理：
    > `AutoLayout` 通过制定一组约束来描述用户界面中的一些布局关系和尺寸属性。这些约束代表了视图与其他视图的相对位置关系、视图自身的尺寸以及视图的尺寸和父视图之间的相对关系等等。然后使用数学算法计算出满足所有约束条件下视图的最优位置和大小。
    
    > 当屏幕尺寸、视图层次、约束条件以及设备方向等条件改变时，系统可以自动的通过算法重新计算并调整视图的位置和尺寸。因此，`AutoLayout` 提供了强大的工具，让开发者能够设计出能在各种尺寸和条件下都能良好显示的界面。

- 性能：
    > 使用 `AutoLayout` 可以省去很多手动计算和调整布局的工作，大大提高了开发效率，同样在处理各种设备尺寸和方向变化时，可以保持良好的界面显示。但是，`AutoLayout` 的性能并不总是最佳的。因为满足约束条件需要通过数学计算，并且复杂的界面和大量的约束可能使得这个计算过程变得复杂和耗时，特别是在一些动态改变约束和布局的情况下。

总的来说，`AutoLayout` 是一个功能强大，使用方便的布局工具，适合大多数情况下使用。但如果面临一些复杂和高效能需求的界面，可能需要考虑其他的布局方式，比如手动布局或使用第三方布局库。

:::

#### ❓`Masonry` 的约束应该写在哪里

::: details 💡

  > `Masonry` 是一个轻量级的布局框架，采用链式编程的方式，让 `AutoLayout` 使用变得更加简单。通常在初始化视图和更新视图布局的地方使用 `Masonry`。

可以把 `Masonry` 的约束写在以下地方：

- 对于 `UIView` 可以在初始化方法 `init` 或者 `initWithFrame:` 中设置约束。

    ```objc
    - (instancetype)init {
        self = [super init];
        if (self) {
            [self setupViews];      // 完成子视图的添加
            [self setupConstraints];// 设置 Masonry 的约束
        }
        return self;
    }
    ```

- 对于 `UIViewController` 可以在 `viewDidLoad` 方法中设置视图约束。

    ```objc
    - (void)viewDidLoad {
        [super viewDidLoad];
        [self setupViews];
        [self setupConstraints];
    }
    ```

- 如果视图布局会在运行时动态改变，那可以在 `updateViewConstraints` 方法中更新约束。

    ```objc
    - (void)updateViewConstraints {
        [super updateViewConstraints];
        // 更新 Masonry 的约束
    }
    ```

:::

------

## 图片

### 图片读取

#### ❓`imageName` vs `imageWithContentsOfFile`

::: details 💡

`UIImage` 的 `imageName:` 和 `imageWithContentsOfFile:` 是两种不同的方法，用于从应用的 `bundle` 中加载图片。

  - `imageName:` 方法是用于从应用的 `主 bundle` 中加载图片的，它会自动根据设备的屏幕类型（比如，`Retina`屏幕）来选择合适的图片（比如，自动选择 `@2x` 或 `@3x` 的图片）。
    > 这个方法也会自动地对加载的图片进行缓存，所以如果你使用该方法多次加载同一张图片，实际上只会加载一次，剩下的调用会直接从缓存中获取图片。这就意味着这个方法在加载大量重复图片时，处理速度会很快。

  - `imageWithContentsOfFile:` 方法则是直接从指定的文件路径中加载图片，它并不会根据屏幕类型来自动选择图片，也不会对加载的图片进行缓存。
    > 每次调用这个方法时，系统都会从磁盘中读取图片数据，这可能会花费更多的时间。如果想要加载一次性使用并且不需要缓存的大图片，这个方法可能会更适合。

总结：`imageName:` 更适合用来加载经常使用的小图片，而 `imageWithContentsOfFile:` 则更适合加载一次性使用的大图片。

:::

#### ❓多个相同的图片，会重复加载吗

::: details 💡

  如果使用`UIImage`的`init(named:)`或`imageNamed:`方法来创建一个图片对象，这个方法会先在缓存中查找是否已经存在相同的图片。如果缓存中存在，那么就会直接从缓存中返回，而不会重新加载。因此，这个方法在加载相同图片时不需要加载多次，会直接从缓存中读取，性能更好。

  如果使用`UIImage`的`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法来加载图片，那么每次调用都会从文件中重新读取，即使在前面已经加载过同一个文件的图片。这是因为这种方法不会使用系统的图片缓存。

因此，如果有多个相同的图片需要加载，且这些图片会频繁使用，那么推荐使用`init(named:)`或`imageNamed:`方法，利用系统的缓存机制，避免重复加载图片，提升性能。如果图片仅用一次，或者图片文件非常大，不适合放入缓存，那么可以考虑使用`init(contentsOfFile:)`或`imageWithContentsOfFile:`方法。

:::

### 图片处理

#### ❓如何高性能的给 `UIImageView` 加圆角

::: details 💡

 给 `UIImageView` 添加圆角有多种方式，但并非所有方法都是高效的。一些常见的方式可能会引入性能问题，例如直接修改视图的 `.layer.cornerRadius` 属性，因为这会导致离屏渲染，影响到性能。

以下是一种高效的给 `UIImageView` 添加圆角的方法，该方法使用了 `Core Graphics` 框架：

```swift
let imageView = UIImageView(image: UIImage(named: "example"))
// 圆角半径
let radius: CGFloat = 10.0 
// 创建一个CGRect，其尺寸与 UIImageView 的 frame 匹配
let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: imageView.frame.size) 
// 创建一个 CGMutablePath，并将该路径添加到一个 CAShapeLayer
let path = UIBezierPath(roundedRect: rect, cornerRadius: radius)
let maskLayer = CAShapeLayer()
maskLayer.path = path.cgPath
// 将这个 CAShapeLayer 设置为 UIImageView 的遮罩层
imageView.layer.mask = maskLayer
```

这种方式不会导致离屏渲染，只会在合成阶段发生，因此比直接修改视图的 `.layer.cornerRadius` 属性更为高效。

:::

### 图片渲染

#### ❓图片怎么显示的，以及图片缓冲区

::: details 💡

图片在屏幕上显示流程：

  - **加载**：首先从磁盘或网络上将二进制数据加载入内存，这些二进制数据描述了图像信息。

  - **解码**：加载完毕后，图像会被解码成位图（`bitmap`）。位图是一种非常详细的矩阵，其中每个单元（像素）记录了在对应位置的颜色信息。因此，位图的大小通常比原始的图像文件要大。

  - **渲染**：渲染图片就是将位图中的每个像素翻译成屏幕上的每个点，这个过程通常由 `GPU`（图形处理器）完成。

> 图片缓冲区，通常会通过一些图像库（如`SDWebImage`）的帮助，将常用图片保存在内存中以备快速访问。这就是所谓的图片缓冲区，也叫做图片缓存。

  图片缓存的目的是提高性能和减少网络或磁盘 `I/O` 的使用。当应用程序需要显示一张图片时，它首先查看缓存，如果缓存中有这张图片，就直接用缓存中的图片，避免了从网络或磁盘上加载。如果缓存中没有，就必须从网络或磁盘加载，加载后的图片会被保存到缓存中，以便下次使用。

注意：任何缓存策略都需要考虑内存使用和过期策略。缓存太多图片会消耗大量内存，可能影响应用程序的性能或触发内存警告。同时，缓存中的图片可能会过时，应定期清除不再需要的图片。

:::

#### ❓图片渲染怎么优化

::: details 💡

  > 优化图片渲染是一门科学

- 图片本身
    * **避免透明像素**：如果一张图片包含透明像素，那么在混合像素时 `GPU` 负担会更重。如果图片不需要透明度，最好选择不带 `alpha` 通道的图片格式，如 `JPG`。
    * **使用正确的图片格式**：不同的图片格式有不同的解压缩性能。
        > 例如，对于静态图片，`PNG` 和 `JPEG` 是常见的格式。通常，`JPEG` 格式的图片解压缩速度会比 `PNG` 快，但是 `PNG` 对透明度的支持更好。

- 图片获取
    * **后台线程加载和准备图片**：为了避免阻塞主线程，一定要在后台线程进行图片的加载、解压缩和其他准备工作。
    * **利用图片缓存**：频繁地从磁盘加载图像是一种昂贵的操作。使用图片缓存可以避免频繁地加载同一张图片。
    * **合理设置图片分辨率**：`@2x` 和 `@3x` 的图片分辨率分别是原始尺寸的2倍和3倍，根据设备屏幕的特性选择合理的图片分辨率，避免不必要的内存消耗。
    
- 图片加载
    * **图片预解码**：图片在渲染到屏幕之前，需要被解码成位图。
        > 这个操作会在图片第一次显示时进行，并且可能会产生一定的性能消耗。可以通过预解码（在后台线程提前进行解码）的方式把这个消耗提前。
    * **图片大小适配**：尽量保持加载的图片大小接近于它在设备屏幕上的显示大小。
        > 如果一个很小的 `UIImageView` 需要显示一个非常大的图片，那么这张图片在显示之前需要被缩放。如果图片实际尺寸过大，会导致额外的内存使用和解压缩成本。

:::

#### ❓图片是什么时候解码的，如何优化

::: details 💡

  当图片被显示在屏幕上时，图片的解码操作通常是在渲染前由 `GPU` 进行的。然后，解码后的位图像素被存储在内存中，用于显示。此过程可能会对性能产生影响，尤其是在滚动动画或切换动画等场景中。

  如果希望优化图片解码，有一种常用的方法是对图片进行预解码。预解码是在主线程渲染前，提前在后台线程将图片解码，而不是等待 `GPU` 在显示的时候进行解码。在其进行解码的过程中，`CPU` 的压力会提高，但同时可以降低 `GPU` 负载，避免在渲染过程中进行解码导致的帧数下降。

  可以通过使用 `Core Graphics` 的 `API` 来对图片进行预解码。具体过程是使用 `CGImage` 创建一个 `CGBitmapContext`，然后将图片绘制到这个 `context` 中。这样，当图片第一次显示在屏幕上时，就无需再进行解码操作。

```swift
// 预解码
func predecode(image originalImage: UIImage) -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(originalImage.size, true, originalImage.scale)
    guard let context = UIGraphicsGetCurrentContext() else { return nil }
    originalImage.draw(at: .zero)
    let decodedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decodedImage
}
```

  由于预解码会增加 `CPU` 压力和内存消耗，所以需要在合适的时机进行，比如在后台线程，用户滚动列表的滑动减速或者停止的时候，或者在图片将要显示之前的闲暇时间。务必要避免在用户滑动列表的过程中进行预解码，因为这个时候进行预解码可能会导致卡顿。另外，过多的预解码也可能导致内存暴涨，所以需要权衡当下的需求和设备性能。

:::

### 大图渲染

#### ❓如何用 `UIImageView` 显示超大分辨率的图，如何支持缩放

::: details 💡

  `UIScrollView` 支持在 `iOS` 设备上进行滚动和缩放操作。如果希望显示一张大图并支持缩放，应该把 `UIImageView` 作为 `UIScrollView` 的子视图。

```swift
class ViewController: UIViewController, UIScrollViewDelegate {
    var imageView: UIImageView!
    var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        // 创建一个 UIScrollView 实例
        scrollView = UIScrollView(frame: view.bounds)
        // 设定 zoom 缩放的最小/最大倍数
        scrollView.minimumZoomScale = 1.0
        scrollView.maximumZoomScale = 6.0

        // 加载一张大图(up to you)
        let image = UIImage(named: "LargeImageName")    
        imageView = UIImageView(image: image)
        imageView.frame = CGRect(x: 0, y: 0, width: image?.size.width ?? 0, height: image?.size.height ?? 0)
        
        //将 ImageView 添加到 ScrollView 中 
        scrollView.addSubview(imageView)
        scrollView.contentSize = imageView.bounds.size
        
        //设置代理
        scrollView.delegate = self

        //添加 ScrollView 到主视图中
        view.addSubview(scrollView)
    }

    func viewForZooming(in scrollView: UIScrollView) -> UIView? {
        return imageView // 返回需要缩放的视图
    }  
}  
```

  对于极其大的图片还是可能有内存问题。如需处理这种情况，可能需要使用像 `CATiledLayer` 这样的技术，它可以分块渲染视图，而不是一次性渲染整个大图。
  
  由于 `UIImageView` 通过 `UIImage` 加载图片，是一次性将图片加载到内存，超大图片会引发内存不足的的问题。所以这个时候不能一次全部加载，需要使用分治思想，将图片像素点分块加载，只加载可视区域像素点。使用 `Tile Rendering` 的解决方案，类似家庭装修贴地砖的方式，先将图片像素按照一定的大小分割成 `Tile`，然后根据图片显示区域渲染。`CATiledLayer` 是一种适用于处理大量数据的渲染的 layer，适合处理这种情况。
  
  缩放功能可以通过将 `UIImageView` 嵌套在 `UIScrollView` 里面，根据缩放的代理回调，进行 `Tile` 的重新绘制。

:::

#### ❓如何将一张内存极大的图片可以像地图一样的加载出来

::: details 💡

  处理极大图片（比如说地图）时，加载整张大图到内存通常是不可行的，因为将会占用太大内存，而手机设备的内存是有限的。为了处理这个问题，通常的做法是分块加载和显示图片——只把当前需要显示在屏幕上的那一部分加载到内存。当用户滚动或缩放图片时，就加载新的部分，同时释放不再需要的部分。这就是所谓的 “切片”（tiling）技术。

  可以使用 `CATiledLayer` 来实现图片的切片加载。
  
  > `CATiledLayer` 是一种特殊的 `CALayer`，它将内容分成多个小的矩形块或"切片"，并且只在需要的时候绘制这些切片。当提供内容时，只需画出指定的矩形区域即可，其它区域则由 `Core Animation` 自动处理。此外，`CATiledLayer` 甚至支持多级别的细节，这使得可以非常容易地实现复杂的地图或图片浏览器功能。

要注意的是，`CATiledLayer`的使用相对复杂，它需要自行管理图片资源并根据需要进行绘制。`MapKit` 就是使用这种技术。另外，一些图片浏览器库，如 `FastImageCache`，也可以处理大图，它实现了自己的切片和缓存机制。

无论你选择哪种方式，都应注意内存管理，并合理地在需要的时候清理不再需要的资源。

:::

------

## 动画

### UIKit 动画

#### ❓`UIKit Animation` vs `Core Animation`

::: details 💡

  - **UIKit Animation**: 一个更高的抽象层进行编程操作。
    > 可以简单的使用 `UIView` 类的动画方法，如 `UIView.animate(withDuration:animations:)`，轻松实现许多动画，如移动、旋转、改变透明度、改变颜色等。

    ```swift
    // 将一个视图在2秒内从屏幕左边移到右边
    UIView.animate(withDuration: 2) {
        view.frame.origin.x = self.view.frame.width - view.frame.width
    }
    ```

  - **Core Animation**: 提供了更底层和更强大的动画控制。
    > 与 `UIKit` 动画相比，它可以实现更复杂的动画，如复杂的转换，3D效果，关键帧动画等。

    ```swift
    // 使用 Core Animation 创建关键帧动画：使视图在2秒内沿着预定的路径移动
    
    // 创建一个 CAKeyframeAnimation 实例
    let animation = CAKeyframeAnimation(keyPath: "position")
    // 设置关键帧
    animation.values = [NSValue(cgPoint: CGPoint(x: 50, y: 50)),
                        NSValue(cgPoint: CGPoint(x: 100, y: 100)),
                        NSValue(cgPoint: CGPoint(x: 50, y: 150))]
    // 动画时间
    animation.duration = 2
    // 将动画添加到视图层
    view.layer.add(animation, forKey: nil)
    ```

:::

#### ❓`UIKit Animation` vs `UI Dynamics`

::: details 💡

`UIKit Animation`和`UI Dynamics`都是在UIKit框架中创建动画的两种主要技术，但它们的使用场景和工作原理是不一样的。

  - **UIKit Animation**：主要用于创建简单，直观和以时间为基础的动画。
    
    ```swift
    // 在1秒内改变视图的背景颜色和大小
    UIView.animate(withDuration: 1) {
        view.backgroundColor = .blue
        view.frame.size = CGSize(width: 100, height: 100)
    }
    ```

  - **UI Dynamics**：一种创建物理基础的模拟动画的方法。这意味着你可以为视图创建如弹力，碰撞，重力这样的物理特性的动画。当希望视图的动画看起来 “感觉像现实世界中的物体那样移动” 那么 `UI Dynamics` 是最好的选择。

    ```swift
    // 视图会根据重力方向进行动画模拟
    let gravity = UIGravityBehavior(items: [myView])  // 创建重力行为
    animator = UIDynamicAnimator(referenceView: view)
    animator.addBehavior(gravity)
    ```

:::

### 核心动画

#### ❓隐式动画 vs 显示动画

::: details 💡

隐式动画和显示动画是在 `Core Animation` 框架中用来描述动画类型的两个术语。

- **隐式动画**：默认的动画类型。
    > 当修改 `CALayer` 的可动画属性时，系统会自动创建并运行动画——这就是所谓的隐式动画。

    ```swift
    // 图层的位置会以动画的形式移动到新位置，而不是立即跳到那里
    layer.position = CGPoint(x: 200, y: 200)
    ```

- **显示动画**：明确地创建一个 `CAAnimation` 对象，设置它的属性，然后将它添加到图层。显示动画给了开发者对动画行为更精细的控制，包括动画的时间线和动画的进度曲线等。

    ```swift
    // 在1秒内将图层的位置从(100, 100)移动到(200, 200)
    let animation = CABasicAnimation(keyPath: "position")
    animation.fromValue = NSValue(cgPoint: CGPoint(x: 100, y: 100))
    animation.toValue = NSValue(cgPoint: CGPoint(x: 200, y: 200))
    animation.duration = 1
    layer.add(animation, forKey: nil)
    ```

总的来说，隐式动画适用于简单和常规的动画，而显示动画则适用于需要更复杂和定制的动画效果的情况。

:::

#### ❓做一些基于 `CALayer` 的动画时，有时需要设置 `layer` 的锚点来配合动画，需要注意什么

::: details 💡

 `CALayer` 的锚点 (`anchorPoint`) 属性决定了图层的哪一点会被放在 `position` 所指的位置，也就是图层的旋转，缩放等变换动画都是围绕这个点进行的。其默认值为(0.5, 0.5)，代表图层的中心点。

修改锚点注意点：

  - **位置变化**：锚点的改变会导致图层的位置移动，因为系统会自动将图层的 `anchorPoint` 放到图层的 `position` 所指的位置。因此，当改变锚点时，可能会看到图层 “跳跃” 到新位置。

    ```swift
    // 如果不希望图层移动，那么就需要在改变 anchorPoint 后，相应地调整图层的 position
    layer.anchorPoint = CGPoint(x: 0, y: 0)  
    layer.position = CGPoint(x: 0, y: 0)
    ```

  - **布局影响**：如果有基于图层的 `Auto Layout` 约束，改变 `anchorPoint` 可能会破坏这些约束。
   
  - **动画影响**：由于图层的旋转，缩放等变化动画都是围绕 `anchorPoint` 进行的，修改此点也会影响这些动画的表现。

  - **几何形状**：`anchorPoint` 的值的范围是在 `[0, 1]` 之间，表示在图层的大小中的相对位置，而不是具体的像素点。

:::

#### ❓`Core Animation` 的实现原理

::: details 💡

工作原理：

  - 图层树（`Layer Tree`）: 所有可见内容的模型，每一个 `UIView` 都有一个对应的 `CALayer`。图层树中的元素可以改变，这包括它们的位置、大小、内容等等。

  - 呈现树（`Presentation Tree`）: 当前屏幕上显示的内容的近似模型。它代表了图层树在任何给定的时间点的可视状态。

  - 渲染树（`Render Tree`）: 这是 `Core Animation` 来创建屏幕上实际像素的模型。渲染树包含了图层树的复制品，并添加了如阴影、形状等等内容。

  在动画过程中 `Core Animation` 会在各个帧之间对图层树的改变进行插值，并更新呈现树和渲染树，然后把最后的结果渲染到屏幕上。这个过程中会尽量复用尽可能多的像素，减少重绘的数量，从而提高动画的流畅度和性能。

:::

#### ❓`Core Animation` 实现交互效果(比如让动画播放一半, 点击让它停止)

::: details 💡

要使用 `Core Animation` 来实现交互（如在动画过程中点击停止），需要访问和控制当前正在进行的动画。

```swift
var isPaused = false  // 用于追踪动画是否已暂停

func toggleAnimation() {
    let layer = self.myView.layer
    if isPaused {
        // 恢复动画
        let pausedTime = layer.timeOffset
        layer.speed = 1.0
        layer.timeOffset = 0.0
        layer.beginTime = 0.0
        let timeSincePause = layer.convertTime(CACurrentMediaTime(), from: nil) - pausedTime
        layer.beginTime = timeSincePause
    } else {
        // 暂停动画
        let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)
        layer.speed = 0.0
        layer.timeOffset = pausedTime
    }
    isPaused = !isPaused
}
```

:::

------

## 渲染

### ❓`UI` 的渲染步骤

::: details 💡

`UI` 的渲染步骤：

  - **布局阶段**：`UIKit` 会计算出所有的视图的大小和位置。这个过程涉及到 `AutoLayout` 和 `Core Animation`，视图的位置和大小会被更新，同时所有的视图约束也会得到满足。对于 `UIView`，这一步涉及到了 `layoutSubviews` 方法。

  - **显示阶段**：所有需要的视图都会被调用 `drawRect:` 方法进行绘制。这里会调用 `Core Graphics` 来进行实际的绘制操作，在视图的 `layer` 上生成一张 `bitmap` 图片代表这个视图。

  - **准备阶段**：这一步主要是将所有的 `Core Animation` 动画提交给渲染服务器。

  - **渲染阶段**：
    * 这一步会进行事务的提交，所有的 `layer tree` 结构会在主线程中拷贝一份到渲染线程。
    * 然后，渲染线程会将视图的 `layer tree` 全部转换为 `OpenGL` 命令或者 `Metal` 命令，最后将其提交给 `GPU`。
    * `GPU` 会进行实际的绘制操作，包括光栅化、混合等步骤，最后将渲染结果显示到屏幕上。
   
  在整个渲染过程中，对 `CPU` 和 `GPU` 的使用是需要权衡的。对于由 `CPU` 进行的布局和显示工作，如果过于复杂，可能导致帧率下降，因为 `CPU` 无法在每帧刷新的时间限制内完成所有工作。对于 `GPU` 来说，过于复杂的渲染操作也可能导致性能问题，比如复杂的渲染效果或者过深的视图层次都可能导致 `GPU` 无法及时完成渲染。

总结：`UIKit 布局` => `Display` => `Prepare` => `Core Animation 提交事务` => `GPU 渲染`。整个过程如果在 16.7ms 之内完成，就能保证界面动画的流畅性。如果超过这个时间，就会出现丢帧卡顿现象。所以在开发中要尽量优化布局和渲染过程，避免过于复杂的操作。

:::

### ❓什么是屏幕渲染

::: details 💡
  
  | 渲染类型 | 说明
  | --- | ---
  | `CPU` 渲染 | 简单视图 `CPU` 渲染可能高于 `GPU` (不需要创建缓冲区和上下文切换)
  | `GPU` 渲染 | `GPU` 浮点运算能力强于 `CPU`，所以 `GPU` 渲染效率高于 `CPU`

  * **屏幕渲染**(On-Screen Rendering) : 在当前屏幕的缓冲区进行渲染。
    > 优点：不需要创建新的缓存，也不需要进行上下文切换，性能较好；缺点：缓存大小受限制，无法进行复杂的操作。
    
  * **离屏渲染**(Off-Screen Rendering) : `GPU` 在当前屏幕外，新开辟了一个缓冲区进行图片的渲染和合成。
    > 渲染完成之后再放入当前屏幕的缓冲区。这个过程需要 `CPU` 调度，将任务分配给 `GPU` 进行渲染然后再将渲染结果返回，需要进行上下文切换和内存读写等操作，对性能影响较大。
  
:::
  
### ❓哪些场景可以触发离屏渲染
  
::: details 💡

  > 离屏渲染：图形或文字无法在当前屏幕缓冲区完成渲染，需要额外创建一个图形缓冲区进行操作，完成后再加载到当前屏幕缓冲区显示。

`iOS` 以下几种场景会触发离屏渲染：

  - 使用阴影效果：如果给 `UIView` 添加阴影效果，会触发离屏渲染。如果可以的话，使用 `shadowPath` 来指定阴影路径，可以避免离屏渲染。
    > `layer.shadowXXX`
   
  - 使用圆角效果：对 `UIView` 的图层进行圆角裁剪(`cornerRadius`)时，如果同时设置了 `masksToBounds` 也会触发离屏渲染。
    > `layer.masksToBounds = true & layer.cornerRadius > 0`
   
  - 使用遮罩(mask)：`CALayer` 的 `mask` 属性可以设置遮罩，给视图层添加遮罩也会触发离屏渲染。
    > `layer.mask`
   
  - 使用光栅化：`shouldRasterize` 属性可以将图层缓存为位图并在 `GPU` 中重用，但这同时也会触发离屏渲染。
    > `layer.shouldRasterize = true`
   
  - 抗锯齿：设置视图的 `layer` 的 `allowsEdgeAntialiasing` 属性为 `true` 会触发离屏渲染。因为抗锯齿需要对视图的边缘像素进行额外的计算和混合，这些操作不能在当前屏幕的缓冲区完成，因此需要离屏渲染。所以，在大部分情况下，如果不是对视觉效果有非常高要求，通常不推荐开启抗锯齿，因为这会增加GPU压力，降低性能。
    > `layer.allowsEdgeAntialiasing = true`
  
  - 不透明度：设置视图的 `alpha` 值本身不会触发离屏渲染。但是有一种场景需要注意，那就是对有子视图的视图设置 `alpha` 值，并且该视图的 `opaque` 属性为 `true` 时，可能会造成额外的离屏渲染。这是因为系统需要先单独绘制这个视图和它的子视图到一个临时的缓冲区，然后将这个临时的缓冲区以指定的 `alpha` 值（也就是透明度）绘制到屏幕上。因此，为了避免这种离屏渲染，当你需要设置视图的`alpha` 值时，应该设置它的 `opaque` 属性为 `false`。
    > `opacity & opaque = true`

  离屏渲染对系统资源消耗比较大，因为它需要创建新的缓冲区，进行上下文切换，最后再把缓冲区的内容载入到屏幕缓冲区。如果在一个视图中使用过多的离屏渲染，可能会导致性能问题，所以在开发过程中需要尽量避免触发离屏渲染。

:::

------

## 事件分发

### ❓用户点击屏幕上按钮，整个过程讲一下

::: details 💡

  - 当用户触摸屏幕时，硬件会将触摸事件转化为一个或一系列的 `UITouch` 对象，并将它们与一次特定的事件(`UIEvent`对象)关联起来。系统会将触摸事件派发给对应的 `UIApplication` 对象。

  - `UIApplication` 对象接收到触摸事件后，会将事件传递给合适的 `UIWindow` 对象。`UIWindow` 对象再将其分发给正在显示的、并且能够响应事件的 `UIView` 对象。 

  - 如果此 `UIView` 对象就是所点击的视图(如：按钮 `UIButton` 对象)，那么此按钮会接收到此点击事件。

  - `UIButton` 对象接收到手势事件后，便会根据事件类型来调用对应的方法。
  
  - 若 `UIButton` 对象存在 `UIControl` 事件（比如 `TouchUpInside`）并且挂接有对应的 `Action`（函数方法），那么系统就会执行这个 `Action`。

:::

### 响应链

#### ❓响应者链条，一个视图不响应的原因

::: details 💡

  > 响应者链条（`Responder Chain`）是 `iOS` 中用来处理界面的 `touch`、`motion`、键盘事件的机制。每个事件有一个接收者，叫做第一响应者 (`First Responder`)，由 `UIApplication` 管理。如果该对象不能处理这个事件，那么它会沿着响应者链向上查找可以处理这个事件的响应者。

一个视图不响应的原因：

  - `userInteractionEnabled` 属性被设置为 `false`。
    > 默认情况下，所有 `UIView` 对象的 `userInteractionEnabled` 属性为 `true`。但是如果手动设置为 `false`，这个视图和它的所有子视图都不能再响应用户的操作。
  
  - 视图隐藏或者透明度极低
    > 视图的 `hidden` 属性设为 `YES` 或者 `alpha` 的值小于 0.01，这个视图除非成为第一响应者，否则对事件无响应。
  
  - 视图被其它视图遮挡。
    > 如果视图 A 被视图 B 完全或者部分遮挡，并且覆盖部分位于用户点击的位置，那么这个事件将被视图 B 捕获。
  
  - 视图超出超视图 `bounds`。
    > 当视图自身超出其父视图的区域范围，超出部分不再响应事件。

  - 视图不在视图层级中。
    > 如果视图还未被添加（或被移除）到视图层级中，那么它将不能响应事件。
    
:::

#### ❓事件响应链（Event Responder Chain） 这个详细的讲讲

::: details 💡

  > `Event Responder Chain` 事件响应链 : 是指当某一个事件发生，如触摸事件、系统事件等，这个事件会从一个对象传递到另一个对象的链式机制。这样从一个对象向另一个对象传递的链式过程就是事件响应链。

  - 当手指触摸屏幕时，`UIKit` 会创建一个包含了触摸的所有信息的事件对象，并会将该事件对象发送给视图层级中最前面的视图对象，即被触摸的视图。
  - 如果该视图不能处理该事件，那系统就会将事件传递给它的上一级视图，也就是它的 `superview`。
  - 如果上级视图也不能处理，那就接着向上传递，直到传递给窗口，再接着传递给 `UIApplication`，最后传递给 `UIApplication` 的代理。

详细的事件传递流程：

  - 如果一个视图是用户交互禁用的（`userInteractionEnabled = false`），或是隐藏的（`hidden = true`），或者是透明的(`alpha = 0`), 那么这个视图和他的子视图就无法成为第一响应者，也就接收不到任何事件。

  - 如果当前视图无法处理接收到的事件或者消息，那么它会将这个事件或消息传递给自己的 `superview`，如此往复，如果都处理不了的话，那么最后会传递给 `UIWindow` 对象。

  - 如果 `UIWindow` 对象也无法处理接收的事件或消息，那么就会传递给 `UIApplication` 对象。

  - 最后由 `UIApplication` 将事件或消息传递给应用程序的代理对象（也就是通常所说的`AppDelegate`）。

:::

#### ❓叠在一起的两个 `View` 哪个会响应

::: details 💡

  - 视图的层次结构：如果两个视图A和B叠在一起，那么对事件的响应权取决于这两个视图在其父视图中的添加顺序。
    > `UIView` 的子视图是按照数组的顺序存放的，后添加的子视图会在数组的后面，而响应事件的优先级则是从数组的后面向前遍历的。所以如果视图A是后添加到其父视图中，那么视图A会遮挡住视图B，并捕获并处理用户的触摸事件。
    
  - z轴的高度：如果为视图设置了`layer.zPosition`，可以改变视图在z轴上的位置，`zPosition` 值越大，视图越靠前，更可能接收到事件。

:::

> ❓如果不想让上面的 `View` 响应，怎么解决

::: details 💡

  - 设置`userInteractionEnabled`属性为`false`。
    > 这将禁用用户在上面的视图上的交互，把事件传递到它下面的视图。

    ```swift
    topView.userInteractionEnabled = false
    ```

  - 重载上面视图的 `hitTest:withEvent:` 方法。
    > 它的目的是找到能响应事件的最佳视图。你可以重写这个方法，让它返回下面的视图。

    ```swift
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        let hitView = super.hitTest(point, with: event)
        if hitView == self {
            return beneathView
        }
        return hitView
    }
    ```

  - 重写视图的 `pointInside:withEvent:` 方法，此方法用于检查触摸点是否在视图内。
    > 如果点在上面的视图外，触摸事件就会传递给它的底层视图。

    ```swift
    override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        // 在这里检查点是否在你想要的区域内
    }
    ```

:::

> ❓如果两个 `View` 都要响应呢

::: details 💡

  - 自定义 `UIView` 子类并重写 `hitTest` 方法或者 `pointInside:withEvent:` 方法来决定哪个视图需要处理接收到的触摸事件。

  - 在一个父视图中进行触摸事件的处理并在适当的时候传递给子视图。

    ```swift
    override func hitTest(point: CGPoint, withEvent event: UIEvent?) -> UIView? {
        let view = super.hitTest(point, withEvent: event)
        if view == self {
            return otherView;
        }
        return view
    }
    ```

:::

### hitTest

#### ❓`hitTest` 和 `pointInside` 的关系

::: details 💡

  - `hitTest:withEvent:` 是用来确定触摸事件应该由哪个子视图处理的方法。
    > 当用户触摸屏幕时，`UIKit` 会询问顶级视图来找出正确的视图处理事件。它会调用 `hitTest:withEvent:` 把触摸点的坐标和触摸事件作为参数传入。

  - `hitTest:withEvent:` 方法的实现通常会调用 `pointInside:withEvent:` 来检查触摸点是否在视图的 `bounds` 内。
    > 如果 `pointInside:withEvent:` 返回 `true`，那么 `hitTest:withEvent:` 就会返回这个视图，表示这个视图可以接收并处理这个触摸事件。
   
  - 如果视图是一个容器视图，并且包含其他子视图，`hitTest:withEvent:` 的实现通常会遍历所有的子视图，并且这个遍历通常是按照反序进行（也就是从顶层子视图到底层子视图）。
    > 对于每个子视图，都会调用 `hitTest:withEvent:`。如果这个方法返回了一个非 `nil` 的视图，那么遍历就会立即停止，并且这个被返回的视图会被认为是最合适处理这次触摸事件的视图。
   
  - 如果 `pointInside:withEvent:` 对所有子视图都返回 `false`，那么 `hitTest:withEvent:` 也就会返回 `nil`，表示这个视图和它的子视图都没有接收这次触摸事件。

:::

#### ❓`hitTest` 有重写吗

::: details 💡

  `hitTest:withEvent:` 可以在子类中重新实现，以更改触摸事件处理的默认行为。默认的实现会遍历视图层次结构，找出在给定点的视图，可以通过重写这个方法来定制这一行为。

```swift
// 扩大了一个视图的触摸区域
override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    let biggerRect = self.bounds.insetBy(dx: -30, dy: -30)
    return biggerRect.contains(point) ? self : nil 
}
```

:::

------

## 算法

### ❓寻找最近的公共 `View`

::: details 💡

```swift
// 寻找两个子视图最近的公共父视图
func findNearestCommonAncestor(view1: UIView, view2: UIView) -> UIView? {
    var currentView: UIView? = view1
    while let view = currentView { // 递归视图的父视图
        // 判断 view2 是否为当前遍历父视图的后代视图，如果是就是公共父视图
        if view2.isDescendant(of: view) { 
            return view
        }
        currentView = view.superview
    }
    return nil
}
```

:::

### ❓打印一个 `View` 的所有子 `View`，要求分层打印

::: details 💡

> 树的层序遍历问题

```swift
// 队列(Queue)来实现树的层次遍历
func printSubviewsInLevelOrder(for view: UIView) {
    var queue = [UIView]()
    queue.append(view)
    while !queue.isEmpty {
        var count = queue.count // 当前层数量
        var levelViews = [UIView]() // 当前层视图
        while (count > 0) {
            let levelView = queue.removeFirst()
            levelViews.append(levelView)
            count -= 1
            // 将当前层视图子视图继续加入队列
            for subview in levelView.subviews {
                queue.append(subview)
            }
        }
        print(levelViews) // 打印当前层视图   
    }
}
```

:::



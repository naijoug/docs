---
title: Objective-C
icon: hashtag

index: true

---

<!-- more -->

## reference

- [2018-07-01 isa && 元类 && 函数调用](https://minilv.github.io/2018/07/01/ias-class-metaClass/)

<!-- block -->

- [2013-11-27 objc 中的 block](https://blog.ibireme.com/2013/11/27/objc-block/)
- [2013-05-29 对 Objective-C 中 Block 的追探](http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html)

<!-- NSCache -->

- [2015-12-09 NSCache 源码分析](https://github.com/nixzhu/dev-blog/blob/master/2015-12-09-nscache.md)
- [2015-02-11 Foundation: NSCache](http://southpeak.github.io/2015/02/11/cocoa-foundation-nscache)
- [2012-07-14 NSCache](http://nshipster.com/nscache)

------

## 设计理念

  `OC` 底层是使用 `C/C++` 实现。定一个继承 `NSObject` 的类，这个类底层使用 `C` 语言中的 `struct` 结构体来实现的。 

### ❓`OC、Java、Python` 运行效率孰高

::: details 💡

- `Objective-C`: 编译型语言，运行效率通常优于解释型语言。底层是基于 `C`，但是由于动态派发的特性会一定程度上影响效率。

- `Java`: 编译型语言，运行环境是 `JVM`(`Java` 虚拟机)，通过 `JIT`(Just In Time compiler)技术，`Java` 能将字节码实时地编译成机器码运行，因此运行效率**较高**，而且在大数据和 `Web` 服务领域表现优秀。

- `Python`: 是解释型语言，其运行效率**较低**，无法与编译型语言相比。但是 `Python` 的易读性、易写性以及丰富的第三方库，使它在科学计算、人工智能等领域得到了广泛的应用。

:::

### ❓`OC` 的动态性

::: details 💡

> `OC` 的 `runtime` 文档中介绍中就详细写明了，`runtime` 的设计是为了将更多的处理延迟到编译后。
 
  - 动态类型 (`Dynamic typing`) : 编译时并不确定对象类型，在运行时才判断对象的类型。`OC` 中一切对象都可以用 `id` 指针指向。
  
  - 动态绑定 (`Dynamic binding`) : 方法的调用也是运行时才决定，而并非编译时。
  
  - 动态加载 (`Dynamic loading`) : 运行时可以动态加载其它模块或框架。

:::

### ❓`OC` 是如何保证系统升级后 `ABI` 的稳定性

::: details 💡

- 向后兼容（`Backward Compatibility`）：新版本的系统库在设计和更新时，会尽量保证向下兼容。

- 动态性（`Dynamic Nature`）：作为一种动态语言，`OC` 大量使用动态分发和运行时解析。这意味着很多事情在运行时才确定，例如方法的调用、对象的生成等。这种机制在维护 `ABI` 稳定性时有很大的灵活性，可以在运行时解析和处理一些可能的问题。 

- 利用类和分类（`Class and Category`）：使用类和分类来模块化代码，使得代码逻辑更容易管理，也更利于维护 `ABI` 稳定性。在新增或者修改功能时，可以通过添加新的类或者分类，而不是修改旧的代码，这样就能保证旧的代码逻辑和 `ABI` 不被破坏。

- 接口过期标注(`API Deprecation`)：系统库在引入新的接口时，会把不推荐使用的旧接口标记为 `deprecated`，但不会立即删除，这样就可以保证依赖旧接口的代码在一段时间内可以正常运行。

  以上这些都只能尽可能地保证 ABI 的稳定性，但并不能绝对地保证。因为系统升级往往会引入新的功能、新的架构，或者修复旧的 `bug`，这些都可能对 `ABI` 产生影响。所以，作为开发者在编写代码时，也需要注意兼容性，避免过度依赖可能会变动的接口和行为。

:::

------

## 数据类型

### id

#### ❓`id` vs `self` vs `super`

::: details 💡

- `id`：一种数据类型，也叫做动态对象类型，所有的 `Objective-C` 对象都可以用 `id` 类型来接收。`id` 类型会忽略类型信息，可以给它发送任何消息，如果在运行时对象能够响应这个消息，则代码可以正常运行，否则会在运行时报错。

- `self`: 每个对象方法的隐含参数，它指向调用当前方法的对象。`self` 的数据类型也是 `id`，但它通常用来引用对象自己。可以用 `self` 来访问属性或者调用方法。

- `super`: 并不是一个指针，是一个编译器标识符，代表当前对象的父类。当你向 `super` 发送消息时，编译器会沿着方法的继承链向上寻找，直到找到对应的方法实现为止。这个机制可用于在子类中调用父类的同名方法，以实现代码的复用。

:::

#### ❓`id` vs `NSObject`

::: details 💡

- `id`: 一个动态类型的对象指针，它可以指向任何类型的 `Objective-C` 对象。`id` 类型的对象可以接收任何消息而不会在编译期报错，运行期若无法响应则会引发异常。使用 `id` 类型可以编写出非常灵活的代码，但是也需要面对潜在的运行期错误。

- `NSObject`: 是所有 `Objective-C` 类的基类，定义了一些所有对象都能响应的基本方法，例如 -`init`、`retain`、`release` 等。如果一个对象类型声明为 `NSObject *`，只能给它发送 `NSObject` 类中定义的方法。如果试图发送其他消息，会得到一个编译错误。

:::

#### ❓`id` vs `instancetype`

::: details 💡

- `id`：一个动态类型的对象指针，可以指向任何类型的 `Objective-C` 对象。使用 `id` 类型的变量可以调用任何方法，如果该对象的类实现了该方法，那么就会在运行时调用。缺点是编译器无法进行类型检查和自动补全。

- `instancetype`：一种特殊的类型，主要用于表示对象的实例，用在方法的返回类型中。与 `id` 类型不同，方法使用 `instancetype` 作为返回类型，那么编译器会认为该方法返回一个当前类的实例。这个特性可以帮助编译器进行更准确的类型检查，同时还能提供自动补全的支持。

:::

#### ❓`id` 为什么不能用点语法

::: details 💡

  > 点语法是一种简化属性访问的语法。底层实际上是编译器做了一个转换操作，把点语法转换成相应的 `getter`（对于获取属性）或者 `setter`（对于设置属性）方法的调用。

- 明确类型的对象，编译器可以知道对象的类定义，知道该对象所拥有的属性和方法，所以在编译期可以正确地做出转换。

- `id` 类型的对象，编译器无法知道它的实际类型以及拥有的属性和方法，所以无法进行点语法的转换。

:::

### ❓`nil` vs `Nil` vs `NULL` vs `NSNull`

::: details 💡

> 这些都是表示"无"或"空"的特定值

  - `nil`：一个表示对象指针为空的特殊值。

  - `Nil`：一个表示类指针为空的特殊值。

  - `NULL`：一个表示未指向任何东西的原始指针的特殊值。正如你在任何纯`C`的代码和`Objective-C`代码中看到的，`NULL`通常指针表示"没有东西"或者是"无"。

  - `NSNull`：一个表示空值的类，通常在不能使用`nil`的情况下表示空值。比如在`NSArray`或`NSDictionary`对象中，你不能直接使用`nil`，但你可以用一个`NSNull`对象来代表"没有值"的情况。

:::

### ❓类簇的优缺点

::: details 💡

  > 类簇（`Class Cluster`）是一种设计模式，在 `Objective-C` 的类库中有广泛的运用，例如`NSString`，`NSArray`，`NSDictionary`等都是类簇的例子。类簇将一些实现细节封装在内部，对外只提供一个简单的公共接口。

- 优点：

    * 封装：类簇将相关的子类放在同一个父类中，使得框架更加简洁，使用者无需熟悉大量类就能够做很多事情。

    * 隐藏实现细节：对外只暴露抽象的接口，隐藏了具体实现的细节。这也保护了代码的稳定性，即使在实现过程中改变了相关的类或算法，对外接口的不变就保证了代码的稳定性。

    * 代码的分层更加清晰：类簇模式将数据和操作数据的方法绑定在同一个对象上，使得类的分层关系更清楚。

- 缺点：

    * 可扩展性差：由于类簇的具体实现不对外暴露，所以如果需要定制某些特殊的行为，扩展性就会变得很差。

    * 创建子类困难：由于大部分方法在私有子类中实现，如果要创建类簇的子类并覆盖某些方法，可能需要实现大量的代码才能获得预期的行为。

    * 维护难度大：由于类簇中包含了大量的私有子类，如果要修改或扩展代码，就需要对所有的子类进行处理，这会增加维护难度。

:::

### NSString
  
#### ❓`OC` 中的三种字符串
    
::: details 💡
    
  - `__NSCFConstantString` ：在编译时被创建的常量字符串对象，如`NSString *str = @"Hello, World!"`。这些对象会在编译时就被创建，并且在程序的整个生命周期中都不会被销毁。
  
  - `__NSTaggedPointerString` ：使用 `Tagged Pointer` 技术来提高内存使用效率，通常用于存储较小的字符串数据。
  
  - `__NSCFString` ：本质上是一个 `Core Foundation` 字符串的引用（`CFStringRef`），这种类型的字符串通常会在运行时程序动态创建的对象字符串。

:::

> ❓`Tagged Pointer` 了解吗

::: details 💡

  > `iOS 7` 之后 `Apple` 为了优化引入的一项技术。从字面意思上来看`Tagged Pointer`就是带有标签的指针。
  
  一般来说，在 `64-bit` 架构下，一个指针的值需要占用 `8 byte` 的内存空间；然而对于一些非常小的数据，比如 `NSNumber`、`NSDate`、`NSString` 等，使用 `8 byte` 存储对象指针就显得非常浪费。为了解决这个问题，苹果引入了 `Tagged Pointer` 技术，通过标签直接将小的数据对象嵌入到指针中，这样对于小的数据对象，就无需额外的内存来存储了，能够显著提高内存的利用率。需要注意，一个对象是否使用 `Tagged Pointer` 是由系统决定的，不能人为控制。
  
  具体到 `NSString` 这种场景中，如果字符串的内容非常短，那么它的实现方式可能就是 `Tagged Pointer`，直接将字符串内容存在指针中，提高了内存利用率。
  
:::

#### ❓`NSString` 如何计算字符的个数

::: details 💡

  可以使用 `NSString` 的 `length` 属性来获取字符串长度，但这实际上返回的是字符串中 `Unicode` 编码的字符数量，并不是通常意义上的字符数量。例如，一个中文字符和一个 `emoji` 表情，可能都会被算作多个 `Unicode` 字符。

可以使用 `NSString` 的 `enumerateSubstringsInRange:options:usingBlock:` 方法，用 `NSStringEnumerationByComposedCharacterSequences` 选项来统计字符串的字符数量。

```objc
__block NSUInteger characterCount = 0;
[myString enumerateSubstringsInRange:NSMakeRange(0, myString.length)
                           options:NSStringEnumerationByComposedCharacterSequences
                        usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {
    characterCount++;
}];
```

:::


### NSArray

#### ❓`[[NSMutableArray alloc] init]` vs `[NSMutableArray array]`

::: details 💡

- 相同点：都是用来创建一个可变数组的。

- 不同点
  * 代码简洁度：`[NSMutableArray array]` 比 `[[NSMutableArray alloc] init]` 代码更简洁，更易于阅读和理解。
  * 返回的对象所有权：`[[NSMutableArray alloc] init]` 返回的是一个引用计数为 1 的对象，而 `[NSMutableArray array]` 返回的是一个自动释放的对象（`autoreleased object`）。因此，如果在方法内创建了数组，然后需要返回这个数组，那么 `[NSMutableArray array]` 是一个更好的选择，因为它返回的对象会在方法结束后自动释放，不需要手动释放。如果是在方法内部创建数组，且数组在方法结束后就不再需要，那么 `[[NSMutableArray alloc] init]` 是一个更好的选择，因为它的引用计数为1，当不再需要它时，可以通过调用 `release` 方法将其释放。

:::

#### ❓`NSMutableArray` 的底层实现

::: details 💡

> `NSMutableArray` 是一个动态数组，可以增加和删除元素。

实现原理：

  - 在创建 `NSMutableArray` 时，会分配一段连续的内存空间，用来保存元素。当元素数量超过数组的容量时，`Foundation` 框架会创建一个新的、更大的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。

  - 当从 `NSMutableArray` 中删除元素时，它并不会立即收缩内存空间。相反，被删除元素的位置会被标记为空闲，可以用来保存新添加的元素。只有当数组的空闲空间达到一定的阈值时，`Foundation` 框架才会创建一个新的、更小的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。

:::

### NSDictionary

#### ❓`NSDictionary` 的底层实现

::: details 💡

> `NSDictionary` 是一个以键值对形式存储对象的接口，是一种哈希表实现。

实现原理：

  - 哈希表：在哈希表中，哈希函数将每个键 (`key`) 映射到表中一个唯一的索引。通过该索引，存储的相关值 (`value`) 可以快速地被找到。这就是 `NSDictionary` 可以快速查找键对应值的原因。

  - 碰撞处理：当两个或者更多的键映射到哈希表的同一个位置时，就会发生碰撞。通常情况下，有几种策略可以处理这种碰撞，比如链地址法，开放地址法等。不过具体 `Foundation` 使用哪种策略去处理碰撞我们并不清楚。

  - 动态调整：随着数据的增加，为了保持操作的高效，哈希表可能需要进行扩容。扩容经常伴随着数据的重新哈希，为的就是保持哈希值均匀分布，保持优秀的查找效率。
    
:::
  
#### ❓`NSDictionary` vs `NSHashTable` vs `NSMapTable`

::: details 💡

> `NSDictionary`，`NSHashTable` 和 `NSMapTable` 都是 `Objective-C` 中常用的集合类型。

  - `NSDictionary`：存储键值对的集合，每个键都映射到一个值。对键进行 `copy` 操作，对值进行 `retain`(强引用)操作。键必须要保持唯一。查找操作性能高效，时间复杂性为 `O(1)`。

  - `NSHashTable`：一个可以存储任意对象的集合，集合中的每个对象都是唯一的。该类提供了对对象强引用、弱引用的选项，可以更加灵活地进行内存管理。

  - `NSMapTable`：和 `NSDictionary` 非常相似，但 `NSMapTable` 对键和值可以选择强引用或弱引用，比 `NSDictionary` 更加灵活。另外，`NSMapTable` 允许键和值为`nil`，而 `NSDictionary` 则不允许。

:::
  
> ❓各自有哪些使用场景
  
::: details 💡
   
  - `NSDictionary`：`NSDictionary` 由于其高效的查找速度，广泛用于需要依据键查找值的场景。
    > 例如，配置文件的存储和读取，网络请求的参数封装，JSON 数据的解析等。

  - `NSHashTable`：`NSHashTable` 适用于存储不需要重复的对象，并且对内存管理有一定要求的场景。
    > 例如，在缓存中存储对象但不引入强引用，防止内存无法释放的问题；或者在存储 `delegate` 对象时，避免引入循环引用。

  - `NSMapTable`：`NSMapTable` 可以实现强引用和弱引用键值对，所以适用于一些特殊场景。
    > 例如，在不引入强引用的情况下缓存对象，或者希望跟踪哪些对象引用了其它对象等。

:::
   
#### ❓`NSDictionary` vs `NSCache`

::: details 💡

`NSDictionary` 和 `NSCache` 都是能够存储键值对的集合，但它们有一些主要的区别，使它们适用于不同的使用场景：

1. `NSDictionary` 是一个不可变的哈希表，其中的键值对都是强引用的。键是唯一的且不可变的。相比之下，`NSCache` 是一个可变的集合，其中的键值对都是强引用的，但有一个例外：键不是像 `NSDictionary` 管理那样通过 `copy` 管理，而是通过 `retain` 管理，因此键可以是可变的。

2. 另一个重要的区别在于内存管理。`NSCache` 在系统内存不足时，会自动释放缓存的部分或全部数据以节省内存。这使得在处理大量数据时，`NSCache` 可以自动处理低内存警告，而 `NSDictionary` 则需要手动处理低内存警告。

3. `NSCache` 支持通过 `NSDiscardableContent` 协议来控制缓存内容的生命周期。这样的对象在被缓存时，可以增加一个 `beginContentAccess` 之后配对的 `endContentAccess` 调用计数器。当对象的计数器为 0 时，那么这个对象就有可能被清出缓存。

综上所述，`NSDictionary` 和 `NSCache` 的不同主要在于内存管理和可变性。实际上，`NSCache` 更类似一个优化了内存管理的 `NSMutableDictionary`，更适合用于存储大量会占据大量内存的对象，例如图片等。

:::

  > ❓`NSCache` 中缓存的对象，在什么时候被释放

::: details 💡

- 内存压力：当操作系统触发低内存警告时，`NSCache` 会自动释放一些缓存的对象以节约内存。

- 缓存某个对象的 `NSCache` 实例被销毁时，该对象会被释放。

- 当缓存达到其极限时（这取决于你设置的缓存的数量和总成本的上限），`NSCache` 可能会开始移除一些对象。

- 如果缓存的对象实现了 `NSDiscardableContent` 协议，那么对象的释放还会取决于它的 `beginContentAccess` 和 `endContentAccess` 方法的调用计数。当这个计数为 0 并且内存压力较大时，对象可能被释放。

:::

#### ❓`isEqual` 和 `hash` 的关系

::: details 💡

- `isEqual:` 方法是用来判断两个对象是否相等。
    > 如何判断对象的相等性，可以在自定义类中重写这个方法来自定义判断规则。

- `hash` 方法返回一个无符号整数（`NSUInteger`）的哈希值，这个值被用于 `UITableView`、`NSSet`、`NSDictionary` 等集合类的操作以提升性能。
    > 对象的哈希值主要是通过对象的内容进行计算得出。

- `isEqual:` 方法和 `hash` 方法需要保持一致，意思是当两个对象 `isEqual` 的返回值相等时，它们的 `hash` 方法返回值必须也相等。
    > ⚠️ 反过来并不一定，即如果两个对象的 `hash` 值相等，并不一定要求他们 `isEqual` 值也一定相等，因为不同的对象有可能产生相同的哈希值（通常被称为哈希冲突）。 

总结：如果需要自定义对象及其相等性的规则，那么通常需要同时重载 `isEqual:` 和 `hash` 方法，并确保它们的行为是一致的。

:::

------

## 属性

### ❓`@property` 是什么

::: details 💡

  > `@property` 是 `Objective-C` 中的一个关键字，用于声明一个属性。主要作用是为类的实例变量（属性）生成对应的访问器方法，即 `getter` 方法和 `setter` 方法。
  
  
- `@property` 修饰器
  
  * 原子性 : `atomic`、`nonatomic`
  * 读写性 : `readwrite`、`readonly`
  * 内存管理 : `assign`、`strong`、`weak`、`copy`
  * 兼容性(`Swift`) : `nullable`、`nonnull`、`class`

- `@property` 优点
  
  * 隔离性：可以封装实例变量的直接访问，将类的内部实现与外部接口隔离，提高数据的安全性。
  * 可维护性：可以在 `getter` 和 `setter` 中添加特定的逻辑如设置新值时进行验证，获取值时返回一个计算后的值等，提高代码的可维护性。 

:::

### ❓`@property` 的默认关键字
  
::: details 💡

```objc
// 基本数据类型 => 默认是: atomic, readwrite, assign
@property int num;
// 对象数据类型 => 默认是: atomic, readwrite, strong, nullable
@property NSObject *obj;
```

:::
  
### ❓`@property` 的底层实现

::: details 💡  
  
  > `@property` 是一个关键字，用于声明类的属性。声明一个属性时，编译器会自动生成一些代码，这就是 `@property` 的底层实现。

  - 实例变量：`@property` 在默认情况下会自动合成一个带下划线前缀的实例变量。
    > 例如声明了一个名为 `foo` 的属性，编译器会自动生成一个名为 `_foo` 的实例变量。

  - `getter` 和 `setter` 方法：会为属性自动生成 `getter` 和 `setter` 方法。

  - 内存管理：指定的属性修饰符（`assign`、`strong`、`weak`、`copy` 等），编译器会在 `setter` 方法中生成相应的内存管理代码，比如引用计数的增加和减小，拷贝对象等。

  - `KVO` 支持：`@property` 自动生成的 `getter` 和 `setter` 方法支持键值观察(`Key-Value Observing`)，允许其它对象观察和响应属性值的改变。
    

  > `runtime` 层面
  
  声明 `@property` 后，编译器会根据属性的特性在 `class_rw_t` 结构中的 `methods` 和 `properties` 中生成 `getter` 和 `setter` 方法以及相应的属性。然后在运行时，这些 `getter` 和 `setter` 方法以及属性被引入到 `objc_class` 的结构中。
  
  ```objc
  struct objc_class {
      Class isa;              // metaclass 的指针
      Class super_class;      // 父类
      cache_t cache;          // 缓存
      class_data_bits_t bits; // 类的相关信息，包含了一个指向 class_rw_t 数据结构的指针
  };
  // 可读写结构，存储运行时添加的类信息
  struct class_rw_t {
      uint32_t flags;
      uint32_t version;
      const class_ro_t *ro;           // 只读结构体，保存编译时确定的类信息
      method_array_t methods;         // 方法列表
      property_array_t properties;    // 属性列表
      protocol_array_t protocols;     // 协议列表
      Class firstSubclass;
      Class nextSiblingClass;
  };
  ```
  
::: 
  
### 原子性
  
#### ❓ `atomic` vs `nonatomic`

::: details 💡



:::

#### ❓`atomic` 修饰的属性是否可以被重载

::: details 💡



:::
  
### 内存管理
  
#### ❓`assign`、`strong`、`weak`、`copy` 区别
  
::: details 💡
  
  - `assign`：是赋值特性，简单设置变量，不更改引用计数。
    > 主要用在基本的数据类型（如 `int`、`float`）或 `C` 数据类型（如 结构体、数组）而不是对象。
  
  - `strong`（类似于：`retain`）：是所有权（owning）特性。
    > 采用 `ARC`（自动引用计数）环境下，编译器会自动在设置方法中插入 `retain` 调用，使对象的引用计数增加，从而表示当前对象拥有数据值。
  
  - `weak`：是非拥有关系（non-owning）特性，即弱引用。
    > 当用 `weak` 修饰对象时，被指向的对象引用计数不会增加，更重要的是，当对象被释放时，被 `weak` 修饰的变量会自动被置为 `nil`，防止野指针的出现。`weak` 修饰的属性适合在已经存在对对象的 `strong` 引用，或者对象之间存在相互循环引用的情况下使用。
  
  - `copy`：是拷贝特性。
    > 适合 `NSString`、`NSArray`、`NSDictionary` 等不可变对象。最重要的一点是：使用 `copy` 保持封装性，对象在内部可能需要一个数据的完整副本，并且把这个副本给外界使用，防止作为接口提供的对象的初始数据被改变。

  选择哪种属性修饰符要视情况而定，如果数据是不可变的，那么选择 `assign` 或 `copy` 较好；如果数据是可变的，可以选择 `strong` 或 `weak`。

:::

#### ❓`assign` 可以用于 `OC` 对象吗

::: details 💡

  > `assign` 是一种属性修饰符，用于指定属性的赋值语义。`assign` 可以用于任何数据类型，包括 `Objective-C` 对象。但是，对于对象来说不推荐使用 `assign`。

  将 `assign` 用于 `Objective-C `对象时，其会生成一个设置器，其行为将传入的值赋值给实例变量，并不改变该对象的引用计数。如果该对象在其它地方被释放，那么这个引用就成了一个悬挂指针（或者说“野指针”），这将会引起程序在调用该对象时崩溃。

  > 在某些特定场景下，可能会选择使用 `assign`。例如，当需要创建一个 “弱引用并且不希望在对象被释放时自动设置为 `nil`” 时，`assign` 就会是个不错的选择，但是需要确保不会发生悬挂指针。

:::

#### ❓`copy` 一般会用来修饰 `NSString`，可以使用 `strong` 吗

::: details 💡

  > `NSString` 使用 `copy` 是为了防止在赋值可变字符串时由于原字符串发生改变而引发非预期问题。

  - `NSString` 的子类 `NSMutableString` 是可以变化的。如果使用 `strong` 并把一个 `NSMutableString` 实例赋值给 `NSString` 对象，然后改变该 `NSMutableString` 实例，那么 `NSString` 实例也会随之改变。

  - 如果使用 `copy`，当一个 `NSMutableString` 实例赋值给 `NSString` 对象时，实际上会复制一个不可变的副本。这样即使原字符串改变 `NSString` 实例也不会受影响。
  
:::

### 兼容性

#### ❓`nonnull`、`nullable` 用过吗

::: details 💡
  
  这两个修饰符是在 `Objective-C` 中引入的一个新特性，它起源于 `Swift` 语言中的 `Optional` 类型。在 `Swift` 中，每个变量或者函数返回值都必须明确说明是否可以为空。为了在 `Objective-C` 和 `Swift` 的桥接中保持一致，引入了这两个修饰符来明确对象的 `nil` 状态。
  
  - `nonnull`：这个修饰符表示一个对象不应该为空，也就是说这个参数或者返回值绝对不能为 `nil`。如果试图将 `nil` 赋值给一个 `nonnull` 的变量，编译器会给出警告。

  - `nullable`：这个修饰符和 `nonnull` 的功能恰恰相反，它表示一个对象可以为空，也就是这个参数或者返回值可以为 `nil`。一个没有被显式声明为 `nonnull` 或者 `nullable` 的对象默认为 `nullable`。

注意：这两个修饰符只是用来帮助编译器检查代码的错误，并不能真正阻止程序员将 `nil` 赋值给 `nonnull` 的对象，这个判断还需要开发者在编码时自己注意。

:::

#### ❓`class` 属性修饰器

::: details 💡

> `class` 属性修饰符主要运用于定义一个类类型的属性，它的用途主要是标明一个 `property` 的关联对象类型是一个类属性，而非一个实例属性。

```objc
@property (class, nonatomic, readonly) NSString *appName;
```

:::

### @synthesize

#### ❓`@synthesize` vs `@dynamic`

::: details 💡

- `@synthesize`：告诉编译器编译时自动创建 `getter/setter` 方法，如果没有手动实现的话。

- `@dynamic`：这个关键字告诉编译器,属性的 `getter` 和 `setter` 方法由自己实现，不自动生成（当然对于`@dynamic var`，编译器还是会默认添加其成员变量`_var`），如果没有手动实现 `setter/getter`，那么程序运行时，编译器发现找不到 `setter/getter` 就会崩溃。好处是可以在运行时动态绑定对象。

> `@dynamic` 常常和运行时函数 `class_addMethod` 配合使用，可以动态添加方法。最常见的应用是在 `Core Data` 的 `NSManagedObject` 子类中，`Core Data` 的属性经常被设置为 `@dynamic`，`NSManagedObject` 利用 `Core Data` 的底层存储访问这些属性，以便将对象的实际数据保存在磁盘上，而不是内存中。 

:::

#### ❓`@synthesize` 合成实例变量的规则是什么

::: details 💡

  > `@synthesize` 指令在实现(`.m`)文件中用于让编译器自动生成与属性相对应的实例变量，并且会为这个实例变量生成 `getter` 和 `setter` 方法。

`@synthesize` 基本规则：

  - 当在 `.h` 文件中用 `@property propertyName;` 声明一个属性时，编译器会自动生成一个名为 `_propertyName` 的实例变量，这个实例变量的名称是属性名前加一个下划线。如果无法访问这个实例变量，那么可能就需要用到 `@synthesize` 来让编译器生成这个实例变量。

  - `@synthesize` 后面可以跟上一个或者两个变量名。如果跟上一个变量名如 `@synthesize propertyName;` 那么编译器会仅为 `propertyName` 这个属性生成一个名为 `propertyName`（没有下划线）的实例变量。如果跟上两个变量名，如 `@synthesize propertyName = _propertyName;` 编译器会为 `propertyName` 这个属性生成一个名为 `_propertyName` 的实例变量。

  - 如果一个属性被 `@synthesize` 指定了一个实例变量，那么这个属性的 `getter` 和 `setter` 方法就会和这个实例变量绑定，即通过 `getter` 和 `setter` 方法操作的就是这个实例变量。

```objc
@implementation MyClass
@synthesize foo = myFoo; // 创建一个名为 myFoo 的实例变量
@end
```

:::

> ❓如果属性名为 `foo`，存在一个名为 `_foo` 的实例变量，还会自动合成新变量么

::: details 💡

  属性名为 `foo`，同时已经实现了一个名为 `_foo` 的实例变量，那么在默认情况下（也就是没有使用 `@synthesize` 关键字来手动指定成员变量名），编译器不会再合成新的实例变量。因为编译器默认的命名规则是在属性名前加 `_` 作为成员变量名，如果已经存在这样的成员变量，编译器就不会再创建新的变量。

```objc
@interface MyClass : NSObject
@property (nonatomic, strong) id foo;
@end

@implementation MyClass {
    id _foo; // 不会再合成新的实例变量
}
```

:::

#### ❓`@synthesize` 的使用场景

::: details 💡

- 设置实例变量名。
    > `@synthesize` 关键字允许手动改变自动生成的实例变量的名称。

- 协议属性自动合成。
    > 实现协议时，为了避免重复编写代码，可以使用 `@synthesize` 来自动合成协议中定义的属性。 

- 不生成实例变量。
    > 当在类扩展 (`@interface MyClass()`) 或者父类中已经声明了属性的实例变量 `_foo`，此时在子类中如果 `@synthesize foo;`，则不会生成 `foo` 对应的实例变量。

- 生成实例变量。
    > 当在头文件或者类扩展（`@interface MyClass()`）中声明 `@property` 属性但没有 `@synthesize foo;`，则会自动生成 `_foo` 实例变量。如果在 `.m` 文件中声明 `@property` 属性但没有 `@synthesize foo;`，则不会自动合成属性的实例变量。

> 在 `Xcode 4.4` 及以上版本中，默认已经开启了 `@synthesize` 自动生成，已经不需要显式地使用 `@synthesize`，除非在某些特殊情况下需要手动指定实例变量的名字。

:::

------

## 拷贝

### ❓`copy` vs `mutableCopy`

::: details 💡

> `copy` 和 `mutableCopy` 是 `NSObject` 类中定义的方法，被用来创建对象的拷贝。

  - `copy`：执行的是浅拷贝（也叫做指针拷贝），拷贝后的对象类型是不可变的。
    > `copy` 并没有开辟新的内存空间，而是拷贝对象持有的指针。因此原始对象和拷贝对象指向相同的内存地址。

  - `mutableCopy`：执行的是深拷贝（也叫做内容拷贝），拷贝后的对象类型是可变的。
    > `mutableCopy` 会开辟一块新的内存空间，拷贝对象的值到这块新的内存空间。

注意：浅拷贝并不意味着拷贝出来的对象一定是不可变的，具体还需要看拷贝的源对象是什么类型。如果拷贝的源对象是不可变的，那么 `copy` 方法拷贝出来的对象也是不可变的；如果拷贝的源对象是可变的，那么 `copy` 方法拷贝出来的对象就是可变的。

:::

> ❓`copy` 修饰的属性，拷贝发生的时机

::: details 💡

  `copy`关键字修饰的属性，拷贝动作发生在 `setter` 方法被调用时。具体发生在属性被赋值的过程之中，新的对象通过 `copy` 方法生成，然后被赋值给属性。

```objc
@property (nonatomic, copy) NSString *name;

// 属性赋值
person.name = @"John";
// 等价于
[person setName:[@"John" copy]];
```

:::


### ❓`copy` 修饰的属性的 `setter` 方法如何重写

::: details 💡

```objc
@interface MyClass : NSObject
@property (nonatomic, copy) NSString *myString;
@end

@implementation MyClass
- (void)setMyString:(NSString *)newString {
    // 先检查新值与旧值是否相等
    if (_myString != newString) {
        _myString = [newString copy]; // 使用 copy 进行赋值
    }
}
@end
```

:::

### ❓`copy` 一般用于不可变对象，为什么

::: details 💡

- 使用 `copy` 可以防止不可变对象在外部被意外修改。

    ```objc
    @interface Person : NSObject
    @property (nonatomic, copy) NSString *name;
    @end
    
    NSMutableString *mutableString = [NSMutableString stringWithString:@"Hello"];
    Person *person = [[Person alloc] init];
    person.name = mutableString;
    [mutableString appendString:@" World"];
    NSLog(@"%@", person.name); // "Hello"，使用 copy，person.name 不会随着 mutableString 的改变而改变
    // 如果 name 使用 strong 修饰，则会会打印 "Hello World"
    ```

- 某些具有父子关系的类，子类对象赋值给用 `copy` 修饰的父类变量后，父类变量会变为原来的父类特性(里氏替换)。
    
    ```objc
    NSMutableString *mutableString = [NSMutableString stringWithString:@"Hello"];
    NSString *copyString = [mutableString copy];
    [mutableString appendString:@" World"];
    NSLog(@"%@", copyString); // "Hello"，copy 后的 copyString 是不可变的，所以它的值不会改变
    ```

:::

### ❓`@property (copy) NSMutableArray *array;` 这个写法正确吗

::: details 💡

这个写法可以运行通过，但从代码规范和最佳实践来说，这并不是一个好的写法。

  给一个属性添加 `copy` 标识时，这个属性的 `setter` 将会使用传入对象的 `copy` 方法来创建一个新的对象。然而，在 `Objective-C` 中，`copy` 方法对 `NSMutableArray` 实例调用将返回一个 `NSArray` 实例。这是由于 `copy` 策略总是返回一个不可变的副本。

  所以，如果用 `@property (copy) NSMutableArray *array;` 这个写法，实际上得到的 `array` 是一个不可变数组 `NSArray`。在后续代码中尝试向这个 “可变数组” (`NSMutableArray`) 中添加或删除元素时，将会导致运行时错误。

:::

> ❓`NSMutableArray` 属性如何支持 `copy` 

::: details 💡

需要手动实现属性的 `getter` 和 `setter` 方法，并在 `setter` 方法中使用 `mutableCopy` 进行拷贝。

```objc
@interface MyClass : NSObject
@property (nonatomic, strong) NSMutableArray *array;
@end

@implementation MyClass

- (void)setArray:(NSMutableArray *)newArray {
    // 这样可以保证每次设置新数组时都创建一个可变副本，而不是指向原始数组。
    _array = [newArray mutableCopy];
}

@end
```

:::

### ❓自定义类如何实现 `copy` 功能

::: details 💡

  自定义类需要支持拷贝功能，需要遵循并实现 `NSCopying` 协议，并重写 `copyWithZone:` 方法。

```objc
// 自定义类 Person 实现 copy 功能
//  - 1> 遵循 NSCopying 协议
@interface Person : NSObject <NSCopying>
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSUInteger age;
@end

@implementation Person
//  - 2> 实现 copyWithZone: 方法
- (id)copyWithZone:(NSZone *)zone {
    Person *copyPerson = [[[self class] allocWithZone:zone]init];
    copyPerson.name = [self.name copyWithZone:zone]; // 对象类型属性需要调用 copyWithZone 完成拷贝
    copyPerson.age = self.age;
    return copyPerson;
}
@end

// 使用
Person *person = [[Person alloc] init];
Person *newPerson = [person copy]; // 完成拷贝
```

:::

### ❓自定义类如何实现 `mutableCopy` 功能

::: details 💡

  自定义类型实现 `mutableCopy`，需要遵循 `NSMutableCopying` 协议，并实现 `mutableCopyWithZone:` 方法。

```objc
@interface Person : NSObject <NSMutableCopying>
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSUInteger age;
@end

@implementation Person
- (id)mutableCopyWithZone:(NSZone *)zone {
    Person *copyPerson = [[[self class] allocWithZone:zone]init];
    copyPerson.name = [self.name mutableCopyWithZone:zone]; // 对象类型，使用 mutableCopyWithZone 获取可变副本
    copyPerson.age = self.age; // 基本数据类型，直接赋值 
    return copyPerson;
}
@end
```

:::

------

## Block
  
### ❓`block` vs `delegate`
  
::: details 💡

- 定义方式：
    * `block` 是一种特殊的数据类型，可以将一段代码封装到一个变量中，然后在需要的时候调用这个变量。
    * `delegate` 代理是一种设计模式，是通过 `protocol` 定义了一系列的方法，然后由其他类去实现这些方法。

- 使用场景：
    * `block` 适合一些简单的逻辑处理，如动画回调，数组遍历等。
    * `delegate` 代理通常用于处理复杂的交互，如 `TableView` 的数据源及代理方法，网络请求的回调等。

- 执行流程：
    * `block` 在调用时是同一个函数或方法内部的，逻辑关系相对清晰，容易理解。
    * `delegate` 代理方法可能分散在代码的不同地方，使得调试和阅读代码稍微困难一些。

- 生命周期：
    * `block` 有可能导致循环引用的问题。
    * `delegate` 由于是 `weak` 引用，不会出现循环引用的问题。

- 排序：
    * `block` 可以有多个且同时存在，顺序可以自由改变。
    * `delegate` 通常只有一个，如果有多个，通常需要其他方式进行排序。 

:::
  
### ❓`block` vs 函数指针
  
::: details 💡
  
  - `block`：一种特殊的数据类型，可以存储一段代码，并且这段代码可以在任何时候被执行。可以访问在声明他的那个作用域中定义的变量，这被称为“变量捕获”。
  
  - 函数指针：函数指针是存储着函数地址的指针变量，本质上是一个地址值，也就是函数在内存中的起始地址。函数指针不能像 `block` 那样访问变量，只能通过传参的方式去使用外部的数据。
  
:::

### ❓`block` 底层实现

::: details 💡

  `block` 是一个 `Objective-C` 对象，它的定义中包含了一个结构体和函数指针。

```objc
// 简化版 block 结构体
struct Block_literal {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct block_descriptor *descriptor;
    /* captured variables... */
};
```

  - `isa`：指向对象的类型，所有 `Objective-C` 对象都有该变量。
  - `flags` 和 `reserved`：提供关于 `block` 的一些信息，如 `block` 类型等。
  - `invoke`：一个函数指针，指向进行调用的函数。
  - `descriptor`：一个指向 `Block_descriptor` 结构的指针，其中包含相关信息。

`block` 的内存管理：

  - 当 `block` 没有捕获任何外部变量，或者仅使用了全局变量和静态变量时，它是一个 `global block`，存储在程序的全局数据区，其生命周期从创建到程序结束。
  
  - 当 `block` 使用了外部的自动变量（包括 `ObjC` 对象和基本数据类型），在未进行 `copy` 操作的情况下，它是一个 `stack block`，存储在栈内存上，超出作用域即被销毁。
  
  - 如果对 `block` 进行了 `copy` 操作，或者是用 `__block` 修饰的自动变量，那么这个 `block` 是一个 `malloc block`，存储在堆内存上，需要手动进行内存管理。

[👉🏻](https://www.mikeash.com/pyblog/friday-qa-2009-08-14-practical-blocks.html)

:::

### __block

#### ❓`block` 内如何修改外部变量

::: details 💡

使用 `__block` 修饰符

```objc
__block int num = 0;
void (^myBlock)(void) = ^{
    num = 1;  
};

myBlock();
NSLog(@"Num: %d", num);  // 这里输出 "Num: 1"
```

:::

#### ❓`block` 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别

::: details 💡

- 自动变量（`auto variables`）：这是在方法或函数中常见的局部变量，如 `int num = 10`。这种变量在 `block` 中默认以值传递形式捕获，即 `block` 捕获的是值，而不是变量本身。如果要在 `block` 中修改局部变量的值，必须在定义变量时加上 `__block` 修饰符。

- 局部静态变量、全局变量、全局静态变量：这些变量在 `block` 中以指针形式捕获，即 `block` 捕获的是对这些变量的指针。这意味着，可以在 `block` 中直接修改这些变量的值，不需要加 `__block` 修饰符。

```objc
int globalVar = 4;
static int staticGlobalVar = 5;

void Test() {
    int localVar = 1;
    static int staticVar = 2;
    __block int blockVar = 3;

    void (^myBlock)(void) = ^{
        NSLog(@"localVar: %d", localVar);          // 1
        NSLog(@"staticVar: %d", staticVar);        // 2
        NSLog(@"blockVar: %d", blockVar);          // 3
        NSLog(@"globalVar: %d", globalVar);        // 4
        NSLog(@"staticGlobalVar: %d", staticGlobalVar);  // 5

        // localVar++;              // Error! "Variable is not assignable (missing __block type specifier)"
        staticVar++;
        blockVar++;
        globalVar++;
        staticGlobalVar++;
    };

    myBlock();
    
    NSLog(@"staticVar after block: %d", staticVar);        // 3
    NSLog(@"blockVar after block: %d", blockVar);          // 4
    NSLog(@"globalVar after block: %d", globalVar);        // 5
    NSLog(@"staticGlobalVar after block: %d", staticGlobalVar);  // 6
}
```

:::

#### ❓`block` 捕获外部局部变量实际上发生了什么

::: details 💡

   `block` 可以捕获其外部的局部变量，使得这些外部变量可以在 `block` 的执行体内部被访问到。捕获的过程其实是在 `block` 被创建时发生的。`block` 会创建对应的变量的 "拷贝"。

  - 对于基本数据类型变量，比如 `int、float，block` 会复制其值，也就是在 `heap`(堆) 应用一段内存，将外部的变量值复制一份到这个内存上。

  - 对于对象类型变量，`block` 会保留该对象，并复制对象指针。这个过程也被称为引用捕获。这样 `block` 对象可以在稍后的时间里随时引用到这个变量。

  `__block` 关键字可以用于解决 `block` 内部无法修改外部变量的问题。当捕获一个 `__block` 变量时，`block` 内部会保留这个 `__block` 变量。在堆上创建的 `block` 会在 `heap` 中维护一个 `__block` 变量的结构体，这个结构体中包含了 `__block` 变量的地址和其值，这样 `block` 就可以通过操作这个结构体来修改 `__block` 变量的值。

:::

> ❓如果 使用 `__block` 捕获了局部变量，这个 `block` 作为返回值 `return` 了，这个局部变量释放了，怎么办

::: details 💡

  在使用 `__block` 捕获局部变量的同时，如果这个 `block` 作为返回值返回，那么这个局部变量就会被 `block` 捕获到，并且它的生命周期就延长到了 `block` 生命周期结束为止。也就是说，这个局部变量不会在离开定义它的作用域时释放，而是将在 `block` 被释放时才释放。

  正常情况下 `block` 是分配在栈上的，栈上的 `block` 在离开作用域后就会被销毁。但是如果这个 `block` 被赋值给了一个强引用的变量，或者被返回出去的话，就需要将栈上的 `block` 复制到堆上，这样 `block` 的生命周期就会得到延长，直到没有强引用指向它为止。

  对于使用 `__block` 修饰的局部变量，这个变量的存储地址会从栈复制到堆上。所以，返回的 `block` 中捕获的是移动到堆上的 `__block` 变量的地址，这也确保了返回后，能够正确地访问和修改这个 `__block` 变量。

:::

#### ❓`block` 修改捕获变量除了用 `__block` 还可以怎么做

::: details 💡

可以使用 `NS(Mutable)Object/Dictionary/Array` 等，这些类型的实例在被捕获后仍然可以修改内容。

```objc
NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    [array addObject:@"Hello"];
};
myBlock();
NSLog(@"%@", array); // 输出: ["Hello"]
```

:::

#### ❓`block` 中修改 `NSMutableArray` 需不需要添加 `__block`

::: details 💡

不需要。在 `Objective-C` 中，`NSMutableArray` 是一个引用类型的对象，即使不使用 `__block`，也可以在 `block` 内部添加、删除或修改 `NSMutableArray` 的元素。因为修改的是 `NSMutableArray` 对象的内容，而不是 `NSMutableArray` 变量本身。

例如，可以这么写：
```objc
NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    [array addObject:@"Hello, World"];
};
myBlock();
NSLog(@"%@", array);  // 输出：["Hello, World"]
```
这段代码在 `block` 中向 `array` 添加了一个字符串，然后打印 `array` 的内容。注意，这里并没有修改 `array` 这个变量本身，只修改了它所引用的对象的内容。所以，无需添加 `__block` 修饰符。

但是，如果希望在 `block` 中修改 `array` 这个变量（比如使其指向一个全新的 `NSMutableArray` 对象），那就需要使用 `__block` 了。例如：
```objc
__block NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    array = [NSMutableArray array];
    [array addObject:@"Hello, World"];
};
myBlock();
NSLog(@"%@", array);  // 输出：["Hello, World"]
```

:::

### 内存管理

#### ❓`block` 如何进行内存管理的

::: details 💡

`block` 的内存管理默认分为三个级别：`_NSConcreteGlobalBlock`、`_NSConcreteStackBlock`、`_NSConcreteMallocBlock`。

  - `__NSConcreteGlobalBlock__`：属于全局区，类似于全局变量，生命周期从应用开始直到应用结束。

  - `__NSConcreteStackBlock__`：存放在栈内存中，当超出其作用域后就会被自动销毁。

  - `__NSConcreteMallocBlock__`：存放在堆内存中，需要手动管理其内存，可以通过 `retain` 来增加其引用计数，通过 `release` 来减少其引用计数，当引用计数为 0 时，`block` 会被销毁。

  在使用 `ARC` (Automatic Reference Counting) 时，对 `block` 的内存管理会简化许多。当 `block` 中引用到了外部变量时，`block` 将会自动从栈复制到堆中（有复制行为的 `block` 都会进入堆区），并且在引用计数为 0 后会自动销毁，不需要手动管理。

  注意：对于 `block` 内部应用到的对象，如果不加特殊处理，是会形成强引用的，因此可能会导致引用循环并引发内存泄漏。为了防止这种情况，经常使用 `__weak` 来修饰引用的对象，避免产生循环引用。

:::

#### ❓`__block` vs `__weak`

::: details 💡

  - `__block`：它用于允许在 `block` 中改变变量的值。
    > `__block` 是存储类型说明符，用于修饰一个变量，让该变量能在 `block` 中被读取和写入。如果没有 `__block`，那么 `block` 就不能修改该变量的值。
    
  - `__weak`：它用于创建一个弱引用。
    > 弱引用是一种特殊类型的引用，它不会增加被引用对象的引用计数。这样可以解决对象互相引用，形成引用循环的问题。在处理 `block` 对象引用 `self` 时，通常会先创建一个弱引用的 `self`，然后在 `block` 中使用这个弱引用，从而避免引用循环。

:::

#### ❓`__block` 在 `ARC` 和非 `ARC` 有区别吗

::: details 💡

有区别

  - 在非 `ARC` 环境下，`__block` 不会改变对象的所有权。也就是说，如果有一个 `__block` 修饰的对象，`block` 不会为这个对象增加引用计数。因此，如果在 `block` 执行后，原来的对象被释放了，那么 `block` 内的这个对象就变成了悬浮指针。

  - 在 `ARC` 环境下，`__block` 有另外一种行为。它会保留 `block` 中使用到的对象。也就是说，如果有一个 `__block` 修饰的对象，当 `block` 执行时，就会增加这个对象的引用计数。因此，在 `ARC` 下，可以安全地在 `block` 中引用 `__block` 修饰的对象，而不必担心它会被提前释放。

一般会选择 `__weak` 代替 `__block` 来避免循环引用，特别是在引用 `self` 或者其成员变量的时候。

:::

#### ❓`block` 什么情况会发生循环引用

::: details 💡
    
  当在一个 `Objective-C` 对象的方法（或者属性）中引用了一个 `block`，而这个 `block` 中又引用了该对象（不论是直接引用还是间接引用）时，就会形成一个循环引用。这是由于 `block` 在捕获对象时默认为强引用，而对象本身又强引用了 `block`，形成了循环。

```objc
// 循环引用
__strong typeof(self) strongSelf = self;
self.myBlock = ^{
    [strongSelf doSomething];
};

// 打破循环引用
__weak typeof(self) weakSelf = self;
self.myBlock = ^{   
    // 临时创建了一个对 weakSelf 的强引用，确保在 block 执行过程中不会出现 weakSelf 被意外释放的情况。
    __strong typeof(weakSelf) strongSelf = weakSelf;
    [strongSelf doSomething];
};
```

:::

#### ❓`UIView` 动画函数 `block` 版本是否需要处理循环引用

::: details 💡

在 `UIView` 的动画函数 `block` 版本中使用 `self`，实际上不会造成引用循环。

```objc
// self 不持有 动画 block
[UIView animateWithDuration:1.0 animations:^{
    self.myView.alpha = 0;
}];
```

:::

#### ❓`block` 一般使用 `copy` 修饰，可以使用 `strong` 吗

::: details 💡

  `block` 使用 `copy` 修饰是为了保持 `block` 的引用计数的正确。`block` 本身是在堆栈上分配的，`copy` 操作将其复制到堆上，可以保证 `block` 在方法返回后不被销毁，保证其正确执行。

  虽然也可以使用 `strong` 来修饰 `block`，但是这样做并不会将 `block` 从栈复制到堆。因此，如果 `block` 捕获了方法内部的变量，当方法返回后，这些变量都已经被释放，可能会导致程序崩溃。

:::

#### ❓为什么在 `block` 外部使用 `__weak` 修饰的同时需要在内部使用 `__strong` 修饰
  
::: details 💡

  使用 `__weak` 修饰符是为了防止循环引用。由于 `block` 会捕获其内部使用的变量，如果 `block` 内部访问了 `self` 或其成员变量，那么会形成循环引用，导致内存泄漏。而使用 `__weak` 修饰符可以将 `self` 或成员变量变成弱引用，从而避免循环引用。

  `__weak` 的不足之处：在 `block` 执行期间，若弱引用的对象被释放了，那么 `block` 内部对该对象的访问就会失效。为了避免这种情况，就需要在 `block` 内部使用 `__strong` 修饰符将弱引用变量提升为强引用。

  这样做可以保证在 `block` 执行期间，这个被提升的强引用变量所指向的对象不会被释放，保证了 `block` 执行过程中对象的访问安全。而在 `block` 执行完毕后，强引用也会随之释放，和在 `block` 外部保持指向对象的弱引用并不存在循环引用问题。

```objc
__weak typeof(self) weakSelf = self;
[self doSomethingWithBlock:^{
    __strong typeof(self) strongSelf = weakSelf;
    [strongSelf doSomethingElse];  
    // 在此处，若 self 在 block 执行期间释放，由于存在 strongSelf 的强引用，self 所指向的对象不会被释放。
}];
```

:::


#### ❓`block` 访问对象类型的 `auto` 变量时，在 `ARC` 和 `MRC` 下有什么区别

::: details 💡

  - 在 `MRC` 下，`block` 只是简单地进行指针拷贝，不会对对象进行 `retain` 操作，这会导致可能的对象释放错误。

  - 在 `ARC` 下，编译器会自动进行内存管理，在 `block` 被创建时，会对它所捕获的对象发送一次 `retain` 消息，同时在 `block` 被释放时，发送一次 `release` 消息。

:::

#### ❓`block` 中可以使用 `KVC` 来访问或修改实例变量吗

::: details 💡

在 `block` 中可以使用 `KVC`(Key-Value Coding) 访问和修改实例变量。

  - 被访问的实例变量是否存在对应的访问器方法(`getter` 和 `setter`)。

  - 被访问的实例变量在类的接口中是否有定义，或者有无 `@property` 声明。

```objc
__weak typeof(self) weakSelf = self;
self.myBlock = ^{
    // 使用 KVC 访问实例变量
    NSInteger value = [[weakSelf valueForKey:@"someValue"] integerValue];
    
    // 使用 KVC 修改实例变量
    [weakSelf setValue:@(123) forKey:@"someValue"];
};
```

:::

------

## 类

### ❓`+load` 与 `+initialize` 区别

::: details 💡

  这两个都是类方法，可以从下面几个方面去对比两者的区别
  
  - 调用时机
    * `+load` : 这是在运行时加载时，进行触发调用。
    * `+initialize` : 会在类第一次使用时，进行触发调用。
  
  - 调用次数
    * `+load` : 只会在运行时加载时，调用一次。
    * `+initialize` : 第一次调用时，调用一次。

  - 调用父类
    * `+load` : 不会调用父类的 `+load`
    * `+initialize` : 如果当前类没有

  - 手动调用
    * `+load` : 不能手动调用，运行时进行调用的。手动调用会触发异常。
    * `+initialize` : 可以手动调用。
  
:::
  
  > ❓`+load` 的调用顺序
  
::: details 💡
  
  - `+load` 方法调用顺序与编译连接顺序有关。
  - 不同类之间的`+load`方法的调用顺序不能确定，取决于编译连接顺序。
  - 如果父类、子类和分类都实现了 `+load` 方法，`+load` 方法的调用顺序是：先调用父类的`+load`，再调用子类的`+load`，最后调用分类的`+load`。
  
:::

### ❓`Designated Initializer` 如何添加？

::: details 💡

  > `NS_DESIGNATED_INITIALIZER` 是一个宏，用于向编译器标明这个是` Designated Initializer`。主要目的就是明确指定初始化方法，并帮助我们遵守初始化方法的基本规则：所有的初始化方法最终都应该通过调用同一类中的一个指定初始化方法来完成初始化。

  `NS_DESIGNATED_INITIALIZER` 这个宏不是必须的。但加上这个宏可以明确指出哪个是指定初始化方法，有助于提高代码的可读性。另外，如果你在使用 `Xcode` 开发，并且启用了一些警告选项，没有使用 `NS_DESIGNATED_INITIALIZER` 宏来标记指定初始化方法可能会导致 `Xcode` 发出警告信息。

  `NS_DESIGNATED_INITIALIZER` 这个宏的工作原理是，如果你的类中的某个初始化方法使用了这个宏，但是这个方法并没有调用同类中的其他使用了这个宏的初始化方法，或者调用了父类中使用了这个宏的初始化方法，那么编译器就会发出一个警告。

```objc
@interface MyClass : NSObject
- (instancetype)initWithMyParameter:(id)myParameter NS_DESIGNATED_INITIALIZER;
@end
@implementation MyClass
- (instancetype)initWithMyParameter:(id)myParameter {
    // 先调用父类的 init
    self = [super init];
    if (self) {
        // 初始化操作...
    }
    return self;
}
@end
```

:::

### ❓`OC` 如何实现多重继承

::: details 💡

  - **协议（Protocol）**：`OC` 中的协议类似于其他语言中的接口，可以定义一组方法和属性，然后由类去实现。一个类可以同时实现多个协议，这就实现了类似多重继承的效果，只是实现协议的类需要自己实现协议中定义的所有方法。

  - **组合**：在一个类中包含其他类的实例作为成员变量，借此可以使用其他类的功能，间接实现多重继承的效果。
    > 例如，类A包含类B和类C的实例，那么类A就可以使用类B和类C的功能。

  - **分类（Category）**：一种使得现有类增加方法的方式，是在运行时决议的。可以通过创建分类，将其他类的方法引入，实现类似多继承的效果。但是分类不能添加新的实例变量。

  - **消息转发（Message Forwarding）**：允许将一个方法调用转发给其他对象进行处理。如果某个类无法响应某个消息，允许在运行时将这个消息转发给另一个能处理这个消息的对象。

:::

### ❓静态方法是否能被重写

::: details 💡

  在 `Objective-C` 中，通常所说的 "静态方法" 实际上是指"类方法"，用 "+" 符号来声明。这种方法是可以被子类重写的。也就是说，如果在子类中重写了一个已经在父类中定义的类方法，那么当你用子类来调用这个类方法的时候，实际上执行的是子类中的版本，这就是方法重写。所以，"静态方法"是可以被子类重写的。

  然而这和其他一些语言如 `Java` 或 `C++` 中的静态方法是不一样的。在 `Java` 或` C++` 中，声明为 `static` 的方法是不能被子类重写的。

:::

### ❓`OC` 中的内省和反射，底层实现原理，应用场景有哪些

::: details 💡

内省和反射是基于其动态的特性实现的，底层依赖于 `runtime` 系统。

  - 内省：面向对象编程中的一种能力，允许程序检查对象的类型或属性。
    > 可以通过系统提供的各种 `API`（如`isKindOfClass:`, `respondsToSelector:` 等方法）来实现内省。

  - 反射：程序能够观察和修改自身结构和行为的一种能力。
    > 反射主要依赖于系统提供的 `API`，如`NSClassFromString`, `NSStringFromClass`, `NSSelectorFromString`, `NSStringFromSelector` 等函数。

实现原理： 
  
  `Objective-C` 对象中都有一个 `isa` 指针指向对象所属的类，这个类中存储了类的方法列表、属性列表，并且如果类继承自其他类，那么这个类还会通过 `superclass` 指针找到其父类，这样层层递推，形成了一条类链，利用这条链条就可以检查和操作对象的行为和结构。

应用场景： 

  - 数据和模型的自动映射。
    > 例如 `JSON` 数据转 `Model` 对象，通常需要写大量的映射代码。利用内省我们可以在运行时获取对象的属性信息，从而实现自动映射。 
  - 在运行时动态地添加类，方法，属性。
    > 例如可以在运行时给一个类添加属性或方法，或者修改方法的实现等。 
  - 在面向切面编程（`AOP`）中，经常需要运行时修改对象的行为。
  - 在执行单元测试时，可以利用反射机制来动态地调用需要测试的方法。

:::

------

## 分类

### ❓`Category` vs `Extension`

::: details 💡

  > `Category`(类别)：`Objective-C` 的一个特性，提供了一种给已存在类添加方法的机制.
    
  - `Category` : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。
  
  - `Extension` : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。

:::

### ❓`NSObject` 添加 `Extension` 会怎么样

::: details 💡

向 `NSObject` 添加 `Extension`(类别)会使 `Extension` 中的方法对继承自 `NSObject` 的所有对象可见和可用。这会对项目产生全局性的影响。

`Extension` 可以用来添加新的方法到现有的类中，但它没有自己的实例变量，所以不能存储新的状态。在使用 `Extension` 时，需要注意以下几点：

- 如果你覆盖已有的方法，所有继承自 `NSObject` 的对象都会受到影响，可能出现无法预知的结果。
- 如果添加的新方法与其他库或者框架定义的方法发生冲突，同样可能导致问题。

因此，虽然往 `NSObject` 添加 `Extension` 可以快速为所有对象添加功能，但需要谨慎使用，尽量避免覆盖现有的方法或者添加可能与其他方法发生冲突的方法。同时，由于该范围非常广，必要时最好选择子类化或协议等方式实现。

另外，如果只是想在项目内全局使用某些通用方法，可以考虑创建一个 `NSObject` 的子类，然后让需要使用这些方法的类继承自这个子类，这样就不会影响到不需要这些方法的类。

:::

### 加载顺序

#### ❓如果分类中添加与类相同的方法签名会发生什么
  
::: details 💡
  
当一个 `OC` 的类别（`Category`）和主类都定义了相同签名的方法时，运行时系统会优先调用类别的方法，而忽略主类中的同名方法。这是因为在运行时的方法解析过程中，分类的方法会被先于主类方法加入到方法列表中。

在代码中，如果主类和分类都实现了同一个方法，那么分类的方法会覆盖掉主类中的方法，也就是说，在方法调用时，实际上执行的是分类中的方法。

```objc
@interface MyClass : NSObject
- (void)print;
@end

@implementation MyClass
- (void)print {
    NSLog(@"print in MyClass");
}
@end

@interface MyClass (MyCategory)
- (void)print;
@end

@implementation MyClass (MyCategory)
- (void)print {
    NSLog(@"print in MyCategory");
}
@end

// 调用时
MyClass *myClass = [[MyClass alloc] init];
[myClass print]; // 输出：print in MyCategory
```

这种特性在某些情况下非常有用，可以实现方法的替换和拦截等。但也需要格外注意，如果不小心覆盖了主类本身的重要方法，可能会造成程序的异常。

:::

#### ❓两个分类的 `load` 方法的加载顺序

::: details 💡

  类和分类中的 `+load` 方法会在类或分类被加载到运行时时调用。对于同一个类的不同分类，各自的 `+load` 方法的调用顺序与编译顺序有关，最后编译的分类的 `+load` 方法会被先调用。

  注意：虽然编译顺序是影响 `+load` 方法调用顺序的因素之一，但不是唯一的决定因素。在一个复杂的项目中，编译顺序可能会受到 `Xcode` 编译设置、文件名字母序、`Xcode` 版本、甚至 `macOS` 系统版本的影响。因此，关于这个问题，`Apple` 官方文档建议不要依赖于 `+load` 方法的调用顺序。如果项目中多个 `+load` 方法之间有依赖关系，那么可能需要仔细设计代码，以避免因 `+load` 方法调用顺序引起的问题。

:::
 
#### ❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法

::: details 💡

  当一个类有多个分类（`Category`），并且这些分类都实现了相同的方法时，会优先调用最后编译的分类中的方法。编译器按照 `.m` 文件编译顺序来加载分类，如果存在多个分类都实现了同一方法，那么顺序是"编译顺序的逆序"，也就是说最后编译的分类会首先被加载，同名方法就会被最后编译的那个分类所覆盖。

  但是具体调用哪个方法并不是确定的，因为分类的编译顺序可能会因为项目配置的改变而改变，比如编译选项的修改、文件名的修改等。所以，实际开发中并不建议在不同的分类中实现相同的方法，这可能会引起不可预见的 `bug`。如果需要在分类中添加方法，应确保新添加的方法与主类和其他分类的方法不冲突。

:::

#### ❓怎么保证自己的类一定能调用到自己写的方法

::: details 💡

  分类（`Category`）是一种可以为已存在的类添加新方法的方式。同时，分类中的方法会替换掉原来类中同名的方法。此特性在一些情况下可能引起不确定的行为，比如可能无意间覆盖掉你写的方法。

预防方法被分类覆盖的方法：

  - **方法命名规范：** 尽可能为方法命名时，添加前缀。这样可以避免和系统默认的方法或他人写的分类中的方法冲突。

  - **使用子类化代替分类：** 如果你控制的类可能被其他开发者使用，那么建议使用子类代替分类。这样，即使有人创建了同名的分类，也不会对原类产生影响。

  - **在源代码级别进行检查：** 在项目编译的时候，通过检查操作来警告和暴露任何重定义的方法。

注意：以上的方式并不能 `100%` 的避免在运行时被覆盖的情况，因为 `Objective-C` 是一种动态类型的语言，它允许在运行时添加或替换方法。这种动态性是 `Objective-C` 的一大特性，但同时也可能带来风险。所以编程时应该遵循良好的开发习惯，避免不必要的麻烦。

:::
 
### 底层实现
 
#### ❓分类是如何实现的，为什么会覆盖掉原来的方法
 
::: details 💡

  `Objective-C` 中的分类 (`Category`) 实质上是对一个存在的类添加额外的方法，而不改变它的声明和定义。分类是在运行时通过 `Objective-C` 的动态性质合并到类上的，这使得可以随意地向任何类添加方法。

  底层实现：是一个 `objc_category` 结构体，它包含了类名(`name`)、类(`cls`)、类别中所有方法的列表(`method_list`)、类别的协议列表(`protocol_list`)、类别中所有的属性列表(`property_list`)。
    
  加载过程：在程序运行时的 `load` 阶段进行的，所有类和分类的 `+load` 方法（如果有）被调用。在调用 `+load` 方法之前，`runtime` 会先将分类的方法、协议、属性合并到类的数据结构中。这个过程中，分类的方法被放在了原来类方法列表的前面，所以在类和分类中有相同方法名的方法的时候，分类的方法会被优先调用，原类的方法被覆盖。

  分类的本质：在编译阶段，每一个分类会被编译成一个特殊的结构体（如 `_category_t`），其中包含了分类名，分类所在类的名字，以及分类中所有添加的方法的列表。在程序启动的时候，这个结构有一个初始化函数会被自动调用。在这个函数中，分类中的方法会被添加到类的方法列表中。因此可以在分类中添加新的方法。
  
  分类中的方法会覆盖掉原来的方法，主要是因为分类的方法被添加到方法列表的顺序优先级更高。在 `Objective-C` 查找方法实现的时候，是按照方法在列表中的顺序，从前往后查找的，当找到第一个匹配的方法时，就停止查找，并且调用这个方法。因此，如果分类中的方法与原类中的方法同名，分类中的方法就会被优先调用，从而覆盖掉原来的方法。

:::

#### ❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理

::: details 💡

  如果分类中的方法与主类的方法名称相同，由于运行时会优先调用分类的方法，所以通常无法直接调用到主类中的方法。不过有一种间接的办法可以实现。可以在分类方法内部通过 `NSInvocation` 或 `methodSignatureForSelector:` 和 `forwardInvocation:` 的方式调用主类的原方法。

```objc
#import "MyClass.h"

@implementation MyClass (MyCategory)
- (void)print {
    // 获取主类原方法
    SEL origSel = @selector(print);
    Method origMethod = class_getInstanceMethod([self class], origSel);
    
    // 构建 NSInvocation
    NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:origSel]];
    [inv setSelector:origSel];
    [inv setTarget:self];
    
    // 调用 NSInvocation
    [inv invoke];
    
    // 获取返回值
    NSString *returnValue;
    [inv getReturnValue:&returnValue];
    NSLog(@"%@", returnValue);
}
@end
```

:::
 
#### ❓分类中为什么不能添加 `@property`

::: details 💡

  `@property`会告诉编译器我们在类中声明了一个属性。默认情况下，编译器会生成一个后备存储（实例变量），并且为属性生成 `getter` 和 `setter` 方法。然而，对于分类（`Category`），一旦对象在运行时被注册，就不能再动态地添加实例变量。

  从 `runtime` 角度来看， 这是由于类型的数据布局已经在编译阶段确定并且注册到了 `Objective-C` 的 `runtime` 系统中，而分类是在运行时被加载，所以无法更改基类的数据布局，也就无法添加实例变量。

```objc
// 类结构体，中的 `ivar_list`（实例变量列表）是确定
struct objc_class {
    Class isa;
    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
}

// 分类结构体，只有方法列表，协议列表和属性列表，并没有实例变量列表
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
};
```
  
  `Objective-C` 分类中不能添加实例变量，也就不能添加带有自动生成的 `getter` 和 `setter` 的 `@property`。但是可以在分类中声明属性，并通过对已有的实例变量手动编写 `getter` 和 `setter`，或者使用关联对象(`Associated Objects`)来模拟实例变量。

  总结：之所以不能在分类中添加 `@property`，是因为在编译器层面和 `runtime` 层面上，`Objective-C` 的设计都不允许动态地向类中添加实例变量。

:::

------

## 消息发送

### ❓`OC` 消息发送 vs `C++` 调用虚方法

::: details 💡

概念知识：

  - `Objective-C` 消息发送：是 `Objective-C` 进行方法调用的方式。
    > 它会在运行时动态地确定应该调用对象的哪个方法。当给 `Objective-C` 对象发送消息时，运行时系统会搜索接收者的类以及所有父类的方法列表，找到第一个可以响应该消息的方法并调用。

  - `C++` 虚方法：是 `C++` 支持多态性的一种方式。
    > 在 `C++` 中，如果一个父类指针指向派生类对象，并通过该指针调用虚函数，那么调用的将是派生类中的虚函数实现。这是通过 `C++` 的虚函数表（`vtable`）来实现的，虚函数表是在编译期确定的。

两者区别：

  - **动态性**：`Objective-C` 的消息发送更具有动态性，因为它在运行时确定方法调用，而 `C++` 的虚函数在编译时已经确定。

  - **灵活性**：`Objective-C` 的消息发送机制允许在运行时为对象动态添加方法，这使得 `Objective-C `具有更高的灵活性。

  - **性能**：由于 `C++` 的虚函数调用是在编译期就已经确定，因此它的性能上优于 `Objective-C` 的动态消息发送。

  - **安全性**：`C++` 的类型检查更为严格，因此调用虚方法要比 `Objective-C` 发送消息更安全，后者如果发送了对象无法响应的消息就会在运行时崩溃。

:::

### ❓消息转发机制和其他语言的消息机制优劣对比

::: details 💡

  - **动态性**：消息转发机制可以在运行时动态地处理未知的消息。而其他一些语言，如 `C++`, `Java`, `C#` 等，在编译期间就已经确定了方法的调用，并不能在运行时动态地处理未知的消息。

  - **灵活性**：消息转发可以不仅仅是转发给其他对象，甚至可以动态地为类生成新的方法。这在很多其他语言中是无法做到的。

  - **性能**：消息转发机制相对于其他语言的消息机制，如 `C++` 的虚函数，性能上会稍差一些。因为 `Objective-C` 是在运行时通过查找类的方法列表来确定方法调用，而不是在编译时就确定。

  - **安全性**：消息转发机制如果使用不当，可能会产生一些难以发现的错误。例如，如果错误地转发了消息，可能会导致运行时崩溃。而其他一些语言，如 `Java`, `C#`, 是在编译期就检查了方法的调用，相对来说更加安全。
  
:::

### ❓`OC` 是否支持方法重载

::: details 💡

  `OC` 不支持方法重载。方法重载指的是在同一个类里面，方法名字相同，但参数不同的多个方法。

  `OC` 是一种动态类型语言，其方法的调用不是在编译期决定的，而是在运行时决定的。`OC` 使用消息派发机制，方法调用更依赖于方法的唯一性，如果有多个方法名字完全相同（即使参数类型不同），编译器和运行时系统就无法准确找到你要调用的方法。

:::

### 方法查找

#### ❓`SEL`、`_cmd`、`IMP` 是什么

::: details 💡

  - `SEL`：是一个选择器的类型。选择器是方法选择器的指定类型，可以想象它就像方法或函数的名字。`SEL`类型的变量就是用来保存这些方法名的。实际上是一个字符串，不同的方法对应不同的 `SEL`。
    
    ```objc
    SEL methodSEL = @selector(methodName);
    ```
    
  - `_cmd`：是一个隐藏的参数，表示当前调用的方法的 `SEL`。每个方法的实现的第二个参数`_cmd`，它是一个 `SEL` 类型的，即当前方法的选择器。
    
    ```objc
    - (void)someMethod {
        NSLog(@"%@", NSStringFromSelector(_cmd)); // 输出 "someMethod"
    }
    ```
  
  - `IMP`：是一个函数指针，这个函数会处理发送到类实例的消息。`IMP` 类型的函数实际上就是对象方法的实现，一个 `IMP` 函数会接收两个隐藏的参数 `self` 和 `_cmd`。
    
:::

#### ❓`OC` 中是如何通过 `SEL` 找到对应的 `IMP` 地址

::: details 💡

  - **查找类方法列表**：当向一个对象发送一条消息，运行时系统首先会在该对象的类的方法列表中查找与这个 `selector` 相对应的方法。如果找到，那么就直接调用这个方法的实现。在这个步骤中，`selector` 会被映射到其对应方法的 `IMP`。

  - **在继承链中查找**：如果在对象的类的方法列表中没有找到对应的方法，那么运行时系统会在该类的父类中查找，如果在父类中找到，同样直接调用对应的 `IMP`。这个过程会一直沿着类的继承链查找，直到 `NSObject`。

  - **调用动态方法解析**：如果在整个继承链上都没有找到对应的方法，那么运行时系统会给一个“补救”的机会，即会调用该类的 `+resolveInstanceMethod:` 或 `+resolveClassMethod:` 方法（取决于是实例方法还是类方法）。可以在此方法中为对应的 `selector` 动态添加实现。

  - **消息转发**：如果 `+resolveInstanceMethod:` 或 `+resolveClassMethod:` 返回 `NO` 或者没有被重写，那么运行时就会启动完整消息转发，此时会调用 `- (void)forwardInvocation:(NSInvocation *)anInvocation;` 方法。可以在这个方法内将消息转发给能响应此消息的其他对象。

  - **抛出异常**：如果以上步骤都没有找到并执行相应的方法，那么运行时系统就会抛出 `unrecognized selector` 异常。

:::

#### ❓`unrecognized selector` 异常是如何发生，应该如何避免

::: details 💡

  `unrecognized selector` 异常是一个常见运行时错误，当向一个对象发送它不能响应的消息时，就会抛出这个异常。

  当调用一个对象的方法时，实际上是在向这个对象发送一条消息。运行时系统会在对象的类及其所有的父类中寻找与这个消息对应的方法。如果找到这个方法，就会调用它。如果在最底层的父类（通常是 `NSObject`）中也找不到这个方法，那么就会抛出 `unrecognized selector` 异常。

避免 `unrecognized selector` 异常：

  - **检查对象是否能响应此消息**：在向对象发送消息之前，使用 `respondsToSelector:` 方法检查这个对象是否能响应这个消息。

    ```objc
    if ([obj respondsToSelector:@selector(foo)]) {
        [obj foo];
    }
    ```

  - **使用异常处理**：`Objective-C` 提供了异常处理语句 `@try、@catch、@finally`。可以将可能抛出异常的代码放在 `@try` 块中，将处理异常的代码放在 `@catch` 块中。

  - **消息转发**：如果一个对象无法识别引发异常的方法，那么在引发异常之前，会先调用这个对象的 `- (void)forwardInvocation:(NSInvocation *)anInvocation;` 方法，可以在这个方法里面向其他能响应此消息的对象发送该消息。这就相当于将此消息转发给其他对象。

:::

### 类方法

#### ❓`OC` 中的类方法和实例方法有什么本质区别和联系

::: details 💡

本质区别：

  - 存储的位置：
    * 实例方法列表存储在类对象（`Class`）中。
    * 类方法列表存储在元类对象（`Meta-Class`）中。

  - 调用者：
    * 实例方法由实例对象调用，即 `[instanceObject exampleMethod];`，其中 `exampleMethod` 是实例对象的方法。
    * 类方法由类对象调用，即 `[ClassObject exampleMethod];`，其中 `exampleMethod` 是类方法。

  - 方法查找过程：
    * 调用实例方法时，`runtime` 系统会在类的方法列表中查找这个方法。
    * 调用类方法时，`runtime` 系统会在元类的方法列表中查找这个方法。

  - `self` 指针：
    * 在实例方法中，`self` 指向调用这个方法的实例对象。
    * 在类方法中，`self` 指向调用这个方法的类对象。

  - 能访问的变量：
    * 实例方法可以访问实例变量和静态变量。
    * 类方法只能访问静态变量。

:::

#### ❓在类方法中是否可以使用 `self`

::: details 💡

  可以在类方法中使用 `self`。但在类方法中，`self` 表示的是类对象本身，而不是类的实例。这意味着不能用 `self` 来访问实例变量，只能用它来调用其他类方法。

```objc
+ (void)aClassMethod {
    // 这里的 self 是类对象本身
    [self anotherClassMethod];
}
```

总结：`self` 在类方法中指的是类对象本身，用来调用其他类方法；在实例方法中指的是调用该方法的实例对象，用来访问实例变量或调用实例方法。

:::

### 消息发送

#### ❓`OC` 中对象消息发送的大致流程

::: details 💡

  - **消息发送者**：当调用一个 `Objective-C` 对象的方法时，实际上是向这个对象发送了一条消息。
    > 例如，`[object methodWithParameter:parameter];`，这里的 `object` 是消息的接受者，`methodWithParameter:` 是消息的选择器（`SEL`，`Selector`）。

  - **动态绑定**：不是在编译的时候决定函数地址，而是在运行时根据接收者和选择器找到对应的函数实现。

  - **寻找接受者**：明确了消息的接收者后，会在对应的类以及其父类中查找这个方法的实现。如果在消息接收者的类中找不到响应的方法，则继续往它的父类中寻找。

  - **消息转发**：如果到了根类（`NSObject`）都没有找到方法实现，那么就会进入对象的 `doesNotRecognizeSelector:` 方法，进入此方法就算出错了，未对此方法做处理的话程序会 `crash`。不过，`NSObject` 提供了最后挽救的机会，走进消息转发机制，可以指定一个新的接受者来响应这条消息。如果消息转发也没有处理，就真的会 `crash` 了。

:::

#### ❓在方法调用的时候，`方法查询-> 动态解析-> 消息转发` 之前做了什么

::: details 💡

  仅当通过发送消息调用方法失败的时候，才会启动方法查找（`method lookup`）、动态解析（`dynamic resolution`）和消息转发（`message forwarding`）这些步骤。

之前操作：

  - **消息发送**：实际上是调用了运行时库中的 `objc_msgSend` 函数。方法的调用者（即消息的接收者）和方法选择器（`selector`）都作为 `objc_msgSend` 的参数。

  - **查找对象的类**：`objc_msgSend` 需要知道对象的类信息，以便在类的方法列表里查找可以响应该消息的方法。对象内部有一个指针指向它的类，`objc_msgSend` 可以通过这个指针获取对象的类。

  - **缓存查找**：`Objective-C` 运行时系统为了优化性能，已经将一部分方法的调用结果缓存起来，所以 `objc_msgSend` 会先从缓存中查找 `selector` 对应的方法实现。如果缓存中有，则直接调用该方法结束查找流程；如果没有，进入下一步。

  - **方法列表查找**：`objc_msgSend` 会在对象的类的方法列表中搜索 `selector` 对应的方法。如果找到，则调用该方法，将方法结果添加到缓存中，并结束查找流程。

:::

#### ❓向一个 `nil` 对象发送消息将会发生什么

::: details 💡

  向 `nil` 对象发送消息是安全的，不会导致程序崩溃。这一特性是 `Objective-C` 语言中的一项重要特性，使其在处理对象的空态时更加灵活。

对一个 `nil` 对象发送消息：
  
  - **方法返回非对象类型**：如果该消息是一个返回非对象类型的方法（例如 `int`，`float`，`struct` 等），会返回零值（0，0.0，相应类型的零值等）。

  - **方法返回对象类型**：如果该消息是一个返回对象的方法，那么将会返回 `nil`。

  - **方法不返回值**：如果该消息是一个不返回值的方法，那么什么都不会发生。

  这种特性使得可以在不检查一个对象是否为 `nil` 的情况下向它发送消息，这通常能使代码更加简洁。反过来，如果在其他语言（例如 `Java` 或 `C#`）那样，在向对象发送消息之前总是先检查它是否为 `nil`，那么可能会编写出很多不必要的代码。然而，注意这并不意味着可以忽略 `nil` 检查，在某些情况下，`nil` 检查仍然是必要的。

:::

#### ❓一个对象向一个不存在的方法发送消息，消息是如何转发的

::: details 💡

  - 动态方法解析（`Dynamic Method Resolution`）
    > 运行时系统会调用 `+resolveInstanceMethod:`（对于类方法是 `+resolveClassMethod:`）。在这个阶段，可以为这个类动态添加一个方法。如果此方法返回 `YES`，那么运行时系统会重新发送消息。

  - 备援接收者（`Backup Receiver`）
    > 如果第一步未处理消息（即 `+resolveInstanceMethod:` 返回 `NO`），系统会调用 `-forwardingTargetForSelector:` 方法，可以返回一个替代的对象。这个方法返回了一个实例后，系统会把这条消息发送给这个实例。

  - 完整消息转发（`Complete Message Forwarding`）
    > 如果 `-forwardingTargetForSelector:` 返回了 `nil`，运行时就会进入完整的消息转发阶段。首先会发送 `-methodSignatureForSelector:` 消息来获取方法的返回和参数类型。然后会发送 `-forwardInvocation:` 消息。可以在 `-forwardInvocation:` 中自行处理消息，或者转发给其他对象处理。

  - 消息转发失败
    > 如果在 `-forwardInvocation:` 中未处理消息，那么运行时会调用 `-doesNotRecognizeSelector:` 方法， 默认会抛出异常。

:::

#### ❓向一个对象发送消息 `[obj foo]` 和 `objc_msgSend()` 函数之间有什么关系

::: details 💡

  `[obj foo]` 这种语义实际上是在运行时通过调用 `objc_msgSend(obj, @selector(foo))` 来实现的。

  方法(`methods`)的调用被称为向一个对象发送消息。当使用方括号语法向对象发送消息时，如 `[obj foo]`，实际上运行时系统会将其转化为 `objc_msgSend()` 函数的调用。

  `objc_msgSend()` 是 `runtime` 库中的函数，接受两个以上的参数。第一个参数(`receiver`)是要发送消息的对象，第二个参数(`selector`)是要发送的消息(`method`)。例如，`objc_msgSend(obj, @selector(foo))` 就是向 `obj` 对象发送名为 `foo` 的消息。

:::

#### ❓`_objc_msgForward` 函数是做什么的

::: details 💡

  > `_objc_msgForward` 是运行时系统中用于对消息进行转发（`Message Forwarding`）的函数。

  当向一个对象发送一条消息，运行时系统会在该对象的类以及其父类链中查找是否有可以响应这条消息的方法。如果没有找到的话，运行时系统会调用 `_objc_msgForward` 函数进行消息转发。 

:::

> ❓直接调用它将会发生什么

::: details 💡
  
  一般不会直接调用 `_objc_msgForward` 函数。因为这个函数是由运行时系统在需要进行消息转发时自动调用的。

  如果直接调用 `_objc_msgForward`，那么一般而言，这将会引起 `unrecognized selector` 异常，因为这个函数的作用就是处理不能识别的选择器（即方法）。如果手动调用它，系统会在尝试进行消息转发时找不到能响应此消息的对象或方法，从而引发异常。基本上，直接调用 `_objc_msgForward` 而没有适当的转发目标和处理机制，是没有意义的。

:::

### 代码题

#### ❓下面代码能正常运行吗(如果能，输出是什么)

```objc
@interface Person : NSObject 
@property(nonatomic,copy) NSString *name; 
@end
@implementation Person
- (void)speak {
    NSLog(@"My name is:%@",self.name); 
}
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    id cls = [Person class];
    void *obj = &cls;
    [(__bridge id)obj speak];
}
@end
```

::: details 💡

这段代码可以正常运行，其输出将是 `My name is:(null)`。

在这段代码中 `id cls = [Person class];`这行代码是获取 `Person` 类。然后 `void *obj = &cls;` 这行代码是获取了指向 `cls` 的指针，所以 `obj` 指向的是一个 `Person` 类的对象，而不是 `Person` 类的实例。然后 `[(__bridge id)obj speak];` 这行代码就是发送一个消息给 `obj`，所以最终调用的是 `Person` 类的 `speak` 方法。

但是这里需要注意的是，并没有给 `name` 属性赋值，所以当打印 `name` 属性的时候，它的值是 `nil`，也就是 `(null)`。

:::

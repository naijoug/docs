---
title: Objective-C
icon: hashtag

index: true

---

<!-- more -->

## 设计理念

  `OC` 底层是使用 `C/C++` 实现。定一个继承 `NSObject` 的类，这个类底层使用 `C` 语言中的 `struct` 结构体来实现的。 

### ❓`OC、Java、Python` 运行效率孰高

::: details 💡

- `Objective-C`: 编译型语言，运行效率通常优于解释型语言。底层是基于 `C`，但是由于动态派发的特性会一定程度上影响效率。

- `Java`: 编译型语言，运行环境是 `JVM`(`Java` 虚拟机)，通过 `JIT`(Just In Time compiler)技术，`Java` 能将字节码实时地编译成机器码运行，因此运行效率**较高**，而且在大数据和 `Web` 服务领域表现优秀。

- `Python`: 是解释型语言，其运行效率**较低**，无法与编译型语言相比。但是 `Python` 的易读性、易写性以及丰富的第三方库，使它在科学计算、人工智能等领域得到了广泛的应用。

:::

### ❓`OC` 的动态性

::: details 💡

  首先理解两个“动态语言与静态语言”

  `OC` 的 `runtime` 文档中介绍中就详细写明了，`runtime` 的设计是为了将 `OC` 中的更多的处理延迟到编译后。

  - 动态类型 (Dynamic typing) : 编译时并不确定对象类型，在运行时才判断对象的类型。`OC` 中一切对象都可以用 `id` 指针指向。
  - 动态绑定 (Dynamic binding) : 方法的调用也是运行时才决定，而并非编译时。
  - 动态加载 (Dynamic loading) : 运行时可以动态加载其它模块或框架

:::

### ❓`OC` 是如何保证系统升级后 `ABI` 的稳定性

::: details 💡

- 向后兼容（`Backward Compatibility`）：新版本的系统库在设计和更新时，会尽量保证向下兼容。

- 动态性（`Dynamic Nature`）：作为一种动态语言，`OC` 大量使用动态分发和运行时解析。这意味着很多事情在运行时才确定，例如方法的调用、对象的生成等。这种机制在维护 `ABI` 稳定性时有很大的灵活性，可以在运行时解析和处理一些可能的问题。 

- 利用类和分类（Class and Category）：使用类和分类来模块化代码，使得代码逻辑更容易管理，也更利于维护 `ABI` 稳定性。在新增或者修改功能时，可以通过添加新的类或者分类，而不是修改旧的代码，这样就能保证旧的代码逻辑和 `ABI` 不被破坏。

- 接口过期标注(`API Deprecation`)：系统库在引入新的接口时，会把不推荐使用的旧接口标记为 `deprecated`，但不会立即删除，这样就可以保证依赖旧接口的代码在一段时间内可以正常运行。

  以上这些都只能尽可能地保证 ABI 的稳定性，但并不能绝对地保证。因为系统升级往往会引入新的功能、新的架构，或者修复旧的 `bug`，这些都可能对 `ABI` 产生影响。所以，作为开发者在编写代码时，也需要注意兼容性，避免过度依赖可能会变动的接口和行为。

:::

### ❓`id` vs `self` vs `super`

::: details 💡

- `id`：一种数据类型，也叫做动态对象类型，所有的 `Objective-C` 对象都可以用 `id` 类型来接收。`id` 类型会忽略类型信息，可以给它发送任何消息，如果在运行时对象能够响应这个消息，则代码可以正常运行，否则会在运行时报错。

- `self`: 每个对象方法的隐含参数，它指向调用当前方法的对象。`self` 的数据类型也是 `id`，但它通常用来引用对象自己。可以用 `self` 来访问属性或者调用方法。

- `super`: 并不是一个指针，是一个编译器标识符，代表当前对象的父类。当你向 `super` 发送消息时，编译器会沿着方法的继承链向上寻找，直到找到对应的方法实现为止。这个机制可用于在子类中调用父类的同名方法，以实现代码的复用。

:::

### ❓`id` vs `NSObject`

::: details 💡

- `id`: 一个动态类型的对象指针，它可以指向任何类型的 `Objective-C` 对象。`id` 类型的对象可以接收任何消息而不会在编译期报错，运行期若无法响应则会引发异常。使用 `id` 类型可以编写出非常灵活的代码，但是也需要面对潜在的运行期错误。

- `NSObject`: 是所有 `Objective-C` 类的基类，定义了一些所有对象都能响应的基本方法，例如 -`init`、`retain`、`release` 等。如果一个对象类型声明为 `NSObject *`，只能给它发送 `NSObject` 类中定义的方法。如果试图发送其他消息，会得到一个编译错误。

:::

### ❓`id` vs `instancetype`

::: details 💡

- `id`：一个动态类型的对象指针，可以指向任何类型的 `Objective-C` 对象。使用 `id` 类型的变量可以调用任何方法，如果该对象的类实现了该方法，那么就会在运行时调用。缺点是编译器无法进行类型检查和自动补全。

- `instancetype`：一种特殊的类型，主要用于表示对象的实例，用在方法的返回类型中。与 `id` 类型不同，方法使用 `instancetype` 作为返回类型，那么编译器会认为该方法返回一个当前类的实例。这个特性可以帮助编译器进行更准确的类型检查，同时还能提供自动补全的支持。

:::

### ❓`id` 为什么不能用点语法？

::: details 💡

  > 点语法是一种简化属性访问的语法。底层实际上是编译器做了一个转换操作，把点语法转换成相应的 `getter`（对于获取属性）或者 `setter`（对于设置属性）方法的调用。

- 明确类型的对象，编译器可以知道对象的类定义，知道该对象所拥有的属性和方法，所以在编译期可以正确地做出转换。

- `id` 类型的对象，编译器无法知道它的实际类型以及拥有的属性和方法，所以无法进行点语法的转换。

:::

### ❓`nil` vs `Nil` vs `NULL` vs `NSNull`

::: details 💡

> 这些都是表示"无"或"空"的特定值

- `nil`：在Objective-C中，nil是一个表示对象指针为空的特殊值。

- `Nil`：在`Objective-C`中，`Nil`是一个表示类指针为空的特殊值。

- `NULL`：在C和Objective-C中，NULL是一个表示未指向任何东西的原始指针的特殊值。正如你在任何纯C的代码和Objective-C代码中看到的，NULL通常指针表示"没有东西"或者是"无"。

- `NSNull`：在Objective-C和Swift中，NSNull是一个表示空值的类，通常在不能使用nil的情况下表示空值。比如在NSArray或NSDictionary对象中，你不能直接使用nil，但你可以用一个NSNull对象来代表"没有值"的情况。

因此，虽然这些都表示某种形式的"无"或"空"，但是每个在特定的情况下使用，并且可能有它们自己的行为和属性。

:::

### ❓`+load` 与 `+initialize` 区别

::: details 💡

  这两个都是类方法，可以从下面几个方面去对比两者的区别
  
  - 调用时机
    * `+load` : 这是在运行时加载时，进行触发调用。
    * `+initialize` : 会在类第一次使用时，进行触发调用。
  
  - 调用次数
    * `+load` : 只会在运行时加载时，调用一次。
    * `+initialize` : 第一次调用时，调用一次。

  - 调用父类
    * `+load` : 不会调用父类的 `+load`
    * `+initialize` : 如果当前类没有

  - 手动调用
    * `+load` : 不能手动调用，运行时进行调用的。手动调用会触发异常。
    * `+initialize` : 可以手动调用。
  
:::
  
  > ❓`+load` 的调用顺序
  
::: details 💡
  
  - `+load` 方法调用顺序与编译连接顺序有关。
  - 不同类之间的`+load`方法的调用顺序不能确定，取决于编译连接顺序。
  - 如果父类、子类和分类都实现了 `+load` 方法，`+load` 方法的调用顺序是：先调用父类的`+load`，再调用子类的`+load`，最后调用分类的`+load`。
  
:::

### ❓`Designated Initializer` 如何添加？

::: details 💡

  > `NS_DESIGNATED_INITIALIZER` 是一个宏，用于向编译器标明这个是` Designated Initializer`。主要目的就是明确指定初始化方法，并帮助我们遵守初始化方法的基本规则：所有的初始化方法最终都应该通过调用同一类中的一个指定初始化方法来完成初始化。

  `NS_DESIGNATED_INITIALIZER` 这个宏不是必须的。但加上这个宏可以明确指出哪个是指定初始化方法，有助于提高代码的可读性。另外，如果你在使用 `Xcode` 开发，并且启用了一些警告选项，没有使用 `NS_DESIGNATED_INITIALIZER` 宏来标记指定初始化方法可能会导致 `Xcode` 发出警告信息。

  `NS_DESIGNATED_INITIALIZER` 这个宏的工作原理是，如果你的类中的某个初始化方法使用了这个宏，但是这个方法并没有调用同类中的其他使用了这个宏的初始化方法，或者调用了父类中使用了这个宏的初始化方法，那么编译器就会发出一个警告。

```objc
@interface MyClass : NSObject
- (instancetype)initWithMyParameter:(id)myParameter NS_DESIGNATED_INITIALIZER;
@end
@implementation MyClass
- (instancetype)initWithMyParameter:(id)myParameter {
    // 先调用父类的 init
    self = [super init];
    if (self) {
        // 初始化操作...
    }
    return self;
}
@end
```

:::

### ❓类簇的优缺点

::: details 💡

  > 类簇（`Class Cluster`）是一种设计模式，在 `Objective-C` 的类库中有广泛的运用，例如`NSString`，`NSArray`，`NSDictionary`等都是类簇的例子。类簇将一些实现细节封装在内部，对外只提供一个简单的公共接口。

- 优点：

    * 封装：类簇将相关的子类放在同一个父类中，使得框架更加简洁，使用者无需熟悉大量类就能够做很多事情。

    * 隐藏实现细节：对外只暴露抽象的接口，隐藏了具体实现的细节。这也保护了代码的稳定性，即使在实现过程中改变了相关的类或算法，对外接口的不变就保证了代码的稳定性。

    * 代码的分层更加清晰：类簇模式将数据和操作数据的方法绑定在同一个对象上，使得类的分层关系更清楚。

- 缺点：

    * 可扩展性差：由于类簇的具体实现不对外暴露，所以如果需要定制某些特殊的行为，扩展性就会变得很差。

    * 创建子类困难：由于大部分方法在私有子类中实现，如果要创建类簇的子类并覆盖某些方法，可能需要实现大量的代码才能获得预期的行为。

    * 维护难度大：由于类簇中包含了大量的私有子类，如果要修改或扩展代码，就需要对所有的子类进行处理，这会增加维护难度。

:::

------

## NSString
  
### ❓`OC` 中的三种字符串？ 
    
::: details 💡
    
  - `__NSCFConstantString` ：在编译时被创建的常量字符串对象，如`NSString *str = @"Hello, World!"`。这些对象会在编译时就被创建，并且在程序的整个生命周期中都不会被销毁。
  
  - `__NSTaggedPointerString` ：使用 `Tagged Pointer` 技术来提高内存使用效率，通常用于存储较小的字符串数据。
  
  - `__NSCFString` ：本质上是一个 `Core Foundation` 字符串的引用（`CFStringRef`），这种类型的字符串通常会在运行时程序动态创建的对象字符串。

:::

> `Tagged Pointer` 了解吗？ 

::: details 💡

  > `iOS 7` 之后 Apple 为了优化引入的一项技术。从字面意思上来看`Tagged Pointer`就是带有标签的指针。
  
  一般来说，在 64-bit 架构下，一个指针的值需要占用 8 byte 的内存空间；然而对于一些非常小的数据，比如 NSNumber、NSDate、NSString 等，使用 8 byte 存储对象指针就显得非常浪费。为了解决这个问题，苹果引入了 `Tagged Pointer` 技术，通过标签直接将小的数据对象嵌入到指针中，这样对于小的数据对象，就无需额外的内存来存储了，能够显著提高内存的利用率。需要注意，一个对象是否使用 `Tagged Pointer` 是由系统决定的，不能人为控制。
  
  具体到 `NSString` 这种场景中，如果字符串的内容非常短，那么它的实现方式可能就是 `Tagged Pointer`，直接将字符串内容存在指针中，提高了内存利用率。
  
:::

### ❓`NSString` 如何计算字符的个数？

::: details 💡

  可以使用 `NSString` 的 `length` 属性来获取字符串长度，但这实际上返回的是字符串中 `Unicode` 编码的字符数量，并不是通常意义上的字符数量。例如，一个中文字符和一个 `emoji` 表情，可能都会被算作多个 `Unicode` 字符。

可以使用 `NSString` 的 `enumerateSubstringsInRange:options:usingBlock:` 方法，用 `NSStringEnumerationByComposedCharacterSequences` 选项来统计字符串的字符数量。

```objc
__block NSUInteger characterCount = 0;
[myString enumerateSubstringsInRange:NSMakeRange(0, myString.length)
                           options:NSStringEnumerationByComposedCharacterSequences
                        usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {
    characterCount++;
}];
```

:::

------

## NSArray

### ❓`[[NSMutableArray alloc] init]` 和 `[NSMutableArray array]` 有什么区别?

::: details

- 相同点：都是用来创建一个可变数组的。

- 不同点
  * 代码简洁度：`[NSMutableArray array]` 比 `[[NSMutableArray alloc] init]` 代码更简洁，更易于阅读和理解。
  * 返回的对象所有权：`[[NSMutableArray alloc] init]` 返回的是一个引用计数为 1 的对象，而 `[NSMutableArray array]` 返回的是一个自动释放的对象（`autoreleased object`）。因此，如果在方法内创建了数组，然后需要返回这个数组，那么 `[NSMutableArray array]` 是一个更好的选择，因为它返回的对象会在方法结束后自动释放，不需要手动释放。如果是在方法内部创建数组，且数组在方法结束后就不再需要，那么 `[[NSMutableArray alloc] init]` 是一个更好的选择，因为它的引用计数为1，当不再需要它时，可以通过调用 `release` 方法将其释放。

:::

### ❓`NSMutableArray` 是怎么实现的，做增删操作的时候内存空间是怎么改变的，可以用别的方法实现吗？

::: details 💡

`NSMutableArray` 的实现是由 Apple 的 Foundation 框架完成的，它是一个动态数组，可以增加和删除元素。具体的内部实现细节 Apple 没有公开，但我们可以推测它的内部工作原理是类似以下方式：

1. 在创建 `NSMutableArray` 时，会分配一段连续的内存空间，用来保存元素。当元素数量超过数组的容量时，Foundation 框架会创建一个新的、更大的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。

2. 当从 `NSMutableArray` 中删除元素时，它并不会立即收缩内存空间。相反，被删除元素的位置会被标记为空闲，可以用来保存新添加的元素。只有当数组的空闲空间达到一定的阈值时，Foundation 框架才会创建一个新的、更小的数组，然后将旧数组的元素拷贝到新数组中，然后释放旧数组。

关于第二个问题，肯定可以用别的方法来实现一个动态数组。例如，我们可以用 C 语言的动态内存分配函数 `malloc`、`realloc` 和 `free` 来实现一个动态数组。另外，我们也可以使用链表数据结构来实现类似 `NSMutableArray` 的功能，但是链表的随机访问性能较差，不适合需要频繁随机访问元素的场景。

:::

------

## NSDictionary

### ❓`NSDictionary` 大致实现原理

::: details 💡

`NSDictionary` 是 Objective-C 中一个非常重要的类，它提供了一个以键值对形式存储对象的接口，是一种哈希表实现。

尽管 Foundation 框架的具体实现没有公开，但我们可以推测一下它的实现原理：

1. 哈希表：在哈希表中，哈希函数将每个键 (key) 映射到表中一个唯一的索引。通过该索引，存储的相关值 (value) 可以快速地被找到。这就是 `NSDictionary` 可以快速查找键对应值的原因。

2. 碰撞处理：当两个或者更多的键映射到哈希表的同一个位置时，就会发生碰撞。通常情况下，有几种策略可以处理这种碰撞，比如链地址法，开放地址法等。不过具体 Foundation 使用哪种策略去处理碰撞我们并不清楚。

3. 动态调整：随着数据的增加，为了保持操作的高效，哈希表可能需要进行扩容。扩容经常伴随着数据的重新哈希，为的就是保持哈希值均匀分布，保持优秀的查找效率。
    
:::
  
### ❓`NSDictionary` vs `NSHashTable` vs `NSMapTable`

::: details 💡

`NSDictionary`，`NSHashTable` 和 `NSMapTable` 都是 Objective-C 中常用的集合类型，各有其特性和适用场景：

1. `NSDictionary`：存储键值对的集合，每个键都映射到一个值。对键进行`copy`操作，对值进行`retain`(强引用)操作。键必须要保持唯一。查找操作性能高效，时间复杂性为O(1)。

2. `NSHashTable`：一个可以存储任意对象的集合，集合中的每个对象都是唯一的。该类提供了对对象强引用、弱引用的选项，可以更加灵活地进行内存管理。

3. `NSMapTable`：和 `NSDictionary` 非常相似，但 `NSMapTable` 对键和值可以选择强引用或弱引用，比 `NSDictionary` 更加灵活。另外，`NSMapTable` 允许键和值为`nil`，而 `NSDictionary` 则不允许。

在考虑使用哪一个时，视具体需求而定：

- 当你需要按照键查找值，且对键和值的生命周期没有特殊要求时，使用 `NSDictionary`。

- 当你需要存储一组唯一对象，并且想要对对象的生命周期有更细粒度的控制时，使用 `NSHashTable`。

- 当你需要存储键值对对象，并且想要对键和值的生命周期有细粒度的控制，或者你需要在集合中存储`nil`对象时，使用 `NSMapTable`。


:::


  > 分别有哪些使用场景？
  
::: details 💡

1. `NSDictionary`：`NSDictionary` 由于其高效的查找速度，广泛用于需要依据键查找值的场景。例如，配置文件的存储和读取，网络请求的参数封装，JSON 数据的解析等。

2. `NSHashTable`：`NSHashTable` 适用于存储不需要重复的对象，并且对内存管理有一定要求的场景。例如，在缓存中存储对象但不引入强引用，防止内存无法释放的问题；或者在存储 delegate 对象时，避免引入循环引用。

3. `NSMapTable`：`NSMapTable` 可以实现强引用和弱引用键值对，所以适用于一些特殊场景。例如，你想在不引入强引用的情况下缓存对象，或者你希望跟踪哪些对象引用了其它对象等。

在实际开发中，正确地选择并使用这些集合可以帮助你更好地管理内存和提高程序性能。

:::
  
### ❓`NSDictionary` vs `NSCache`

::: details 💡

`NSDictionary` 和 `NSCache` 都是能够存储键值对的集合，但它们有一些主要的区别，使它们适用于不同的使用场景：

1. `NSDictionary` 是一个不可变的哈希表，其中的键值对都是强引用的。键是唯一的且不可变的。相比之下，`NSCache` 是一个可变的集合，其中的键值对都是强引用的，但有一个例外：键不是像 `NSDictionary` 管理那样通过 `copy` 管理，而是通过 `retain` 管理，因此键可以是可变的。

2. 另一个重要的区别在于内存管理。`NSCache` 在系统内存不足时，会自动释放缓存的部分或全部数据以节省内存。这使得在处理大量数据时，`NSCache` 可以自动处理低内存警告，而 `NSDictionary` 则需要手动处理低内存警告。

3. `NSCache` 支持通过 `NSDiscardableContent` 协议来控制缓存内容的生命周期。这样的对象在被缓存时，可以增加一个 `beginContentAccess` 之后配对的 `endContentAccess` 调用计数器。当对象的计数器为 0 时，那么这个对象就有可能被清出缓存。

综上所述，`NSDictionary` 和 `NSCache` 的不同主要在于内存管理和可变性。实际上，`NSCache` 更类似一个优化了内存管理的 `NSMutableDictionary`，更适合用于存储大量会占据大量内存的对象，例如图片等。

:::

  > `NSCache` 中缓存的对象，在什么时候被释放？

::: details 💡

`NSCache` 中缓存的对象被释放的时机取决于几个因素：

1. 内存压力：当操作系统触发低内存警告时，`NSCache` 会自动释放一些缓存的对象以节约内存。

2. 缓存某个对象的 `NSCache` 实例被销毁时，该对象会被释放。

3. 当缓存达到其极限时（这取决于你设置的缓存的数量和总成本的上限），`NSCache` 可能会开始移除一些对象。

4. 如果缓存的对象实现了 `NSDiscardableContent` 协议，那么对象的释放还会取决于它的 `beginContentAccess` 和 `endContentAccess` 方法的调用计数。当这个计数为 0 并且内存压力较大时，对象可能被释放。

这样的设计使 `NSCache` 非常适合用于缓存大量占用内存的对象（例如图片等）。因为它的自动内存管理机制可以防止应用因为低内存压力而崩溃，同时还能确保缓存的有效利用。

:::

### ❓`isEqual` 和 `hash` 的关系？

::: details 💡

在 Objective-C 中，`isEqual:` 和 `hash` 两个方法在很多场合都需要同时使用，比如在对自定义对象进行集合操作（存入 `NSSet`，作为 `NSDictionary` 的 Key 等）时。它们的关系可以这样理解：

1. `isEqual:` 方法是用来判断两个对象是否相等。如何判断对象的相等性，你可以在自定义类中重写这个方法来自定义判断规则。

2. `hash` 方法返回一个无符号整数（`NSUInteger`）的哈希值，这个值被用于 UITableView、NSSet、NSDictionary 等集合类的操作以提升性能。对象的哈希值主要是通过对象的内容进行计算得出。

3. `isEqual:`方法和 `hash` 方法需要保持一致，意思是当两个对象 `isEqual` 的返回值相等时，它们的 `hash` 方法返回值必须也相等。反过来并不一定，即如果两个对象的 `hash` 值相等，并不一定要求他们 `isEqual` 值也一定相等，因为不同的对象有可能产生相同的哈希值（通常被称为哈希冲突）。 

总结来说，如果你需要自定义对象及其相等性的规则，那么通常需要同时重载 `isEqual:` 和 `hash` 方法，并确保它们的行为是一致的。

:::

------

## 拷贝

### ❓`copy` 和 `mutableCopy` 的区别？

::: details 💡

`copy` 和 `mutableCopy` 是 `Foundation` 框架 `NSObject` 类中定义的方法，被用来创建对象的拷贝，它们的区别如下：

1. `copy`：执行的是浅拷贝（也叫做指针拷贝），拷贝后的对象类型是不可变的。这意味着在实际操作中，`copy` 并没有开辟新的内存空间，而是拷贝对象持有的指针。因此原始对象和拷贝对象指向相同的内存地址。

2. `mutableCopy`：执行的是深拷贝（也叫做内容拷贝），拷贝后的对象类型是可变的。这意味着在实际操作中，`mutableCopy` 会开辟一块新的内存空间，拷贝对象的值到这块新的内存空间。

主要的差异是拷贝出来的对象可变性和持有数据的方式（指针拷贝或者内容拷贝）。需要注意的是，浅拷贝并不意味着拷贝出来的对象一定是不可变的，具体还需要看拷贝的源对象是什么类型。如果拷贝的源对象是不可变的，那么 `copy` 方法拷贝出来的对象也是不可变的；如果拷贝的源对象是可变的，那么 `copy` 方法拷贝出来的对象就是可变的。

:::

### ❓自定义类如何实现 `copy` 功能？

::: details 💡

在 Objective-C 中，如果你的类需要支持拷贝功能，那么你需要声明并实现 NSCopying 或 NSMutableCopying 协议。这通常涉及重写 `copyWithZone:` 方法。

以一个简单的自定义类 `Person` 为例，假设它有两个属性 `name` 和 `age`：

```objc
@interface Person : NSObject <NSCopying>
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSUInteger age;
@end
 
@implementation Person
- (id)copyWithZone:(NSZone *)zone {
    Person *copyPerson = [[[self class] allocWithZone:zone]init];
    copyPerson.name = [self.name copyWithZone:zone];
    copyPerson.age = self.age;
    return copyPerson;
}
@end
```

这样，通过 [xx copy] 的语法就可以获取到 `Person` 的拷贝了。其中，`copyWithZone:` 方法创建了一个新的实例，然后复制了 `name` 和 `age` 属性。

:::

### ❓自定义类如何实现 `mutableCopy` 功能？

::: details 💡

我们以一个Person类为例，如果需要自定义类型实现mutableCopy，需要遵循`NSMutableCopying`协议并实现`mutableCopyWithZone:`方法。

```objc
@interface Person : NSObject <NSMutableCopying>
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSUInteger age;
@end

@implementation Person
- (id)mutableCopyWithZone:(NSZone *)zone {
    Person *copyPerson = [[[self class] allocWithZone:zone]init];
    copyPerson.name = [self.name mutableCopyWithZone:zone]; 
    copyPerson.age = self.age;  
    return copyPerson;
}
@end
```

在这个示例中，我们声明Person类遵循NSMutableCopying协议，并实现其`mutableCopyWithZone:`方法。在该方法中，我们创建一个新的Person实例，然后逐个将原始对象的属性值复制到新的实例上。对于`name`属性，我们调用其`mutableCopyWithZone:`方法来得到一个可变副本。而对于`age`属性，由于它是一个基本数据类型，我们直接赋值即可。

记住，`mutableCopyWithZone:`方法返回的应该是一个全新的实例，而不应该是原始对象自身，因为这样才是deep copy, 克隆出来的对象和原对象没有任何影响。

同样的，我们还可将Person类遵循NSCopying协议，并实现其`copyWithZone:`方法，这样Person类就可以支持`mutableCopy`和`copy`操作了。

:::

### ❓如何重写带 `copy` 关键字的 `setter`？

::: details 💡

在Objective-C中，如果想要重写带`copy`关键字的`setter`方法，你可以这样进行：

首先我们假设有一个属性：`@property (nonatomic, copy) NSString *name;`

其重写的`setter`方法将会是这样：

```objc
- (void)setName:(NSString *)newName {
    if(_name != newName) {
       [_name release]; // MRC 下
       _name = [newName copy];
    }
}
```

在这个例子中，`if(_name != newName)`是为了防止传入的新值和旧值是同一个对象，如果是同一个对象而直接release掉，那么接下来进行copy操作就可能会出现问题。

接着`[_name release]`是为了释放掉旧值对象，因为重写setter通常是在改变属性值时进行的。

最后`_name = [newName copy]`是为了对新值对象进行copy操作，这样就能保证_name属性始终持有一个对应字符串的copy。

记住，在你释放旧值前，要先将新值copy或retain了，因为如果新值和旧值是同一个对象的话，你释放了旧值也就意味着释放了新值，这可能会导致unpredictable的后果。

:::

### ❓`@property (copy) NSMutableArray *array;` 这个写法正确吗？

::: details 💡

这个写法可以运行通过，但从代码规范和最佳实践来说，这并不是一个好的写法。

当你给一个属性添加 `copy` 标识时，这个属性的 `setter` 将会使用传入对象的 `copy` 方法来创建一个新的对象。然而，在 Objective-C 中，`copy` 方法对 `NSMutableArray` 实例调用将返回一个 `NSArray` 实例。这是由于 `copy` 策略总是返回一个不可变的副本。

所以，如果你用 `@property (copy) NSMutableArray *array;` 这个写法，实际上你得到的 `array` 是一个不可变数组 `NSArray`。当你在后续代码中尝试向这个“可变数组”(`NSMutableArray`) 中添加或删除元素时，将会导致运行时错误。

如果你需要属性为一个可变数组并支持 `copy` 行为，你需要手动实现属性的 `getter`和`setter`方法，并在`setter`方法中使用 `mutableCopy` 进行拷贝。

下面是一个例子来说明如何操作：

```objc
@interface MyClass : NSObject
@property (nonatomic, strong) NSMutableArray *array;
@end

@implementation MyClass

- (void)setArray:(NSMutableArray *)newArray {
    _array = [newArray mutableCopy];
}

@end
```

这样你可以保证每次设置新数组时都创建一个可变副本，而不是指向原始数组。

:::

### ❓为什么不可变对象要用 `copy`？

::: details 💡

第一，使用 `copy` 可以防止对象在外部被意外修改：

设想这样一种情况，你有一个类，这个类有一个公共的 NSString 属性，你希望这个属性的值在你设置后就不会被改变，如果你将该属性声明为 `strong` 属性，这个属性就可以被外部改变。例如：

```objc
self.myObject.name = @"Original";
NSMutableString *nameString = [NSMutableString stringWithString:@"Change"];
self.myObject.name = nameString;
[nameString appendString:@"Add"];

NSLog(@"Name: %@", self.myObject.name);
```

上述代码将打印 "ChangeAdd"，因为 nameString 与 myObject.name 指向的是同一个对象。为了防止可能的外部访问改变我们的对象，我们应该创建一份独立的副本，这可以通过声明该属性为 `copy` 来实现。

第二，某些具有父子关系的类，子类对象赋值给用 `copy` 修饰的父类变量后，父类变量会变为原来的父类特性(里氏替换)。如：

  假设你将一个 NSMutableString 实例赋值给一个类型为 NSString 且用 copy 修饰的变量，那么这个变量就不再有 NSMutableString 的特性，而只有 NSString 的特性。所以从某种意义上说，用 copy 也是为了类型安全。

:::

------

## 属性

### ❓`@property` 属性是什么？

::: details 💡

  > `@property` 是 `Objective-C` 中的一个关键字，用于声明一个属性。主要作用是为类的实例变量（属性）生成对应的访问器方法，即 `getter` 方法和 `setter` 方法。
  
  `@property` 访问器
  - 原子性 : `atomic`、`nonatomic`
  - 读写性 : `readwrite`、`readonly`
  - 内存管理 : `assign`、`strong`、`weak`、`copy`

  `@property` 优点
  - 隔离性：可以封装实例变量的直接访问，将类的内部实现与外部接口隔离，提高数据的安全性。
  - 可维护性：可以在 `getter` 和 `setter` 中添加特定的逻辑如设置新值时进行验证，获取值时返回一个计算后的值等，提高代码的可维护性。 

 > `class` 属性修饰器

 在Objective-C中，class属性修饰符主要运用于定义一个Class类型的属性，它的用途主要是标明一个property的关联对象类型是一个Class，而非一个实例。

以下是使用“class”属性修饰符的一个例子：

``` objective-c
@property (class, nonatomic, readonly) NSString *appName;
```

在这段代码中，appName属性被定义为一个字符串，并且使用class关键字标识为类属性。这意味着这个属性不属于实例，而是属于类本身。

类属性在所有实例中保持一致，它们的所有权并不属于特定的实例，而是公共所有。类似于静态变量，类属性是由类直接管理并控制的。它能够在类的任何实例中被查询或修改。和其他属性一样，通过使用@property关键词定义的类属性准备好了getter和setter方法，你可以使用点语法来访问它。然而，你不能使用实例来访问类属性，就像你不能使用具体实例来调用静态方法一样。

需要注意的是class属性修饰符只能够用于类中，而不能够用于对象中。

:::

### ❓`@property` 的默认关键字？
  
::: details 💡

```objc
// 基本数据类型 => 默认是: atomic, readwrite, assign
@property int num;
// 对象数据类型 => 默认是: atomic, readwrite, strong
@property NSObject *obj;
```

:::
  
### ❓`@property` 的底层实现？

::: details 💡  
  
  > `@property` 是一个关键字，用于声明类的属性。声明一个属性时，编译器会自动生成一些代码，这就是 `@property` 的底层实现。

- 实例变量：`@property` 在默认情况下会自动合成一个带下划线前缀的实例变量。例如声明了一个名为 `foo` 的属性，编译器会自动生成一个名为 `_foo` 的实例变量。

- `getter` 和 `setter` 方法：会为属性自动生成 `getter` 和 `setter` 方法。

- 内存管理：指定的属性修饰符（`assign`、`strong`、`weak`、`copy` 等），编译器会在 `setter` 方法中生成相应的内存管理代码，比如引用计数的增加和减小，拷贝对象等。

- `KVO` 支持：`@property` 自动生成的 `getter` 和 `setter` 方法支持键值观察(`Key-Value Observing`)，允许其它对象观察和响应属性值的改变。


  > runtime 层面
  
  声明 `@property` 后，编译器会根据属性的特性在 `class_rw_t` 结构中的 `methods` 和 `properties` 中生成 `getter` 和 `setter` 方法以及相应的属性。然后在运行时，这些 `getter` 和 `setter` 方法以及属性被引入到 `objc_class` 的结构中。
  
  ```objc
  struct objc_class {
      Class isa;              // metaclass 的指针
      Class super_class;      // 父类
      cache_t cache;          // 缓存
      class_data_bits_t bits; // 类的相关信息，包含了一个指向 class_rw_t 数据结构的指针
  };
  // 可读写结构，存储运行时添加的类信息
  struct class_rw_t {
      uint32_t flags;
      uint32_t version;
      const class_ro_t *ro;           // 只读结构体，保存编译时确定的类信息
      method_array_t methods;         // 方法列表
      property_array_t properties;    // 属性列表
      protocol_array_t protocols;     // 协议列表
      Class firstSubclass;
      Class nextSiblingClass;
  };
  ```
  
::: 
  
### ❓`assign`、`strong`、`weak`、`copy` 区别？
  
::: details 💡
  
  - `assign`：是赋值特性，简单设置变量，不更改引用计数。
    > 主要用在基本的数据类型（如 int、float）或 C 数据类型（如 结构体、C 数组）而不是对象。
  
  - `strong`（类似于：retain）：是所有权（owning）特性。
    > 采用 `ARC`（自动引用计数）环境下，编译器会自动在设置方法中插入 `retain` 调用，使对象的引用计数增加，从而表示当前对象拥有数据值。
  
  - `weak`：是非拥有关系（non-owning）特性，即弱引用。
    > 当用 `weak` 修饰对象时，被指向的对象引用计数不会增加，更重要的是，当对象被释放时，被 `weak` 修饰的变量会自动被置为 `nil`，防止野指针的出现。`weak` 修饰的属性适合在已经存在对对象的 `strong` 引用，或者对象之间存在相互循环引用的情况下使用。
  
  - `copy`：是拷贝特性。
    > 适合 `NSString`、`NSArray`、`NSDictionary` 等不可变对象。最重要的一点是：使用 `copy` 保持封装性，对象在内部可能需要一个数据的完整副本，并且把这个副本给外界使用，防止作为接口提供的对象的初始数据被改变。

  选择哪种属性修饰符要视情况而定，如果数据是不可变的，那么选择 `assign` 或 `copy` 较好；如果数据是可变的，可以选择 `strong` 或 `weak`。

:::

### ❓`NSString` 为什么使用 `copy`，可以使用 `strong` 吗？

::: details 💡

  > `NSString` 使用 `copy` 是为了防止在赋值可变字符串时由于原字符串发生改变而引发非预期问题。

  - `NSString` 的子类 `NSMutableString` 是可以变化的。如果使用 `strong` 并把一个 `NSMutableString` 实例赋值给 `NSString` 对象，然后改变该`NSMutableString` 实例，那么 `NSString` 实例也会随之改变。

  - 如果使用 `copy`，当一个 `NSMutableString` 实例赋值给 `NSString` 对象时，实际上会复制一个不可变的副本。这样即使原字符串改变 `NSString` 实例也不会受影响。
  
:::

### ❓`assign` 可以用于 `OC` 对象吗？

::: details 💡

  > `assign` 是一种属性修饰符，用于指定属性的赋值语义。`assign` 可以用于任何数据类型，包括 `Objective-C` 对象。但是，对于对象来说不推荐使用 `assign`。

  将 `assign` 用于 `Objective-C `对象时，其会生成一个设置器，其行为将传入的值赋值给实例变量，并不改变该对象的引用计数。如果该对象在其它地方被释放，那么这个引用就成了一个悬挂指针（或者说“野指针”），这将会引起程序在调用该对象时崩溃。

  > 在某些特定场景下，可能会选择使用 `assign`。例如，当需要创建一个 “弱引用并且不希望在对象被释放时自动设置为 `nil`” 时，`assign` 就会是个不错的选择，但是需要确保不会发生悬挂指针。

:::

### ❓`nonnull` 用过吗

::: details 💡
  
  > `nonnull` 关键字在 `Objective-C` 中的出现是为了更好地与 `Swift` 兼容。

:::

### ❓`@synthesize` vs `@dynamic`

::: details 💡

- `@synthesize`：告诉编译器编译时自动创建 `getter/setter` 方法，如果没有手动实现的话。

- `@dynamic`：这个关键字告诉编译器,属性的 `getter` 和 `setter` 方法由自己实现，不自动生成（当然对于`@dynamic var`，编译器还是会默认添加其成员变量`_var`），如果没有手动实现 `setter和getter`，那么程序运行时，编译器发现找不到 `setter/getter` 就会崩溃。好处是可以在运行时动态绑定对象。

> `@dynamic`常常和运行时函数 `class_addMethod` 配合使用，可以动态添加方法。最常见的应用是在 `Core Data` 的 `NSManagedObject` 子类中，`Core Data` 的属性经常被设置为 `@dynamic`，`NSManagedObject` 利用 `Core Data` 的底层存储访问这些属性，以便将对象的实际数据保存在磁盘上，而不是内存中。 

:::

### ❓`@synthesize` 合成实例变量的规则是什么？如果属性名为 `foo`，存在一个名为 `_foo` 的实例变量，还会自动合成新变量么？

::: details 💡

  > `@synthesize` 关键字用于手动指定需要 `@property` 属性对应的成员变量名称。

  属性名为 `foo`，同时已经实现了一个名为 `_foo` 的实例变量，那么在默认情况下（也就是你没有使用 `@synthesize` 关键字来手动指定成员变量名），编译器不会再合成新的实例变量。因为编译器默认的命名规则是在属性名前加`_`作为成员变量名，如果已经存在这样的成员变量，编译器就不会再创建新的变量。

```objc
@interface MyClass : NSObject
@property (nonatomic, strong) id foo;
@end

@implementation MyClass {
    id _foo; // 不会再合成新的实例变量
}
```

  使用了 `@synthesize` 来指定了一个新的名称，那么编译器便会按照指定名称创建新的实例变量。
  
```objc
@implementation MyClass
@synthesize foo = myFoo; // 创建一个名为 myFoo 的实例变量
@end
```

:::

### ❓`@synthesize` 都有哪些使用场景？

::: details 💡

- 设置实例变量名。`@synthesize`关键字允许手动改变自动生成的实例变量的名称。

- 协议属性自动合成。实现协议时，为了避免重复编写代码，可以使用 `@synthesize` 来自动合成协议中定义的属性。 

- 不生成实例变量。当在类扩展 (`@interface MyClass()`) 或者父类中已经声明了属性的实例变量 `_foo`，此时在子类中如果 `@synthesize foo;`，则不会生成 `foo` 对应的实例变量。

- 生成实例变量。当在头文件或者类扩展（`@interface MyClass()`）中声明 `@property` 属性但没有 `@synthesize foo;`，则会自动生成 `_foo` 实例变量。如果在 `.m` 文件中声明 `@property` 属性但没有 `@synthesize foo;`，则不会自动合成属性的实例变量。

  > 在 `Xcode 4.4` 及以上版本中，默认已经开启了 `@synthesize` 自动生成，已经不需要显式地使用 `@synthesize`，除非在某些特殊情况下需要手动指定实例变量的名字。

:::

------

## Block
  
### ❓`block` vs `Delegate`
  
::: details 💡

Block和代理（Delegate）都是iOS开发中用于实现逻辑回调的常用方式，但他们之间存在一些区别。

1. 定义方式：Block是一种特殊的数据类型，可以将一段代码封装到一个变量中，然后在需要的时候调用这个变量。而代理是一种设计模式，是通过protocol定义了一系列的方法，然后由其他类去实现这些方法。

2. 使用场景：Block适合一些简单的逻辑处理，如动画回调，数组遍历等；代理通常用于处理复杂的交互，如TableView的数据源及代理方法，网络请求的回调等。

3. 执行流程：Block在调用时是同一个函数或方法内部的，逻辑关系相对清晰，容易理解；而代理方法可能分散在代码的不同地方，使得调试和阅读代码稍微困难一些。

4. 生命周期：Block有可能导致循环引用的问题；而Delegate由于是weak引用，不会出现循环引用的问题。

5. 排序：Block可以有多个且同时存在，顺序可以自由改变。而delegate通常只有一个，如果有多个，通常需要其他方式进行排序。 

总结来说，具体使用哪种方式，需要根据代码的复杂性，执行环境，对内存管理的要求等因素综合考虑。

:::
  
### ❓`block` vs 函数指针
  
::: details 💡
  
  - `block`：一种特殊的数据类型，可以存储一段代码，并且这段代码可以在任何时候被执行。可以访问在声明他的那个作用域中定义的变量，这被称为“变量捕获”。
  
  - 函数指针：函数指针是存储着函数地址的指针变量，本质上是一个地址值，也就是函数在内存中的起始地址。函数指针不能像 `block` 那样访问变量，只能通过传参的方式去使用外部的数据。
  
:::

### ❓`block` 什么情况会发生循环引用？

::: details 💡

`Block` 会在以下情况下形成循环引用：

当在一个 Objective-C 对象的方法（或者属性）中引用了一个 Block，而这个 Block 中又引用了该对象（不论是直接引用还是间接引用）时，就会形成一个循环引用。这是由于 Block 在捕获对象时默认为强引用，而对象本身又强引用了 Block，形成了循环。

例如，以下代码就存在循环引用：

```objective-c
__strong typeof(self) strongSelf = self;
self.myBlock = ^{
    [strongSelf doSomething];
};
```

这段代码中，Block 引用了 self，而 self 又通过 `self.myBlock` 引用了 Block，从而形成循环引用。

为了打破这个循环，我们通常采用弱化 self 的方式：

```objective-c
__weak typeof(self) weakSelf = self;
self.myBlock = ^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    [strongSelf doSomething];
};
```

这里通过 `__weak typeof(self) weakSelf = self;` 创建了一个对 self 的弱引用，然后在 Block 中使用这个弱引用，从而避免了循环引用。但在 Block 中实际使用时，又通过 `__strong typeof(weakSelf) strongSelf = weakSelf;` 临时创建了一个对 weakSelf 的强引用，确保在 Block 执行过程中不会出现 weakSelf 被意外释放的情况。

:::

### ❓`UIView` 动画函数 `block` 版本是否需要处理循环引用？

::: details 💡

在 UIView 的动画函数 block 版本中使用 self，实际上不会造成引用循环。

因为这些动画 block 只会在动画结束后才被释放，而不是被 self 所拥有。另外，这种动画函数不会保持对动画 block 的长期持有，一般在动画结束后就会将其释放，因此也就不存在循环引用的问题。

所以在这种情况下，你可以直接使用 self 而不用担心引发循环引用的问题。例如：

```objc
[UIView animateWithDuration:1.0 animations:^{
    self.myView.alpha = 0;
}];
```

:::

### ❓`block` 底层实现

::: details 💡

在底层，Block 是一个 Objective-C 对象，它的定义中包含了一个结构体和函数指针。

一个简化版的 Block 的结构体可以这样描述：
```objc
struct Block_literal {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct block_descriptor *descriptor;
    /* captured variables... */
};
```
这里面的元素分别表示：

- `isa`：指向对象的类型，所有 Objective-C 对象都有该变量。
- `flags` 和 `reserved`：提供关于 Block 的一些信息，如 Block 类型等。
- `invoke`：一个函数指针，指向进行调用的函数。
- `descriptor`：一个指向 Block_descriptor 结构的指针，其中包含相关信息。

除此以外，结构体中还包含通过闭包捕获的变量。

以上是 Block 的简化版的结构体描述，实际上 Block 的底层实现要复杂的多，应用到了大量的内存管理技术。在 Objective-C 中，对 Block 的内存管理方法为 global（全局块）、stack（栈块）和 malloc（堆块）。

在默认情况下，Objective-C 的编译器会根据情况适当地为 Block 分配内存。当 Block 没有捕获任何外部变量，或者仅使用了全局变量和静态变量时，它是一个 global Block，存储在程序的全局数据区，其生命周期从创建到程序结束。当 Block 使用了外部的自动变量（包括 ObjC 对象和基本数据类型），在未进行 copy 操作的情况下，它是一个 stack Block，存储在栈内存上，超出作用域即被销毁。如果对 Block 进行了 copy 操作，或者是用 __block 修饰的自动变量，那么这个 Block 是一个 malloc Block，存储在堆内存上，需要手动进行内存管理。

[👉🏻](https://www.mikeash.com/pyblog/friday-qa-2009-08-14-practical-blocks.html)

:::

### ❓`block` 内如何修改外部变量

::: details 💡

在Objective-C中，如果你想在 block 内部访问和修改 block 外部的变量，你需要在变量前加上 __block 修饰符，如下：

```objc
__block int num = 0;
void (^myBlock)(void) = ^{
    num = 1;  
};

myBlock();
NSLog(@"Num: %d", num);  // 这里输出 "Num: 1"
```

在这里，num 变量前面加上了 __block 修饰符，所以可以在 block 内部被修改。myBlock 被调用后，num 的值被改变为1，因此 NSLog 可以打印出 "Num: 1"。

如果不加 __block 修饰符，编译器会报错，因为 block 默认捕获变量的值，而不是变量本身，因此不能修改这个变量的值。加了 __block 后，block 将捕获变量本身，使得可以在 block 内部修改该变量。

:::

### ❓`block` 在捕获自动变量，局部静态变量，全局变量，全局静态变量有什么区别

::: details 💡

`Block` 对自动变量、局部静态变量、全局变量、全局静态变量的捕获方式是不同的：

1. 自动变量（auto variables）：这是我们在方法或函数中常见的局部变量，如 int num = 10。这种变量在 block 中默认以值传递形式捕获，即 block 捕获的是值，而不是变量本身。如果要在 block 中修改局部变量的值，必须在定义变量时加上 __block 修饰符。

2. 局部静态变量、全局变量、全局静态变量：这些变量在 block 中以指针形式捕获，即 block 捕获的是对这些变量的指针。这意味着，可以在 block 中直接修改这些变量的值，不需要加 __block 修饰符。

以下是个简单代码示例：

```objc
int globalVar = 4;
static int staticGlobalVar = 5;

void Test() {
    int localVar = 1;
    static int staticVar = 2;
    __block int blockVar = 3;

    void (^myBlock)(void) = ^{
        NSLog(@"localVar: %d", localVar);          // 1
        NSLog(@"staticVar: %d", staticVar);        // 2
        NSLog(@"blockVar: %d", blockVar);          // 3
        NSLog(@"globalVar: %d", globalVar);        // 4
        NSLog(@"staticGlobalVar: %d", staticGlobalVar);  // 5

        // localVar++;              // Error! "Variable is not assignable (missing __block type specifier)"
        staticVar++;
        blockVar++;
        globalVar++;
        staticGlobalVar++;
    };

    myBlock();
    
    NSLog(@"staticVar after block: %d", staticVar);        // 3
    NSLog(@"blockVar after block: %d", blockVar);          // 4
    NSLog(@"globalVar after block: %d", globalVar);        // 5
    NSLog(@"staticGlobalVar after block: %d", staticGlobalVar);  // 6
}
```

:::

### ❓`block` 捕获外部局部变量实际上发生了什么

::: details 💡

在 Objective-C 中，block 可以捕获其外部的局部变量，使得这些外部变量可以在 block 的执行体内部被访问到。捕获的过程其实是在 block 被创建时发生的。block 会创建对应的变量的 "拷贝"，这个拷贝的过程会考虑变量的类型：

1. 对于基本数据类型变量，比如 int、float，block 会复制其值，也就是在 heap(堆) 应用一段内存，将外部的变量值复制一份到这个内存上。

2. 对于对象类型变量，block 会保留该对象，并复制对象指针。这个过程也被称为引用捕获。这样 block 对象可以在稍后的时间里随时引用到这个变量。

然而，像上面所说的，block 捕获到的是外部局部变量的副本，所以你不能改变外部的局部变量。如果你想在 block 内修改外部局部变量，则需要在定义局部变量时加上 "__block" 修饰符。

__block关键字可以用于解决 block 内部无法修改外部变量的问题。这是因为，当捕获一个 __block 变量时，block 内部会保留这个 __block 变量。在堆上创建的 block，会在 heap 中维护一个 __block 变量的结构体，这个结构体中包含了 __block 变量的地址和其值，这样 block 就可以通过操作这个结构体来修改 __block 变量的值。


:::

> 如果 使用 __block 捕获了局部变量，这个 block 作为返回值 return 了，这个局部变量释放了，怎么办？

::: details 💡

在使用 __block 捕获局部变量的同时，如果这个 block 作为返回值返回，那么这个局部变量就会被 block 捕获到，并且它的生命周期就延长到了 block 生命周期结束为止。也就是说，这个局部变量不会在离开定义它的作用域时释放，而是将在 block 被释放时才释放。

注意一点，正常情况下 block 是分配在栈上的，栈上的 block 在离开作用域后就会被销毁。但是如果这个 block 被赋值给了一个强引用的变量，或者被返回出去的话，就需要将栈上的 block 复制到堆上，这样 block 的生命周期就会得到延长，直到没有强引用指向它为止。

同时，对于使用 __block 修饰的局部变量，这个变量的存储地址会从栈复制到堆上。所以，返回的 block 中捕获的是移动到堆上的 __block 变量的地址，这也确保了返回后，能够正确地访问和修改这个 __block 变量。

:::

### ❓`block` 修改捕获变量除了用 `__block` 还可以怎么做？有哪些局限性？

::: details 💡

如果你希望在 block 中修改一个捕获变量，除了用 __block，可以使用 __strong 或者创建一个可修改的对象，如 NSMutableArray 或 NSMutableDictionary，然后在 block 中修改该对象的内容。但是，这并不能改变原始变量的值，只是改变了它所引用的对象的内容。

例如：
```objc
NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    [array addObject:@"Object"];
};

myBlock();
NSLog(@"%@", array); // 输出：Object
```
在这个例子中，我们并没有修改 array 这个变量本身，而是修改了它所引用的对象的内容。也就是说，我们不是改变 array 这个指针所指向的地址，而是改变了这个指针所指向的内存中的内容。

此种方式来达到block内部修改变量的效果的局限性在于，只有可变的引用类型（比如NSMutableArray）可以使用此方法，基本数据类型或者不可变的引用类型无法使用此方法在block中进行修改。与使用__block相比也更加的不直观。

:::

### ❓`block` 中修改 `NSMutableArray` 需不需要添加 `__block`

::: details 💡

不需要。在 Objective-C 中，NSMutableArray 是一个引用类型的对象，即使不使用 `__block`，你也可以在 block 内部添加、删除或修改 NSMutableArray 的元素。因为你修改的是 NSMutableArray 对象的内容，而不是 NSMutableArray 变量本身。

例如，你可以这么写：
```objc
NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    [array addObject:@"Hello, World"];
};
myBlock();
NSLog(@"%@", array);  // 输出：["Hello, World"]
```
这段代码在 block 中向 array 添加了一个字符串，然后打印 array 的内容。注意，这里并没有修改 array 这个变量本身，只修改了它所引用的对象的内容。所以，我们无需添加 `__block` 修饰符。

但是，如果你希望在 block 中修改 array 这个变量（比如使其指向一个全新的 NSMutableArray 对象），那就需要使用 `__block` 了。例如：
```objc
__block NSMutableArray *array = [NSMutableArray array];
void (^myBlock)(void) = ^{
    array = [NSMutableArray array];
    [array addObject:@"Hello, World"];
};
myBlock();
NSLog(@"%@", array);  // 输出：["Hello, World"]
```

:::

### ❓`__block` vs `__weak`

::: details 💡

在 Objective-C 中，我们经常使用 `__block` 和 `__weak` 这两个修饰符来修饰变量。尽管它们的用法看起来相似，但它们的作用和使用场景却有所不同。

1. `__block`：它到底是允许在块（Block）中改变变量的值。在 Objective-C 中，`__block` 是存储类型说明符，用于修饰一个变量，让该变量能在 Block 中被读取和写入。如果没有 `__block`，那么 Block 就不能修改该变量的值。

2. `__weak`：它用于创建一个弱引用。在 Objective-C 中，弱引用是一种特殊类型的引用，它不会增加被引用对象的引用计数。这样可以解决对象互相引用，形成引用循环的问题。在处理Block 对象引用 self 时，我们通常会先创建一个弱引用的 self，然后在 Block 中使用这个弱引用，从而避免引用循环。

在使用这两个修饰词来修饰变量时，我们需要根据需求和实际使用场景来选择。如果我们希望在 Block 中改变一个变量的值，应该使用 `__block`。而如果我们想避免引用循环，应该使用 `__weak`。

:::

### ❓`__block` 在 `ARC` 和非 `ARC` 有区别吗

::: details 💡

是的，`__block` 在 ARC（Automatic Reference Counting）和非 ARC 环境下确实有区别。

在非 ARC 环境下，__block不会改变对象的所有权。也就是说，如果我们有一个__block修饰的对象，block 不会为这个对象增加引用计数。因此，如果在 block 执行后，原来的对象被释放了，那么 block 内的这个对象就变成了悬浮指针。

在 ARC 环境下，__block 有另外一种行为。它会保留 block 中使用到的对象。也就是说，如果我们有一个 __block 修饰的对象，当 block 执行时，就会增加这个对象的引用计数。因此，在 ARC 下，我们可以安全地在 block 中引用 __block 修饰的对象，而不必担心它会被提前释放。

为了在两种环境下都能安全使用，我们一般会选择 __weak 代替 __block 来避免循环引用，特别是在引用 self 或者其成员变量的时候。

:::

### ❓一个 `int` 变量用 `__block` 修饰与不修饰有区别吗

::: details 💡

是的，对于一个 `int` 类型的变量，使用 `__block` 修饰与否是有区别的。

如果一个变量被 `__block` 修饰，那么它可以在 block 内部被更改。如果没有被 `__block` 修饰，那么在 block 内部是无法更改这个变量的，它在 block 中会被视为常量。

例如，对于以下代码：
```objc
int value = 0;
void (^myBlock)(void) = ^{
    value = 1;  // 这里会报错，因为 value 在 block 内部不能被更改
};
```
但如果 `value` 被 `__block` 修饰：
```objc
__block int value = 0;
void (^myBlock)(void) = ^{
    value = 1;  // 这里可以正常运行，value 在 block 内部可以被更改
};
```
因此，如果需要在 block 内部更改一个变量的值，那么这个变量必须使用 `__block` 修饰。

:::

### ❓`block` 如何进行内存管理的

::: details 💡

在 Objective-C 中，Block 的内存管理默认分为三个级别：_NSConcreteGlobalBlock、_NSConcreteStackBlock、_NSConcreteMallocBlock。

1. `__NSConcreteGlobalBlock__`：这种 Block 属于全局区，类似于全局变量，生命周期从应用开始直到应用结束。

2. `__NSConcreteStackBlock__`：这种 Block 存放在栈内存中，当超出其作用域后就会被自动销毁。

3. `__NSConcreteMallocBlock__`：这种 Block 存放在堆内存中，需要手动管理其内存，可以通过 retain 来增加其引用计数，通过 release 来减少其引用计数，当引用计数为 0 时，Block 会被销毁。

在使用 ARC (Automatic Reference Counting) 时，对 Block 的内存管理会简化许多。当 Block 中引用到了外部变量时，Block 将会自动从栈复制到堆中（有复制行为的 Block 都会进入堆区），并且在引用计数为 0 后会自动销毁，不需要手动管理。

但要注意的一点是，对于 Block 内部应用到的对象，如果不加特殊处理，是会形成强引用的，因此可能会导致引用循环并引发内存泄漏。为了防止这种情况，我们经常使用 __weak 来修饰引用的对象，避免产生循环引用。

:::

### ❓`block` 一般使用 `copy` 修饰，可以使用 `strong` 吗,发生 `copy` 的时机

::: details 💡

`block`使用`copy`修饰是为了保持`block`的引用计数的正确。`block`本身是在堆栈上分配的，`copy`操作将其复制到堆上，可以保证`block`在方法返回后不被销毁，保证其正确执行。

虽然你也可以使用`strong`来修饰`block`，但是这样做并不会将`block`从栈复制到堆。因此，如果`block`捕获了方法内部的变量，当方法返回后，这些变量都已经被释放，可能会导致程序崩溃。

`copy`操作一般发生在你把`block`作为属性进行设置的时候，这个时候赋值方法（setter）会进行`copy`操作。也可以手动调用`copy`方法来进行操作。

总的来说，将`block`属性用`copy`修饰，能够更好地管理其内存，并确保其正确执行。

:::

### ❓为什么在 `block` 外部使用 `__weak` 修饰的同时需要在内部使用 `__strong` 修饰
  
::: details 💡

在 block 中使用 __weak 修饰符是为了防止循环引用。由于 block 会捕获其内部使用的变量，如果 block 内部访问了 self 或其成员变量，那么会形成循环引用，导致内存泄漏。而使用 __weak 修饰符可以将 self 或成员变量变成弱引用，从而避免循环引用。

然而，使用 __weak 修饰符也会有其不足之处：在 block 执行期间，若弱引用的对象被释放了，那么 block 内部对该对象的访问就会失效。为了避免这种情况，就需要在 block 内部使用 __strong 修饰符将弱引用变量提升为强引用。

这样做可以保证在 block 执行期间，这个被提升的强引用变量所指向的对象不会被释放，保证了 block 执行过程中对象的访问安全。而在 block 执行完毕后，强引用也会随之释放，和在 block 外部保持指向对象的弱引用并不存在循环引用问题。

以下是一个典型的例子：
```objc
__weak typeof(self) weakSelf = self;
[self doSomethingWithBlock:^{
    __strong typeof(self) strongSelf = weakSelf;
    [strongSelf doSomethingElse];  
    // 在此处，若 self 在 block 执行期间释放，由于存在 strongSelf 的强引用，self 所指向的对象不会被释放。
}];
```
在这个例子中，会先创建一个 `weakSelf` 的弱引用，然后在 block 中将其提升为 `strongSelf` 的强引用。这样可以保证 `self` 在 block 执行期间不会被释放，从而避免了访问无效对象的风险。

:::


### ❓`block` 访问对象类型的 `auto` 变量时，在 `ARC` 和 `MRC` 下有什么区别

::: details 💡

在MRC和ARC下，`block`访问对象类型的`auto`变量时，有一些不同。

在MRC下，`block`只是简单地进行指针拷贝，不会对对象进行`retain`操作，这会导致可能的对象释放错误。

在ARC下，编译器会自动进行内存管理，在`block`被创建时，会对它所捕获的对象发送一次`retain`消息，同时在`block`被释放时，发送一次`release`消息。

这是在ARC和MRC环境下，`block`对`auto`变量的主要区别。为了避免内存管理问题，我们一般选择在ARC环境下使用`block`。

:::

### ❓`block` 中可以使用 `KVC` 来访问实例变量吗？可以使用 `KVC` 修改它的值吗

::: details 💡

在`block`中使用KVC(Key-Value Coding)访问和修改实例变量，必须注意以下两点：

1. 被访问的实例变量是否存在对应的访问器方法(getter 和 setter)。

2. 被访问的实例变量在类的接口中是否有定义，或者有无@property声明。

如果满足以上条件，你可以在`block`中使用KVC来访问和修改实例变量。例如：

    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        // 使用KVC访问实例变量
        NSInteger value = [[weakSelf valueForKey:@"someValue"] integerValue];
        
        // 使用KVC修改实例变量
        [weakSelf setValue:@(123) forKey:@"someValue"];
    };
    
注意：在ARC环境下，不要直接在`block`虽然用`self`，否则可能导致循环引用问题。一定要记住使用弱引用或者强引用来防止循环引用。

:::

------

## 分类

### ❓`Category` vs `Extension`

::: details 💡

  > `Category`(类别)：`Objective-C` 的一个特性，提供了一种给已存在类添加方法的机制.
    
  - `Category` : 只能添加方法，不能添加实例变量(除非通过关联对象)。分类中的方法是运行时添加到方法列表中的。
  - `Extension` : 可以添加方法和计算属性，也可以添加构造方法，也可以实现以一个协议。编译时已经确定，不支持动态添加方法。

:::

### ❓`NSObject` 添加 `Extension` 会怎么样

::: details 💡

向`NSObject`添加`Extension`(类别、Category)会使`Extension`中的方法对继承自`NSObject`的所有对象可见和可用。这会对你的项目产生全局性的影响。

`Extension`可以用来添加新的方法到现有的类中，但它没有自己的实例变量，所以不能存储新的状态。在使用`Extension`时，需要注意以下几点：

- 如果你覆盖已有的方法，所有继承自`NSObject`的对象都会受到影响，可能出现无法预知的结果。
- 如果添加的新方法与其他库或者框架定义的方法发生冲突，同样可能导致问题。

因此，虽然往`NSObject`添加`Extension`可以快速为所有对象添加功能，但需要谨慎使用，尽量避免覆盖现有的方法或者添加可能与其他方法发生冲突的方法。同时，由于该范围非常广，必要时最好选择子类化或协议等方式实现。

另外，如果只是想在项目内全局使用某些通用方法，可以考虑创建一个`NSObject`的子类，然后让需要使用这些方法的类继承自这个子类，这样就不会影响到不需要这些方法的类。

:::

### ❓如果分类中添加与类相同的方法签名会发生什么
  
::: details 💡
  
当一个OC的类别（Category）和主类都定义了相同签名的方法时，运行时系统会优先调用类别的方法，而忽略主类中的同名方法。这是因为在运行时的方法解析过程中，分类的方法会被先于主类方法加入到方法列表中。

在代码中，如果主类和分类都实现了同一个方法，那么分类的方法会覆盖掉主类中的方法，也就是说，在方法调用时，实际上执行的是分类中的方法。

```
@interface MyClass : NSObject
- (void)print;
@end

@implementation MyClass
- (void)print {
    NSLog(@"print in MyClass");
}
@end

@interface MyClass (MyCategory)
- (void)print;
@end

@implementation MyClass (MyCategory)
- (void)print {
    NSLog(@"print in MyCategory");
}
@end

// 调用时
MyClass *myClass = [[MyClass alloc] init];
[myClass print]; // 输出：print in MyCategory
```

这种特性在某些情况下非常有用，可以实现方法的替换和拦截等。但也需要格外注意，如果不小心覆盖了主类本身的重要方法，可能会造成程序的异常。

:::
 
### ❓分类是如何实现的，它为什么会覆盖掉原来的方法
 
::: details 💡

  底层实现：是一个 `objc_category` 结构体，它包含了类名(name)、类(cls)、类别中所有方法的列表(method_list)、类别的协议列表(protocol_list)、类别中所有的属性列表(property_list)。
    
  加载过程：在程序运行时的 `load` 阶段进行的，所有类和分类的 `+load` 方法（如果有）被调用。在调用 `+load` 方法之前，`runtime` 会先将分类的方法、协议、属性合并到类的数据结构中。这个过程中，分类的方法被放在了原来类方法列表的前面，所以在类和分类中有相同方法名的方法的时候，分类的方法会被优先调用，原类的方法被覆盖。

Objective-C 中的分类 (Category) 实质上是对一个存在的类添加额外的方法，而不改变它的声明和定义。分类是在运行时通过Objective-C的动态性质合并到类上的，这使得我们可以随意地向任何类添加方法。

分类实现的本质是这样的：在编译阶段，每一个分类会被编译成一个特殊的结构体（如 `_category_t`），其中包含了分类名，分类所在类的名字，以及分类中所有添加的方法的列表。在程序启动的时候，这个结构有一个初始化函数会被自动调用。在这个函数中，分类中的方法会被添加到类的方法列表中。因此你可以在分类中添加新的方法。

分类中的方法会覆盖掉原来的方法，主要是因为分类的方法被添加到方法列表的顺序优先级更高。在Objective-C查找方法实现的时候，是按照方法在列表中的顺序，从前往后查找的，当找到第一个匹配的方法时，就停止查找，并且调用这个方法。因此，如果分类中的方法与原类中的方法同名，分类中的方法就会被优先调用，从而覆盖掉原来的方法。

:::


### ❓分类中有与主类相同的方法，如果想要调用主类中的方法如何处理

::: details 💡

如果分类中的方法与主类的方法名称相同，由于运行时会优先调用分类的方法，所以我们通常无法直接调用到主类中的方法。不过有一种间接的办法可以实现。

你可以在分类方法内部通过 `NSInvocation` 或 `methodSignatureForSelector:` 和 `forwardInvocation:` 的方式调用主类的原方法。下面给出 `NSInvocation` 实现的例子：

```objectivec
#import "MyClass.h"

@implementation MyClass (MyCategory)
- (void)print {
    // 获取主类原方法
    SEL origSel = @selector(print);
    Method origMethod = class_getInstanceMethod([self class], origSel);
    
    // 构建 NSInvocation
    NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:origSel]];
    [inv setSelector:origSel];
    [inv setTarget:self];
    
    // 调用 NSInvocation
    [inv invoke];
    
    // 获取返回值
    NSString *returnValue;
    [inv getReturnValue:&returnValue];
    NSLog(@"%@", returnValue);
}
@end
```

需要注意的是，仅当主类方法和分类方法没有强制要求的执行顺序时才可以这样做，否则可能会破坏类的封装性并导致不明确的行为。如果你的代码常常需要这么做，那可能是设计有问题，应该考虑重构代码以避免这种情况。

:::

### ❓两个分类的 `load` 方法的加载顺序

::: details 💡

Objective-C 类和分类中的 `+load` 方法会在类或分类被加载到运行时时调用。对于同一个类的不同分类，各自的 `+load` 方法的调用顺序与编译顺序有关，最后编译的分类的 `+load` 方法会被先调用。

但是要注意，虽然编译顺序是影响 `+load` 方法调用顺序的因素之一，但不是唯一的决定因素。在一个复杂的项目中，编译顺序可能会受到 Xcode 编译设置、文件名字母序、Xcode 版本、甚至 Mac 系统版本的影响。因此，关于这个问题，Apple 官方文档建议不要依赖于 `+load` 方法的调用顺序。如果项目中多个 `+load` 方法之间有依赖关系，那么可能需要仔细设计代码，以避免因 `+load` 方法调用顺序引起的问题。

:::

### ❓两个分类的同名方法的加载顺序
 
::: details 💡

在Objective-C中，编译器按照.m文件编译顺序来加载分类，如果存在多个分类都实现了同一方法，那么顺序是"编译顺序的逆序"，也就是说最后编译的分类会首先被加载，同名方法就会被最后编译的那个分类所覆盖。

需要注意的是，依赖于这种顺序来设计代码是很不稳定的，因为当其他开发者操作或更改了文件的编译顺序，可能会导致相关代码的运行出问题。此外，互相覆盖的设计也会降低代码的可读性和维护性。所以最好避免在多个分类中都实现同一方法，以保证代码的稳定运行。

:::
 
### ❓一个类中有个多个分类都实现了相同的方法，会调用哪个方法

::: details 💡

当一个类有多个分类（Category），并且这些分类都实现了相同的方法时，会优先调用最后编译的分类中的方法。这是因为Objective-C在运行时加载分类的顺序是根据编译的顺序，最后编译的分类的方法会被放到方法列表的最前面，从而覆盖掉其他同名方法。

但是具体调用哪个方法并不是确定的，因为分类的编译顺序可能会因为项目配置的改变而改变，比如编译选项的修改、文件名的修改等。所以，实际开发中我们并不建议在不同的分类中实现相同的方法，这可能会引起不可预见的bug。如果需要在分类中添加方法，应确保新添加的方法与主类和其他分类的方法不冲突。

:::
 
### ❓分类中为什么不能添加 `@property`

::: details 💡

在Objective-C中，`@property`会告诉编译器我们在类中声明了一个属性。默认情况下，编译器会生成一个后备存储（实例变量），并且为属性生成getter和setter方法。然而，对于分类（Category），一旦对象一旦在运行时被注册，我们就不能再动态地添加实例变量。

从runtime角度来看， 这是由于类型的数据布局已经在编译阶段确定并且注册到了Objective-C的runtime系统中，而分类是在运行时被加载，所以无法更改基类的数据布局，也就无法添加实例变量。

具体来说，类结构体`struct objc_class`中的`ivar_list（实例变量列表）`是确定的：

```c
struct objc_class {
    Class isa;
    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
}
```

而分类结构体`struct category_t`中只有方法列表，协议列表和属性列表，并没有实例变量列表：

```c
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
};
```
所以在Objective-C分类中不能添加实例变量，也就不能添加带有自动生成的getter和setter的`@property`。但是你可以在分类中声明属性，并通过对已有的实例变量手动编写getter和setter，或者使用关联对象(Associated Objects)来模拟实例变量。

总的来说，之所以不能在分类中添加`@property`，是因为在编译器层面和runtime层面上，Objective-C的设计都不允许我们动态地向类中添加实例变量。

:::

### ❓分类的结构体里面有哪些成员
 
::: details 💡

在 Objective-C 的运行时系统中，每个 Category 都对应着一个结构体 category_t。这个结构体的定义（在 objc-runtime-new.h 中）如下：

```c
typedef struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
} category_t;
```

这个结构体中的字段包含以下内容：

- `name`：分类的名字。
- `cls`：分类所属的类。
- `instanceMethods`：分类中新增的实例方法列表。
- `classMethods`：分类中新增的类方法列表。
- `protocols`：分类实现的协议列表。
- `instanceProperties`：分类中新增的实例属性列表。

因此，你可以在分类中声明和实现新的实例方法和类方法，实现新的协议，以及添加新的实例属性。

需要注意的是，虽然可以在分类中声明和实现新的属性，但是你不能使用 `@synthesize` 来生成存取方法，也无法生成实例变量。你只能手动实现 getter 和 setter 来操作已存在的实例变量，或者使用关联对象（Associated Object）来模拟实例变量。

:::

### ❓分类中如何添加属性
 
::: details 💡
 
  可以使用关联对象（`Associated Objects`）让分类拥有“伪属性”。
 
 在Objective-C中，分类（Category）的定义中并不支持直接添加属性（instance variable）。但我们可以通过 Objective-C 的关联对象（Associative References）机制实现给分类添加属性。 

以下是一个例子，演示如何给一个分类添加一个属性：

  ```objc
  #import "NSObject+Property.h"
  #import <objc/runtime.h>

  static const void *MyKey = &MyKey;

  @implementation NSObject (Property)
  // getter
  - (NSString *)myProperty {
    // `objc_getAssociatedObject` 用于取关联对象。
    //  - 首个参数是要存取的对象
    //  - 第二个参数是键，我们用一个静态常量 `MyKey` 作为键（每个关联到对象的键必须全局唯一）
    return objc_getAssociatedObject(self, MyKey);
  }
  // setter
  - (void)setMyProperty:(NSString *)myProperty {
    // `objc_setAssociatedObject` 第三个参数是存储的值，第四个参数是关联策略
    // `OBJC_ASSOCIATION_COPY_NONATOMIC`，表示这是一个 copy ，非原子操作的特性
    objc_setAssociatedObject(self, MyKey, myProperty, OBJC_ASSOCIATION_COPY_NONATOMIC);
  }
  @end
  ```

在这个示例中，我们定义了一个 `NSObject` 的分类并为它添加了一个 `myProperty` 属性。

。对于 ，例如在这里我们将它设为了 。

  通过关联对象可以间接实现在分类中"添加"属性，这也是 `Objective-C` 动态的特性之一。
 
:::

------

## 消息发送

### ❓`OC` 中的内省和反射，底层实现原理，应用场景有哪些

::: details 💡

Objective-C中的内省和反射是基于其动态的特性实现的，底层依赖于runtime系统。

内省是面向对象编程中的一种能力，允许程序检查对象的类型或属性。在Objective-C中，可以通过runtime系统提供的各种API（如`isKindOfClass:`,`respondsToSelector:`,等方法）来实现内省。

反射是指程序能够观察和修改自身结构和行为的一种能力。在Objective-C中，反射主要依赖于runtime系统提供的API，如`NSClassFromString`,`NSStringFromClass`,`NSSelectorFromString`, `NSStringFromSelector`等函数。

底层实现原理： 
Objective-C对象中都有一个isa指针指向对象所属的类，这个类中存储了类的方法列表、属性列表，并且如果类继承自其他类，那么这个类还会通过superclass指针找到其父类，这样层层递推，形成了一条类链，利用这条链条就可以检查和操作对象的行为和结构。

应用场景： 
内省和反射在很多场景下都非常有用，例如： 
1. 数据和模型的自动映射，例如JSON数据转Model对象，通常需要写大量的映射代码。利用内省我们可以在运行时获取对象的属性信息，从而实现自动映射。 
2. 在运行时动态地添加类，方法，属性。例如我们可以在运行时给一个类添加属性或方法，或者修改方法的实现等。 
3. 在面向切面编程（AOP）中，经常需要运行时修改对象的行为。
4. 在执行单元测试时，可以利用反射机制来动态地调用需要测试的方法。

:::

### ❓`OC` 如何实现多重继承

::: details 💡

Objective-C 并不直接支持多重继承（即一个子类可以拥有多个父类的属性和方法）。但 Objective-C 提供了几种方法可以实现类似多重继承的效果：

1. **协议（Protocol）**：OC 中的协议类似于其他语言中的接口，可以定义一组方法和属性，然后由类去实现。一个类可以同时实现多个协议，这就实现了类似多重继承的效果，只是实现协议的类需要自己实现协议中定义的所有方法。

2. **组合**：组合是指在一个类中包含其他类的实例作为成员变量，借此可以使用其他类的功能，间接实现多重继承的效果。例如，类A包含类B和类C的实例，那么类A就可以使用类B和类C的功能。

3. **分类（Category）**：分类是一种使得现有类增加方法的方式，是在运行时决议的。可以通过创建分类，将其他类的方法引入，实现类似多继承的效果。但是分类不能添加新的实例变量。

4. **消息转发（Message Forwarding）**：这是 Objective-C 的动态特性，允许将一个方法调用转发给其他对象进行处理。如果某个类无法响应某个消息，Objective-C 允许我们在运行时将这个消息转发给另一个能处理这个消息的对象。

注意，以上方式只能部分模拟多重继承，并不能完全替代多重继承，在使用时应根据具体需求和情况选择最合适的方式。

:::

### ❓`OC` 是否支持方法重载

::: details 💡

  `OC` 不支持方法重载。方法重载指的是在同一个类里面，方法名字相同，但参数不同的多个方法。

  `OC` 是一种动态类型语言，其方法的调用不是在编译期决定的，而是在运行时决定的。`OC` 使用消息派发机制，方法调用更依赖于方法的唯一性，如果有多个方法名字完全相同（即使参数类型不同），编译器和运行时系统就无法准确找到你要调用的方法。

:::

### ❓静态方法是否能被重写

::: details 💡

在 Objective-C 中，通常所说的 "静态方法" 实际上是指"类方法"，用 "+" 符号来声明。这种方法是可以被子类重写的。也就是说，如果在子类中重写了一个已经在父类中定义的类方法，那么当你用子类来调用这个类方法的时候，实际上执行的是子类中的版本，这就是方法重写。所以，Objective-C 的"静态方法"是可以被子类重写的。

然而这和其他一些语言如 Java 或 C++ 中的静态方法是不一样的。在 Java 或 C++ 中，声明为 "static" 的方法是不能被子类重写的。

:::

### ❓怎么保证自己的类一定能调用到自己写的方法

::: details 💡

在 Objective-C 中，分类（Category）是一种可以为已存在的类添加新方法的方式。同时，分类中的方法会替换掉原来类中同名的方法。此特性在一些情况下可能引起不确定的行为，比如可能无意间覆盖掉你写的方法。

若要阻止自己写的方法被分类覆盖，可以考虑以下方法：

1. **方法命名规范：** 尽可能为方法命名时，添加前缀。这样可以避免和系统默认的方法或他人写的分类中的方法冲突。

2. **使用子类化代替分类：** 如果你控制的类可能被其他开发者使用，那么建议使用子类代替分类。这样，即使有人创建了同名的分类，也不会对原类产生影响。

3. **在源代码级别进行检查：** 在项目编译的时候，通过检查操作来警告和暴露任何重定义的方法。

但是，以上的方式并不能100%的避免在运行时被覆盖的情况，因为 Objective-C 是一种动态类型的语言，它允许在运行时添加或替换方法。这种动态性是 Objective-C 的一大特性，但同时也可能带来风险。所以编程时应该遵循良好的开发习惯，避免不必要的麻烦。

:::

### ❓`OC` 中的类方法和实例方法有什么本质区别和联系

::: details 💡

在 Objective-C 的 runtime 层面，类方法和实例方法有一些本质的区别：

**存储的位置：**

实例方法列表存储在类对象（Class）中，而类方法列表存储在元类对象（Meta-Class）中。

**调用者：**

实例方法由实例对象调用，即 `[instanceObject exampleMethod];`，其中`exampleMethod`是实例对象的方法；类方法由类对象调用，即 `[ClassObject exampleMethod];`，其中`exampleMethod`是类方法。

**方法查找过程：**

调用实例方法时，runtime 系统会在类的方法列表中查找这个方法；调用类方法时，runtime 系统会在元类的方法列表中查找这个方法。

**self 指针：**

在实例方法和类方法中，self 指针的含义是不同的。在实例方法中，self 指向调用这个方法的实例对象；而在类方法中，self 指向调用这个方法的类对象。

**能访问的变量：**

实例方法可以访问实例变量和静态变量，而类方法只能访问静态变量。

在类方法和实例方法之间也存在一些联系。例如，它们都可以调用彼此。实例方法可以通过实例化对象来调用类方法，类方法也可以通过创建类的实例来调用实例方法。它们都是满足 Objective-C 面向对象特性的一部分，各自处理与对象或类相关的行为。

:::

### ❓在类方法中是否可以使用 `self`

::: details 💡

在Objective-C中，你可以在类方法中使用`self`。但在类方法中，`self`表示的是类对象本身，而不是类的实例。这意味着你不能用`self`来访问实例变量，只能用它来调用其他类方法。例如：

```objc
+ (void)aClassMethod {
    // 这里的self是类对象本身
    [self anotherClassMethod];
}
```

在这个例子中，`anotherClassMethod`会被正确地调用，因为`self`在这里代表类对象。

但是，你不能在类方法中使用`self`来访问实例变量或调用实例方法，因为在类方法中没有实例来调用它们。尝试这样做会在编译时出错。

总的来说，`self`在类方法中指的是类对象本身，用来调用其他类方法；在实例方法中指的是调用该方法的实例对象，用来访问实例变量或调用实例方法。

:::

### ❓`SEL`、`_cmd` 是什么

::: details 💡

在 Objective-C 中，`SEL` 是 `selector` 在 Obj-C 中的类型，`_cmd` 是当前方法的 `SEL` 。`SEL` 是方法选择器，可以看做是一个查找表，用于在运行时查找方法的实现。

具体来说：

1. SEL： 是一个表示方法的类型，实际上是一个字符串，不同的方法对应不同的 `SEL` 。例如 `SEL methodSEL = @selector(methodName);`

2. _cmd：是一个隐藏的参数，表示当前调用的方法的 `SEL`。每个方法的实现的第二个参数_cmd，它是一个 `SEL` 类型的，即当前方法的选择器。

```objc
- (void)someMethod {
    NSLog(@"%@", NSStringFromSelector(_cmd)); // 输出 "someMethod"
}
```
在这个例子中，_cmd 被用来输出当前方法的名称。通常情况下，你可能不需要直接使用 _cmd，但它在调试，特别是在动态方法解析（dynamic method resolution）时非常有用。

:::

### ❓`OC` 中对象消息发送的大致流程

::: details 💡

Objective-C 对象消息发送主要包含以下步骤：

1. **消息发送者：** 当调用一个 Objective-C 对象的方法时，实际上是向这个对象发送了一条消息。例如，`[object methodWithParameter:parameter];`，这里的“object”是消息的接受者，“methodWithParameter:”是消息的选择器（SEL，Selector）。

2. **动态绑定：** Objective-C 采用动态绑定，不是在编译的时候决定函数地址，而是在运行时根据接收者和选择器找到对应的函数实现。

3. **寻找接受者：** 明确了消息的接收者后，OC 会在对应的类以及其父类中查找这个方法的实现。如果在消息接收者的类中找不到响应的方法，则继续往它的父类中寻找。

4. **消息转发：** 如果到了根类（一般是 NSObject ）都没有找到方法实现，那么就会进入对象的 `doesNotRecognizeSelector:` 方法，进入此方法就算出错了，未对此方法做处理的话程序会 crash。不过，NSObject 为我们提供了最后挽救的机会，走进消息转发机制，你可以指定一个新的接受者来响应这条消息。如果消息转发也没有处理，就真的会 crash 了。

以上就是 Objective-C 中对象消息发送的主要流程。这些步骤大大增加了 Objective-C 的灵活性，让代码具有更好的扩展性和维护性。即使一个对象没有实现某个方法，也不会在编译阶段报错，而会在运行时进入消息转发阶段，给我们处理未实现方法的机会。

:::

### ❓向一个 `nil` 对象发送消息将会发生什么

::: details 💡

在 Objective-C 中，向 `nil` 对象发送消息是安全的，不会导致程序崩溃。这一特性是 Objective-C 语言中的一项重要特性，使其在处理对象的空态时更加灵活。

对一个 `nil` 对象发送消息，下面是可能会发生的情况：

1. **方法返回非对象类型：** 如果该消息是一个返回非对象类型的方法（例如 int，float，struct 等），会返回零值（0，0.0，相应类型的零值等）。

2. **方法返回对象类型：** 如果该消息是一个返回对象的方法，那么将会返回 `nil`。

3. **方法不返回值（例如 void 类型）：** 如果该消息是一个不返回值的方法，那么什么都不会发生。

这种特性使得你可以在不检查一个对象是否为 `nil` 的情况下向它发送消息，这通常能使你的代码更加简洁。反过来，如果你在像其他语言（例如 Java 或 C#）那样，在向对象发送消息之前总是先检查它是否为 `nil`，那么你可能会编写出很多不必要的代码。然而，注意这并不意味着你可以忽略 `nil` 检查，在某些情况下，`nil` 检查仍然是必要的。

需要注意的是，向一个 `nil` 对象发送消息会返回 `nil` 或零值，但是在某些情况下，这可能会隐藏程序中的错误，如果密切注意这一点，这一特性可以使你的代码更加简洁和强大。

:::

### ❓向一个对象发送消息 `[obj foo]` 和 `objc_msgSend()` 函数之间有什么关系

::: details 💡

在 Objective-C 语言中，`[obj foo]` 这种语义实际上是在运行时通过调用 `objc_msgSend(obj, @selector(foo))` 来实现的。

在 Objective-C 中，方法(methods)的调用被称为向一个对象发送消息。当你使用方括号语法向对象发送消息时，如 `[obj foo]`，实际上 Objective-C 的运行时系统会将其转化为 `objc_msgSend()` 函数的调用。

`objc_msgSend()` 是 Objective-C runtime 库中的函数，它接受两个以上的参数。第一个参数(receiver)是你要发送消息的对象，第二个参数(selector)是你要发送的消息(method)。例如，`objc_msgSend(obj, @selector(foo))` 就是向 obj 对象发送名为 foo 的消息。

这表明了 Objective-C 中的方法调用实际上是基于运行时的消息传递机制。Objective-C 将类和实例的方法调用抽象化为对特定对象发送特定消息，通过动态的消息分派机制找到并执行对应的方法实现。这种特性也是 Objective-C 存在动态特性的基础。

:::

### ❓一个对象向一个不存在的方法发送消息，消息是如何转发的

::: details 💡

当 Objective-C 的一个对象接收到一个不存在的方法时，程序将通过以下步骤进行消息转发：

1. 动态方法解析（Dynamic Method Resolution）
   运行时系统会调用 `+resolveInstanceMethod:`（对于类方法是 `+resolveClassMethod:`）。在这个阶段，我们可以为这个类动态添加一个方法。如果此方法返回 `YES`，那么运行时系统会重新发送消息。

2. 备援接收者（Backup Receiver）
   如果第一步未处理消息（即 `+resolveInstanceMethod:` 返回 `NO`），系统会调用 `-forwardingTargetForSelector:` 方法，允许我们返回一个替代的对象。这个方法返回了一个实例后，系统会把这条消息发送给这个实例。

3. 完整消息转发（Complete Message Forwarding）
   如果 `-forwardingTargetForSelector:` 返回了 `nil`，运行时就会进入完整的消息转发阶段。首先会发送 `-methodSignatureForSelector:` 消息来获取方法的返回和参数类型。然后会发送 `-forwardInvocation:` 消息。我们可以在 `-forwardInvocation:` 中自行处理消息，或者转发给其他对象处理。

4. 消息转发失败
   如果 在 `-forwardInvocation:` 中未处理消息，那么运行时会调用 `-doesNotRecognizeSelector:` 方法， 默认会抛出异常。

需要注意的是，消息转发虽然强大，但由于需要经过多次查找，性能开销较大。当频繁调用时应用程序的运行效率会受到很大影响。因此，我们通常仅在需要动态处理未知消息时才会使用消息转发。

:::

### ❓`unrecognized selector` 异常是如何发生，应该如何避免

::: details 💡

`unrecognized selector` 异常是 Objective-C 中的一个常见运行时错误，当向一个对象发送它不能响应的消息时，就会抛出这个异常。

在 Objective-C 中，当你调用一个对象的方法时，实际上是在向这个对象发送一条消息。运行时系统会在对象的类及其所有的父类中寻找与这个消息对应的方法。如果找到这个方法，就会调用它。如果在最底层的父类（通常是 NSObject）中也找不到这个方法，那么就会抛出`unrecognized selector`异常。

避免 `unrecognized selector` 异常的方法有以下几种：

1. **检查对象是否能响应此消息：** 在向对象发送消息之前，使用 `respondsToSelector:` 方法检查这个对象是否能响应这个消息。

```objc
if ([obj respondsToSelector:@selector(foo)]) {
    [obj foo];
}
```

2. **使用异常处理：** Objective-C 提供了异常处理语句 @try、@catch、@finally。你可以将可能抛出异常的代码放在 @try 块中，将处理异常的代码放在 @catch 块中。

3. **消息转发：** 如果一个对象无法识别引发异常的方法，那么在引发异常之前，会先调用这个对象的 `- (void)forwardInvocation:(NSInvocation *)anInvocation;` 方法，我们可以在这个方法里面向其他能响应此消息的对象发送该消息。这就相当于将此消息转发给其他对象。

以上就是避免 `unrecognized selector` 异常的一些方法，希望对你有所帮助。

:::

### ❓`_objc_msgForward` 函数是做什么的，直接调用它将会发生什么

::: details 💡

`_objc_msgForward` 是 Objective-C 运行时系统中用于对消息进行转发（Message Forwarding）的函数。

在 Objective-C 中，当你向一个对象发送一条消息，运行时系统会在该对象的类以及其父类链中查找是否有可以响应这条消息的方法。如果没有找到的话，运行时系统会调用 `_objc_msgForward` 函数进行消息转发。 

消息转发是 Objective-C 动态特性的一部分，它允许你在运行时动态地处理不能被对象直接响应的消息。也就是说，你可以将消息转发给其他可以处理此消息的对象，或者生成可以处理此消息的方法。

也就是说，你一般不会直接调用 `_objc_msgForward` 函数。因为这个函数是由运行时系统在需要进行消息转发时自动调用的。

如果你硬要直接调用 `_objc_msgForward`，那么一般而言，这将会引起 `unrecognized selector` 异常，因为这个函数的作用就是处理不能识别的选择器（即方法）。如果你手动调用它，系统会在尝试进行消息转发时找不到能响应此消息的对象或方法，从而引发异常。基本上，直接调用 `_objc_msgForward` 而没有适当的转发目标和处理机制，是没有意义的。

:::

### ❓`OC` 中是如何通过 `selector` 找到对应的 `IMP` 地址

::: details 💡

在 Objective-C 中，通过 selector 找到对应的 IMP（Implementation）地址的过程是这样的：

1. **查找类方法列表：** 当你向一个对象发送一条消息，运行时系统首先会在该对象的类的方法列表中查找与这个 selector 相对应的方法。如果找到，那么就直接调用这个方法的实现。在这个步骤中，selector 会被映射到其对应方法的 IMP。

2. **从父类中查找：** 如果在对象的类的方法列表中没有找到对应的方法，那么运行时系统会在该类的父类中查找，如果在父类中找到，同样直接调用对应的 IMP。这个过程会一直沿着类的继承链查找，直到 NSObject。

3. **调用动态方法解析：** 如果在整个继承链上都没有找到对应的方法，那么运行时系统会给你一个“补救”的机会，即会调用该类的 `+resolveInstanceMethod:` 或 `+resolveClassMethod:` 方法（取决于是实例方法还是类方法）。你可以在此方法中为对应的 selector 动态添加实现。

4. **消息转发：** 如果 `+resolveInstanceMethod:` 或 `+resolveClassMethod:` 返回NO或者没有被重写，那么运行时就会启动完整消息转发，此时会调用 `- (void)forwardInvocation:(NSInvocation *)anInvocation;` 方法。你还可以在这个方法内将消息转发给能响应此消息的其他对象。

5. **抛出异常：** 如果以上步骤都没有找到并执行相应的方法，那么运行时系统就会抛出 `unrecognized selector` 异常。

以上就是 Objective-C 通过 selector 找到对应的 IMP 地址的过程。你可能已经注意到了，这个过程包含了运行时系统的很多动态特性，使得我们能在运行时动态地处理对象的行为。

:::

### ❓`C++` 调用虚方法与 `OC` 发消息有什么区别

::: details 💡

C++ 虚方法和 Objective-C 发消息是两种不同编程语言的两种不同的机制，它们在工作原理和应用场景上都有一些不同。

**C++ 虚方法：** 是 C++ 支持多态性的一种方式。在 C++ 中，如果一个父类指针指向派生类对象，并通过该指针调用虚函数，那么调用的将是派生类中的虚函数实现。这是通过 C++ 的虚函数表（vtable）来实现的，虚函数表是在编译期确定的。

**Objective-C 发消息：** 是 Objective-C 进行方法调用的方式。它会在运行时动态地确定应该调用对象的哪个方法。当给 Objective-C 对象发送消息时，运行时系统会搜索接收者的类以及所有父类的方法列表，找到第一个可以响应该消息的方法并调用。

这两种机制的主要区别在于：

1. **动态性：** Objective-C 的消息发送更具有动态性，因为它在运行时确定方法调用，而 C++ 的虚函数在编译时已经确定。

2. **灵活性：** Objective-C 的消息发送机制允许我们在运行时为对象动态添加方法，这使得 Objective-C 具有更高的灵活性。

3. **性能：** 由于C++的虚函数调用是在编译期就已经确定，因此它的性能上优于 Objective-C 的动态消息发送。

4. **安全性：** C++的类型检查更为严格，因此调用虚方法要比 Objective-C 发送消息更安全，后者如果发送了对象无法响应的消息就会在运行时崩溃。

由于这两种机制的区别，所以在实际开发中，我们需要根据不同的场景和需求选择使用 C++ 的虚函数还是 Objective-C 的消息发送。

:::

### ❓消息转发机制和其他语言的消息机制优劣对比

::: details 💡

Objective-C 的消息转发机制是一种非常强大的动态特性，在一些其他的面向对象编程语言中，并没有类似的功能。下面我们从几个方面来分析 Objective-C 消息转发机制和其他语言的消息机制的优劣。

**1. 动态性：** Objective-C 的消息转发机制可以让我们在运行时动态地处理未知的消息。而其他一些语言，如 C++, Java, C# 等，在编译期间就已经确定了方法的调用，并不能在运行时动态地处理未知的消息。

**2. 灵活性：** Objective-C 的消息转发可以不仅仅是转发给其他对象，甚至可以动态地为类生成新的方法。这在很多其他语言中是无法做到的。

**3. 性能：** Objective-C 的消息转发机制相对于其他语言的消息机制，如 C++ 的虚函数，性能上会稍差一些。因为 Objective-C 是在运行时通过查找类的方法列表来确定方法调用，而不是在编译时就确定。

**4. 安全性：** Objective-C 的消息转发机制如果使用不当，可能会产生一些难以发现的错误。例如，如果错误地转发了消息，可能会导致运行时崩溃。而其他一些语言，如 Java, C#, 是在编译期就检查了方法的调用，相对来说更加安全。

所以，Objective-C 的消息转发机制和其他语言的消息机制各有优劣，需要根据具体的需求和场景来选择使用哪种机制。

:::

### ❓在方法调用的时候，`方法查询-> 动态解析-> 消息转发` 之前做了什么

::: details 💡

在 Objective-C 运行时系统中，仅当通过发送消息调用方法失败的时候，才会启动方法查找（method lookup）、动态解析（dynamic resolution）和消息转发（message forwarding）这些步骤。在这之前，已经经过了一系列过程：

1. **消息发送：** 当代码中发送了一条消息给某个 Objective-C 对象时，实际上是调用了 Objective-C 运行时库中的 `objc_msgSend` 函数。方法的调用者（即消息的接收者）和方法选择器（selector）都作为 `objc_msgSend` 的参数。

2. **查找对象的类：** `objc_msgSend` 需要知道对象的类信息，以便在类的方法列表里查找可以响应该消息的方法。对象内部有一个指针指向它的类，`objc_msgSend` 可以通过这个指针获取对象的类。

3. **缓存查找：** Objective-C 运行时系统为了优化性能，已经将一部分方法的调用结果缓存起来，所以 `objc_msgSend` 会先从缓存中查找 selector 对应的方法实现。如果缓存中有，则直接调用该方法结束查找流程；如果没有，进入下一步。

4. **方法列表查找：** `objc_msgSend` 会在对象的类的方法列表中搜索 selector 对应的方法。如果找到，则调用该方法，将方法结果添加到缓存中，并结束查找流程。

以上就是在“方法查询 -> 动态解析 -> 消息转发”之前所做的事情。如果经过上述步骤仍然找不到可以响应消息的方法，运行时系统就会启动方法查询、动态解析等步骤，尝试在运行时解决这个问题。

:::

### ❓下面代码能正常运行吗(如果能，输出是什么)

```objc
@interface Person : NSObject 
@property(nonatomic,copy) NSString *name; 
@end
@implementation Person
- (void)speak {
    NSLog(@"My name is:%@",self.name); 
}
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    id cls = [Person class];
    void *obj = &cls;
    [(__bridge id)obj speak];
}
@end
```

::: details 💡

这段代码可以正常运行，其输出将是 `My name is:(null)`。

在这段代码中 `id cls = [Person class];`这行代码是获取 Person 类。然后 `void *obj = &cls;` 这行代码是获取了指向 cls 的指针，所以 obj 指向的是一个 Person 类的对象，而不是 Person 类的实例。然后 `[(__bridge id)obj speak];` 这行代码就是发送一个消息给 obj，所以最终调用的是 Person 类的 speak 方法。

但是这里你需要注意的是，我们并没有给 name 属性赋值，所以当我们打印 name 属性的时候，它的值是 nil，也就是 `(null)`。

:::

---
title: 代码题
icon: hashtag

index: true

---

<!-- more -->

------

## Objective-C

### ❓下面代码输出结果

```objc
@property (atomic) NSInteger i;
// 线程中
for (int i = 0; i < 10000; i++) {
    self.i++;
}
```

::: details 💡

在这种情况下，属性 `i` 并不能保证以线程安全的方式递增。虽然 `atomic` 属性确实提供了一定的线程安全性，但是它的操作并不是完全原子性的（atomic）。具体来说， `atomic` 只能保证属性的 `getter` 和 `setter` 方法在被调用时不会被其他线程打断，并不能保证像 `self.i++` 这样的复合操作是线程安全的。

`self.i++` 实际上包含了三个操作：获取 `i` 的值，将获取到的值加一，然后将新值赋值给 `i`。这三个操作是分开进行的，并不是原子操作，所以多个线程可能同时在获取和设置 `i` 的值，这会导致数据的混乱。

所以这段代码的结果是不可预测的，它将取决于线程调度和运行时的具体情况。如果你希望在多线程环境中更新共享变量，那么你需要使用锁或者其他同步机制来确保线程安全。

:::


### ❓下面代码输出结果

```objc
@interface NSObject (Test)
+ (void)test;
- (void)test;
@end

@implementation NSObject (Test)
- (void)test {
    NSLog(@"Test");
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [NSObject test];
        [[NSObject new] test];
    }
    return 0;
}
```

::: details 💡

> 在 `Objective-C` 对象模型中，所有类的元类(`meta-class`)形成了一个单向链表，链表的末端是根类（如`NSObject`）的元类，`NSObject` 的元类的方法列表中包含了其所有子类的类方法。因此，当一个子类的类方法在其自身的元类中找不到实现时，会在这条单向链表中继续寻找，最终会找到根元类 `NSObject` 的方法列表，所以 `[NSObject test]`会调用到定义在分类中的实例方法。

输出为：

```
Test
Test
```

:::

### ❓下面代码输出结果

```objc
@interface DogTest : NSObject
 + (void)test;
 - (void)test;
 @end

 @implementation DogTest
 - (void)test {
    NSLog(@"TEST");
 }
 @end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [[DogTest new] test];
        [DogTest test];
    }
    return 0;
}
```

::: details 💡

输出一个 “TEST” 之后崩溃。

  一个类方法在它们自己的类中没有找到，`Objective-C` 运行时将尝试在它的超类中查找。但是自定义的类 `DogTest`（子类）并不包含元类方法 `+test`，并且它的超类 `NSObject` 也没有这个方法，因此 `[DogTest test];` 将引发 `unrecognized selector sent to class` 异常，导致程序崩溃。

:::

### ❓下面代码输出结果

```objc
@interface Animal
@end
@interface Dog : Animal
@end
@implementation Dog
    - (instancetype)init {
        self = [super init];
        if (self) {
            NSLog(@"%@", NSStringFromClass([self class]));
            NSLog(@"%@", NSStringFromClass([super class]));
        }
        return self;
    }
@end
```
  
::: details 💡
  
  输出： 
  
        Dog 
        Dog
  
  `super` 并不会改变消息的接收者，所以当调用 `[super class]` 时，虽然是从父类开始查找 `class` 方法，但是方法的接收者依然是 `self` 本身，其类别自然是当前类本身。这也是为什么调用 `[super class]` 时还会返回 `Dog` 类的原因。

:::

### ❓下面代码能正常运行吗(如果能，输出是什么)

```objc
@interface Person : NSObject 
@property(nonatomic,copy) NSString *name; 
@end
@implementation Person
- (void)speak {
    NSLog(@"My name is:%@",self.name); 
}
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    id cls = [Person class];
    void *obj = &cls;
    [(__bridge id)obj speak];
}
@end
```

::: details 💡

这段代码可以正常运行，其输出将是 `My name is:(null)`。

在这段代码中 `id cls = [Person class];`这行代码是获取 `Person` 类。然后 `void *obj = &cls;` 这行代码是获取了指向 `cls` 的指针，所以 `obj` 指向的是一个 `Person` 类的对象，而不是 `Person` 类的实例。然后 `[(__bridge id)obj speak];` 这行代码就是发送一个消息给 `obj`，所以最终调用的是 `Person` 类的 `speak` 方法。

注意：并没有给 `name` 属性赋值，所以当打印 `name` 属性的时候，它的值是 `nil`，也就是 `(null)`。

:::


------

## Swift

#### ❓下面代码输出是什么？

```swift
@propertyWrapper
struct Wrapper<T> {
	var wrappedValue: T

	var projectedValue: Wrapper<T> { return self }

	func foo() { print("Foo") }
}
struct HasWrapper {
	@Wrapper var x = 0
    
	func foo() {
	    print(x) // `wrappedValue`
	    print(_x) // wrapper type itself
	    print($x) // `projectedValue`
	}
}
```

::: details 💡

  - `x` 是通过 `@Wrapper` 修饰符被包装的属性。 当直接访问 `x` 时，将获取 `wrappedValue` 的实际值。
  - `_x` 则访问到 `Wrapper` 的实例本身。
  - `$x` 用于访问 `projectedValue`，返回的是 `Wrapper` 的实例(由于 `Wrapper` 结构体没有定义 `CustomStringConvertible` 协议，因此它会使用默认的描述符，也就是其内部存储的字符串描述。)。

```swift
print(x)    // 0
print(_x)   // Wrapper(wrappedValue: 0)
print($x)   // Wrapper(wrappedValue: 0)
```

:::

------

## UIKit

### ❓寻找最近的公共 `View`

::: details 💡

```swift
// 寻找两个子视图最近的公共父视图
func findNearestCommonAncestor(view1: UIView, view2: UIView) -> UIView? {
    var currentView: UIView? = view1
    while let view = currentView { // 递归视图的父视图
        // 判断 view2 是否为当前遍历父视图的后代视图，如果是就是公共父视图
        if view2.isDescendant(of: view) { 
            return view
        }
        currentView = view.superview
    }
    return nil
}
```

:::

### ❓打印一个 `View` 的所有子 `View`，要求分层打印

::: details 💡

> 树的层序遍历问题

```swift
// 队列(Queue)来实现树的层次遍历
func printSubviewsInLevelOrder(for view: UIView) {
    var queue = [UIView]()
    queue.append(view)
    while !queue.isEmpty {
        var count = queue.count // 当前层数量
        var levelViews = [UIView]() // 当前层视图
        while (count > 0) {
            let levelView = queue.removeFirst()
            levelViews.append(levelView)
            count -= 1
            // 将当前层视图子视图继续加入队列
            for subview in levelView.subviews {
                queue.append(subview)
            }
        }
        print(levelViews) // 打印当前层视图   
    }
}
```

:::

------

## 多线程

### ❓下面代码输出结果

```objc
NSLog(@"1");
dispatch_sync(dispatch_get_main_queue(), ^{
    NSLog(@"2");
});
NSLog(@"3");
```

::: details 💡

  - 如果这段代码在**主线程**中执行，那么会导致死锁。
    > 因为 `dispatch_sync` 函数是一个同步执行的函数，它会阻塞当前线程，并等待 `dispatch_sync` 内部的任务执行完成后再继续执行。然而此处的 `dispatch_sync` 内部任务被派发到了主队列，所以这个任务需要在主线程上执行。但是主线程此时被上述的 `dispatch_sync` 阻塞了，所以 `dispatch_sync` 内部的任务无法执行。这就造成了死锁，上述代码会在输出 "1" 后停止。

  - 如果这段代码在一个**非主线程**执行，那么它会先阻塞该线程，再在主线程上同步执行任务，输出 "2"，然后取消阻塞，接着输出 "3"，所以结果是 "1"，"2"，"3"。

:::

> ❓改为 `global queue` 呢

```objc
NSLog(@"1");
dispatch_sync(dispatch_get_global_queue(), ^{
    NSLog(@"2");
});
NSLog(@"3");
```

::: details 💡

这段代码无论在主线程还是在子线程中执行，最终的输出结果都是 "1", "2", "3"。

  首先输出 "1"，然后 `dispatch_sync` 会将 `block` 中的任务同步地添加到全局队列，并阻塞当前线程直到 `block` 中的任务执行完毕。由于这里使用的是全局队列，这个队列是并发队列，且和当前线程（无论主线程或子线程）不是同一个队列，所以不会造成死锁。`block` 中的任务执行后，输出 "2"，然后 `dispatch_sync` 返回，当前线程继续执行，输出 "3"。所以最终的输出结果就是 "1", "2", "3"。

:::

### ❓下面代码输出结果

```objc
dispatch_queue_t queue = dispatch_get_main_queue();
BOOL isEqual = [queue isKindOfClass:[NSObject class]];
NSLog(@"isEqual=%d", isEqual);
```

::: details 💡

输出结果是 `isEqual=1`。

  虽然 `Objective-C `的 `GCD` 队列是基于 `C` 语言的 `dispatch_queue_t` 类型实现的，但它仍然是 `NSObject` 的子类。尽管 `GCD` 的 `API` 都是用纯 `C` 来实现的，但实际上 `GCD` 对象在 `Objective-C` 的运行时环境中是被当作 `Objective-C` 对象来处理的。所以这里的 `queue` 是可以被当作 `NSObject` 的实例来处理的，所以 `[queue isKindOfClass:[NSObject class]]` 的结果是 `YES`，即 `isEqual=1`。

  然而，不能直接对 `dispatch_queue_t` 类型的对象发送 `Objective-C` 消息，例如 `respondsToSelector:`、`performSelector:` 等，这样做可能会引发异常或者崩溃。因为 `dispatch_queue_t` 以及其他的 `GCD` 对象类型并没有实现这些方法。

:::

### ❓下面代码输出结果

```swift
func test() {
    DispatchQueue.main.sync {
        print("1")
    }
}
test()
```

::: details 💡

这段代码会造成主线程的死锁。

函数`test()` 是在主线程中被调用的，然后在 `test()` 函数中，又使用了`DispatchQueue.main.sync`尝试再次在主线程中执行一段任务。

由于 `sync` 是同步执行，也就是说 `sync`后面的任务会立刻执行，执行完后才会继续执行后面的代码。但是 `sync` 后面的代码块又是在主线程中执行的，这个时候主线程已经被前面的 `test()` 函数占用，所以`sync`后面的代码块就会等待主线程空闲，但是主线程在等待 `sync` 后的代码块执行完毕，导致互相等待，产生死锁。+

:::

### ❓下面代码输出结果

```swift
func test() {
    print("1")
    let queue = DispatchQueue.init(label: "thread")
    queue.async {
        print("2")
        DispatchQueue.main.sync {
            print("3")
            queue.sync {
                print("4")
            }
        }
        print("5")
    }
    print("6")
    queue.async {
        print("7")
    }
    print("8")
}
test()
```

::: details 💡

根据这段代码的执行流程，代码中打印的消息的顺序应该是：

```
1
6
8
2
3
5
7
```

下面是这段代码的一些解释：

- 这段代码首先在主线程中调用 `print("1")`，接着创建一个自定义的并发队列 `queue`。
- 然后在 `queue` 中异步执行一个 block，但执行这个 block 并不会阻塞当前线程（即主线程）。所以，`print("1")`，`print("6")` 和 `print("8")` 几乎是立即执行的，只是因为 CPU 的调度问题，可能存在轻微的延迟。
- 之后，回到 `queue` 中异步执行的那个 block。在这个 block 的执行过程中，会首先执行 `print("2")`。接着，在主线程中同步执行一个 block。这个 block 的执行会阻塞 `queue`，直到这个 block 执行完毕。 在这个 block 中，又在 `queue` 中执行了一个 block，但是由于这是同步执行的，所以要等待这个 block 执行完毕后才能继续执行主线程的 block。但是，这个 block 并不会被执行，因为他是在 `queue` 中同步执行的，`queue` 在这个时候还在等待主线程中的 block 执行完毕。这就产生了死锁。
- 最后，`queue` 中的另一个 block 并不会被执行，因为在执行这个 block 的时候，`queue` 已经被上面的死锁阻塞了。

因此，这段代码的实际输出应该只有 `print("1")`， `print("6")` 和 `print("8")`的输出，并且程序会在 `queue.sync { print("4") }` 这行产生死锁。

注意：Swift 中，每一个线程都有一个与之相关联的 DispatchQueue（分派队列），这个 DispatchQueue 用来管理和调度这个线程上的任务。`DispatchQueue.main.sync` 表示将一个任务添加到主线程相关联的 DispatchQueue 中，并立即等待这个任务执行完毕。`queue.async` 表示将一个任务异步地添加到 `queue` 中，这个任务会在 `queue` 有空闲的时候执行，并且添加任务后的代码不会等待这个任务执行完毕就会继续执行。

:::

### ❓下面代码输出结果

```objc
NSLog(@"1");
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@"2");
    [self performSelector:@selector(test) withObject:nil afterDelay:10];
    NSLog(@"3");
});
NSLog(@"4");
- (void)test {
    NSLog(@"5");
}
```

::: details 💡

  > 打印顺序 : 1, 4, 2, 3

  "1"和"4"是普通的直接执行代码，因此会按照顺序输出。
  
  "2"和"3"位于异步并发队列中，会在新线程中执行，所以会在"1"和"4"之后开始执行。

  "5"不会输出。原因是`[self performSelector:@selector(test) withObject:nil afterDelay:10];`这一行代码被放在异步并发队列中，并且是在子线程中执行，但是这种执行方式是依赖 `RunLoop` 的，而新创建的线程默认是没有启动 `RunLoop` 的，所以`performSelector:afterDelay:`方法会失效。

:::

> ❓如果想要使 "5" 能够打印，应该怎么处理

::: details 💡   
 
```objc
// 方案一 : 放入主线程 RunLoop
[self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:NO];
    
// 方案二 : 在子线程中手动启动 RunLoop
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[self performSelector:@selector(test) withObject:nil afterDelay:5.0];
[runLoop run];
```

:::

### ❓下面代码会发生什么

```objc
@property (nonatomic, strong) NSString *target;
//....

dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i < 1000000 ; i++) {
	dispatch_async(queue, ^{
     	self.target = [NSString stringWithFormat:@"ksddkjalkjd%d",i];
	});
}
```

::: details 💡

这段代码在一个并发队列 ("parallel") 上异步地多次执行一个 BLOCK。每次 BLOCK 执行时,会把 self.target 的值设置为一个新的字符串。因为这是在并发队列上执行的，所以这些设置 self.target 的操作可能同时执行。

这会引起线程安全的问题——数据竞争 (data race)。由于 setter 本质上是读取+写入两个操作，如果多个线程同时进行这两个操作，可能会造成数据不一致。这就是所谓的线程安全问题。

同时，不确定的并发操作可能会导致内存暴涨。dispatch_async的block，会被dispatch_retain，然后被存储起来等待执行。如果并行队列中block剧增，未执行的block可能会积压，导致大量内存消耗。

因此对于涉及多线程访问和修改的属性，应该引入线程同步机制，如使用 `@synchronized(self)`、`dispatch_semaphore_t`（信号量）等来防止数据竞争。当然，考虑到性能问题，在多线程环境下我们应该尽量避免大量读写同一个共享资源。

:::
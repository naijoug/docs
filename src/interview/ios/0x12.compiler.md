---
title: 编译器
icon: hashtag

index: true

---

<!-- more -->

## reference

- [2020-06-27 Swift 编译器中间码 SIL](https://juejin.cn/post/6844904200493596680)
- [2019-08-13 iOS程序员的自我修养](https://juejin.cn/post/6844903912143585288)

------

## 调试

### ❓`lldb (gdb)` 常用的调试命令

::: details 💡

  > `lldb`是一个使用 `C++` 编写的调试工具，用于解决运行在 `Apple` 平台上的代码问题。
  
常用的`lldb`调试命令：

  - 断点调试

     * **watchpoint set variable (w s v)**: 开始监视特定变量的值，当其值改变时，执行会停止。

        ```shell
        w s v myVariable
        ```

    * **breakpoint set (br s)**: 设置断点。可以根据函数名、文件名和行号、或者地址设置断点。
 
        ```shell
        br s -n functionName
        ```

    * **breakpoint delete (br del)**: 删除断点。

        ```shell
        br del 1
        ```

    * **continue (c)**: 从当前位置继续执行代码。
    * **step over (n)**: 单步执行代码，但是会跳过函数或方法的内部。
    * **step into (s)**: 单步执行代码，如果当前行是一个函数或方法，会跳转到它的内部。
    * **step out (finish)**: 如果当前位置是在一个函数或方法的内部，单步执行代码直到返回到父级。

  - 堆栈信息
    
    * **thread backtrace (bt)**: 显示当前线程的堆栈信息。
    * **thread return (th r)**: 返回到上层的线程。
    * **frame variable (fr v)**: 显示当前栈帧下的所有变量。
    * **frame select (fr s)**: 切换到指定的栈帧。
    * **expression (e)**: 在当前栈帧下执行指定的代码，例如修改变量的值，或者执行方法等。

        ```shell
        e self.view.backgroundColor = [UIColor redColor]
        ```

  - 其它命令

    * **list (l)**: 列出源代码。
    * **process interrupt (pro int)**: 暂停正在运行的进程。

:::

------

## 架构

### ❓项目采用 `64` 位，为什么要用 64 位，怎么修改成 `64` 位，`i386` 是什么

::: details 💡

首先，64位架构的主要优势是它可以使用更多的内存（达到18.4百万TB），而32位系统只能支持到4GB内存。其次，64位架构的处理器还可以处理更多的数据，也就是说 CPU 一次可以读取、处理和传输的数据位数更多，因此性能更强。

在 iOS 开发中，从 2015 年 2 月 1 日开始，App Store 要求所有新提交的应用和应用更新都需要支持 64 位。也就是说，应用必须同时支持 32 位和 64 位架构。这是因为从 iPhone 5s 开始，所有的 iPhone、iPad 和 iPod touch 都已经转为采用 64 位架构的处理器。

在 Xcode 中，你可以修改项目的“Build Settings”来指定项目的架构（Target -> Build Settings -> Architectures）。在这里，你应该选择 "Standard Architectures" 来让你的应用同时支持 armv7（32位）、armv7s（32位, iPhone 5以上）、arm64（64位）。

i386 是 Intel 开发的一种 32 位微处理器架构，同时也是一种指令集架构。在 iOS 开发中，i386 通常用于指代运行在 32 位模拟器上的架构。与之对应的是 x86_64，代表 64 位模拟器的架构。

:::

------

## 编译器

### ❓iOS 整个编译流程说一下

::: details 💡

  - 预处理：这一步主要是处理源代码中的预处理器指令，如 `#define、#include` 等，并将结果输出为预处理后的源文件。

  - 编译：预处理后的源文件被编译器（例如`Clang`）编译，进行词法分析、语法分析、语义分析和优化，将代码转换成对应的中间代码。然后将中间代码进一步优化并生成汇编代码。

  - 汇编：汇编器（例如 `Clang` 的集成汇编器）将汇编代码转换为目标文件（`.o` 文件），即包含了机器语言代码的文件。

  - 链接：链接器（例如 `ld`）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行文件。这里涉及到的主要步骤有地址和空间的分配、符号决议及重定位。

  - 打包：可执行文件配合对应的资源文件（如图片、音频等）一起打包，生成 `.ipa` 文件，这一步主要由 `Xcode` 的工具完成。

  - 签名：`.ipa` 文件需要经过开发者的私钥进行签名才能在设备上运行，签名过程通常也称为代码签名。

  - 安装：将签名后的 `.ipa` 文件安装到设备上，通常是通过 `iTunes` 或者 `Xcode` 进行安装。

:::

### ❓`Xcode` 的编译流程做了啥

::: details 💡

  - 预处理：这个阶段主要是处理源代码文件中的预处理命令，比如 `#define`、`#if`、`#import/#include` 等。在 `Swift` 项目中这个步骤也可能处理 `Swift` 的引入和一些编译标记。

  - 编译：编译器(`Clang for Objective-C`, `Swiftc for Swift`)将经过预处理的代码编译成相应的汇编文件。

  - 汇编：将汇编文件进一步转化为目标文件，也就是机器能直接执行的机器码。

  - 链接：链接器将所有的目标文件以及库文件链接在一起，生成可执行文件。在这个过程中会处理外部引用，解析符号，把在编译时分散的模块聚合在一起。

  - 打包：将可执行文件以及项目中的资源文件（例如图片、音乐、故事版等）打包进 `.app` 目录中。
    
  - 签名：使用开发者的证书对该 `.app` 目录进行签名。这个过程是必要的，`iOS` 在安装应用时会校验该签名。
    
:::

### ❓`Swift` 和 `Python` 的各自的编译流程

::: details 💡

  - `Swift` 编译流程：
    * 解析：编译器将 `Swift` 源代码解析为抽象语法树（`AST`）。
    * 类型检查：编译器分析 `AST` 并进行类型检查以确保代码中的一些操作符和函数被发送到正确的参数类型。
    * 中间代码生成：编译器进一步将 `AST` 转换为 `SIL`（`Swift Intermediate Language`）中间代码。
    * 优化：编译器对 `SIL` 进行一系列的优化，如删除死代码，函数内联等。
    * 生成 `LLVM` 中间代码：将优化后的 `SIL` 代码转化为 `LLVM` 中间代码。
    * 原生代码生成：`LLVM` 将其中间代码生成为原生的机器语言代码。

  - `Python` 编译流程：
    * 解析：`Python` 的解释器首先将源代码解析为抽象语法树 `AST`。
    * 字节码生成：然后将 `AST` 转换为字节码并存储在 `.pyc` 文件中。字节码是一种高级的机器语言，比原始的机器码要高级得多。
    * 字节码执行：解释器通过 `Python` 的虚拟机执行字节码。此步骤在运行时动态完成，而不是静态的编译和链接。

总结：`Swift` 是一种编译式语言，`Python` 是一种解释型语言，所以它们的编译流程有所不同。在 `Python` 中，真正的执行过程发生在运行时，而非编译阶段，这使得 `Python` 具有很强的动态和灵活性。而 `Swift` 则更倾向于在编译阶段做尽可能多的优化，以提高运行效率。

:::

### ❓从代码仓库拉取代码，到生成 `.ipa` 都有哪些过程，期间都生成了什么文件

::: details 💡

  - 拉取代码
    > 使用版本控制工具（如`Git`）从代码仓库拉取项目代码。

  - 预处理
    > 通过 `Xcode` 或命令行工具进行预处理，将源代码中的宏等预处理指令进行展开。这个过程并不直接生成文件，只是对源代码进行预处理。

  - 编译
    > 预处理后的代码被编译器（如`Clang`）逐个编译为目标文件（`.o` 文件）。此过程中可能会生成一些中间文件，如预编译头文件 `.pch`，或者 `Swift` 模块文件 `.swiftmodule` 等。

  - 链接
    > 由链接器（如 `ld`）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行的 `Mach-O` 文件。

  - 打包
    > 将可执行文件以及各种资源文件（如图片、`xib`、`storyboard` 文件等）打包到 `.app` 文件（即应用程序包）中。

  - 签名
    > 对 `.app` 文件进行签名，生成 `embedded.mobileprovision`（包含开发者证书和设备 `UDID`）、`CodeResources`（包含资源文件的哈希值）等文件，并被包含到 `.app` 文件中。

  - 生成 `.ipa`
    > 将上述的 `.app` 文件以及 `iTunesArtwork`（`iTunes` 中用来展示的 `App` 图标）等文件打包进 `Payload` 文件夹，然后以 `.zip` 格式进行压缩，最后将文件后缀名改为 `.ipa`，就生成了最后的 `.ipa` 文件。

:::

### ❓`OClint` 实现静态分析的原理是什么，它是如何做到的

::: details 💡

> `OClint`（`Objective-C linter`）是一个对 `Objective-C`，`C` 和 `C++` 进行静态代码分析的工具。静态分析是一种不需要实际运行程序代码，而是直接分析源代码本身结构、语法、符号等的技术。`OClint` 能够通过静态分析帮助查找出程序中的 `bug`，也能对代码质量进行评估和提升。

  `OClint` 基于 `LLVM/Clang` 静态分析技术实现分析。`LLVM`（`Low Level Virtual Machine`）是一个自由软件项目，主要包括一套编译器基础设施，用来建立、优化和生产中间代码和目标代码。`Clang` 是 `LLVM` 推出的 `C/C++/Objective-C` 编译器，提供了一套具备工业强度的编译、链接和调试功能的完整工具链。

实现原理：

  - 预处理：首先进行预处理操作，移除注释，并处理预处理器指令。
  - 语法分析：使用 `Clang` 对源代码进行语法分析，生成抽象语法树（`AST`）。
  - 遍历 `AST`：遍历 `AST`，根据预设的一组规则检查每一个节点。
    > 在遍历抽象语法树（`AST`）的过程中，`OClint` 通过调用各种检查规则，对语法树的节点进行分析和检查，不断寻找可能违反规则的代码元素。这些检查规则包括但不限于复杂度检查（如代码行数、圈复杂度等）、约定性检查（如命名、注释等）、潜在 `bug` 检查（如空指针解引用、内存泄漏等）。
  - 提供报告：收集检查结果，并提供详细的报告。分析结果会包括代码中可能存在的问题，和可能引发这些问题的代码片段。

总结：`OClint` 通过语法分析 `AST`，然后在不断的遍历和检查中，通过各种规则来找到可能存在的问题，并最终生成详细的分析报告，以供开发者参考和优化代码。

:::

### ❓`Swiftlint` 实现静态分析的原理是什么，它是如何做到的

::: details 💡

> `SwiftLint` 是一款为 `Swift` 编写的工具，用于在 `Xcode` 或是 `AppCode` 编写的代码中执行一系列的规则，并报告任何不合规的实例。`SwiftLint` 通过对项目源代码进行静态分析，找出不符合设定规则的部分，从风格、习惯方面帮助提升代码质量。

基本原理：

  - 解析：首先将源代码解析为抽象语法树（`AST`）。这是通过 `SourceKit`（`Swift` 的开源库，提供了对 `Swift` 源代码进行高效处理的能力）实现的。

  - 遍历 `AST`：遍历生成的 `AST`，查找是否存在与事先定义好的规则不符合的地方。

  - 规则检查：在 `AST` 中每遇到一个节点，会将其与所有启用的规则进行比对。这包括命名规则、空格规则、标点符号规则甚至是某些代码的复杂度规则等。

  - 报告：如果在这个过程中发现任何规则的违反情况，就会将这个违规信息添加到报告中。

  - 重复执行：对项目中的每个文件重复上面的过程，最后将所有文件的检查结果组合起来，形成最终的报告。

:::

### bitcode

#### ❓说说对 `bitcode` 的理解和作用

::: details 💡

> `Bitcode` 是苹果在 `2015` 年推出的一个新的编译选项，它是 `LLVM`（低级虚拟机）的一种中间表示（`Intermediate Representation，IR`）形式。对源代码做完一些基本的语义分析和验证工作后，就可以转化成`Bitcode`。

  `Bitcode` 的出现是为了支持苹果的 `App Thinning` 特性。具体来说，当提交一个包含 `Bitcode` 的应用到 `App Store` 时，苹果会在后台重新编译提交的应用并进行优化，生成针对各种设备的具体执行文件。因此，当用户从 `App Store` 下载应用时，他们只需下载适用于他们自己设备架构的二进制代码，而无需下载面向所有设备的通用二进制代码。

优点：

  - 节省存储空间：用户下载的应用体积更小，节省了设备的存储空间。
  - 提高性能：苹果可以根据特定硬件和 `iOS` 版本进行特定的优化，从而更好地利用硬件性能。
  - 更新兼容：当苹果引 `introduce` 新的硬件或者指令集时，可以在后台重新编译 `Bitcode`，自动使应用适配最新的设备，而无需开发者重新编译和提交。

缺点：

  - 失去一些控制权：由于程序最终是由 `Apple` 的服务器进行编译和优化，开发者无法知道、控制和验证优化的细节。
  - 调试难度增加：当出现问题时，可能下载的二进制代码已经被修改，与开发者本地编译出的二进制不一致，因此可能带来调试困难。此外，提交的 `.ipa` 包也无法直接运行和调试，由于里面的二进制代码实际上是 `Bitcode`，需要通过运行 `App Store` 版本或者从 `Xcode` 中下载 `dSYM` 文件来获取具体的崩溃日志。

总结：`Bitcode` 有点像把原先在本地进行的“链接”过程交给了苹果的服务器来完成，进一步加强了苹果对 `AppStore` 中应用的控制，又能提升用户的下载体验和设备性能。对于开发者来说，需要权衡 `Bitcode` 带来的好处与潜在问题。

:::

#### ❓`IR` 和 `bitcode` 有什么区别

::: details 💡

  - `IR`(`Intermediate Representation`) - 中间表示：是 `LLVM` 的核心，是其编译策略的基石。它是一种低级的编程语言，用于表示编译器中的程序。`LLVM` 前端（例如 `Clang`）负责将源代码（例如 `C，C++` 等）转化为 `IR`。
    > `LLVM IR`可以以三种形式存在：
    > * 即时编译（`JIT`）
    > * 位码（`bitcode`）
    > * 人类可读的汇编语言格式。

  - bitcode：是 `LLVM` 的二进制编码格式，是 `LLVM IR` 的一种序列化形式。
    > `Apple` 在发布 `iOS 9` 和 `OS X 10.11` 的时候推出了新的 `bitcode` 选项。这个选项的目的是让开发者在提交应用给 `App Store` 的时候只需上传 `bitcode`，然后由 `Apple` 服务器进行最后的编译过程。这样 `Apple` 可以在未通知开发者的情况下，为开发者的应用进行某些优化，稍微延长了二进制的兼容性期限。

总结：`LLVM` 的 `IR` 是一种更为底层的标识编译器理解的代码的方式，而 `bitcode` 是 `LLVM IR` 的一种序列化形式，可以使用 `bitcode` 轻松地在不同的模块之间共享并操控 `IR` 代码。

:::

------

## hook

### ❓`iOS` 中 `hook` 一个方法有什么途径

::: details 💡

  - `Method Swizzling`：通过 `Objective-C` 的方法交换 (`Method Swizzling`)，可以在运行时动态地交换某个类的两个方法的实现。

  - 分类(`Category`)：在其中添加一个新方法，然后用这个新方法的实现替换原始方法的实现。这将导致原始方法被分类中的新方法所替代。

  - 反射机制：可以在运行时动态地创建类、检查类的属性和方法，甚至改变类的结构。通过反射可以实现对方法的拦截和替换。

  - 使用第三方库：如`Aspects`，`Facebook` 的 `fishhook`，它们提供了较为方便和简洁的 `hook` 方案。

  - `Cycript`：这是一个用于调试和研究 `iOS` 应用的工具，它可以注入 `JavaScript` 语境进入正在运行的应用进程中，从而实现对对象和函数的交互操作。

:::

### ❓`iOS` 如何 `hook` 一个对象的方法，而不影响其它对象

::: details 💡

> “Isa Swizzling”：这是一种动态改变对象的类的技术。

```objc
// 原来的类
@interface MyClass : NSObject
- (void)originalMethod;
@end

@implementation MyClass
- (void)originalMethod {
    NSLog(@"Original method");
}
@end

// 子类
@interface MySwizzledClass : MyClass
@end

@implementation MySwizzledClass
- (void)originalMethod {
    NSLog(@"Swizzled method");
    [super originalMethod];
}
@end

// 让 hook 的对象使用子类
MyClass *myInstance = [[MyClass alloc] init];
object_setClass(myInstance, [MySwizzledClass class]);
[myInstance originalMethod]; // 输出 “Swizzled method” 和 “Original method”
```

:::

### ❓了解 `fishhook` 吗，说说为什么 `fishhook` 不能修改非动态连接库中的符号

::: details 💡

  > `fishhook` 是 `Facebook` 开发的一个用于 `iOS` 和 `macOS` 应用的开源库，允许你在运行时对 `C` 语言函数进行重绑定，并且是通过修改 `mach-O` 文件中的符号表（`Symbol Table`）实现的。

不能修改非动态连接库中的符号的原因：

  - `fishhook` 修改的是动态链接表，在程序启动时，动态链接器(`dyld`)会根据表中的符号信息，找到动态链接库中的函数地址，并在运行时进行函数调用。而对于静态链接库，链接发生在编译时，对应的函数或者变量的值在编译后就确定了，不存在动态链接表，因此 `fishhook`无法修改。
  
  - 静态库在编译时会直接被合并到可执行文件中，静态库中的符号信息会在编译时被解析并且写入到可执行文件中，所以 `fishhook`也 无法修改。
  
  - 根据 `Mach-O` 文件格式的定义，`fishhook` 通过修改 `LC_SYMTAB command` 下的符号表，而这个符号表主要用于动态连接过程中的符号解析，所以只能修改动态库中的符号。
    
  总结：`fishhook` 只能修改动态库的符号，无法修改非动态库的符号。

:::

### ❓`fishhook` 的实现原理

::: details 💡

> `fishhook`是 `Facebook` 开源的一个库，它是一个用于在 `iOS` 中自由地重定向 `C` 函数的强大工具。我们只需要输入原函数和新函数，`fishhook` 就能实现与之匹配的重定向。

实现原理：主要基于 `Unix` 中的动态链接过程，特别是在其中用到的 `GOT`（`Global Offset Table`）和 `PLT`（`Procedure Linkage Table`）技术。`fishhook` 会将需要重定向函数的 `PLT` 表项修改为新函数的地址，从而实现原始函数到新函数的转发。

`fishhook` 的主要工作过程：

  - `fishhook` 会通过在目标镜像的 `Mach-O` 文件中遍历 `segment command`，找到 `Data segment` 中的 `__nl_symbol_ptr` 和 `__got` 节段。

  - 每个节段由一系列指针组成，指向需要重定向的函数。`fishhook` 会遍历所有的指针，并将其指向的地址替换为新函数的地址。为了能够在后续调用原始函数，`fishhook` 在替换地址的同时，也会保存原始的地址。

  - 当应用程序下次调用函数时，由于 `PLT` 表中的地址已经被修改，因此，实际运行的将是新函数。如果新函数需要调用原始函数，则可以通过 `fishhook` 提供的接口直接访问。

注：`fishhook` 只能重定向动态链接的 `C` 函数。对于静态链接的函数，由于它们被直接嵌入到了可执行文件中，因此 `fishhook` 无法进行操作。

:::

------

## 逆向安全

### ❓简述下 `Match-O` 文件结构

::: details 💡

> `Mach-O` （Mach Object）文件格式是用于可执行文件、对象代码、共享库、动态加载代码以及内核代码等在 `macOS` 和 `iOS` 中的格式。

  - `Header`：描述了整个 `Mach-O` 文件的一些基本信息。
    > 例如文件类型（如可执行文件、动态库或对象文件等）、`CPU` 类型、加载命令的数量和大小等。

  - `Load Commands`：负责描述 `Mach-O` 文件的内部结构和布局。
    > 例如 `Segment、Section、Dynamic Symbol Table、Dylib ID、Entry Point` 等信息。

  - `Segments and Sections`：`Segments` 包含一种或多种类型的 `Sections`。每个 `Segment` 对应程序运行时的一个内存映射，`Sections` 则存储具体的代码和数据。

  - `Data`：包括符号表、字符串表等各种实际的数据。
    > 例如程序的执行代码、常量、全局变量等。

:::

### ❓防抓包如何做

::: details 💡

> 在 `iOS` 开发中，防抓包的一般策略主要是对网络请求的数据进行加密，以防止敏感信息在传输过程中被抓包工具截获。

  - 使用 `HTTPS`：默认情况下，`HTTPS` 协议可以防止数据在传输过程中被第三方获取，因为 `HTTPS` 在 `Client` 和 `Server` 之间建立了一个加密通道。但是，如果用户的设备中安装了抓包工具并配置了相关证书，依然可以抓取 `HTTPS` 的数据。因此，需要进一步采用证书绑定或者公钥绑定的方式来提升安全性。
  
  - `SSL Pinning`：是一种证书绑定的策略，即预先将服务端的公钥或者证书存储在客户端，在建立 `SSL` 连接时将服务端返回的证书和客户端存储的公钥或者证书进行对比，如果一致则认证成功，否则认证失败。`SSL Pinning` 有效防止中间人攻击。
  
    ```swift
    // Swift 中实现 SSL Pinning
    let url = URL(string: "https://your-website.com")!
    let urlSession = URLSession(
        configuration: .default,
        delegate: self,
        delegateQueue: nil
    )
    
    let task = urlSession.dataTask(with: url) { data, response, error in
        // handle response
    }
    task.resume()
    
    extension UIViewController: URLSessionDelegate {
       public func urlSession(
            _ session: URLSession,
            didReceive challenge: URLAuthenticationChallenge,
            completionHandler: @escaping (
                URLSession.AuthChallengeDisposition,
                URLCredential?
            ) -> Void) {
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
                let serverTrust = challenge.protectionSpace.serverTrust {
                var secresult = SecTrustResultType.invalid
                let status = SecTrustEvaluate(serverTrust, &secresult)
                
                if errSecSuccess == status,
                    let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0), // 获取服务器证书
                    let serverCertificateData = SecCertificateCopyData(serverCertificate) as Data?, // 转化服务器证书数据
                    let localCertificateData = yourLocalCertificateDataMethod() { // 获取本地证书数据
                    if (serverCertificateData == localCertificateData) { // 对比服务器证书与本地证书是否匹配
                        completionHandler(.useCredential, URLCredential(trust: serverTrust))
                        return
                    }
                }
            }           
            completionHandler(.cancelAuthenticationChallenge, nil)
        }
    }
    ```
    
  - 使用自定义协议进行数据传输：除了 `HTTPS`，还可以使用一些自定义的协议进行数据传输，比如 `WebSocket`、`MQTT` 等。这些协议可以自定义加密方式，比如可以在传输数据前，先对数据进行 `AES` 或者 `RSA` 等加密，然后再传输。

  - 数据混淆：在数据传输前，对数据进行混淆处理，使得抓包工具很难解析出真正的数据。
  
  - 进程护舷：使用一些系统级别的手段禁止抓包工具的运行，比如检测网络代理、`VPN` 的使用情况，发现有异常就拒绝服务。
    
:::

### ❓`ptrace` 反调试如何做

::: details 💡

> `iOS` 的反调试技术中，早期常用的是利用 `ptrace` 函数。`ptrace` 是 `Unix` 和类 `Unix` 系统（包括 `iOS`）提供的一个系统调用，可以用来控制和查看另一个进程的执行情况。

反调试：可以通过设置 `ptrace` 来禁止别的进程 `attach` 到自己的进程上。

```swift
// 引入头文件
import UIKit

// 定义 c 语言的方法
private let PT_DENY_ATTACH: CInt = 31

// 在 didFinishLaunchingWithOptions 中调用此方法
if #available(iOS 9.0, *) {
    // iOS 9 之后使用 syscall
    let result = syscall(
        SYS_ptrace,
        PT_DENY_ATTACH,
        0,
        0,
        0
    )
    if result == -1 {
        print("Unable to call ptrace")
    }
} else {
    // iOS 9 之前使用 ptrace
    let result = ptrace(
        PT_DENY_ATTACH,
        0,
        0,
        0
    )
    if result == -1 {
        print("Unable to call ptrace")
    }
}
```

注意：自 `iOS 9` 开始，`Apple` 不再允许 `App Store` 里的应用调用 `ptrace` 函数，除非是已经进行了特殊设置的企业应用。所以如果希望应用能上架到 `App Store`，就不能使用这种方法进行反调试。

:::

### ❓`iOS` 反调试手段

::: details 💡

  - 检测父进程：在 `Unix` 系统中，当一个新的进程（`child`）从一个已有的进程（`parent`）`fork` 出去时，子进程会继承父进程的一些属性，比如环境变量等。由于调试器也是通过这种方式启动被调试程序的，因此可以检查当前进程的父进程信息，如果父进程是调试器，就代表当前进程正在被调试。
    
  - 使用 `ptrace` 系统调用：使用 `ptrace` 系统调用并设置参数 `PT_DENY_ATTACH`，这会导致后面任何试图 `attach` 的调试器在 `attach` 时失败。这种方法通常被称作 “`ptrace` 反调试”。

  - 检查断点：调试器常用的一种调试手段是设置断点。当 `CPU` 执行到断点时就会触发一个特殊的中断信号(`SIGTRAP`)，然后操作系统就会把控制权交给调试器。这种机制给了一个反调试的思路：检查程序的代码段中的"断点"。如果发现有断点，就说明程序正在被调试。

  - 监听系统调试通知：当一个进程被另一个进程调试时，内核会给这个被调试的进程发送一个 `SIGSTOP` 信号。应用程序可以监听这个信号，当接收到这个信号时，就可以采取一些行动，比如立刻退出。
    
  - 具有反调试功能的第三方库：有些第三方的安全库已经实现了这些反调试功能，只需要引入这些库并按照文档正确配置即可。
    
注意：使用反调试方法需要依据具体应用的需求和场景，这些方法可能会对应用的稳定性和性能造成一些影响，需要仔细评估。另外，这些反调试方法并不是绝对安全的，仍有可能被绕过。

:::

### ❓数据是怎么加密的，怎么保证逆向拿不到我们的加密秘钥

::: details 💡

在 `iOS` 设备上数据加密的方式主要有两种：

  - 文件级别的加密：
    > `iOS` 系统提供了数据保护 `API`，开发者可以轻松的利用这些 `API` 给 `App` 中的文件进行加密。只需在创建文件或写数据时，指定正确的数据保护等级即可。具体的数据保护等级有：`No Protection`, `Complete Until First User Authentication`, `Complete Unless Open`, `Complete Protection`。

  - 数据库级别的加密：
    > 对于存储在数据库中的数据，可以使用如 `SQLCipher` 这样的工具进行加密。`SQLCipher` 是一个开源的 `SQLite` 数据库的扩展，它为数据库文件添加了透明的 256 级 `AES` 加密。

保证逆向工程拿不到加密秘钥的方法：

  - 不要在代码中硬编码秘钥。一旦硬编码，逆向工程师可以很容易地通过静态分析找到它。可以选择在运行时动态生成秘钥，或者从服务器获取。

  - 利用 `iOS` 的钥匙串服务（`Keychain Services`）来存储秘钥。钥匙串是 `iOS` 系统提供的一个安全的存储容器，可以用来存储秘钥、密码等敏感信息。钥匙串中的数据是加密的，且默认只有相同开发者账号下的应用才能访问。

  - 尽可能地使用最新和最安全的加密算法，并定期更新你的加密策略。因为老旧的加密算法可能已经被破解。

  - 确保你的应用有反逆向工程的保护，例如混淆代码，使得攻击者很难从可执行文件中复原源代码。

  - 利用操作系统提供的安全特性，例如在 `iOS` 上可以使用 `App Transport Security`（`ATS`）来保证网络数据传输的安全。

:::

### ❓`iOS` 逆向分析

::: details 💡

> `iOS` 逆向分析，通常指破解者通过分析和修改设备中的 `iOS` 应用程序来了解其工作原理的行为。逆向分析的应用场景广泛，包括但不限于：`Bug` 定位、性能优化、安全测试以及对竞品的调研等。

`iOS` 逆向分析的方法：

  - 静态分析：静态分析是分析字节码或逆向编译后的代码来了解其功能和行为的过程，未运行程序代码。常用的静态分析工具有 `Hopper Disassembler`、`IDA Pro` 等。

  - 动态分析：动态分析是在程序运行时观察其行为，常用到的工具有 `LLDB`、`Cycript`、`frida` 等。通过动态分析可以实时查看和修改程序的运行状态。

  - `Class-Dump`：是一个用来解析在 `Mach-O` 文件中 `Objc` 的类信息的命令行工具。逆向分析的第一步常常是使用 `Class-Dump` 获取被分析对象的头文件信息。

  - `Mach-O` 文件探索：`Mach-O` 文件是 `macOS` 和 `iOS` 的可执行文件的格式。通过探索 `Mach-O` 文件，可以获取到程序的 `Segments、Sections、Symbol` 等信息，分析程序的入口点、链接库等。

:::

### ❓`lild` 重签名

::: details 💡

> `Resigning` 重签名：对给定的库或者插件进行签名才能将它包含在我们的应用中。

> `lild`（Link Identity Editor）是一个在 `macOS` 上可以用来重签名可执行文件的命令行工具。

```shell
# 清除原有签名
codesign --remove-signature /path/to/my.framework
    
# 添加新的签名
#   -f: 强制重签名，即使已经签过名了
#   -s: 开发者证书，可以在 Keychain Access 应用程序中找到
codesign -f -s "iPhone Developer: Your Name (ID)" /path/to/my.framework
```

注意：进行重签名操作需要正确的开发者证书和配套的 `Provisioning Profiles`，否则重签名后的文件将无法在设备上运行。重签名是安全敏感操作，必须确保源文件和签名证书的可信任性。遵守相关法律法规和协议出于合法合规的前提操作。

:::

### ❓防重签名如何做

::: details 💡

> 防止重签名的主要策略是检测应用的签名信息，以确定应用是否经过了别人的重签名。

  - 检查代码签名：在应用启动或某些操作之前，可以检查应用的签名信息。如果发现签名信息不符合预期（比如签名证书、公钥等），就可以认为应用经过了重签名。
    > 具体做法是：可以在代码中加入检测代码签名的逻辑，iOS 提供了 `SecRequirementCreateWithString` 和 `SecStaticCodeCheckValidity` 等 `API` 可以对应用的签名证书进行校验。

  - 绑定设备信息：可以把应用的签名信息（如`bundle ID`、证书公钥、证书指纹等）和一些设备信息（如`UUID`、设备型号等）绑定在一起，并存储在应用的服务器上。然后，在应用启动或者进行某些操作时，检查本地的设备信息和服务器上的设备信息是否一致。如果不一致，就说明应用可能经过了重签名。
  
  - 把一些关键的、敏感的数据和代码放在服务器上：对于一些重要的功能，可以设计成需要服务器的支持才能使用。在使用这些功能时，服务器会检查请求是否来自合法的应用。如果检查不通过，服务器可以拒绝提供服务，从而使重签名后的应用无法正常使用。
  
:::


### ❓怎么防止别人反编译你的 `iOS App`

::: details 💡

  - 代码混淆：这是最基本的方法，通过改变变量名和方法名，添加无用代码等手段来让反编译出的代码难以阅读。

  - 字符串加密：很多时候，敏感的信息是以字符串的形式存在于程序中的，通过将这些字符串加密，可以有效防止这些信息被泄露。

  - 符号剥离：将程序中的符号信息剥离掉，这样在反编译的时候就看不到原始的符号信息，降低可读性。

  - 把关键代码部分用汇编或者 `C` 语言重写：高级语言相比于底层语言更易于被反编译和理解，把关键部分的代码用汇编或者 `C` 语言写可以增加破解难度。

  - 使用防护壳：就像电脑端的软件可以使用加壳技术一样，移动端的程序也可以通过防护壳来对抗反编译。

  - 运行时防护：可以在程序中加入一些运行时检测的代码，比如检测设备是否被越狱，检测正在运行的进程等，一旦发现破解行为，就立即终止运行。
    
:::
---
title: 编译器
icon: hashtag

index: true

---

<!-- more -->

------

## 编译器

### ❓iOS 整个编译流程说一下

::: details 💡

iOS应用的编译流程主要由以下几个步骤：

1. 预处理：这一步主要是处理源代码中的预处理器指令，如#define、#include等，并将结果输出为预处理后的源文件。

2. 编译：预处理后的源文件被编译器（例如Clang）编译，进行词法分析、语法分析、语义分析和优化，将代码转换成对应的中间代码。然后将中间代码进一步优化并生成汇编代码。

3. 汇编：汇编器（例如Clang的集成汇编器）将汇编代码转换为目标文件（.o文件），即包含了机器语言代码的文件。

4. 链接：链接器（例如ld）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行文件。这里涉及到的主要步骤有地址和空间的分配、符号决议及重定位。

5. 打包：可执行文件配合对应的资源文件（如图片、音频等）一起打包，生成.ipa文件，这一步主要由Xcode的工具完成。

6. 签名：.ipa文件需要经过开发者的私钥进行签名才能在设备上运行，签名过程通常也称为代码签名。

7. 安装：将签名后的.ipa文件安装到设备上，通常是通过iTunes或者Xcode进行安装。

以上就是iOS应用的主要编译流程，其中包含了预处理、编译、汇编、链接、打包、签名和安装等主要步骤。

:::

### ❓app 的启动过程

::: details 💡

Apple应用的启动过程包含了以下步骤：

1. Main函数执行前：

- App点击图标后，由springboard进程通过posix_spawn函数来创建新的进程。

- 动态链接器dyld作为新进程的主线程开始执行。首先加载Mach-O文件中的dyld路径，解析加载App的所有依赖库。

- 在加载依赖库过程中，dyld首先会通过mach-o加载器解析mach-o文件，按依赖顺序进行加载。然后对library进行rebase和bind操作，以确保library在内存中的正确位置。接着进行初步的lazy binding和weak binding操作。

- dyld为了提高执行性能，会缓存一份共享缓存，提高下次启动性能。

2. Runtime初始化：

- 加载完成后，dyld会初始化runtime并调用所有image中的 +load 方法。

- 之后对C++全局构造器和__attribute__((constructor))修饰的方法进行调用。

- 进行完上述步骤，dyld则把控制权交回给App。

3. Main函数和UIApplicationMain函数执行：

- main函数开始执行。通常在main函数中，我们会调用UIApplicationMain函数。

- 在UIApplicationMain中，它会创建UIApplication对象，并设置UIApplicationDelegate，并启动主运行循环（即Main Run Loop），开始接收用户操作。

- UIApplication启动后，它会根据Info.plist是否指定Main storyboard文件名，如果指定，那么就会加载Main storyboard，创建和设置UIWindow和root view controller，然后显示window到屏幕，App呈现出来。

4. finishLaunching流程：

- UIApplication对象会回调UIApplicationDelegate中的application:didFinishLaunchingWithOptions:方法，这是App启动的最后一步，之后就进入了事件处理循环，启动流程到此结束。

:::

### ❓从代码仓库拉取代码，到生成 `.ipa` 都有哪些过程，期间都生成了什么文件

::: details 💡

从代码仓库拉取代码到生成.ipa文件的过程如下：

1. 拉取代码：使用版本控制工具（如Git）从代码仓库拉取项目代码。

2. 预处理：通过Xcode或命令行工具进行预处理，将源代码中的宏等预处理指令进行展开。这个过程并不直接生成文件，只是对源代码进行预处理。

3. 编译：预处理后的代码被编译器（如Clang）逐个编译为目标文件（.o文件）。此过程中可能会生成一些中间文件，如预编译头文件.pch，或者Swift模块文件.swiftmodule等。

4. 链接：由链接器（如ld）将所有的目标文件以及所需的系统库和框架进行链接，生成可执行的Mach-O文件。

5. 打包：将可执行文件以及各种资源文件（如图片、xib、storyboard文件等）打包到.app文件（即应用程序包）中。

6. 签名：对.app文件进行签名，生成embedded.mobileprovision（包含开发者证书和设备UDID）、CodeResources（包含资源文件的hash值）等文件，并被包含到.app文件中。

7. 生成.ipa：最后，将上述的.app文件以及iTunesArtwork（iTunes中用来展示的App图标）等文件打包进Payload文件夹，然后以.zip格式进行压缩，最后将文件后缀名改为.ipa，就生成了最后的.ipa文件。

上述流程中，主要生成的文件有：目标文件、Mach-O文件、.app文件、embedded.mobileprovision、CodeResources、.ipa文件等。

:::

### ❓程序到可执行文件的过程，链接过程都干了啥

::: details 💡

将程序转换为可执行文件可以分为编译和链接两个过程，我们首先简单介绍一下编译过程，然后详细说明链接过程。

编译过程：

1. 预处理：这一步主要处理源文件中的预处理命令，如宏定义、头文件包含等。

2. 编译：预处理过的源文件被编译成汇编语言。

3. 汇编：汇编程序将汇编语言文件转换为目标文件，这是个二进制文件，包含了源程序编译后的机器语言代码。

链接过程：

链接主要对编译生成的多个目标文件之间的引用进行解析并合并，输出为一个可执行文件，具体做了以下几个步骤：

1. 符号解析：每个符号对应着一块内存，符号解析的主要目标就是找到这块内存的地址。链接器要负责把每个符号的引用与定义关联起来。

2. 重定位：在符号解析的基础上，进行地址分配和重定位。地址分配就是把每个段分配一个运行时内存地址。重定位就是把每条指令和全局变量引用的符号修改成运行时地址。

3. 段合并：将所有目标文件的同名段合并成一个段，位于一个可执行文件中的同一位置。

4. 空间和地址分配：为每个段分配一个内存地址。

5. 重定位表和符号表的创建和更新：创建和更新这两个表是为了程序的加载和运行。

6. 调试及其它的信息：加入必要的调试等信息。

7. 结果输出：将链接结果输出到可执行文件。

所谓的链接，其实就是解决各个编译单元之间的引用问题，包括地址分配，符号解析，重定位等步骤。它是把各个编译单元编译生成的目标文件连接成一个完整的可执行程序的过程。

:::

### ❓动态库静态库区别

::: details 💡

静态库和动态库是两种不同类型的代码库，区别主要在于它们被链接和加载的方式不同。

静态库：

静态库在编译时就被链接到目标程序中，程序运行时不再需要该静态库。生成的可执行文件较大，因为所有使用的库函数代码都会被复制到目标代码中。因此，静态库的改动需要重新编译程序才能生效，但具有较好的可移植性。

动态库：

动态库在编译时并不会被链接到目标程序中，而是在程序运行时由系统动态地加载并链接到程序中。动态库虽然会缩小生成的可执行文件的体积，但需要保证运行环境中有相应的库文件。动态库的一个特点是，多个应用程序可以共享一个动态库的单一拷贝，这样可以节省系统资源。

两者比较：

1. 空间占用：静态库会让程序体积变大，动态库则会让程序在运行时占用更多内存。

2. 调试：静态库调试比较简单，因为所有的代码都在可执行文件中。而动态库则需要在运行时才能够进行调试。

3. 兼容性：静态链接的程序更便于分发，因为它包含了所有需要的代码。而动态链接的程序则需要可以访问特定版本的动态库，否则可能会导致运行错误。

4. 更新：动态库可以利用系统的动态链接机制进行更新，而不需要重新编译程序。

结论：静态库和动态库各有各的优缺点，使用哪一种需要根据具体情况来确定。

:::

### ❓静态库和动态库各自的好处

::: details 💡

静态库的好处：

1. 高效：静态库在编译阶段就已经被包含到了二进制可执行文件中，运行时不需要额外的动态链接过程，所以从这个角度来说静态链接的执行效率会优于动态链接。

2. 可移植性：因为静态库被打包到了最终的可执行文件中，可以简化程序的发布，不需要考虑是否缺少某些动态库。

3. 安全：避免了动态库版本不一致导致的问题。

动态库的好处：

1. 节省资源：若有很多程序都要用到某个库，那么使用静态库将会在每个程序中都生成一份这个库的拷贝。而动态库只需要一份拷贝，所有的程序共享同一份动态库，这样就节省了磁盘空间和内存。

2. 更新简便：如果库需要更新或者修复bug，只需要重新编译库，然后替换现有的动态库文件即可，不需要对使用到这个库的软件进行重新链接。对于使用静态库的程序则需要重新编译链接全部程序。

3. 动态链接：可以在程序运行时动态加载所需的库，甚至是程序启动后再决定加载哪个库。这极大的提高了程序的灵活性和功能的扩展性。

不同的情况下应该选择使用不同的库，具体需要根据软件的需要以及开发和运行的环境来决定。

:::

### ❓说说对 `bitcode` 的理解和作用

::: details 💡

`Bitcode` 是苹果在2015年推出的一个新的编译选项，它是LLVM（低级虚拟机）的一种中间表示（Intermediate Representation，IR）形式。对源代码做完一些基本的语义分析和验证工作后，就可以转化成Bitcode。

Bitcode的出现是为了支持苹果的App Thinning特性。具体来说，当你提交一个包含Bitcode的应用到App Store时，苹果会在后台重新编译你的应用并进行优化，生成针对各种设备的具体执行文件。因此，当用户从App Store下载应用时，他们只需下载适用于他们自己设备架构的二进制代码，而无需下载面向所有设备的通用二进制代码。

这样的做法有以下好处：

1. 节省存储空间：用户下载的应用体积更小，节省了设备的存储空间。
2. 提高性能：苹果可以根据特定硬件和iOS版本进行特定的优化，从而更好地利用硬件性能。
3. 更新兼容：当苹果引 introduce 新的硬件或者指令集时，可以在后台重新编译Bitcode，自动使应用适配最新的设备，而无需开发者重新编译和提交。

但也有一些潜在的缺点，包括：

1. 失去一些控制权：由于程序最终是由Apple的服务器进行编译和优化，开发者无法知道、控制和验证优化的细节。
2. 调试难度增加：当出现问题时，可能下载的二进制代码已经被修改，与开发者本地编译出的二进制不一致，因此可能带来调试困难。此外，提交的`.ipa`包也无法直接运行和调试，由于里面的二进制代码实际上是Bitcode，需要通过运行App Store版本或者从Xcode中下载dSYM文件来获取具体的崩溃日志。

综合来看，Bitcode有点像把原先在本地进行的“链接”过程交给了苹果的服务器来完成，进一步加强了苹果对App Store中应用的控制，又能提升用户的下载体验和设备性能。对于开发者来说，需要权衡Bitcode带来的好处与潜在问题。

:::

------

## hook

### ❓`iOS` 中 `hook` 一个方法有什么途径

::: details 💡

在iOS中，我们有几种方法可以对一个方法进行Hook：

1. Method Swizzling：这可能是在Objective-C语言中最常见的一种hook技术了。通过Objective-C的方法交换 (Method Swizzling)，我们可以在运行时动态地交换某个类的两个方法的实现。

2. 具体来说，比如我们可以创建一个类别(Category)，在其中添加一个新方法，然后用这个新方法的实现替换原始方法的实现。这将导致原始方法被我们的新方法所替代，而原有的实现可以在新方法内部被再次调用，从而在原方法执行前后添加自定义的代码逻辑。

3. 使用第三方库：如Aspects，Facebook的fishhook，甚至runtime函数等，它们提供了较为方便和简洁的hook方案。

4. 使用反射机制：Objective-C支持反射机制，可以在运行时动态地创建类、检查类的属性和方法，甚至改变类的结构。通过反射可以实现对方法的拦截和替换。

5. 在Swift中，由于语言特性和安全性的原因，Method Swizzling的应用并不广泛。不过在某些情况下，我们仍然可以通过Runtime的方法交换或者使用第三方框架来实现hook。

6. Cycript：这是一个用于调试和研究iOS应用的工具，它可以注入JavaScript语境进入正在运行的应用进程中，从而实现对对象和函数的交互操作。

需要注意hook可能会增加代码的复杂性、降低可维护性，且可能违反App Store的规则，因此只应在清楚知道自己在做什么时才使用，且一般仅限于Debug模式或者是越狱环境下。

:::

### ❓`iOS` 如何 `hook` 一个对象的方法，而不影响其它对象

::: details 💡

要Hook一个对象的方法而不影响其他对象，需要在运行时动态改变这个对象的类。以下是在 Objective-C 中实现的步骤：

1. 首先，你需要对这个类创建一个子类，并在子类中重写或添加你需要的方法。
2. 然后，使用 `object_setClass` 函数来将你要 `hook` 的对象的类动态修改为这个子类。这样就只有这个对象的类会变，其他的对象的类不会受到影响。

这种技术叫做 “Isa Swizzling”。这是一种动态改变对象的类的技术。

示例代码如下：

```objc
// 原来的类
@interface MyClass : NSObject
- (void)originalMethod;
@end

@implementation MyClass
- (void)originalMethod {
    NSLog(@"Original method");
}
@end

// 子类
@interface MySwizzledClass : MyClass
@end

@implementation MySwizzledClass
- (void)originalMethod {
    NSLog(@"Swizzled method");
    [super originalMethod];
}
@end

// 让 hook 的对象使用子类
MyClass *myInstance = [[MyClass alloc] init];
object_setClass(myInstance, [MySwizzledClass class]);
[myInstance originalMethod]; // 输出 “Swizzled method” 和 “Original method”
```

这样，myInstance 就被 hook 了，但其他的 MyClass 的对象不会被影响。

需要注意的是，这种技术在一些特殊情况下可能会导致问题，比如当你的类有实例变量时，因为子类和父类的实例变量布局可能不同。而且，Isa Swizzling可能会影响到一些Objective-C的特性，比如“类簇（class clusters）”。所以在使用时需要谨慎。

:::

### ❓了解 `fishhook` 吗，说说为什么 `fishhook` 不能修改非动态连接库中的符号

::: details 💡

Fishhook是Facebook开发的一个用于iOS和macOS应用的开源库，允许你在运行时对C语言函数进行重绑定，并且是通过修改mach-O文件中的符号表（Symbol Table）实现的。

对于你要了解为什么 Fishhook 不能修改非动态连接库中的符号的问题，主要有以下几个原因：

1. Fishhook修改的是动态链接表，在程序启动时，动态链接器(dyld)会根据表中的符号信息，找到动态链接库中的函数地址，并在运行时进行函数调用。而对于静态链接库，链接发生在编译时，对应的函数或者变量的值在编译后就确定了，不存在动态链接表，因此Fishhook无法修改。

2. 另一方面，静态库在编译时会直接被合并到可执行文件中，静态库中的符号信息会在编译时被解析并且写入到可执行文件中，所以Fishhook也无法修改。

3. 最后，根据Mach-O文件格式的定义，Fishhook通过修改LC_SYMTAB command下的符号表，而这个符号表主要用于动态连接过程中的符号解析，所以只能修改动态库中的符号。

所以综上，Fishhook只能修改动态库的符号，无法修改非动态库的符号。

:::

------

## 安全问题

### ❓`iOS` 设备获取唯一设备号的历史变迁

::: details 💡

在iOS平台上获取设备唯一标示（identifier）的方式经历了几次重大的变化，以下是一些关键的历史节点：

1. UDID（Unique Device Identifier）：在早期的iOS版本中（iOS 5之前），开发者可以直接使用 [UIDevice currentDevice].uniqueIdentifier 来获取设备的UDID，它是一个40位的十六进制序列，由设备的各种硬件信息生成，每台设备唯一。然而，由于隐私问题，Apple 在 iOS 5及以后的版本中废弃了这个API。

2. MAC地址：因为UDID被废弃，部分开发者开始使用设备的Wi-Fi chip的MAC地址作为替代。然而在iOS 7以后，Apple 也禁止了获取MAC地址，所有尝试获取的行为都会返回固定的"02:00:00:00:00:00"。

3. UUID（Universally Unique Identifier）：UUID 是每次生成都不同的一串字符。在UDID和MAC地址都不能使用后，部分开发者开始产生一个UUID并将其存储在应用的KeyChain中，这样就可以保证同一台设备上不同的安装过程中获取的UUID相同。但是，如果应用被彻底删除后或者设备被重置后，之前的UUID将无法再被获取到。

4. IDFA（Identifier for Advertisers）：在 iOS 6及以后的版本中，Apple 引入了广告标识符IDFA，主要用于广告商跟踪和标识用户。用户可以在设置中重置自己的IDFA，或者完全关闭这个功能。

5. IDFV（Identifier for Vendor）：在 iOS 6及以后的版本中，Apple 也引入了IDFV，这是一个针对同一开发者（Vendor）下的所有应用都相同的标识符。只有当用户将该厂商的所有应用全部删除后，这个标识符才会被重置。

综上，为了保护用户隐私，Apple 不断的改变标识设备的方式，开发者必须适应这些变化并尊重用户的隐私。

:::

### ❓沙盒目录的每个文件夹划分的作用

::: details 💡

iOS应用都运行在一个受限制的环境中，即沙盒(Sandbox)，每个应用都有一个自己的沙盒目录，其他应用应用或者外部环境无法访问该应用的沙盒。这是iOS保证用户数据隐私和安全的机制之一。在应用的沙盒内，又划分了一些目录文件夹，不同的目录有着不同的作用：

1. `Documents`：用来存储用户创建或应用程序运行需要持久化的数据。iTunes同步设备时会备份该目录内容。

2. `tmp`：用于存放临时文件，当应用退出后，这个目录下的文件会被删除。所以有些临时产生的文件，如缓存的图片或者下载的临时的文件可以放在这里。

3. `Library`：Library目录下有两个子目录，`Caches` 和 `Preferences`。其中 `Caches` 目录主要存放缓存文件，`Preferences` 目录主要存放应用的配置信息，这些数据在设备的设置应用中设置。此外，`Library` 还可以存放应用的其他一些持久性的文件。

4. `Library/Caches`：保存应用程序使用时产生的需要持久化的数据，iTunes不会备份该目录，此目录下文件不会在应用退出后删除。

每个目录都有其自己的用途，使用这些目录时应当合理分配每个文件存放的地方，以达到最佳的存储效果。

:::

### ❓`iOS` 逆向分析

::: details 💡

iOS逆向分析，通常指破解者通过分析和修改Apple设备中的iOS应用程序来了解其工作原理的行为。逆向分析的应用场景广泛，包括但不限于：Bug定位、性能优化、安全测试以及对竞品的调研等。

以下是一些常用的iOS逆向分析的方法：

1. 静态分析：静态分析是分析字节码或逆向编译后的代码来了解其功能和行为的过程，未运行程序代码。在iOS逆向分析中，常用的静态分析工具有`Hopper Disassembler`、`IDA Pro`等。

2. 动态分析：动态分析是在程序运行时观察其行为，常常使用到的工具有`LLDB`、`Cycript`、`frida`等。通过动态分析我们可以实时查看和修改程序的运行状态。

3. `Class-Dump`：是一个用来解析在Mach-O文件中Obj-C的类信息的命令行工具。逆向分析的第一步常常是使用Class-Dump获取被分析对象的头文件信息。

4. Mach-O文件探索：Mach-O文件是macOS和iOS的可执行文件的格式。通过探索Mach-O文件，可以获取到程序的Segments、Sections、Symbol等信息，分析程序的入口点、链接库等。

逆向工程分析是一个复杂的过程，它需要逆向工程师对iOS系统有深入的理解，并掌握Objective-C、Swift等语言的知识。同时，安全和合法问题也是需要考虑的。建议仅在合法和遵守道德规范的前提下进行操作。

:::

### ❓怎么防止别人反编译你的 `iOS App`

::: details 💡

预防iOS应用被反编译是一个涉及多个维度的问题，下面介绍一些常用的防护方法：

1. 代码混淆：这是最基本的方法，通过改变变量名和方法名，添加无用代码等手段来让反编译出的代码难以阅读。

2. 字符串加密：很多时候，敏感的信息是以字符串的形式存在于程序中的，通过将这些字符串加密，可以有效防止这些信息被泄露。

3. 符号剥离：将程序中的符号信息剥离掉，这样在反编译的时候就看不到原始的符号信息，降低可读性。

4. 把关键代码部分用汇编或者C语言重写：高级语言相比于底层语言更易于被反编译和理解，把关键部分的代码用汇编或者C语言写可以增加破解难度。

5. 使用防护壳：就像电脑端的软件可以使用加壳技术一样，移动端的程序也可以通过防护壳来对抗反编译。

6. 运行时防护：可以在程序中加入一些运行时检测的代码，比如检测设备是否被越狱，检测正在运行的进程等，一旦发现破解行为，就立即终止运行。

以上是一些常用的防止反编译的手段，但是并不能完全阻止反编译。预防反编译是一个持续的过程，需要随着反编译技术的进步不断的完善我们的防护措施数字。

:::

### ❓`lild` 重签名

::: details 💡

在 iOS 开发过程中，有时候我们可能需要对给定的库或者插件进行签名才能将它包含在我们的应用中，这个过程就叫做重签名（Resigning）。`lild`（Link Identity Editor）就是一个在 macOS 上可以用来重签名可执行文件的命令行工具。

使用 `lild` 进行重签名的基本步骤如下：

1. 清除原有签名：
   ```
   codesign --remove-signature /path/to/my.framework
   ```
2. 添加新的签名：
   ```
   codesign -f -s "iPhone Developer: Your Name (ID)" /path/to/my.framework
   ```

其中，
- `-f` 选项指的是强制重签名，即使已经签过名了。
- `-s` 选项后跟的是你的开发者证书，它可以在 Keychain Access 应用程序中找到。

以上只是最基本的使用方法，有时可能需要进行一些更复杂的操作。此外，需要注意的是，进行重签名操作需要正确的开发者证书和配套的 Provisioning Profiles，否则重签名后的文件将无法在设备上运行。重签名是安全敏感操作，必须确保源文件和签名证书的可信任性。遵守相关法律法规和协议出于合法合规的前提操作。

:::

### ❓简述下 `Match-O` 文件结构

::: details 💡

Mach-O （Mach Object）文件格式是用于可执行文件、对象代码、共享库、动态加载代码以及内核代码等在macOS和iOS中的格式。以下是其主要的组成部分：

1. Header：描述了整个Mach-O文件的一些基本信息，例如文件类型（如可执行文件、动态库或对象文件等）、CPU类型、加载命令的数量和大小等。

2. Load Commands：负责描述Mach-O文件的内部结构和布局，例如Segment、Section、Dynamic Symbol Table、Dylib ID、Entry Point等信息。

3. Segments and Sections：Segments包含一种或多种类型的Sections。每个Segment对应程序运行时的一个内存映射，Sections则存储具体的代码和数据。

4. Data：包括符号表、字符串表等各种实际的数据，例如程序的执行代码、常量、全局变量等。

整体来说，Mach-O文件的结构是由Header开始，然后是Load Commands和接下来的数据区域组成的。每一个Load Command描述了后面的数据的类型以及它们在文件中和内存中的位置。通过解析Mach-O文件，可以清楚地了解到程序的组织结构和运行方式。

:::
---
title: 网络
icon: hashtag

index: true

---

<!-- more -->

## reference



------

## URLSession

### ❓`NSURLSession` vs `NSURLConnection`

::: details 💡

`NSURLConnection` 和 `NSURLSession` 都是提供的用于网络请求的类。

  - **NSURLConnection**：`iOS 7`之前用于处理 `HTTP`、`FTP`等协议的网络请求的主要类。
    > 提供了同步和异步两种方式来获取网络数据。由于同步请求会阻塞主线程，因此开发中一般使用异步请求。然而，`NSURLConnection` 在 `iOS 9.0` 之后已经被标记为过期。

  - **NSURLSession**：`iOS 7`之后引入的新的网络请求类，用于替代`NSURLConnection`。
    > 相比于`NSURLConnection`，`NSURLSession`提供了一些新的特性，例如后台下载、上传任务等。同时，`NSURLSession`提供了更现代化、组件化的接口，使得网络请求的处理更为方便和灵活。
  
  `NSURLSession` 有 `DataTask`、`UploadTask`、`DownloadTask`三种任务类型，分别对应获取数据、上传和下载文件的操作。对于任务的处理，`NSURLSession` 采用了 `Block` 的方式，使得请求的结果处理在同一个地方，更为清晰。

:::

### ❓`NSURLSession` 解决了 `NSURLConnection` 什么问题

::: details 💡

  - **后台传输**：`NSURLConnection` 不支持在应用退出后继续传输数据，`NSURLSession` 通过创建后台会话可以在应用处于后台或者被杀死后继续进行数据传输。

  - **请求的暂停和续传**：`NSURLConnection` 无法像 `NSURLSession` 那样暂停和续传网络请求，因为它并没有提供相应的方法或者对应的操作状态。

  - **代理回调**： `NSURLConnection` 使用代理的方式进行回调，在复杂应用场景下，可能导致代理方法混杂，变得难以管理和维护。而 `NSURLSession` 则采用了基于 `block` 的回调方式，更加直观和方便。

  - **配置会话**：`NSURLSession` 提供了 `NSURLSessionConfiguration` 类，可以用于配置会话的行为，比如请求超时、蜂窝网络是否访问、`HTTP` 最大并发数等，而 `NSURLConnection` 则无法做到这些。

  - **重用和取消网络请求**：`NSURLSession` 通过 `NSURLSessionTask` 对象来管理每个网络请求，每个任务都是可以取消、暂停和恢复的，而 `NSURLConnection` 则无法做到。

:::

### ❓`NSURLSession` 的实现原理

::: details 💡

  - `NSURLSessionConfiguration`：这是一个会话配置对象，它决定了会话的行为模式。
    > 如：允许蜂窝访问、cookie 策略、超时设置、HTTP 管道化等。

  - `NSURLSession`：这是网络加载的上下文环境。
    > 它协调一组相关网络数据转换任务的完成。会话中包含一个代理以及一个用来监控特定任务组的进度的委托。

  - `NSURLSessionTask`：任务对象负责启动并维护相关的网络操作，提供了开始、暂停、取消任务的操作；并且可以查看传输进度、网络状态等信息。
    > 细分为三个子类，分别是 `NSURLSessionDataTask`、`NSURLSessionUploadTask`、`NSURLSessionDownloadTask`，对应的是数据获取任务、上传任务和下载任务。

  - `NSURLSessionDelegate`：会话代理
    > 监听整个会话的事件，比如任务的完成、认证请求、后台下载完成等。

  - `NSURLSessionTaskDelegate`：任务代理
    > 监听特定任务的事件，例如上传进度、下载进度等。

:::

## 功能设计

### ❓断点续传怎么实现，需要设置什么

::: details 💡

  > 断点续传：主要是利用 `HTTP` 协议中的 `Range` 请求头字段，在发起网络请求时设置 `Range` 字段，告诉服务器我们需要从哪个字节开始接收数据。

实现步骤：

  - 在用户暂停或者请求失败等需要断点续传的情况下，需要保存已经接收到的数据长度。
    > 比如使用`NSURLSessionDownloadTask` 进行下载时，可以调用 `cancelByProducingResumeData:` 方法获取到一个 `NSData` 对象，这个对象包含了已经下载数据的长度以及资源的链接等信息，可以保存到本地用于以后恢复下载。

  - 当需要恢复下载时，可以使用这个 `NSData` 对象调用 `NSURLSession` 的 `downloadTaskWithResumeData:` 方法来创建一个 `NSURLSessionDownloadTask` 对象，然后再调用 `resume` 方法，即可完成断点下载。

  - 另外一种方法则是，在请求头部添加 `Range` 字段，值为 `bytes=已下载长度-` 这样在发出请求时，服务器会接收到这个字段，然后从需要的字节开始返回数据。这种方式需要自己处理已下载的数据，将新下载的数据拼接到已下载的数据后面。

注意：并不是所有服务器都支持断点续传的，这需要服务器支持 `HTTP` 协议中的 `Range` 字段。

:::

### ❓如何解决两个网络请求之间的依赖

::: details 💡

  - `DispatchGroup`：利用队列组进行网络请求之间的依赖。
    > 可以把两个网络请求添加到一个队列分组中，然后利用队列组的 `notify` 方法监听在队列组中所有任务都完成后才执行的方法。

    ```swift
    let dispatchGroup = DispatchGroup()
    
    dispatchGroup.enter()
    doSomething {
        // when task is done
        dispatchGroup.leave()
    }
    dispatchGroup.enter()
    doSomethingElse {
        // when another task is done
        dispatchGroup.leave()
    }
    
    dispatchGroup.notify(queue: .main) {
        print("Both asynchronous tasks are complete!")
    }
    ```

  - `Operation` 是基于 `GCD` 更高一层的封装，提供了更多的可控制性。
    > 利用它的 `addDependency` 方法，可轻易创建依赖关系。

    ```swift
    let queue = OperationQueue()
    let operation1 = BlockOperation {
        // your network request
    }
    let operation2 = BlockOperation {
        // Another network request
    }
    // operation2 在 operation1 完成后才执行
    operation2.addDependency(operation1)
    
    queue.addOperations([operation1,operation2], waitUntilFinished: false)
    ```

:::

### ❓设计一个网络框架     

::: details 💡

设计原则：

  - 解耦性：网络框架与业务代码相分离，做到各部分职责明确，降低各部分之间的耦合程度。
  - 扩展性：应对业务或需求的变化，有良好的扩展性是十分重要的。
  - 安全性：保证数据的安全传输，包括数据加密，`HTTPS` 验证等。
  - 易用性：网络请求的发起和结果的处理应该尽可能简洁明了。

一个网络框架的简单设计：

  - 网络配置类 `NetworkConfiguration`：
    > 用于处理一些全局的网络配置，比如 `BaseURL`、超时时间、公共的请求头、公共的请求参数等。

  - 网络请求类 `NetworkRequest`：
    > 这是一个抽象的基类，它包含一个请求的所有必要要素，例如：`URL`、`HTTP`方法（`GET`、`POST`...）、`HTTP`头、请求参数等。

    也可以创建这个类的子类，比如 `JSONNetworkRequest`、`FormDataNetworkRequest` 等，它们覆盖和扩展基类一些行为以适应特定类型的网络请求。

  - 网络会话类 `NetworkSession`：
    > 这个类用来执行 `NetworkRequest`，它依赖于 `URLSession` 等系统组件执行实际的网络请求。这个类也是处理证书挑战，提供 `URLSessionDelegate` 等系统回调的地方。

  这个类通常是个单例对象，所有的 `NetworkRequest` 都由它来负责发送，也可以创建多个 `NetworkSession` 对象，每个对象可以有自己的 `URLSessionConfiguration`。

  - 结果处理 `NetworkResponse`：
    > 用一个类或者结构体来封装网络请求的返回结果，它一般包含原始的 `HTTPURLResponse` 对象，请求是否成功的标志，请求返回的数据或者是请求失败的错误对象。

    ```swift
    struct NetworkResponse {
        var response: HTTPURLResponse?
        var data: Data?
        var error: Error?
    }
    ```

  - 错误定义 `NetworkError`：
    > 用来在网络请求时产生错误时返回给调用者具体的错误信息。可以使用 `Swift` 的 `Error` 协议来定义。

:::

> ❓重连机制如何处理

::: details 💡

  > 网络重连机制主要是在网络连接失败或断开时，自动进行重新连接。
  
处理策略：

  - 立即重连：在网络连接断开后立即进行连接，但是这种方式并不总是有效，因为有可能是网络环境问题，立即重连也可能会失败。

  - 延时重连：这是一个更好的策略，即在初次连接断开後，不立即重连，而是采用逐步增加的时间间隔进行重连，例如初次连接失败后 2 秒后进行第一次重连，如果还是失败，则 4 秒后进行第二次重连，依次类推，增加重试间隔。

  - 最大重连次数：设置一个最大的重连次数，例如 3 次或 5 次。一旦重连次数达到这个值，就不再进行重连，而是将错误报告给用户。

  - 网络状态检查：在进行重连之前，先检查当前的网络状态，如果网络不可用，那么就不进行重连。

  大多数的网络库，例如 `OkHttp`、`AFNetworking`、`Alamofire` 等，都内置了这种网络重试的机制，只需要简单的配置即可启用。需要注意的是，过于频繁的重连可能会加重服务器的负担，所以需要根据实际情况合理配置重连策略。

:::

> ❓状态码错误转发机制的处理

::: details 💡

  > 状态码错误通常是指网络请求已经成功完成，但是服务端返回了一个错误的状态码，例如`HTTP` 400，403，404，500等错误。处理这类错误的一种常见方法是使用 `HTTP` 错误中间件或者拦截器。 

处理步骤：

  - 判断 `HTTP` 状态码：
    > 在接收到网络请求的响应后，首先检查 `HTTP` 状态码。如果状态码在 200-299 之间，通常表示请求成功。否则，就表示发生了错误。

  - 创建错误对象：
    > 根据 `HTTP` 状态码，创建一个表示具体错误的对象。这个错误对象通常会包含错误的状态码，以及服务器返回的错误信息。

  - 使用中间件或者拦截器：
    > 创建一个错误处理中间件或者拦截器。这个中间件的任务是在每个网络请求完成后，检查请求的结果。如果发现结果中包含了 `HTTP` 错误，那么就把这个错误转发给应用程序的其他部分。

  - 错误处理：
    > 在应用程序的其他部分，注册错误处理函数。这些处理函数会在接收到由中间件转发的错误时被调用。根据错误的具体情况，执行相应的处理，例如显示错误信息，或者重新执行网络请求。
    
:::

------

## Web

### ❓`WKWebView` 缓存和清理缓存的方法

::: details 💡

```swift
// 禁止缓存
let url = URL(string: "https://www.website.com")!
var request = URLRequest(url: url)
request.cachePolicy = .reloadIgnoringLocalCacheData
wkWebView.load(request)

// 清除缓存
let dateFrom = Date(timeIntervalSince1970: 0)
var websiteDataTypes = Set<String>()
websiteDataTypes.insert(WKWebsiteDataTypeDiskCache)
websiteDataTypes.insert(WKWebsiteDataTypeMemoryCache)
WKWebsiteDataStore.default().removeData(ofTypes: websiteDataTypes, modifiedSince: dateFrom, completionHandler: {})
```

注意：清理缓存操作可能需要几秒钟的时间去完成，特别是当磁盘中的缓存比较大的情况下，应当对它进行异步处理。

:::
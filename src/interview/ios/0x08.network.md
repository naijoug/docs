---
title: 网络
icon: hashtag

index: true

---

<!-- more -->

## reference



------

## URLSession

### ❓`NSURLSession` vs `NSURLConnection`

::: details 💡

`NSURLConnection` 和 `NSURLSession` 都是提供的用于网络请求的类。

  - **NSURLConnection**：`iOS 7`之前用于处理 `HTTP`、`FTP`等协议的网络请求的主要类。
    > 提供了同步和异步两种方式来获取网络数据。由于同步请求会阻塞主线程，因此开发中一般使用异步请求。然而，`NSURLConnection` 在 `iOS 9.0` 之后已经被标记为过期。

  - **NSURLSession**：`iOS 7`之后引入的新的网络请求类，用于替代`NSURLConnection`。
    > 相比于`NSURLConnection`，`NSURLSession`提供了一些新的特性，例如后台下载、上传任务等。同时，`NSURLSession`提供了更现代化、组件化的接口，使得网络请求的处理更为方便和灵活。
  
  `NSURLSession` 有 `DataTask`、`UploadTask`、`DownloadTask`三种任务类型，分别对应获取数据、上传和下载文件的操作。对于任务的处理，`NSURLSession` 采用了 `Block` 的方式，使得请求的结果处理在同一个地方，更为清晰。

:::

### ❓`NSURLSession` 解决了 `NSURLConnection` 什么问题

::: details 💡

  - **后台传输**：`NSURLConnection` 不支持在应用退出后继续传输数据，`NSURLSession` 通过创建后台会话可以在应用处于后台或者被杀死后继续进行数据传输。

  - **请求的暂停和续传**：`NSURLConnection` 无法像 `NSURLSession` 那样暂停和续传网络请求，因为它并没有提供相应的方法或者对应的操作状态。

  - **代理回调**： `NSURLConnection` 使用代理的方式进行回调，在复杂应用场景下，可能导致代理方法混杂，变得难以管理和维护。而 `NSURLSession` 则采用了基于 `block` 的回调方式，更加直观和方便。

  - **配置会话**：`NSURLSession` 提供了 `NSURLSessionConfiguration` 类，可以用于配置会话的行为，比如请求超时、蜂窝网络是否访问、`HTTP` 最大并发数等，而 `NSURLConnection` 则无法做到这些。

  - **重用和取消网络请求**：`NSURLSession` 通过 `NSURLSessionTask` 对象来管理每个网络请求，每个任务都是可以取消、暂停和恢复的，而 `NSURLConnection` 则无法做到。

:::

### ❓`NSURLSession` 的实现原理

::: details 💡

  - `NSURLSessionConfiguration`：这是一个会话配置对象，它决定了会话的行为模式。
    > 如：允许蜂窝访问、cookie 策略、超时设置、HTTP 管道化等。

  - `NSURLSession`：这是网络加载的上下文环境。
    > 它协调一组相关网络数据转换任务的完成。会话中包含一个代理以及一个用来监控特定任务组的进度的委托。

  - `NSURLSessionTask`：任务对象负责启动并维护相关的网络操作，提供了开始、暂停、取消任务的操作；并且可以查看传输进度、网络状态等信息。
    > 细分为三个子类，分别是 `NSURLSessionDataTask`、`NSURLSessionUploadTask`、`NSURLSessionDownloadTask`，对应的是数据获取任务、上传任务和下载任务。

  - `NSURLSessionDelegate`：会话代理
    > 监听整个会话的事件，比如任务的完成、认证请求、后台下载完成等。

  - `NSURLSessionTaskDelegate`：任务代理
    > 监听特定任务的事件，例如上传进度、下载进度等。

:::

------

## AFNetworking

### ❓`AFNetworking` 2.0 中常驻线程设计是为了解决什么问题

::: details 💡

`AFNetworking 2.0` 中的 `AFURLConnectionOperation` 类中存在一个常驻线程的设计。其是为了解决 `NSURLConnection` 的异步操作的线程问题。

  如果在线程中创建一个异步 `NSURLConnection` 网络请求，这个请求只有在 `runloop` 运行的时候才会进行。如果线程的工作一旦完成就退出了，那么 `NSURLConnection` 的异步请求就被中断了，所以在网络请求期间这个线程必须被保活，保证其 `runloop` 在请求完成之前一直是在运行状态。

  总结：`AFNetworking` 创建了一个常驻线程，把所有的网络请求的操作（`NSURLConnection`）都放到这个线程的 `runloop` 中，完全避免了新建线程的开销以及由于线程退出导致的网络请求被中断问题。这样，无论发起多少个网络请求，都只有一个线程在执行，避免了频繁的线程切换和大量线程并发所带来的性能问题。

:::

### ❓`AFNetworking` 是否支持 `IPv6`

::: details 💡

> `AFNetworking` 是支持 `IPv6` 的。

  从 2016 年开始，`Apple` 强制所有提交的应用必须支持 `IPv6-only` 网络。这影响了很多网络框架的开发者，因为需要做出相应的修改以支持 `IPv6`。`AFNetworking` 也进行了相应的升级和调整，从 `2.6.0` 版本开始，`AFNetworking` 已经支持 `IPv6`。

注意：要正确使用 `AFNetworking`（或任何其他网络库）以兼容 `IPv6`，应该始终使用域名而不是 `IP` 地址来发起请求。`IPv6` 环境中，直接使用 `IPv4` 地址是无法连接成功的。所以，如果应用需要接入 `IPv6-only` 网络，不论使用何种框架，都应避免直接使用 `IP` 地址进行网络请求。

:::

### ❓`AFNetworking` 的底层原理

::: details 💡

> `AFNetworking` 是一种优秀的网络请求库，其底层原理主要建立在苹果的网络请求库 `NSURLSession` 之上，再结合一些设计模式如 `Block`，`Delegate`，`GCD` 等以实现更高效的网络访问。

实现原理：

  - **基于NSURLSession实现**：底层对 `iOS` 原生的网络请求库 `NSURLSession` 进行了封装。
    > `NSURLSession` 是苹果为 `iOS7` 及之后的版本提供的网络请求库，本身已经很强大，包括了很多网络协议，比如`HTTP`、`HTTPS`、`FTP`等，而 `AFNetworking` 在此基础上提供了更方便易用的接口。

  - **封装各种请求方式**：为 `HTTP` 的各种请求方式例如`GET`、`POST`、`PUT`、`DELETE`等都进行了封装，使其可以以更简洁的方式进行网络请求。

  - **多线程处理**：通过 `GCD` 实现多线程并发，使得网络请求可以异步进行，防止 `UI` 线程阻塞。

  - **序列化处理**：为请求和响应的序列化提供了接口，包括了`JSON`、`XML`、属性列表等格式的序列化。

  - **快速处理服务器响应数据**：提供了一套完整的解决方案，让开发者能够快速处理服务器响应的数据。

  - **网络状态监测**：通过监听系统提供的网络状态更改通知，可以实时监测当前的网络状态。

  - **内存缓存和硬盘缓存**：结合 `NSURLCache` 对网络请求进行内存和硬盘缓存，速度快且节省流量。
    
:::

### ❓`Alamofire` 的实现原理

::: details 💡

> `Alamofire` 是一个在 `Swift` 中编写的网络库，它基于 `Apple` 的基础网络库 `URLSession` 进行封装，提供了更高级的 `API`，使得网络请求更加方便和灵活。

实现原理：

  - **请求的发起**：通过使用 `Alamofire.Session.default/request/download/upload` 方法中的各种重载函数，支持所有的 `HTTP` 方法，如 `GET`，`POST`，`PUT`，`DELETE` 等。

  - **请求的处理**：这包括请求参数的编码，请求头的设置，请求转发的处理，验证等。在 `Alamofire` 中有多种参数编码方式，比如将字典类型的参数转为 `URL` 参数或者 `JSON` 格式的请求体。

  - **响应的处理**：提供了灵活的结果处理方式，比如 `json` 数据，字符串，二进制数据等。还可以自定义数据解析类，以便返回你需要的数据类型。

  - **错误处理**：会捕捉在发送请求和接受数据过程中出现的所有错误，可以方便的在请求完成后的回调函数中处理这些错误。

  - **多任务管理**：可以同时发起多个网络请求，并且使用闭包来处理每个请求的返回结果，并行或者串行的执行这些请求。

  - **数据上传和下载**：支持文件的上传和下载，尤其是它会自动处理 `iOS` 后台文件下载的问题，使得在后台下载文件变得很简单。

  - **自定义 Session**：使用 `Session` 类来封装 `URLSession`，可以通过使用自定义配置（`URLSessionConfiguration`）来创建新的 `Session` 实例。比如可以自定义 `HTTP Headers`，超时时间，`Cookie` 存储方式等。

总结：`Alamofire` 使用 `Swift` 来封装了苹果提供的 `HTTP/HTTPS` 网络库，通过灵活的 `API` 设计使得在 `Swift` 中进行网络请求变得更简洁易用。同时，`Alamofire` 也保持了足够的扩展性，可以自定义多种功能。

:::

------

## 功能设计

### ❓断点续传怎么实现，需要设置什么

::: details 💡

  > 断点续传：主要是利用 `HTTP` 协议中的 `Range` 请求头字段，在发起网络请求时设置 `Range` 字段，告诉服务器我们需要从哪个字节开始接收数据。

实现步骤：

  - 在用户暂停或者请求失败等需要断点续传的情况下，需要保存已经接收到的数据长度。
    > 比如使用`NSURLSessionDownloadTask` 进行下载时，可以调用 `cancelByProducingResumeData:` 方法获取到一个 `NSData` 对象，这个对象包含了已经下载数据的长度以及资源的链接等信息，可以保存到本地用于以后恢复下载。

  - 当需要恢复下载时，可以使用这个 `NSData` 对象调用 `NSURLSession` 的 `downloadTaskWithResumeData:` 方法来创建一个 `NSURLSessionDownloadTask` 对象，然后再调用 `resume` 方法，即可完成断点下载。

  - 另外一种方法则是，在请求头部添加 `Range` 字段，值为 `bytes=已下载长度-` 这样在发出请求时，服务器会接收到这个字段，然后从需要的字节开始返回数据。这种方式需要自己处理已下载的数据，将新下载的数据拼接到已下载的数据后面。

注意：并不是所有服务器都支持断点续传的，这需要服务器支持 `HTTP` 协议中的 `Range` 字段。

:::

### ❓如何解决两个网络请求之间的依赖

::: details 💡

  - `DispatchGroup`：利用队列组进行网络请求之间的依赖。
    > 可以把两个网络请求添加到一个队列分组中，然后利用队列组的 `notify` 方法监听在队列组中所有任务都完成后才执行的方法。

    ```swift
    let dispatchGroup = DispatchGroup()
    
    dispatchGroup.enter()
    doSomething {
        // when task is done
        dispatchGroup.leave()
    }
    dispatchGroup.enter()
    doSomethingElse {
        // when another task is done
        dispatchGroup.leave()
    }
    
    dispatchGroup.notify(queue: .main) {
        print("Both asynchronous tasks are complete!")
    }
    ```

  - `Operation` 是基于 `GCD` 更高一层的封装，提供了更多的可控制性。
    > 利用它的 `addDependency` 方法，可轻易创建依赖关系。

    ```swift
    let queue = OperationQueue()
    let operation1 = BlockOperation {
        // your network request
    }
    let operation2 = BlockOperation {
        // Another network request
    }
    // operation2 在 operation1 完成后才执行
    operation2.addDependency(operation1)
    
    queue.addOperations([operation1,operation2], waitUntilFinished: false)
    ```

:::

### ❓设计一个网络框架     

::: details 💡

设计原则：

  - 解耦性：网络框架与业务代码相分离，做到各部分职责明确，降低各部分之间的耦合程度。
  - 扩展性：应对业务或需求的变化，有良好的扩展性是十分重要的。
  - 安全性：保证数据的安全传输，包括数据加密，`HTTPS` 验证等。
  - 易用性：网络请求的发起和结果的处理应该尽可能简洁明了。

一个网络框架的简单设计：

  - 网络配置类 `NetworkConfiguration`：
    > 用于处理一些全局的网络配置，比如 `BaseURL`、超时时间、公共的请求头、公共的请求参数等。

  - 网络请求类 `NetworkRequest`：
    > 这是一个抽象的基类，它包含一个请求的所有必要要素，例如：`URL`、`HTTP`方法（`GET`、`POST`...）、`HTTP`头、请求参数等。

    也可以创建这个类的子类，比如 `JSONNetworkRequest`、`FormDataNetworkRequest` 等，它们覆盖和扩展基类一些行为以适应特定类型的网络请求。

  - 网络会话类 `NetworkSession`：
    > 这个类用来执行 `NetworkRequest`，它依赖于 `URLSession` 等系统组件执行实际的网络请求。这个类也是处理证书挑战，提供 `URLSessionDelegate` 等系统回调的地方。

  这个类通常是个单例对象，所有的 `NetworkRequest` 都由它来负责发送，也可以创建多个 `NetworkSession` 对象，每个对象可以有自己的 `URLSessionConfiguration`。

  - 结果处理 `NetworkResponse`：
    > 用一个类或者结构体来封装网络请求的返回结果，它一般包含原始的 `HTTPURLResponse` 对象，请求是否成功的标志，请求返回的数据或者是请求失败的错误对象。

    ```swift
    struct NetworkResponse {
        var response: HTTPURLResponse?
        var data: Data?
        var error: Error?
    }
    ```

  - 错误定义 `NetworkError`：
    > 用来在网络请求时产生错误时返回给调用者具体的错误信息。可以使用 `Swift` 的 `Error` 协议来定义。

:::

> ❓重连机制如何处理

::: details 💡

  > 网络重连机制主要是在网络连接失败或断开时，自动进行重新连接。
  
处理策略：

  - 立即重连：在网络连接断开后立即进行连接，但是这种方式并不总是有效，因为有可能是网络环境问题，立即重连也可能会失败。

  - 延时重连：这是一个更好的策略，即在初次连接断开後，不立即重连，而是采用逐步增加的时间间隔进行重连，例如初次连接失败后 2 秒后进行第一次重连，如果还是失败，则 4 秒后进行第二次重连，依次类推，增加重试间隔。

  - 最大重连次数：设置一个最大的重连次数，例如 3 次或 5 次。一旦重连次数达到这个值，就不再进行重连，而是将错误报告给用户。

  - 网络状态检查：在进行重连之前，先检查当前的网络状态，如果网络不可用，那么就不进行重连。

  大多数的网络库，例如 `OkHttp`、`AFNetworking`、`Alamofire` 等，都内置了这种网络重试的机制，只需要简单的配置即可启用。需要注意的是，过于频繁的重连可能会加重服务器的负担，所以需要根据实际情况合理配置重连策略。

:::

> ❓状态码错误转发机制的处理

::: details 💡

  > 状态码错误通常是指网络请求已经成功完成，但是服务端返回了一个错误的状态码，例如`HTTP` 400，403，404，500等错误。处理这类错误的一种常见方法是使用 `HTTP` 错误中间件或者拦截器。 

处理步骤：

  - 判断 `HTTP` 状态码：
    > 在接收到网络请求的响应后，首先检查 `HTTP` 状态码。如果状态码在 200-299 之间，通常表示请求成功。否则，就表示发生了错误。

  - 创建错误对象：
    > 根据 `HTTP` 状态码，创建一个表示具体错误的对象。这个错误对象通常会包含错误的状态码，以及服务器返回的错误信息。

  - 使用中间件或者拦截器：
    > 创建一个错误处理中间件或者拦截器。这个中间件的任务是在每个网络请求完成后，检查请求的结果。如果发现结果中包含了 `HTTP` 错误，那么就把这个错误转发给应用程序的其他部分。

  - 错误处理：
    > 在应用程序的其他部分，注册错误处理函数。这些处理函数会在接收到由中间件转发的错误时被调用。根据错误的具体情况，执行相应的处理，例如显示错误信息，或者重新执行网络请求。
    
:::

### 网络层封装做了哪些事

------

---
title: 树 & 图
icon: hashtag

index: true

---

> 04 树 & 图 (12)

<!-- more -->

## 4.1 节点间通路
  > 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

## 4.2 最小高度树
  > 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

## 4.3 特定深度节点链表
  > 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。

## 4.4 检查平衡性
  > 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。

## 4.5 合法二叉搜索树
  > 实现一个函数，检查一棵二叉树是否为二叉搜索树。

## 4.6 后继者
  > 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。可以假定每个节点都含有指向父节点的连接。

## 4.7 编译顺序
  > 给你一系列项目（projects）和一系列依赖关系（依赖关系dependencies为一个链表，其中每个元素为两个项目的编组，且第二个项目依赖于第一个项目）。所有项目的依赖项必须在该项目被编译前编译。请找出可以使得所有项目顺利编译的顺序。如果没有合法的编译顺序，返回错误。
    
    示例：
        输入：
            projects: a, b, c, d, e, f
            dependencies: (a, d), (f, b), (b, d), (f, a), (d, c)
        输出：
            f, e, a, b, d, c

## 4.8 首个共同祖先
  > 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

## 4.9 二叉搜索树序列
  > 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。
    
    示例：
        输入:
             2
            /  \
           1    3
        输出: 
            {2, 1, 3}, {2, 3, 1}
    
## 4.10 检查子树
  > 你有两棵非常大的二叉树：T1，有几百万个节点；T2，有几百个节点。设计一个算法，判断T2是否为T1的子树。如果T1有这么一个节点n，其子树与T2一模一样，则T2为T1的子树，也就是说，从节点n处把树砍断，得到的树与T2完全相同。

::: tip
#4，#11，#18，#31，#37
:::

## 4.11 随机节点
  > 你现在要从头开始实现一个二叉树类，该类除了插入（insert）、查找（find）和删除（delete）方法外，需要实现getRandomNode()方法用于返回树中的任意节点。该方法应该以相同的概率选择任意的节点。设计并实现getRandomNode方法并解释如何实现其他方法。

::: tip
#42，#54，#62，#75，#89，#99，#112，#119
:::

## 4.12 求和路径
  > 给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。
---
title: 高难度题
icon: hashtag

index: true

---

> 17 - 高难度题 (26)

<!-- more -->

## 17.1 不用加号的加法
  > 设计一个函数把两个数字相加。不得使用+或者其他算术运算符。

## 17.2 洗牌
  > 设计一个用来洗牌的函数。要求做到完美洗牌，也就是说，这副牌52！种排列组合出现的概率相同。假设给定一个完美的随机数发生器。

## 17.3 随机集合
  > 编写一个方法，从大小为n的数组中随机选出m个整数。要求每个元素被选中的概率相同。

## 17.4 消失的数字
  > 数组A包含从0到n的所有整数，但其中缺了一个。在这个问题中，只用一次操作无法取得数组A里某个整数的完整内容。此外，数组A的元素皆以二进制表示，唯一可用的访问操作是“从A[i]中取出第j位数据”，该操作的时间复杂度为常量。请编写代码找出那个缺失的整数。你有办法在O(n) 时间内完成吗？

## 17.5 字母与数字
  > 给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。

## 17.6 2出现的次数
  > 编写一个方法，计算从0到n（含n）中数字2出现的次数。
    
    示例:
        输入：25
        输出：9(2, 12, 20, 21, 22, 23, 24, 25)（注意22应该算作两次）

## 17.7 婴儿名字
  > 每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John和Jon本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果John和Jon是相同的，并且Jon和Johnny相同，则John与Johnny也相同，即它们有传递和对称性。在结果列表中，任选一个名字做为真实名字就可以。
    
    示例：
        输入：
            Names: John(15)、Jon(12)、Chris(13)、Kris(4)、Christopher(19)
            Synonyms: (Jon, John)、(John, Johnny)、(Chris, Kris)、(Chris, Christopher)
        输出：
            John(27)、Kris(36)

## 17.8 马戏团人塔
  > 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。
    
    示例：
        输入：
            (ht, wt)：(65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110)
        输出：
            从上往下数，叠罗汉最多能叠 6 层：(56, 90) (60,95) (65,100) (68,110) (70,150) (75,190)

## 17.9 第k个数
  > 有些数的素因子只有3，5，7，请设计一个算法找出第k个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是1，3，5，7，9，15，21。

## 17.10 主要元素
  > 如果数组中多一半的数都是同一个，则称之为主要元素。给定一个正数数组，找到它的主要元素。若没有，返回-1。要求时间复杂度为O(N)，空间复杂度为O(1)。
    
    示例：
        输入：1 2 5 9 5 9 5 5 5
        输出：5

## 17.11 单词距离
  > 有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离（相隔单词数）。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗？
    
## 17.12 BiNode
  > 有个名为BiNode的简单数据结构，包含指向另外两个节点的指针。
    
  ```java
  public class BiNode {
      public BiNode node1, node2;
      public int data;
  }
  ```
    
  BiNode可用来表示二叉树（其中node1为左子节点，node2为右子节点）或双向链表（其中node1为前趋节点，node2为后继节点）。实现一个方法，把用BiNode实现的二叉搜索树转换为双向链表，要求值的顺序保持不变，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
    
::: tip    
#508，#607，#645，#679，#700，#718
:::

## 17.13 恢复空格
  > 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子“I reset the computer. It still didn't boot！”已经变成了“iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典，用一个string的集合表示。不过，有些词没在词典里。假设文章用string表示，设计一个算法，把文章断开，要求未识别的字符最少。
    
    示例：
        输入：jesslookedjustliketimherbrother
        输出：jess looked just like tim her brother（7个未识别的字符）

::: tip            
#495，#622，#655，#676，#738，#748
:::

## 17.14 最小k个数
  > 设计一个算法，找出数组中最小的k个数。

::: tip
#469，#529，#551，#592，#624，#646，#660，#677
:::

## 17.15 最长单词
  > 给定一组单词，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。
  
    示例：
        输入：cat, banana, dog, nana, walk, walker, dogwalker
        输出：dogwalker

::: tip  
#474，#498，#542，#588
:::

## 17.16 按摩师
  > 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有15分钟的休息时间，因此她不能接受时间相邻的预约。给定一个预约请求序列（都是15分钟的倍数，没有重叠，也无法移动），替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
    
    示例：
        输入：{30, 15, 60, 75, 45, 15, 15, 45}
        输出：180 minutes ({30, 60, 45, 45})

::: tip            
#494，#503，#515，#525，#541，#553，#561，#567，#577，#586，#606
:::

## 17.17 多次搜索
  > 给定一个字符串b和一个包含较短字符串的数组T，设计一个方法，根据T中的每一个较短字符串，对b进行搜索。

::: tip    
#479，#581，#616，#742
:::

## 17.18 最短超串
  > 假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。
    
    示例：
        输入：{1, 5, 9} | {7, 5, 9, 0, 2, 1, 3, 5, 7, 9, 1,1, 5, 8, 8, 9, 7}
        输出：[7, 10] (the underlined portion above)

::: tip            
#644，#651，#668，#680，#690，#724，#730，#740
:::

## 17.19 消失的两个数字
  > 给定一个数组，包含从1到N所有的整数，但其中缺了一个。你能在O(N)时间内只用O(1)的空间找到它吗？如果是缺了两个数字呢？

::: tip    
#502，#589，#608，#625，#648，#671，#688，#695，#701，#716
:::

## 17.20 连续中值
  > 随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值并保存。

::: tip    
#518，#545，#574，#708
:::

## 17.21 直方图的水量
  > 给定一个直方图（也称柱状图），假设有人从上面源源不断地倒水，最后直方图能存多少水量？直方图的宽度为1。
    
    示例：
        输入：{0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0}
        输出：26

::: tip        
#628，#639，#650，#657，#661，#675，#692，#733，#741
:::

## 17.22 单词转换
  > 给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词，但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。
    
    示例：
        输入：DAMP, LIKE
        输出：DAMP -> LAMP ->LIMP ->LIME ->LIKE
    
::: tip        
#505，#534，#555，#579，#597，#617，#737
:::

## 17.23 最大黑方阵
  > 给定一个方阵，其中每个单元（像素）非黑即白。设计一个算法，找出4条边皆为黑色像素的最大子方阵。

::: tip    
#683，#694，#704，#713，#720，#735
:::

## 17.24 最大子矩阵
  > 给定一个正整数和负整数组成的N×N矩阵，编写代码找出元素总和最大的子矩阵。

::: tip
#468，#510，#524，#538，#564，#580，#594，#614，#620
:::

## 17.25 单词矩阵
  > 给定一份几百万个单词的清单，设计一个算法，创建由字母组成的最大矩形，其中每一行组成一个单词（自左向右），每一列也组成一个单词（自上而下）。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。

::: tip
#476，#499，#747
:::

## 17.26 稀疏相似度
  > 两个（具有不同单词的）文档的交集（intersection）中元素的个数除以并集（union）中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3}和{1, 7, 2, 3}的相似度是0.4，其中，交集的元素有2个，并集的元素有5个。
    
  > 给定一系列的长篇文档，每个文档元素各不相同，并与一个ID相关联。它们的相似度非常“稀疏”，也就是说任选2个文档，相似度都很接近0。请设计一个算法返回每对文档的ID及其相似度。
  
  > 只需输出相似度大于0的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。
    
    示例：
    输入：
        13: {14, 15, 100, 9, 3}
        16: {32, 1, 9, 3, 5}
        19: {15, 29, 2, 6, 8, 7}
        24: {7, 10}
    输出：
        ID1, ID2  : SIMILARITY
        13, 19    : 0.1
        13, 16    : 0.25
        19, 24    : 0.14285714285714285

::: tip        
#483，#497，#509，#517，#533，#546，#554，#560，#568，#576，#583，#602，#610，#635
:::
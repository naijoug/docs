---
title: 链表
icon: hashtag

index: true

---

> 02 链表 (8)

<!-- more -->

## 2.1 移除重复节点
  > 编写代码，移除未排序链表中的重复节点。
    
  进阶：如果不得使用临时缓冲区，该怎么解决？

## 2.2 返回倒数第k个节点
  > 实现一种算法，找出单向链表中倒数第k个节点。

## 2.3 删除中间节点
  > 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。
    
    示例：
        输入：单向链表a->b->c->d->e->f中的节点c
        结果：不返回任何数据，但该链表变为a->b->d->e->f
    
## 2.4 分割链表
  > 编写程序以x为基准分割链表，使得所有小于x的节点排在大于或等于x的节点之前。如果链表中包含x，x只需出现在小于x的元素之前（如下所示）。分割元素x只需处于“右半部分”即可，其不需要被置于左右两部分之间。
    
    示例：
        输入：3-> 5-> 8-> 5-> 10-> 2-> 1 [分节点为5]
        输出：3-> 1-> 2-> 10-> 5-> 5-> 8
    
## 2.5 链表求和
  > 给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。
    
    示例：
        输入：(7-> 1-> 6) + (5-> 9-> 2)，即617 + 295
        输出：2-> 1-> 9，即912
    
  进阶：假设这些数位是正向存放的，请再做一遍。
    
    示例：
        输入：(6-> 1-> 7) + (2-> 9-> 5)，即617 + 295
        输出：9-> 1-> 2，即912
    
## 2.6 回文链表
  > 编写一个函数，检查链表是否为回文。
  
## 2.7 链表相交
  > 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
  
## 2.8 环路检测
  > 给定一个有环链表，实现一个算法返回环路的开头节点。有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。
    
    示例：
        输入：A -> B -> C -> D -> E -> C（C节点出现了两次）
        输出：C
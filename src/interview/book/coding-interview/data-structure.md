---
title: 数据结构
icon: hashtag

index: true
order: 1

---

> 数据结构 (45)

<!-- more -->

## 字符串 (9)

### 【05】替换空格
  > 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
    
::: details 💡

:::
    
### 【19】正则表达式匹配
  > 请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab\*a"均不匹配
    
::: details 💡

:::
    
### 【20】表示数值的字符串
  > 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
    
::: details 💡

:::
    
### 【38】字符串的排列
  > 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
    
::: details 💡

:::
    
### 【46】把数字翻译成字符串
  > 给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b”，……，11翻译成“1”,……，25翻译成“z”。一个数字可能有多个翻译。例如：12258有5种不同的翻译，分别是“bccfi”、“bwfi”、“bczi”、“mcfi”和“mzi”。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
    
::: details 💡

:::
    
### 【48】最长不含重复字符的子字符串
  > 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含 'a'~'z' 的字符。例如，在字符串 "arabcacfr" 中，最长的不含重复的子字符串是 "acfr"，长度为4。

::: details 💡

:::

### 【50】第一次只出现一次的字符
    
  - 字符串中第一个只出现一次的字符
    > 在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置
    
::: details 💡

:::
        
  - 字符流中第一个自出现一次的字符
    > 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
        
::: details 💡

:::

### 【58】翻转字符串
    
  - 翻转单词顺序
    > 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如，输入字符串“I am a student.”，则输出“student. a am I”。
        
::: details 💡

| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(n)  | O(n)  | 使用一个栈来保存遍历每一个字符，然后出栈赋值回原字符串
| 2 | O(1)  | O(n/2)| 使用头尾指针往中间遍历交换，直到两个指针相遇 

:::  
        
  - 左旋转字符串
    > 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋操作的功能。例如，输入字符串“abcdefg”和数字2，该函数将返回左旋两位得到的结果“cdefgab”。
    
::: details 💡

:::
        
### 【67】把字符串转换成整数
  > 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
    
::: details 💡

:::

## 数组 (11)

### 【03】数组中重复的数字
    
  - 找出数组中重复的数字    
    > 在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}, 那么对应的输出是重复的数字 2 或者 3。
        
::: details 💡
        
【思路1】集合，遍历数组放入集合，放入时判断是否集合中已存在，如果已存在则返回结果
        
【思路2】哈希表，与 思路1 相识求解过程
        
【思路3】数组，使用一个长度的为 n 的额外数组作为计数数组，类似计数排序，遍历数组中的数字，将数字对应的位置的计数数组加1。如果计数数组该位置已经为1，则返回结果。
        
【思路4】布尔数组，进一步优化 思路3，直接使用布尔数组标记该位置是否已存在数。
        
【思路5】思路1 ~ 思路4 都是使用哈希表的方案只是使用的数据结构不同，都是需要 O(n) 的空间复杂度。如果不使用额外空间，完全可以将当前数组当做计数数组，利用数字与数组下标的对应关系，每次遍历时将数字交换到对应下标位置，如果对应下标数字已经与下标匹配，则返回结果。
        
:::
        
  - 不修改数组找出重复的数字
    > 在一个长度为 n+1 的数组里的所有数字都在 0~n 的范围内，数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但是不能修改输入的数组。例如，如果输入长度为 8 的数组 {2,3,5,4,3,2,6,7}, 那么对应的输出是重复的数字 2 或者 3。
    
::: details 💡
     
【思路】不修改数组，就只能改用上面哈希表的思路(1 ~ 4)。

:::

::: details 📈
    
  | 解法 | 空间复杂度 | 时间复杂度 | 思路
  | --- | --- | --- | ---
  | 1     | O(n)  | O(n)          | 哈希法，遍历数组，用一个 n 位数组(或哈希表)按角标 i 保存对应数
  | 2     | O(1)  | O(n*log n)    | 排序法，将数组排序之后比较前后两个数
  | 3     | O(1)  | O(n)          | 原地哈希法，遍历当前数组，比较角标 i 和当前数，如果相等则跳过；如果不相等，则与当前数相等的角标交换，直到当前角标 i 与交换后数相等，则进行下一次循环。

:::


### 【04】二维数组中的查找
  > 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

::: details 💡

【思路1】遍历整个二维数组进行判断
    
【思路2】查找的关键在于缩小范围，思路1 没有利用题目给定的有利条件行列的有序性。关键点在于如何遍历可以利用这个有序条件。  
  二维数组四个顶点
    - 左上角开始遍历两个方向都是递增无法缩减范围。
    - 右下角开始遍历两个方向都是递减无法缩减范围。
    - 右上角遍历行方向递减，列方向递增，目标值如果小于该位置值，则可以过滤掉该列；如果目标值大于该位置值，则可以过滤掉该行，如果等于则返回结果。
    - 左下角同右上角一样可以缩小范围，过滤方向相反而已。
    

| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(1)  | O((i + j)/2)  | 使用 (row, column) 遍历二维数组，每次比较右上角元素；如果大于右上角元素，row++；如果小于右上角元素，column--

:::

### 【21】调整数组顺序使奇数位于偶数前面
  > 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

::: details 💡

【思路1】遍历数组，用两个额外数组分别保存奇数和偶数，最后将两个数组合并返回结果，使用了 O(n) 的空间复杂度
    
【思路2】尾部插入法，遍历数组遇到偶数，将后面的数组整体往前移动，最后将偶数插入到数组尾部，重复改操作，直至调整完毕。该方案可以保证数据的相对位置不变，由于存在每次移动数组的操作，时间复杂度 O(n²)

【思路3】双指针法，数组头部指针往后寻找第一个偶数，尾部指针往前寻找第一个奇数，将两个位置元素进行交换；继续该操作直至两个指针相遇，调整完毕。这样会导致元素相对位置发生变化，不符合要求 ❎


| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(n)  | O(n)  | 遍历数组，使用两个数组，分别保存奇数和偶数，然后赋值回原数组
| 2 | O(1)  | O(n²) | 尾部插入法，遍历数组，遇到偶数，向前移动数组，将偶数插入到尾部
| 3 | O(1)  | O(n)  | 双指针法，头尾指针遍历，进行奇数和偶数的交换

:::

### 【29】顺时针打印矩阵
  > 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
  
::: details 💡

【思路】二维数组的遍历，需要控制好每次转向的边界，以及遍历结束条件
    
| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(n)  | O(n)  | 根据二维数组的 (row, column) 边界，判断好遍历条件

:::

### 【39】数组中出现次数超过一半的数字
  > 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
  
::: details 💡

【思路1】使用哈希表进行计数，每次计数增加之后，判断是否超过数组长度一半，如果超过，则返回结果。使用了 O(n) 空间复杂度。
    
【思路2】先将数组进行排序，排序之后，遍历数组，判断相邻数字相等进行计数，如果计数超过数组长度一半，则返回结果。
    
【思路3】
    
| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(?)  | O(n)          | 哈希法，遍历数组，使用哈希表保存遍历数字的计数
| 2 | O(1)  | O(n*log n)    | 排序法，先排好序，遍历统计每个数字的个数
| 3 | O(1)  | O(2n)         | 计分法，使用 count 计分，number 为可能值，遍历数组，如果可能值与当前数相等 count++；如果不相等 count--；如果 count == 0，修改可能值为当前数；遍历完，最后剩下 count > 0 的可能数就有可能超过一半。再循环遍历一次数组统计可能数的个数。

:::
    
### 【44】数字序列中某一位的数字
  > 数字以 0123456789101112131415...的格式序列化一个字符序列中。在这个序列中，第 5 位(从 0 开始计数)是 5，第 13 位是 1，第 19 位是 4，等等。请写一个函数，求任意第 n 位对应的数字。

::: details 💡

【思路1】可以很自然的想到转化字符数组，直接通过数组下标取值。
    
【思路2】

| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(1)  | O(1)  | 转化为字符数组，按数组下标取值

:::

### 【45】把数组排成最小的数
  > 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
    
::: details 💡

【思路1】排列组合问题，全排列之后，比较大小
    
【思路2】

| 解法 | 空间复杂度 | 时间复杂度 | 思路
| --- | --- | --- | ---
| 1 | O(n)  | O(1)  | 按照数组中的最长数补齐其它数，比较大小，按照从小到大合成最小数
| 2 | O(?)  | O(?)  | 全排列

:::

### 【49】丑数
  > 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
  
::: details 💡

:::  

### 【51】数组中的逆序对
  > 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

::: details 💡

【疑问点】逆序对的定义，前后两个数已经组成逆序对，那下一个逆序对判断是否跳过这两个数？也就是说一个数是否可以组成前后两个逆序对？

【思路1】按照不能重复使用的原则，遍历数组，如果组成了逆序对则跳过两个索引，如果不能组成逆序对则跳过一个索引。

:::

### 【56】数组中数字出现的次数
    
  - 数组中只出现一次的两个数字
    > 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度O(n)，空间复杂度O(1)。
    
::: details 💡

:::
    
  - 数组中唯一只出现一次的数字
    > 在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出哪个只出现一次的数字。
    
::: details 💡

:::
        
### 【66】构建乘积数组
  > 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0] x A[1] x ... x A[i-1] x A[i+1] x ... x A[n-1]。不能使用除法。

::: details 💡

:::
    
## 链表 (8)

### 【06】从尾到头打印链表
  > 输入一个链表，从尾到头打印链表每个节点的值。

::: details 💡

:::
    
### 【18】删除链表的节点
    
  - 在 O(1) 时间内删除链表节点
    > 给定单向链表的头指针和一个节点指针，定义一个函数在 O(1) 时间内删除该节点。
    
::: details 💡

:::
        
  - 删除链表中重复的节点
    > 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
        
::: details 💡

:::
        
### 【22】链表中倒数第 k 个节点
  > 输入一个链表，输出该链表中倒数第k个结点。为符合计数习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如：一个链表有6个节点，从头节点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
    
::: details 💡

:::
    
### 【23】链表中环的入口结点
  > 如果一个链表中包含环，请找出该链表的环的入口结点。例如：在1->2->3->4->5->6->3的链表中，包含一个环，环的入口节点是3。
    
::: details 💡

:::
    
### 【24】反转链表
  > 输入一个链表，反转链表后，输出反转链表的头结点。

::: details 💡

:::

### 【25】合并两个排序链表
  > 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调递增规则。例如：链表1：1->3->5；链表2：2->4->6；合并后为：1->2->3->4->5->6。
    
::: details 💡

:::
    
### 【35】复杂链表的复制
  > 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    
::: details 💡

:::
    
### 【52】两个链表的第一个公共节点
  > 输入两个链表，找出它们的第一个公共结点。
    
::: details 💡

:::
    
## 栈 & 队列 (4)

### 【9】用两个栈实现队列
  > 用两个栈来实现一个队列。实现该队列的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。队列中的元素为int类型。
    
::: details 💡

:::
    
### 【30】包含 min 函数的栈
  > 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用min、push以及pop的时间复杂度都是O(1)。
    
::: details 💡

:::
    
### 【31】栈的压入、弹出序列
  > 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
    
::: details 💡

:::
    
### 【59】队列的最大值
    
  - 滑动窗口的最大值
    > 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
      例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
        
::: details 💡

:::
        
  - 队列的最大值
    > 请定义一个队列并实现函数 max 得到队列里的最大值，要求函数 max、push_back 和 pop_front 的时间复杂度都是 O(1)。

::: details 💡

:::
        
## 树 (13)

### 【7】重建二叉树
  > 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
    
::: details 💡

:::
    
### 【8】二叉树的下一个结点
  > 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

::: details 💡

:::

### 【26】树的子结构
  > 输入两棵二叉树A，B，判断B是不是A的子结构。

::: details 💡

:::

### 【27】二叉树的镜像
  > 操作给定的二叉树，将其变换为源二叉树的镜像。
    输入描述:
    二叉树的镜像定义:
    源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9  11
    镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
       11  9 7  5
    
::: details 💡

:::
    
### 【28】对称的二叉树
  > 请实现一个函数，用来判断一棵二叉树是不是对称的。如果二叉树和它的镜像一样，那么它是对称的。
    
::: details 💡

:::
    
### 【32】从上到下打印二叉树
    
  - 不分行从上到下打印二叉树
    > 从上倒下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
        
::: details 💡

:::
        
 - 分行从上到下打印二叉树
    > 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
        
::: details 💡

:::
        
  - 之字形打印二叉树
    > 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
        
::: details 💡

:::
        
### 【33】二叉搜索树的后序遍历序列
  > 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。例如，输入数组{5,7,6,9,11,10,8}，则返回true，因为这个整数序列是可以展开为一二叉搜索树的后序遍历结果。如果输入的数组是{7,4,6,5}，则由于没有哪棵二叉搜索树的后序遍历结果是这个序列，因此返回false。
    
::: details 💡

:::
    
### 【34】二叉树中和为某一值的路径
  > 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
    
::: details 💡

:::
    
### 【36】二叉搜索树与双向链表
  > 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

::: details 💡

:::
    
### 【37】序列化二叉树
  > 请实现两个函数，分别用来序列化和反序列化二叉树
    
::: details 💡

:::
    
### 【54】二叉搜索树的第 k 大节点
  > 给定一颗二叉搜索树，请找出其中的第k大的结点。
    例如， 
             5 
            / \ 
           3   7 
          /\   /\ 
         2  4 6  8 
     中，按结点数值大小顺序第三个结点的值为4。
    
::: details 💡

:::
    
### 【55】二叉树的深度
    
  - 二叉树的深度
    > 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
        
::: details 💡

:::
        
  - 平衡二叉树
    > 输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
        
::: details 💡

:::
        
### 【68】数中两个节点的最低公共祖先
  > 输入两个树节点，求他们的最低公共祖先。
   
::: details 💡

  - 二叉树（二叉搜索树）：二叉搜索树是排序的，如果当前节点大于两个节点的值，去左子树中寻找；如果当前节点小于两个节点的值，去右子树中寻找；如果当前节点位于两个节点值之间，则该节点就是要寻找的最低公共祖先。
  - 普通树（存在指向父节点的指针）：从给定节点出发，由父节点指针回到到根结点，形成链表。从而将问题转化为求两个链表的第一个公共节点的问题。
  - 普通树（不存在指向父节点的指针）：利用两个辅助链表通过递归遍历的方法找到两条到达给定节点的路径，寻找两个链表最后一个公共节点，就是最低公共祖先。
  
:::
    

    
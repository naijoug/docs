---
title: React
icon: hashtag

index: true

---

<!-- more -->

## 组件

### ❓函数组件与类组件有什么区别

::: details 💡

函数组件与类组件的主要区别如下：

1. **语法**：函数组件是一个简单的JavaScript函数，而类组件需要继承自`React.Component`。
2. **状态管理**：类组件可以使用`this.state`和`this.setState`来管理状态，而函数组件通常使用React Hooks（如`useState`）来管理状态。
3. **生命周期方法**：类组件可以使用生命周期方法（如`componentDidMount`、`componentDidUpdate`等），而函数组件通过`useEffect` Hook来实现类似的功能。
4. **性能**：函数组件通常比类组件更轻量，且在React的后续版本中，函数组件的性能得到了显著提升。
5. **代码简洁性**：函数组件通常更简洁，易于理解和维护。

随着React的发展，函数组件和Hooks已经成为编写React组件的首选方式。

:::

### ❓React中的受控组件和非受控组件是什么

::: details 💡

**受控组件**和**非受控组件**是React中处理表单输入的两种方式：

1. **受控组件**：
   - 表单数据由React组件的state控制
   - 每当输入值变化时，都会调用onChange等事件处理函数更新state
   - 表单的当前值存储在组件state中，而不是DOM元素中
   - 更容易实现表单验证和禁用提交按钮等功能
   - 示例：
     ```jsx
     function ControlledForm() {
       const [value, setValue] = useState('');
       
       return (
         <input 
           value={value} 
           onChange={(e) => setValue(e.target.value)} 
         />
       );
     }
     ```

2. **非受控组件**：
   - 表单数据由DOM本身处理
   - 使用ref获取表单值，而不是通过事件处理函数
   - 不需要为每个状态更新编写事件处理函数
   - 适合简单的表单或与非React代码集成
   - 示例：
     ```jsx
     function UncontrolledForm() {
       const inputRef = useRef(null);
       
       function handleSubmit() {
         console.log(inputRef.current.value);
       }
       
       return (
         <input ref={inputRef} defaultValue="默认值" />
       );
     }
     ```

选择使用哪种方式取决于具体需求，但React官方推荐使用受控组件，因为它们更符合React的数据流理念。

:::

### ❓如何在React中实现组件通信

::: details 💡

React组件之间有多种通信方式：

1. **父组件向子组件通信**：通过props传递数据
   ```jsx
   function Parent() {
     const data = "Hello from parent";
     return <Child message={data} />;
   }
   
   function Child({message}) {
     return <p>{message}</p>;
   }
   ```

2. **子组件向父组件通信**：通过回调函数
   ```jsx
   function Parent() {
     const handleChildData = (data) => {
       console.log("从子组件收到:", data);
     };
     
     return <Child onSendData={handleChildData} />;
   }
   
   function Child({onSendData}) {
     return (
       <button onClick={() => onSendData("子组件数据")}>
         发送数据到父组件
       </button>
     );
   }
   ```

3. **兄弟组件通信**：通过共同的父组件作为中介
   ```jsx
   function Parent() {
     const [data, setData] = useState("");
     
     return (
       <>
         <SiblingA onSendData={setData} />
         <SiblingB receivedData={data} />
       </>
     );
   }
   ```

4. **跨层级组件通信**：
   - 使用Context API
     ```jsx
     const DataContext = createContext();
     
     function DataProvider({children}) {
       const [data, setData] = useState("共享数据");
       
       return (
         <DataContext.Provider value={{data, setData}}>
           {children}
         </DataContext.Provider>
       );
     }
     
     function DeepChild() {
       const {data} = useContext(DataContext);
       return <p>{data}</p>;
     }
     ```
   
   - 使用状态管理库如Redux或MobX

5. **全局事件**：使用自定义事件或第三方事件库

选择哪种通信方式取决于组件的关系和应用的复杂度。对于简单应用，props和回调通常足够；对于复杂应用，Context或状态管理库可能更合适。

:::

## 生命周期

### ❓React组件的生命周期有哪些阶段

::: details 💡

React类组件的生命周期可以分为三个主要阶段：

1. **挂载阶段(Mounting)**：组件被创建并插入DOM
   - `constructor()` - 初始化state和绑定方法
   - `static getDerivedStateFromProps()` - 根据props更新state
   - `render()` - 渲染组件
   - `componentDidMount()` - 组件挂载后执行，适合进行API调用、订阅等

2. **更新阶段(Updating)**：组件重新渲染，可由props或state变化触发
   - `static getDerivedStateFromProps()` - 同上
   - `shouldComponentUpdate()` - 决定组件是否需要重新渲染
   - `render()` - 重新渲染组件
   - `getSnapshotBeforeUpdate()` - 在DOM更新前捕获一些信息
   - `componentDidUpdate()` - 组件更新后执行，可以进行DOM操作或网络请求

3. **卸载阶段(Unmounting)**：组件从DOM中移除
   - `componentWillUnmount()` - 组件卸载前执行，用于清理工作如取消订阅、定时器等

**错误处理**：
- `static getDerivedStateFromError()` - 渲染备用UI
- `componentDidCatch()` - 记录错误信息

**注意**：以下生命周期方法已被标记为过时，应避免使用：
- `componentWillMount()`
- `componentWillReceiveProps()`
- `componentWillUpdate()`

在函数组件中，可以使用Hooks（如`useEffect`）来模拟生命周期行为：
```jsx
// 模拟componentDidMount
useEffect(() => {
  // 执行副作用
  return () => {
    // 清理函数，模拟componentWillUnmount
  };
}, []); // 空依赖数组表示只在挂载和卸载时执行

// 模拟componentDidUpdate
useEffect(() => {
  // 当依赖项变化时执行
}, [dependency1, dependency2]);
```

:::

### ❓componentDidMount和useEffect有什么区别

::: details 💡

`componentDidMount`和`useEffect`都用于处理副作用，但有几个重要区别：

1. **执行时机**：
   - `componentDidMount`：仅在组件首次渲染后执行一次
   - `useEffect`：默认情况下在每次渲染后执行，但可以通过依赖数组控制

2. **使用场景**：
   - `componentDidMount`：仅用于类组件
   - `useEffect`：仅用于函数组件

3. **清理机制**：
   - `componentDidMount`：需要在`componentWillUnmount`中手动清理
   - `useEffect`：可以返回一个清理函数，React会在组件卸载或下一次effect执行前调用它

4. **条件执行**：
   - `componentDidMount`：总是在首次渲染后执行
   - `useEffect`：可以通过依赖数组控制何时执行
     ```jsx
     // 仅在挂载和卸载时执行，模拟componentDidMount
     useEffect(() => {
       // 执行代码
       return () => {
         // 清理代码，相当于componentWillUnmount
       };
     }, []); // 空依赖数组
     
     // 当count变化时执行
     useEffect(() => {
       document.title = `点击了${count}次`;
     }, [count]);
     
     // 每次渲染后执行
     useEffect(() => {
       // 执行代码
     }); // 没有依赖数组
     ```

5. **同步性**：
   - `componentDidMount`：同步执行
   - `useEffect`：默认异步执行（在浏览器绘制后），可以使用`useLayoutEffect`实现同步效果

6. **多个实例**：
   - `componentDidMount`：一个组件只能有一个
   - `useEffect`：一个组件可以有多个，按声明顺序执行

理解这些区别有助于在迁移类组件到函数组件时正确使用Hooks。

:::

## Hooks

### ❓React Hooks的主要优势是什么

::: details 💡

React Hooks的主要优势包括：

1. **简化组件逻辑**：Hooks允许在不使用类的情况下使用状态和其他React特性，使代码更简洁。

2. **更好的代码复用**：自定义Hooks使逻辑复用变得简单，避免了高阶组件和render props带来的"嵌套地狱"。

3. **关注点分离**：可以根据相关功能而不是生命周期方法组织代码，使相关逻辑集中在一起。
   ```jsx
   // 传统类组件中，相关逻辑分散在不同生命周期方法中
   componentDidMount() {
     this.fetchData();
     window.addEventListener('resize', this.handleResize);
   }
   
   componentDidUpdate(prevProps) {
     if (prevProps.id !== this.props.id) {
       this.fetchData();
     }
   }
   
   componentWillUnmount() {
     window.removeEventListener('resize', this.handleResize);
   }
   
   // 使用Hooks，相关逻辑可以集中在一起
   useEffect(() => {
     fetchData();
     
     return () => {
       // 清理代码
     };
   }, [id]);
   
   useEffect(() => {
     window.addEventListener('resize', handleResize);
     return () => {
       window.removeEventListener('resize', handleResize);
     };
   }, []);
   ```

4. **避免this关键字**：不需要理解JavaScript中this的工作方式，减少了常见的错误来源。

5. **更好的类型推断**：在TypeScript中，Hooks通常比高阶组件有更好的类型推断。

6. **减少包大小**：函数组件通常比类组件编译后的代码更小。

7. **更容易测试**：纯函数更容易测试，自定义Hooks可以独立测试。

8. **渐进式采用**：可以在现有项目中逐步采用Hooks，不需要重写所有组件。

9. **更好的开发者体验**：减少了模板代码，使组件更易于理解和维护。

10. **未来兼容性**：React团队表示，Hooks是React的未来发展方向。

:::

### ❓解释useState和useEffect的基本用法

::: details 💡

**useState**和**useEffect**是React最常用的两个Hooks。

**useState** - 在函数组件中添加状态：

```jsx
import React, { useState } from 'react';

function Counter() {
  // 声明一个名为count的state变量，初始值为0
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>你点击了{count}次</p>
      <button onClick={() => setCount(count + 1)}>
        点击我
      </button>
      {/* 使用函数式更新，适用于基于先前状态更新的情况 */}
      <button onClick={() => setCount(prevCount => prevCount + 1)}>
        函数式更新
      </button>
      <button onClick={() => setCount(0)}>重置</button>
    </div>
  );
}
```

useState的关键特性：
1. 返回一个包含两个元素的数组：当前状态值和更新函数
2. 可以多次调用useState来声明多个状态变量
3. 初始状态可以是任何类型：数字、字符串、布尔值、对象、数组等
4. 更新函数可以接收新值或基于先前状态计算新值的函数
5. 与类组件的setState不同，useState不会自动合并对象

**useEffect** - 处理副作用（如数据获取、订阅、DOM操作等）：

```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [count, setCount] = useState(0);
  
  // 示例1：仅在组件挂载和卸载时执行（模拟componentDidMount和componentWillUnmount）
  useEffect(() => {
    console.log('组件已挂载');
    
    // 返回清理函数
    return () => {
      console.log('组件将卸载');
    };
  }, []); // 空依赖数组
  
  // 示例2：在组件挂载时获取数据
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch('https://api.example.com/data');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []); // 空依赖数组表示仅在挂载时执行
  
  // 示例3：当count变化时执行
  useEffect(() => {
    document.title = `点击了${count}次`;
  }, [count]); // 依赖数组包含count
  
  // 示例4：每次渲染后执行
  useEffect(() => {
    console.log('组件已更新');
  }); // 没有依赖数组
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        点击了{count}次
      </button>
      
      {loading && <p>加载中...</p>}
      {error && <p>错误: {error.message}</p>}
      {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
```

useEffect的关键特性：
1. 默认在每次渲染后执行
2. 第二个参数（依赖数组）控制何时执行
3. 可以返回一个清理函数，在组件卸载或下一次effect执行前调用
4. 可以在一个组件中多次使用useEffect，按声明顺序执行
5. 异步执行，不会阻塞浏览器绘制（如需同步执行，可使用useLayoutEffect）

:::

### ❓什么是自定义Hook，如何创建

::: details 💡

自定义Hook是一种复用状态逻辑的机制，它不复用状态本身，而是复用状态逻辑。自定义Hook是一个以"use"开头的JavaScript函数，可以调用其他Hook。

**创建自定义Hook的步骤**：

1. 创建一个以"use"开头的函数（这是一个约定，让React知道这是一个Hook）
2. 在函数内部使用React内置的Hook
3. 确定Hook需要的参数和返回值
4. 在组件中使用自定义Hook

**示例1：创建一个管理表单字段的Hook**

```jsx
// 自定义Hook: useFormField
function useFormField(initialValue = '') {
  const [value, setValue] = useState(initialValue);
  
  function handleChange(e) {
    setValue(e.target.value);
  }
  
  return {
    value,
    onChange: handleChange,
    reset: () => setValue(initialValue)
  };
}

// 使用自定义Hook
function SignupForm() {
  const name = useFormField('');
  const email = useFormField('');
  const password = useFormField('');
  
  function handleSubmit(e) {
    e.preventDefault();
    console.log({
      name: name.value,
      email: email.value,
      password: password.value
    });
    
    // 重置表单
    name.reset();
    email.reset();
    password.reset();
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input placeholder="姓名" {...name} />
      <input placeholder="邮箱" type="email" {...email} />
      <input placeholder="密码" type="password" {...password} />
      <button type="submit">注册</button>
    </form>
  );
}
```

**示例2：创建一个数据获取Hook**

```jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (isMounted) {
          setData(result);
          setError(null);
        }
      } catch (err) {
        if (isMounted) {
          setError(err.message);
          setData(null);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      isMounted = false;
    };
  }, [url]);
  
  return { data, loading, error };
}

// 使用自定义Hook
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`https://api.example.com/users/${userId}`);
  
  if (loading) return <p>加载中...</p>;
  if (error) return <p>错误: {error}</p>;
  if (!data) return <p>无数据</p>;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>Email: {data.email}</p>
      <p>Phone: {data.phone}</p>
    </div>
  );
}
```

**自定义Hook的优势**：

1. **逻辑复用**：在多个组件之间共享逻辑，而不需要更改组件结构
2. **关注点分离**：将复杂组件的逻辑拆分为更小、更易管理的单元
3. **可测试性**：自定义Hook可以独立测试
4. **可组合性**：可以组合多个自定义Hook创建更复杂的功能

**注意事项**：

1. 自定义Hook必须以"use"开头（React的lint规则会强制执行）
2. 每次调用Hook都会获得独立的状态
3. 可以在自定义Hook中调用其他自定义Hook
4. 只能在React函数组件或其他自定义Hook中调用Hook

:::

### ❓useCallback和useMemo的区别和使用场景

::: details 💡

`useCallback`和`useMemo`都是用于性能优化的React Hooks，它们通过记忆化（memoization）避免不必要的计算或渲染，但有不同的用途：

**useCallback**：
- **用途**：记忆化**函数引用**
- **返回值**：记忆化的函数
- **使用场景**：
  - 将回调函数传递给依赖引用相等性的子组件（如使用React.memo包装的组件）
  - 当函数作为其他Hook的依赖项时

```jsx
import React, { useState, useCallback } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(0);
  
  // 没有使用useCallback - 每次渲染都会创建新函数
  const handleClickNormal = () => {
    setCount(count + 1);
  };
  
  // 使用useCallback - 只有当count变化时才会创建新函数
  const handleClickMemoized = useCallback(() => {
    setCount(count + 1);
  }, [count]); // 依赖数组
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Other state: {otherState}</p>
      
      {/* 即使otherState变化导致父组件重新渲染，MemoizedChild也不会重新渲染 */}
      <MemoizedChild onIncrement={handleClickMemoized} />
      
      <button onClick={() => setOtherState(otherState + 1)}>
        更新其他状态
      </button>
    </div>
  );
}

// 使用React.memo包装的子组件，只有当props变化时才会重新渲染
const MemoizedChild = React.memo(function Child({ onIncrement }) {
  console.log('Child组件渲染');
  return <button onClick={onIncrement}>增加计数</button>;
});
```

**useMemo**：
- **用途**：记忆化**计算结果**
- **返回值**：记忆化的值（可以是任何类型）
- **使用场景**：
  - 避免昂贵的计算
  - 避免创建新的引用（对象、数组等）

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ list, filter }) {
  // 使用useMemo记忆化过滤和排序结果
  const processedList = useMemo(() => {
    console.log('执行昂贵计算');
    
    // 假设这是一个昂贵的操作
    return list
      .filter(item => item.includes(filter))
      .sort()
      .map(item => ({ text: item }));
  }, [list, filter]); // 只有当list或filter变化时才重新计算
  
  return (
    <div>
      <p>过滤条件: {filter}</p>
      <ul>
        {processedList.map((item, index) => (
          <li key={index}>{item.text}</li>
        ))}
      </ul>
    </div>
  );
}

function ParentWithObject() {
  const [name, setName] = useState('');
  const [counter, setCounter] = useState(0);
  
  // 不使用useMemo - 每次渲染都会创建新对象
  const userWithoutMemo = { name, age: 30 };
  
  // 使用useMemo - 只有当name变化时才会创建新对象
  const userWithMemo = useMemo(() => {
    return { name, age: 30 };
  }, [name]);
  
  return (
    <div>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="输入名字"
      />
      <button onClick={() => setCounter(c => c + 1)}>
        点击计数: {counter}
      </button>
      
      {/* 即使counter变化导致父组件重新渲染，也只有当name变化时才会重新渲染 */}
      <MemoizedChildWithObject user={userWithMemo} />
    </div>
  );
}

const MemoizedChildWithObject = React.memo(function ChildWithObject({ user }) {
  console.log('ChildWithObject渲染', user);
  return <div>用户: {user.name}, 年龄: {user.age}</div>;
});
```

**主要区别**：
1. `useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`
2. `useCallback` 记忆化函数本身，而 `useMemo` 记忆化函数的执行结果
3. `useCallback` 返回一个函数，而 `useMemo` 可以返回任何值

**使用建议**：
1. 不要过早优化，只在性能问题明显时使用
2. 确保依赖数组正确，否则可能导致bug
3. 使用React DevTools Profiler识别不必要的重新渲染
4. 考虑使用`useReducer`代替多个相关状态和回调
5. 对于简单的UI渲染，记忆化的成本可能超过收益

:::

## 状态管理

### ❓React中状态管理的方式有哪些

::: details 💡

React应用中有多种状态管理方式，从简单到复杂：

1. **组件内部状态**：
   - 使用`useState`或类组件的`this.state`
   - 适用于简单组件的局部状态
   ```jsx
   function Counter() {
     const [count, setCount] = useState(0);
     return (
       <button onClick={() => setCount(count + 1)}>
         点击次数: {count}
       </button>
     );
   }
   ```

2. **状态提升**：
   - 将共享状态提升到最近的共同父组件
   - 通过props向下传递状态和更新函数
   - 适用于少量相关组件共享状态
   ```jsx
   function Parent() {
     const [count, setCount] = useState(0);
     return (
       <>
         <Counter count={count} setCount={setCount} />
         <Display count={count} />
       </>
     );
   }
   ```

3. **Context API**：
   - 避免"props drilling"（通过多层组件传递props）
   - 适用于中等规模应用或特定领域的状态（如主题、用户认证）
   ```jsx
   const CountContext = createContext();
   
   function CountProvider({ children }) {
     const [count, setCount] = useState(0);
     return (
       <CountContext.Provider value={{ count, setCount }}>
         {children}
       </CountContext.Provider>
     );
   }
   
   function DeepChild() {
     const { count, setCount } = useContext(CountContext);
     return (
       <button onClick={() => setCount(count + 1)}>
         点击次数: {count}
       </button>
     );
   }
   ```

4. **Redux**：
   - 集中式状态管理
   - 基于不可变数据和单向数据流
   - 适用于大型应用或复杂状态逻辑
   ```jsx
   // 创建reducer
   function counterReducer(state = { count: 0 }, action) {
     switch (action.type) {
       case 'INCREMENT':
         return { count: state.count + 1 };
       default:
         return state;
     }
   }
   
   // 使用Redux Toolkit简化
   const counterSlice = createSlice({
     name: 'counter',
     initialState: { count: 0 },
     reducers: {
       increment: state => {
         state.count += 1; // 内部使用Immer，实际上是不可变更新
       }
     }
   });
   ```

5. **MobX**：
   - 基于可观察对象的响应式状态管理
   - 相比Redux更少的模板代码
   - 适用于喜欢面向对象风格的开发者
   ```jsx
   class CounterStore {
     count = 0;
     
     constructor() {
       makeAutoObservable(this);
     }
     
     increment() {
       this.count += 1;
     }
   }
   ```

6. **Recoil**：
   - Facebook开发的原子化状态管理
   - 适用于需要细粒度状态控制的应用
   ```jsx
const countState = atom({
  key: 'countState',
  default: 0
});

function RecoilCounter() {
  const [count, setCount] = useRecoilState(countState);
  return (
    <button onClick={() => setCount(count + 1)}>
      点击次数: {count}
    </button>
  );
}
```

7. **Zustand**：
   - 轻量级状态管理库
   - 简单的API，无需样板代码
   - 适用于中小型应用
   ```jsx
   const useStore = create((set) => ({
     count: 0,
     increment: () => set((state) => ({ count: state.count + 1 }))
   }));

   function ZustandCounter() {
     const { count, increment } = useStore();
     return (
       <button onClick={increment}>
         点击次数: {count}
       </button>
     );
   }
   ```

8. **Jotai**：
   - 原子化状态管理，类似Recoil但更轻量
   - 基于原始值构建复杂状态
   - 适用于需要细粒度更新的应用
   ```jsx
   const countAtom = atom(0);
   
   function JotaiCounter() {
     const [count, setCount] = useAtom(countAtom);
     return (
       <button onClick={() => setCount(count + 1)}>
         点击次数: {count}
       </button>
     );
   }
   ```

选择合适的状态管理方案应考虑以下因素：
- 应用规模和复杂度
- 团队熟悉度和偏好
- 性能需求
- 开发体验
- 长期维护成本

对于大多数应用，建议从简单的方案开始（如组件状态、状态提升或Context），随着应用增长再考虑引入专门的状态管理库。

:::
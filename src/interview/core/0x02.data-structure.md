---
title: data structure - “数据结构”
icon: hashtag

index: true

---

<!-- more -->

## 数组

### ❓为什么大部分编程语言中的数组下标都是从 0 开始
    
::: details 💡
    
  这个与数组的结构特性和内存寻址有关系。数组是一块存储相同类型数据的连续内存空间，而数组的指针或引用是指向数组的一个元素的。访问数组其它位置的元素就是计算其位置的指针地址。
  
  如果第一元素下标从 0 开始，则寻址公式为：`a[i] = a0 + i * dataSize`。
  
  如果第一元素下标从 1 开始，则寻址公式为：`a[i] = a1 + (i - 1) * dataSize`。
  
  可以看出如果下标为 0，寻址公式少了一次减法运算，提高了数组的访问效率。

:::

### ❓为什么数组访问效率优于链表
  
::: details 💡
  
  归根到底是因为数组分配的一块连续内存。
  
  其一是数组的访问的可以直接通过下标计算出元素地址，到达了 `O(1)` 的时间复杂度，而链表访问数据需要遍历整个链表时间复杂度为 `O(n)`。
  
  其二是 `CPU` 的缓存机制，因为 `CPU` 访问数据时为了提高效率，每次读取数据时并不是只读指定地址内存，而是读取一个内存块保存到 `CPU` 缓存中。以数组来说会将数组后面的数据以加载到 `CPU` 缓存中，当再次读取数组元素时会直接中缓存中读取。
  
:::

### ❓可变数组的实现原理

::: details 💡 

  > 可变数组，也叫动态数组(比如 `Python`中的 `list` 或者 `C++` 中的 `vector`)。在内部是由固定长度的数组实现的，这种数据结构允许添加和删除元素，可以自动地调整自身的大小以适应当前存储的元素数量。

实现原理：

  - **初始状态**：当创建一个新的动态数组时，会分配一块固定大小的内存空间（比如 16 个元素），这是实际数组。

  - **添加元素**：如果数组空间还有多余，添加元素只需要再最后一个元素后添加新元素，并将数组长度 +1。

  - **数组扩容**：当数组已满，需要添加新元素时，算法会自动创建一个新的更大的数组（比如原本空间大小的 2 倍），然后将旧数组中的所有元素复制到这个新数组里，最后在新数组的尾部添加新元素。然后原数组的内存空间会被释放，原数组将指向新的内存地址。

  - **删除元素**：如果从数组中删除元素，元素数量变少，但是实际分配的内存并不会立即减少。通常会有一个下限阈值，只有当数组剩余的元素数量小于某个比例（如 1/4）时，才会像扩容一样，进行缩容。

时间复杂度分析：单次扩容和缩容的操作是昂贵的，花费为 `O(n)`，但是如果考虑所有元素的添加或删除，这种开销会被平摊，使得每个元素的添加或删除的平均时间复杂度为 `O(1)`。

:::

------

## 链表

### ❓数组可以实现链表吗
 
::: details 💡
 
  可以使用两个数组实现。一个数据数组，一个节点数组(对应数据数组的索引，值为下一个节点的索引)。

:::

### ❓带头链表的好处
  
::: details 💡
  
  带头链表可以简化链表的添加、删除操作。如果是不带头链表，添加时需要判断链表为空的情况，删除时需要判断链表仅剩一个节点的情况。
  
  * 不带头链表 : 链表头节点指向链表的第一个数据节点。链表为空时，头结点为空。
  * 带头链表 : 会有一个不包含数据的节点，头结点一直指向这个节点。链表为空时，也会包含这个头结点。

:::

------

## 栈

### ❓栈的实现
  
::: details 💡
  
  栈的实现核心是通过维护栈顶指针来进行栈操作。
  
  * 顺序栈 : 使用数组实现栈     
  * 链式栈 : 使用链表实现栈   

:::

### ❓栈有哪些使用场景

::: details 💡

  * 函数调用栈 : 函数调用时，在函数作用域内的局部变量，数据的内存分配刚好符合栈先进先出的特性。
  * 表达式求值
  * 括号匹配
  * 浏览器的前进和后退功能
  
:::

------

## 队列

### ❓队列的实现
  
::: details 💡
  
  堆列的实现核心是通过队头指针和队尾指针来进行队列操作。
  
  * 顺序队列 : 使用数组实现队列
  * 链式队列 : 使用链表实现队列

:::

### ❓高级队列了解吗
 
::: details 💡
  
  * 循环队列 : 一般使用数组实现，解决的数组队列的在删除数据时的数据迁移问题。
  
  * 阻塞队列 : 在队列操作中加入阻塞逻辑就是阻塞队列。入队时如果队列已满则阻塞，等待队列有空位置再入队；出队时如果队列为空则阻塞，等队列有数据时再出队。
    > “生产者-消费者” 就是基于阻塞队列实现。
  
  * 并发队列 : 多线程的情况下会有多个线程同时访问队列的情况，就会存在线程安全问题，而加入解决多线程访问安全问题的队列的就是并发队列。
    - 解决多线程并发最普遍的解决方案，在入队操作和出队操作时，进行加锁。
    - 基于数组的循环队列 + `CAS` 原子操作就可以高效的实现并发队列。
  
:::
  
### ❓队列有哪些使用场景
  
::: details 💡
  
  * 线程池
  * 数据库连接池
  * (分布式)消息队列 : `kafaka` 
  
:::

------

## 哈希表

### ❓介绍哈希算法的原理

::: details 💡 

> 哈希（`Hash`）是一种数据处理和存储的技术，可以将任意长度的数据映射到一个固定长度的数据值。这个映射的过程就是哈希函数或哈希算法(散列函数)，映射得到的固定长度的数据值就是哈希值。

工作原理：

  - **输入数据**：可以将任何类型和大小的数据输入到哈希算法中，比如字符串，文件，图片，音视频等。
    
  - **处理数据**：哈希算法将输入数据进行处理和转换，通常会将输入数据分割为等大小的块，然后逐块进行处理。处理方式各种各样，可能是简单的数学运算，也可能是复杂的加密算法，具体取决于所使用的哈希算法。

  - **生成哈希值**：通过处理，将输入数据转化为固定长度的字符串，这个字符串就是哈希值。哈希值的长度取决于所使用的哈希算法，不同的算法生成的哈希值长度可能不同。

主要特性：

  - **确定性**：对于同一个输入，无论运行多少次哈希算法，得到的哈希值总是相同的。
  - **唯一性**：理想情况下，不同的输入应该得到不同的哈希值。然而，实际上由于哈希值的长度有限，所以可能存在不同的输入得到相同的哈希值，这种情况称为哈希冲突。
  - **敏感性**：输入数据的微小改变都会导致哈希值产生巨大的变化，这是哈希算法的 “雪崩效应”。
  - **不可逆性**：从哈希值不能反推出原始数据。这一特性使得哈希算法在密码学和数据校验等领域有很大的应用。

应用场景：

  - 数据检索（哈希表，一种快速查找和存储数据的结构）
  - 密码学（用于生成数字指纹，保护数据的安全性）
  - 文件校验（用于检查文件是否在传输过程中被篡改）

:::

### ❓`hash` 的具体实现，程序里面一个对象怎么通过 `hash` 定位到具体的内存区

::: details 💡 

哈希在程序中的应用主要是通过哈希函数和哈希表实现的。


  - **创建对象**：在程序中创建一个新的对象。这个对象可能是任何类型，比如一个字符串，一个数字，或者一个复杂的自定义数据类型。

  - **计算哈希值**：会使用一个哈希函数（算法）对这个对象进行哈希。哈希函数将获取对象的输入数据，通过一系列的运算，输出一个固定长度的哈希值（可以是数字或字符串）。这个哈希值是打算用来唯一代表这个对象的特征。

  - **用哈希值定位内存**：接着哈希值会用来索引哈希表。哈希表是一种特殊的数据结构，它使用键-值对（哈希值-对象）的方式存储数据。哈希值作为键，用来索引并快速定位到存储对象的内存区。

```py
class MyClass:
    def __init__(self, value):
        self.value = value

object = MyClass(2)
hash_value = hash(object)
hash_table = {hash_value: object}
```

:::

### ❓哈希数组扩容

::: details 💡 

> 哈希表（`HashTable`）或称散列表，使用哈希函数将元素键值映射到该元素在数组中的位置。然而随着哈希表内元素的增加，可能会出现位置冲突（多个元素键值映射到同一位置），或者元素分布过于集中而无法存放新元素，此时就需要对哈希数组进行扩容。

扩容步骤：

  - **创建新的哈希数组**：这个新的数组通常会是原数组大小的两倍（或者其他比例，取决于实际需求和设定）。

  - **重新哈希**：从原哈希数组中取出每个元素，并对每个元素进行重新哈希。因为现在的数组大小已经改变，原来的哈希位置可能需要改变。这一步通常需要重新计算每个键对应的哈希值，并根据新的数组大小计算新的索引位置。

  - **元素迁移**：将每个元素移到新的哈希数组中对应的位置。

优化策略：渐进式 `rehash`，即逐步将旧数组元素移动到新数组，分散 `rehash` 的运算开销。

:::

------

## 树

### ❓`跳表`(`redis`) vs `B+ 树`(`mysql`) 的优势和劣势

::: details 💡 

- 跳表
    > 一个可以进行快速查找的数据结构，主要使用在内存数据库和缓存系统（如 `Redis`）中。

  优势:

    * 跳表的一个重要优点是，它的插入和删除操作非常快，时间复杂度为 `O(log n)`。
    * 跳表是一个动态的数据结构，能够自我调整。
    * 跳表在实现上相对简单，和链表相比仅需额外维护多级索引。

  劣势:

    * 跳表的一个主要问题是占用内存较多，因为要存储多级索引。
    * 查询效率方面，跳表查询的效率和树相比可能会略低一些。

- `B+ 树`
    > 被广泛应用于数据库和文件系统中。
    
  优势:
    
    * `B+ 树` 特别适合磁盘或其他直接访问存储设备的数据存储，因为 `B+ 树` 的设计可以最大化减少磁盘 `I/O` 操作。
    * `B+ 树` 的查找效率是稳定的，不会出现最坏情况。
    * `B+ 树` 适合做范围查询，因为 `B+ 树` 的叶子节点形成一个链表。
    
  劣势:
    
    * `B+ 树` 操作相对复杂，插入和删除操作需要进行大量的节点分裂和合并操作。
    * `B+ 树` 需要通过磁盘 `IO` 访问，可能比基于内存的数据结构（如跳表）慢。

:::

### ❓`B+ 树` 相比 `哈希表` 和 `B 树` 的优势之处

::: details 💡 

- `B+ 树` 相比哈希表的优势：

    * **范围查找**：哈希表在处理范围查询的性能上不如 `B+ 树`。由于每个元素的位置都是独立计算出来的，哈希表对于范围查询效率很低，而在 `B+ 树` 中，所有叶子节点都是有序的，所以非常适合范围查询。

    * **储存顺序**：`B+ 树` 的数据是有序的，而哈希表的数据是无序的。有序的数据结构对于有序操作和检索非常重要。
    
    * **哈希碰撞**：哈希表在数据量大的情况下很容易产生哈希碰撞，这时查找效率会降低，而 `B+ 树` 不会有这个问题。

- `B+ 树` 相比 `B 树` 的优势：

    * **磁盘读写性能**：`B+ 树` 的磁盘读写性能比 `B 树` 更优，特别是数据库中的大部分操作都是磁盘 `I/O` 操作，因为 `B+ 树` 的所有叶子节点都是相互链接的，大大提高了区间查询的性能。

    * **查询稳定性**：`B+ 树` 的每一个叶子节点都包含了全部的键值信息，所以每一个关键字查询的路径长度相同，导致所有的查询都有相同的效率；而 `B 树` 中，由于非叶子节点同样存储着键值信息，所以部分关键字查找不需要深入到叶子节点，效率较高。

    * **空间利用率**：由于 `B+ 树` 的分支节点不含有实际的数据，只包含 `key`，因此每个节点所能包含的路由信息更多，树的层级更少，相比 `B 树` 存储相同数量的数据，树就更矮胖一些。
    
:::

------

## 图

### ❓强连通分量算法了解吗

::: details 💡

  > 强连通分量：描述有向图中的一个特性。在有向图中，如果从一个节点A出发，可以通过有向边到达节点B，然后再从节点B出发，通过有向边返回到节点A，那么节点A和节点B就构成了一个强连通分量。如果这样的节点集合在图中有多个，那么这个图就可以分为多个强连通分量。

强连通分量的算法：

  - `Tarjan` 算法：从任意一个节点开始，深度优先搜索整个图，利用一个栈和两个时间戳数组，进行回溯，找到所有的强连通分量。
    
  - `Kosaraju` 算法：先对原图进行一次深度优先搜索，按照退出的顺序（即在 `DFS` 中，最后一个退出 `DFS` 的节点为最先），反向建立新图。然后再对新图进行深度优先搜索，搜索的每一轮所能到达的所有节点，即为一个强连通分量。

  两个算法的时间复杂度都是线性的，即 `O(n + m)`，其中 `n` 是节点数，`m` 是边数。

:::
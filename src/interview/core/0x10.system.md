---
title: system - “操作系统”
icon: hashtag

index: true

---

<!-- more -->

------

## 虚拟内存

### ❓“虚拟内存”是什么？

::: details 💡

  > `Virtual Memory` - “虚拟内存”

:::

### 一个程序当中的地址是虚拟地址还是物理地址？

### 拿到一个虚拟地址后，怎么转成物理地址？

### ❓`TLB` 了解吗？

::: details 💡

  > TLB (Translation Lookaside Buffer) 是一个硬件缓存，系统用 `TLB` 来改进和加速虚拟地址到物理地址的转换过程。

  操作系统通常使用一种叫做分页的内存管理技术，把虚拟地址空间和物理地址空间分割成大小相等的块，称为页面。这种页面映射一般会存储在内存中，但每次地址转换都访问这个映射的开销很大，因此 `TLB` 用于缓存最近使用过的映射，以减少访问内存的次数，加快地址转换速度。

  `TLB` 是一种依赖硬件支持的高速缓存，它提供了从虚拟内存到物理内存的快速转换，使得内存访问更加高效。

:::

------

## 页表

### 行间的换页算法有哪些？

### 页表在 `Linux` 中怎么用的，页式、段式、段页式聊了聊？

### 你是怎么理解页表的？

### 二级页表是什么？

------

## CPU

### `CPU` 是如何调用 `GPU`？

::: details 💡

  图像的成像原理 : 计算中的图像的展示，需要 `CPU`、`GPU` 和显示器合作完成。`CPU` 负责计算图像哪些数据需要显示，`GPU` 负责将需要显示的图像数据渲染，然后放入缓存区，显示器读取缓存区数据将图像显示出来。
  
:::
  
------
  
## 用户态

::: details 💡

  > `User Mode` - “用户态”
  
  > `Kernel Mode` - “核心态”
    
  这个区分是一种安全机制，保证了用户程序不能随意访问操作系统核心数据和硬件，保证了操作系统运行的稳定性和安全性。

- 在用户态运行的代码不能访问操作系统核心数据结构和硬件，不能执行影响操作系统稳定性的操作。
- 核心态运行的代码可以访问操作系统的所有的内存和硬件，大多数操作系统核心程序运行在核心态上，可以执行 CPU 指令，也可以访问所有硬件资源。

:::
  
### 用户态和内核态，什么时候用户态会转为内核态？



### `backtrace` 是在用户态实现吗？能否讲讲实现它的大致思路？

::: details 💡

  先理解两个概念 : `backtrace`、用户态
  
  * `backtrace` 是回溯栈，记录程序运行过程中的调用栈信息，当程序 `Crash` 时，可以通过这个信息了解程序崩溃的上下文，调试程序问题。
  * 用户态是属于操作系统的一个分区概念，主要分为内核态和用户态。两者的区别的是为了保证内核安全，只有以内核态运行的程序才具备操作系统所有资源的访问权限，而以用户态运行的程序会受到限制，这样是为了保证操作系统的稳定运行。

:::

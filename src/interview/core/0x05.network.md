---
title: network - “网络”
icon: hashtag

index: true

---

<!-- more -->

## reference

- []()[2024-06-26 HTTP3 为什么抛弃了经典的 TCP，转而拥抱 QUIC 呢](https://juejin.cn/post/7384266820466180148)
- [](✅)[2023-08-22 POST 为什么会发送两次请求？](https://juejin.cn/post/7269952188927017015)
- []()[2023-02-09 一个网管的自我修养之 TCP 协议](https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&mid=2449471495&idx=1&sn=1e0828e8914355ace477de5c5790f43c&chksm=8fbcb660b8cb3f764887e805636763776fd301036e3b311e501d9732ee676de573ed9636eea7&scene=178&cur_album_id=2773668596047757314#rd)
- [2019-11-13 为什么 DNS 使用 UDP 协议](https://draveness.me/whys-the-design-dns-udp-tcp)
- [2019-10-28 为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake)
- []()[2015-03-07 GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791)

------

## 概念知识

### 网络模型

#### ❓`OSI` 七层模型

::: details 💡

> `OSI`(`Open Systems Interconnection` - 开放系统互连) 模型，是描述和理解复杂网络系统交互和通信机制的重要工具。该模型将网络通信分解为七层，每个层次完成特定的功能，提供下一层所需的接口和服务。

自顶向下：

  - 应用层：负责与软件应用程序（例如 `Web` 浏览器、电子邮件客户端等）交互，以确保发送和接收有效的数据。
  
  - 表示层：负责定义数据格式和加密。
  
  - 会话层：负责在数据封装的端点之间建立、管理和终止连接。
  
  - 传输层：负责提供端到端的可靠传输。主要协议有 `TCP` 和 `UDP`。
  
  - 网络层：负责决定数据的路径和转发，包括 `IP` 地址处理和路由。
  
  - 数据链路层：负责在数据网络中传输数据包，包括错误检测和修正。
  
  - 物理层：负责传输比特流（数据的二进制形式），包括如何通过通信媒介（如电缆、光纤等）进行物理连接，如何识别设备等。

注意：`OSI` 模型并不是任何一个实际的网络协议族，而是作为一个参考模型，帮助人们描述和理解不同网络协议的功能和如何协同工作。

:::

#### ❓`TCP/IP` 五层模型

::: details 💡

自顶向下：

  - 应用层 : `DNS`、`HTTP`、`HTTPS`、`RPC`、`P2P` (`DHCP`、`RTMP`、`GTP`)
    > 应用层包括许多协议，如 `HTTP` 协议，`FTP` 协议，`DNS` 协议，它负责如何处理特定类型的网络连接，即应用程序和网络之间的通信协议。
    
    `OSI` 七层模型中，将应用层细分为(应用层、表示层、会话层)
    
      * 应用层：负责与软件应用程序交互，以确保发送和接收有效的数据。
      * 表示层：负责定义数据格式和加密。
      * 会话层：负责在数据封装的端点之间建立、管理和终止连接。

  - 传输层 : `TCP`、`UDP`、`QUIC`
    > 传输层负责将数据进行分段，并保证这些分段正确无误的到达目的地，再在目的地将这些分段重新组合。`TCP` 和 `UDP` 协议就在这一层。
    
  - 网络层 : (`IP` 层) `IP` (`ICMP`、`OSPF`、`BGP`、`IPSec`、`GRE`)
    > 网络层控制子网的操作，处理将数据包从源传送到目的地的任务，这包括在复杂的网络中处理路由和全局地址。

  - 链路层 : (`MAC` 层) `ARP`、`VLAN`、`STP`
    > 数据链路层在物理层之上，它负责如何在两个节点之间传输数据，处理由物理层的硬件错误产生的问题，例如数据错误，数据丢失等。

  - 物理层 : 
    > 提供了网络通信所需的硬件接口，负责把帧数据转换为适合物理介质的形式，即用来传输比特流。不同的介质和具体的设备有许多协议，例如 `Ethernet`、`Wi-Fi`、`Bluetooth` 等。

:::

#### ❓`TCP/IP` 模型 vs `OSI` 模型

::: details 💡

 `TCP/IP` 模型和 `OSI` 模型都是网络通信模型，都有对网络通信进行分层的思想，但是两者的层数以及每一层承担的责任有所不同。

  - `TCP/IP` 模型是一个五层结构（物理层、数据链路层、网络层、传输层、应用层）；`OSI` 模型则是一个七层结构（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）

  - `TCP/IP` 模型是在 `OSI` 模型基础上简化而来的。在 `TCP/IP` 模型中，`OSI` 模型中的 (会话层、表示层和应用层) 统一归为了应用层，因此 `TCP/IP` 模型的应用层比较复杂。
    
  - 两者在层次划分上的哲学不同。`OSI` 模型倾向于详尽地将网络通信过程中的所有可能的环节进行分层；而 `TCP/IP` 模型更倾向于从实用的角度，基于实际的网络硬件和网络协议进行分层。
  
:::

### ❓为什么能通过一个 `URL` 就能请求到对应的资源

::: details 💡

> `URL`（`Uniform Resource Locator` - 统一资源定位符），它给出了网络上某一资源的绝对位置，其结构包含了请求资源所需的所有信息，因此能够通过 `URL` 向服务器请求并获取资源。

`URL`的基本结构：`protocol://hostname:port/path?query#fragment`

  - `Protocol`（协议）：指定了客户端与服务器需要遵循的通信规则。
    > 例如 `HTTP`、`HTTPS`、`FTP` 等。

  - `Hostname`（主机名）：标识了网络上机器的位置。服务器和客户端通过网络连接进行通信，主机名作为服务器的标识，可以让客户端找到正确的服务器。
    > 例如 `www.google.com`

  - `Port`（端口号）：指定了服务器上的特定服务，每个服务在服务器上都有一个唯一的端口号。

  - `Path`（路径）：指定了服务器上的特定资源。它通常包含了相关文件或者页面的目录结构信息。

  - `Query`（查询）：这部分以 `?` 开头，用于传递额外的参数。在访问动态网页的时候，查询字符串通常用于指定查询参数。
    
  - `Fragment`（片段）：这部分以 `#` 开头，只在客户端浏览器中起作用，用于定位特定的页面元素。

结论：通过以上元素组成的 `URL` 可以精确地定位到网络上的资源，因此可以通过一个 `URL` 就能请求到对应的资源。

:::

### ❓`MTU` 了解吗

::: details 💡

  > `MTU`(Max Transfer Unit)：最大传输单元，指的是网络中一种协议可以在不进行分片的情况下发送的最大数据包大小。

  在网络中，数据包的大小不能超过 `MTU` 大小，否则在发送过程中数据包会被分片。`MTU` 大小的设置取决于发送这些数据包的物理媒介或者网络协议。
  
  > 例如，在以太网中，`MTU` 的大小通常设置为 `1500` 字节。

  当数据包在网络中传输时，可能会经过不同的网络设备，这些设备可能有各自的 `MTU` 大小。为了避免数据包被分片，或者减少数据包的分片次数，路由器和其他网络设备可能采用最小 `MTU`（所有设备中 `MTU` 最小的值）进行发送。

  - 过大的 `MTU`：会导致数据包在传输过程中过于庞大，增大网络负担和延迟。
  - 过小的 `MTU`：会使得数据包过小，分片过多，影响网络效率。

  > 例如：`POST` 请求增加 `Content-Length` 参数后，数据传输过大时可能导致 `Broken pipe` 报错，调整 `MTU` 值可以解决这个问题。 

:::

### ❓全双工和半双工模式是什么

::: details 💡

“双工”：数据传输的两个方向的工作状态。

  - 全双工（`Full-Duplex`）模式：通信系统中的两个设备可以同时进行发送和接收操作。两个方向是独立的，可以同时进行。
    > 例如：电话，我们可以同时听对方说话，同时跟对方说话，这就是全双工的例子。

  - 半双工（`Half-Duplex`）模式：通信系统中的设备不能同时发送和接收数据。两个方向是互斥的，一次只能有一个方向在进行数据传输。
    > 例如，对讲机，就是一种半双工设备，当一个人按下按钮说话时，其他人只能听，不能同时说话。

:::

### Cookie

#### ❓`Cookie` vs `Session`

::: details 💡

> `Cookie` 和 `Session`都用于跟踪用户的状态。

区别：

  - **存储位置**：
    * `Cookie`  保存在客户端（浏览器）。
    * `Session` 保存在服务端。

  - **生命周期**：
    * `Cookie`  的生命周期：由创建时设定的过期时间决定，可以持久化存储，即使关闭浏览器或者关机，只要还未到达过期时间就能继续使用。
    * `Session` 的生命周期：以服务器为准，当浏览器关闭，或者` Session` 超时（根据服务器设置），`Session` 就会失效。

  - **安全性**：
    * `Cookie`  存储在客户端，较容易被恶意用户分析和篡改，所以敏感信息通常不存储在 `Cookie` 中。
    * `Session` 存储在服务端，相对来说保密性更好。

  - **容量**：
    * `Cookie`  对大小有限制，每个站点的 `Cookie` 总量大致在 `4KB` 左右。
    * `Session` 没有大小的限制，可以存储大量数据。

  - **对服务器压力**：
    * `Cookie`  是保存在客户端，对服务器压力较小。
    * `Session` 是存储在服务端，如果并发访问用户很多，服务器的压力就会变大。

  - **应用场景**：
    * `Cookie`  经常用于保存用户一些偏好设置，用户名等非敏感信息。
    * `Session` 经常用于需要记录的敏感信息，如用户的登录状态。

实际应用：往往会结合两者使用。
  
  > 例如，服务器创建一个 `Session` 发送给客户端(浏览器)，然后客户端将 `Session` 的唯一标识符存储在 `Cookie` 中，这样既利用了 `Cookie` 方便的客户端存储，也避免了在 `Cookie` 中存储敏感信息的风险。

:::

#### ❓`Cookies` 经常用在哪些地方，客户端可以修改 `Cookies` 吗

::: details 💡

使用场景：

  - 会话管理：如登录、购物车、游戏分数，或者任何其他在服务器上存储的临时信息。

  - 个性化设置：如用户偏好设置、主题等。

  - 跟踪和分析用户行为：记录和分析用户对网站的访问和使用情况，用于网站优化、广告投放等。


`Chrome` 浏览器中修改 `Cookies` 的方法：

  - 打开开发者工具 `DevTools`

  - 切换到 `Application` 标签页

  - 在左边菜单栏中的 `Storage` 下面找到 `Cookies` 点击后会显示当前网页所有的 `Cookies`。

  - 此时可以很方便的添加、修改、删除 `Cookies`。直接双击想要修改的 `Cookie` 的 `Value` 部分，就可以开始修改了。

:::

#### ❓一个 `URL` 的域是什么，`cookie` 可以实现跨域访问吗

::: details 💡

URL的域指的是URL中的主机部分。例如，在URL "http://www.example.com:8000/path/to/myfile.html?key1=value1&key2=value2#Somediv" 中，"www.example.com" 就是URL的域。

至于Cookie是否可以实现跨域访问，答案是不能。这是由同源策略所规定的，也是为了保护用户隐私和网络安全。

同源策略要求一个网页上运行的脚本只能访问和操作同源页面的Cookie。"同源"是指"协议 + 域名 + 端口"三者相同。也就是说，两个URL，只有这三者相同，才能共享Cookie。

比如，"http://www.example.com" 和 "https://www.example.com" 或 "http://static.example.com" 或 "http://www.example.com:8001"，这些都是非同源的，不能共享Cookie。

不过，虽然不能直接实现跨域共享Cookie，但是有一些技术和方法可以实现类似的效果，如JSONP、CORS（跨源资源共享）、document.domain等，在这些技术的帮助下，可以安全地跨域传递数据和Cookie，但是这就涉及到更复杂的网络通信和编程技术了。

:::

### ❓流量控制和拥塞避免的区别

::: details 💡

  - **流量控制**：点对点（从一台主机到另一台主机）的通信机制。常在网络的传输层（如 `TCP` 协议）进行。
    > 主要目的：防止发送方发送过多的数据给接收方，以免接收方无法处理这么多数据。其中，接收方将根据其处理能力，反馈给发送方一个“接收窗口”大小，告诉发送方它应该发送多少数据。发送方根据这个反馈来调整发送速率。

  - **拥塞控制**：是全局性的，包括了所有主机和所有的网络链路。在网络层，涉及整个网络的运行状态。
    > 主要目的：防止过多的数据在网络中传输，以免导致网络拥塞和性能下降。其中，网络的通信节点（如路由器或交换机）或发送方将根据网络的拥塞情况，调整数据的发送速率。

总结：流量控制更关注发送方和接收方之间的平衡，而拥塞控制则关注整个网络的健康运行状态。

:::

### ❓了解过端口映射吗，说一下端口映射的方法。

::: details 💡

> 端口映射，又称端口转发，是防火墙的一种设置，它把防火墙上的一个端口映射到私有网络的特定主机上特定的一个端口，通过端口映射，可以让外界通过防火墙访问内部网络中的主机。

端口映射的配置方法：

  - 静态端口映射：将内部主机固定端口的网络服务映射到防火墙的指定端口上。
    > 例如，将内部主机的 `HTTP` 服务（`TCP` 80 端口）映射到防火墙的 8080 端口。当外部网络用户访问防火墙的 8080 端口时，防火墙自动将外部网络用户的请求转发给内部主机的 80 端口。
    
  - 动态端口映射：在需要的时候提供一种动态的端口映射服务，外部网络用户可以在需要的时候动态的访问内部网络主机的网络服务。
    > 例如，当内部网络主机的 `FTP` 服务被外部用户请求时，防火墙会动态的创建一个端口映射，将外部用户的请求转发给内部主机的 `FTP` 服务。

:::

------

## UDP

### ❓`UDP`

::: details 💡

> `UDP` (`User Datagram Protocol`)：用户数据报协议，是一种无连接的网络通信协议，位于 `OSI` 模型的传输层。与 `TCP` 协议不同，`UDP` 不提供数据正确性保证和顺序保证，也不进行流量控制和拥塞控制。

主要特性：

  - 无连接：`UDP` 发送数据前无需建立连接，每个数据报都独立处理，因此可以支持同时向多个接收者发送数据。
  - 少量开销：`UDP` 不需要进行复杂的错误检查和恢复机制，头部开销只有 8 字节，比 `TCP` 更简单也更快。
  - 不可靠性：`UDP` 不保证数据的到达和顺序，数据可能会丢失或者乱序。
  - 支持一对一、一对多、多对一和多对多的交互通信。

应用：比如实时应用（如 `VoIP` 和在线游戏），广播和多播应用，以及需要快速传输且不太关心丢包的应用（如 `DNS` 和 `DHCP`）。

:::

### ❓`TCP` vs `UDP`
  
::: details 💡
  
`TCP` 特点
  
  - 可靠性 : 通过确认应答、超时重传等机制保证数据的可靠传输。
  - 有序性 : 通过数据序号来保证数据有序，传输完成后通过排序来保证数据的正确性。
  - 双全工 : 通信双方(服务端和客户端)都具备发送和接受数据的能力。(三次握手来保证)
  
`UDP` 特点

  - 不可靠 : 通信通信双方不需要建立连接，不能保证数据准确送达。
  - 无序性 : 每次发送的数据包相互独立，没有特定的顺序。
  - 速度快 : 由于数据包结构简单，保证的 `UDP` 传输速度优于 `TCP`
  
  一些游戏、直播和需要低延迟实时性要求较高的应用，会使用 `UDP`。

两者区别：

  - 连接方式：
    * `TCP` 是一种面向连接的协议，在正式收发数据之前，必须和对方建立可靠的连接。
        > 一个TCP连接必须要经过三次“对话”才能建立起来。我们通常所说的“三次握手”（`three-way handshake`）就是指建立一个TCP连接，这种机制保证了两端系统在通信开始之前就已知了对方的存在。
    * `UDP` 则是面向非连接的协议，它不与对端建立连接，而是直接就发送数据包，尽管如此，`UDP` 数据包的到达和顺序也不能被保证。

  - 可靠性和速度：
    * `TCP` 提供了全面的错误检查和确认机制，并且有重发机制，所以它能提供可靠的数据传输，适合对可靠性要求很高的场景，如文件传输。
    * `UDP` 则不提供必要的检查，也不保证数据的顺序, 因此它的性能更高，传输速度更快，适用于对实时性要求高的场景，如视频通话，直播等。

  - 数据交互方式：
    * `TCP` 是双向通信的，即 A 主机到 B 主机和 B 主机到 A 主机的交互都可以。
    * `UDP` 则主要用于单向发送数据，如声明性（datagram）服务。

  - 流控制：
    * `TCP` 提供了流量控制的机制，既有发送端控制发送速率使接收端来得及接收，又有接收端通过滑动窗口控制接收速率，防止接收端处理不过来。
    * `UDP` 则没有提供流量控制的机制，数据发送之后也无法获得发送是否成功的反馈。

总结：如果需要可靠性和数据完整性，应该用 `TCP`；如果需要速度，那么应该用 `UDP`。

:::

### ❓有人认为 `TCP` 一定比 `UDP` 更快，你觉得呢

::: details 💡

不对，一般情况来说，`TCP` 比 `UDP` 更慢。

  - `TCP`（`Transmission Control Protocol`）是一种面向连接、可靠的传输协议，它提供了数据完整性和顺序保证，适合于对数据传输准确性要求高的场景。但是，`TCP` 为了确保这种可靠性，引入了确认（`ACK`）、重传等机制，这些处理会消耗一定的时间，对性能有所影响。

  - `UDP`（`User Datagram Protocol`）是一种无连接、不可靠的传输协议，它不保证数据的到达和顺序。因此，`UDP` 相比 `TCP` 有较小的协议开销，对于那些要求实时性，可以容忍丢包，但对传输延迟和效率要求较高的场景（如流媒体传输、在线游戏）来说，`UDP` 可能会比 `TCP` 更快。

:::

### ❓`UDP` 除了不用握手，还有什么优点

::: details 💡

  - 速度快：由于 `UDP` 是无连接的，没有像 `TCP` 那样的握手、确认和终止连接等过程，所以通信速度较快。

  - 资源占用小：`UDP` 没有复杂的管理机制，因此网络设备需要的处理逻辑少，占用的系统资源也较少。

  - 实时性高：`UDP` 适合实时应用，在语音、视频、游戏传输等对实时性要求高的场景有优势。

  - 灵活性高：`UDP` 的数据传输方式比较灵活，可以支持一对一、一对多、多对一、多对多的通讯模式。

  - 控制权在用户手中：`UDP` 协议把网络程序所需的控制权交给应用程序自己去处理，应用程序可以自定义一些算法进行流量控制或错误处理。

:::

------

## TCP

### ❓`TCP`

::: details 💡

> `TCP` (`Transmission Control Protocol`)：传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议，位于 `OSI` 模型的传输层。在 `Internet` 协议家族（`TCP/IP` 协议家族）中，`TCP` 与网络层的 `IP` 协议共同构成了 `Internet` 的核心。

主要特性：

  - 三次握手：建立连接，经过 “三次握手”，确保双方都准备好进行数据交换。
  - 使用序列号和确认应答：`TCP` 为每个字节赋予一个序列号，并期望收到接收端的确认应答。如果发送端没有收到确认应答，就会重发数据。
  - 窗口大小和滑动窗口机制：为了控制数据的流量和避免网络拥塞，`TCP` 使用了窗口大小和滑动窗口的机制。
  - 流量控制：通过适时调整窗口大小，`TCP` 能够根据接收端的处理能力，来控制发送端的发送速率。
  - 检错和重传：`TCP` 通过检验和和定时器等机制来实现数据的无差错传输，如果出现错误或者丢包，`TCP` 会自动进行重传。
  - 四次挥手：断开连接，`TCP` 会通过 “四次挥手” 来安全地关闭连接。

应用：需要高可靠性的网络通信，比如 `Web` 浏览、邮件传输、文件传输等。

:::

### 建立连接

#### ❓三次握手

::: details 💡

`TCP` 三次握手过程：建立连接的过程。
   
  - 第一次握手：客户端发送 `SYN` 包（序列号 `seq` 为 `X`）到服务器，并进入 `SYN_SEND` 状态。

  - 第二次握手：服务器收到 `SYN` 包，必须确认客户的 `SYN`(`ACK` = `X+1`)，同时自己也发送一个 `SYN` 包（序列号 `seq` 为 `Y`），即 `SYN + ACK `包，服务器此时进入 `SYN_RECV` 状态。

  - 第三次握手：客户端收到服务器的 `SYN + ACK` 包，向服务器发送确认包 `ACK`(`ACK`= `Y+1`)，此包发送完毕，客户端和服务器进入 `ESTABLISHED` 状态，完成三次握手。

:::

#### ❓为什么要三次握手

::: details 💡

  -  确保双方都准备好进行通信：在三次握手的过程中，客户端和服务器都会发送并确认接收到了对方的消息。这确保了两边都有能力收发信息，即两边的发送和接收功能都正常。

  - 防止已经失效的连接请求报文段突然又传到了服务端，由于服务端误认为客户端又发出一次连接请求，于是就向客户端发送确认报文段，同意连接。这种情况下，如果没有三次握手，则会建立一个无用的连接，浪费服务器资源。

  - 确定序列号：三次握手还可以帮助通信的双方确定数据包的序列号。在TCP通信中，每个数据包都有一个序列号，接收方根据序列号来重新组织数据包。通过三次握手，双方都能知道对方期待接收的初始序列号。

总结：`TCP` 协议选择使用了三次握手这种方式来建立连接，以确保数据的正确、可靠传输。

:::

#### ❓三次握手，第三次丢失会怎么样

::: details 💡

第三次握手客户端发送的 `ACK` 包在传输过程中丢失：

  - 服务器一直处于 `SYN_RECV` 状态下，同时等待客户端再次发送 `ACK` 包。默认情况下，服务器在 75 秒后会关闭等待连接。

  - 客户端的 `ACK` 丢失，但是连接已经建立，在 `ESTABLISHED` 状态。接下来如果客户端开始发送数据，服务器就知道连接已经建立了。

  - 如果服务器在等待 `ACK` 的过程中，系统的连接队列已经满了，那么新的 `SYN` 包将无法得到响应，这会导致客户端无法建立新的连接。

结论：如果第三次握手的 `ACK` 包丢失，对于已经建立好的 `TCP` 连接影响并不大，但可能会影响新的连接建立。

:::

#### ❓三次握手，可以携带数据吗

::: details 💡

  `TCP` 三次握手过程主要是为了建立连接，同时确定数据包的序列号，从而保证数据传输的正确性和完整性。在三次握手的过程中，理论上说第三次握手时，可以携带数据并将数据传给接收方。因为此时已经建立了连接，而且握手的 `ACK` 和数据部分在 `TCP` 的设计里面并不是强相关的。

  是否携带数据、何时携带数据，这个取决于网络协议栈的设计，也跟上层应用有关。在很多实际的网络协议栈实现中，并不在三次握手时携带数据，主要是因为需要等待握手成功后，才能确认双方具备了接收数据和处理数据的能力。所以通常情况下，三次握手不包括数据的发送。

结论：从是否可行的角度看，三次握手过程中是可以携带数据的。但在实际操作中，一般并不这么做。

:::

### 断开连接

#### ❓四次挥手

::: details 💡

`TCP` 四次挥手过程：结束连接的过程。

  - 第一次挥手：当某一端完成数据发送后（假设是客户端），会向另一端（服务器）发送 `FIN` 包，请求关闭连接。
  
  - 第二次挥手：服务器收到 `FIN` 包后，并不是立即关闭连接，而是先向客户端回复确认包 `ACK`，告诉客户端 “你的请求我收到了”。然而，此刻服务器可能还有数据要发送，所以并不直接发送 `FIN` 包。

  - 第三次挥手：等服务器所有数据都发送完了以后，再向客户端发送 `FIN` 包，请求关闭连接。

  - 第四次挥手：最后客户端收到 `FIN` 包后，也不是立即关闭连接，而是先回复一个 `ACK` 给服务器，然后等待一段时间（等待`2MSL`，也就是报文最大生存时间的两倍时间，约1-4分钟）再关闭连接。

:::

#### ❓为什么要四次挥手

::: details 💡

  因为 `TCP` 连接是全双工的，即数据可以在两个方向上独立地进行传输。这意味着每个方向都需要单独关闭，这样的设计使得 `TCP` 连接的关闭更为可靠。

  - 每个方向的关闭都需要发送一个 `FIN` 包和一个 `ACK` 包。
    * 发送 `FIN` 包表示我已经没有数据要发送了，并请求关闭连接。
    * 发送 `ACK` 包则是确认接收到对方的 `FIN` 包。

  - 一个方向的连接关闭就需要两次挥手，而一个 `TCP` 连接由于是全双工的（双方都可以发送数据），所以两个方向都需要关闭，因此总的来说需要四次挥手。

  - 为了保证能够让未完全传输的数据能够被接收，接收到 `FIN` 包的一方会进入到一个叫做 `TIME-WAIT` 的状态，在这个状态中，它会等待一段时间以确保对方接收到了 `ACK` 包。这就是为什么有时候会看到一些还处于 `TIME-WAIT` 状态的 `TCP` 连接，那是因为它们在等待最终的确认。

  - 能处理双方同时发起关闭连接请求的情况。

:::

#### ❓`TCP` 双方同时发起关闭连接请求的情况，是如何处理的

::: details 💡

  四次挥手是 `TCP` 协议用来结束连接的过程。理想情况下，一般是由其中一方（比如客户端）先发起关闭连接请求。然而，`TCP` 连接的每一方都能独立地关闭它们的发送通道，所以双方都可以发送 `FIN` 报文来请求关闭连接。

同时发起关闭请求处理流程：

  - 主机 A 发送一个 `FIN`，并进入 `FIN-WAIT-1` 状态。
  - 主机 B 在收到这个 `FIN` 后，返回一个 `ACK`，并让 A 进入 `FIN-WAIT-2` 状态。
  - 几乎同时，主机 B 也发送一个 `FIN`，并进入 `LAST-ACK` 状态。
  - 主机 A 收到 B 的 `FIN` 后，返回一个 `ACK`，并进入 `TIME-WAIT` 状态，同时 B 收到这个 `ACK` 后关闭连接。
  - 对于 A 后续的行为，会根据具体实现，可能会继续等待一段时间，或者直接关闭连接。

:::

#### ❓`CLOSE-WAIT` 和 `TIME-WAIT` 有什么区别

::: details 💡

> 这两个状态时是在 `TCP` 协议的四次握手断开连接的过程中。

  - `CLOSE_WAIT`: 这个状态的意思是等待本地应用程序关闭连接。也就是说，对方发送了一个 `FIN` 报文，等待你关闭连接。这个状态的持续时间取决于应用程序何时关闭连接。

  - `TIME_WAIT`: 这是 `TCP` 连接断开后的最终状态。这个状态表示，本地机器已关闭了连接，也发送了对方需要的最后的 `ACK` 报文。然后本地机器会等待一段时间再释放通信资源。这个等待的时间就是 `TIME_WAIT` 的时间。

区别：

  - `CLOSE_WAIT` 状态下，我们尚未发送 `FIN` 报文关闭连接，意味着应用程序需要关闭连接，应用程序一旦关闭连接，发送 `FIN` 报文后，我们就进入 `LAST_ACK` 状态。

  - `TIME_WAIT` 状态下，我们已经关闭了连接，表明已发送 `FIN` 报文，并收到了对应的 `ACK`。此时如果 `TCP` 连接处在这个状态，会继续等待一段时间（两个最长报文寿命的时间，2 MSL）以确保远端收到关闭连接的通知。这是为了确保 `ACK` 报文能够正确送达。这样才能保证整个四次挥手过程的完整性。
    
注意：过多的 `CLOSE_WAIT` 状态可能意味着存在问题，它可能表示应用程序没有正确关闭连接。而过多的 `TIME_WAIT` 状态可能会消耗过多的服务器资源，但这不一定表示存在问题，它可能仅仅表示服务器正在处理大量的短连接。

:::

### 运行机制

#### ❓`TCP` 的 `Keep-Alive` 机制

::: details 💡

  > `Keep-Alive`: 顾名思义是否还活着，是一种心跳检测机制。用于判断连接方是否还处于活动状态，以便断开已经失活连接释放资源。发送探测包后，如果处于活动状态，接收方会发送确认信号；如果处于失活状态，则会再连续再发送几次探测包如果均无响应则证明对方已断开连接，可以释放资源。
  
注意：

  - `Keep-Alive` 机制的时长一般默认为 **2 小时**。所以，不能使用使用该机制来确认实时性较高的保活探测。

  - `Keep-Alive` 并不是默认开启的。在一般情况下，如果两端的 `TCP` 都正常工作，是不需要使用到 `Keep-Alive` 机制的。只有在网络不稳定，或者是需要维持长连接的应用中，比如数据库连接，`Keep-Alive` 才会显得比较有用。

:::

#### ❓`TCP` 长连接和短连接的区别

::: details 💡

> `TCP` 长连接和短连接的区别主要体现在连接持续的时间和资源占用上。

  - 长连接：在建立连接后，客户端和服务器会一直保持这个连接，在数据传输完毕后并不会主动关闭连接。后续如果还有请求需要处理，就直接使用这个已经建立好的连接。
    > 长连接适合于链接状态频繁、数据交互量大且连续的情况，可以减少频繁的连接建立和断开所带来的开销。在 `HTTP 1.0` 协议中，通过设置 `Connection:keep-alive` 来使用长连接，之后的版本默认使用长连接。
    > 在一些并发连接数需要很高的场景下（例如`IM`、游戏服务器等），一般会倾向于使用长连接。

  - 短连接：短连接在客户端和服务器处理完一次请求后，就会立即断开连接。再次请求时需要重新建立连接。短连接对于服务器的资源占用相对较小，但是对于每次请求都需要经历建立连接、断开连接的过程，导致处理速度相对较慢。
    > 在一些并发连接数相对较低，但是连接非常频繁的场景下（例如 `RESTful API` 服务等），一般会倾向于使用短连接。

:::

#### ❓`TCP` 中长连接和短连接的实际应用有哪些

::: details 💡

TCP长连接和短连接各自有其实际应用场景，以下有一些常见的例子：

  - 长连接：
    * 聊天服务器、游戏服务器：这些场景下客户端和服务器需要频繁交互，且交互时间不固定，也不能有延时。使用长连接可以减小开销，提高效率。
    * 数据库连接：大多数数据库在操作时也会采用长连接，以确保快速高效地进行数据读写。
    * `HTTP/1.1` 及以下版本的网络传输标准中，默认就是用的长连接方式。`HTTP/1.0` 通过 `header`中的 `Connection: keep-alive` 设置为长连接。
    * `WebSocket`：创建一个长连接，实现实时的双向通信。
    
  - 短连接：
    * `HTTP/1.0` 的网络请求默认就是短连接，因为一般的 `HTTP` 请求/响应模型都是一次请求对应一次响应，不需要保持连接。
    * 邮件 `SMTP` 传输：`SMTP` 用来发送邮件，不可能一直发送邮件，所以采用短连接的模式。
    * 日常访问网页：浏览器通常在下载完网页之后就断开连接，以释放系统资源。每次再访问遵循 `HTTP/1.0` 协议的网页都会重新建立一次新的连接。
    
:::

#### ❓什么情况下发送方的滑动窗口会后移

::: details 💡

  > `TCP` 发送方的滑动窗口 : 用来控制网络通信流量和确保信息可靠传输的一种机制。防止网络拥塞，确保在有限的网络带宽中，数据能够被高效、有序、可靠地传输。

滑动窗口后移的两种情况：

  - 当接收到确认(`ACK`)消息时
    > 当发送方接收到接收方发送的确认消息(`ACK`)，说明发送方发送的数据已经被接收方正确接收，此时发送方的滑动窗口的左边界会按照收到的确认信息进行移动。相应地，滑动窗口的右边界也会移动，使窗口大小保持不变。这样可以控制发送方继续发送未被确认的数据，或者发送新的数据。

  - 当窗口内数据全部被确认时
    > 如果滑动窗口中的所有数据都已经被接收方确认接收，那么滑动窗口会往右移动，来为新的数据腾出空间。

🌰 比如发送方发送了 `1、2、3、4` 这 4 个包，那么初始的窗口便是 `[1, 4]`，当接收方收到 `1、2` 两个包后，并向发送方发送了 `ACK` 确认报文，那么发送方的滑动窗口就会后移，变成 `[3, 6]`。在整个过程中，窗口的大小(4 个包的大小)保持不变，只是随着数据传输的进行，窗口在数据流上滑动。

:::

#### ❓解释下 `TCP` 的慢启动特性

::: details 💡

> `TCP` 的慢启动是一种防止网络拥塞的机制。

工作原理：当一个 `TCP` 连接刚开始的时候，发起方不会立即以最大速度发送数据，而是会首先以较慢的速度发送，然后逐渐提高发送速度，直到找到网络的最大负载能力。

  慢启动的名字可能会让人误解，实际上它不是真的 “慢”，而是一个加速过程。`TCP` 连接开始时的发送窗口不是非常大，意味着一次能发送的数据量较小，这就是 “慢” 启动的含义。每当收到一个确认（`ACK`）报文，发送窗口就增大一点，这样下一次就可以发送更多的数据。这个过程不断重复，发送窗口的大小以指数级别增长，也就是说传输速度会迅速提升。

  为了防止网络拥塞，当达到一个阈值（`ssthresh`，`slow start threshold`）后，`TCP` 将不再指数级别增长，而是转为线性增长，这就是进入 “拥塞避免” 阶段。如果出现了网络拥塞的信号（例如丢包，超时等），`TCP` 会降低传输速度，重新回到慢启动阶段。

总结：`TCP` 的慢启动特性是一种通过动态调整传输速度来适应网络状况，防止网络拥塞的有效机制。

:::

#### ❓讲一下 `TCP` 的四种拥塞控制算法

::: details 💡

  - 慢启动算法（`Slow Start`）:
    > 慢启动算法使用了一个 “拥塞窗口” 且初始值为一个报文段。每当确认数目到达，拥塞窗口就增加一，即每经过一个往返时间 `RTT`，拥塞窗口就加倍。这样就实现了在网络并未出现拥塞的情况下，数据报的传送速率逐渐加快。但是当拥塞窗口大到一定程度后，就有可能导致网络拥塞。

  - 拥塞避免算法（`Congestion Avoidance`）:
    > 拥塞避免算法主要是为了预防因慢开始算法加速过快导致网络拥塞，所以在拥塞窗口到达阈值后，改用拥塞避免算法，让拥塞窗口每经过一个 `RTT` 只增加一，也就是以线性的速度增长，这样增长速率就放慢了，避免了慢开始算法过快的增长导致的拥塞。
    
  - 快重传算法（`Fast Retransmit`）:
    > 快重传算法在接收方收到一个失序的报文段后，就会立即发出重复确认，而不是等到自己需要发送数据时才捎带确认。在发送方，只要连续收到三个重复确认，就立即重传没有被确认的报文段，而不必等待设置的重传计时器到期。这样可以尽早地知道有报文段没有到达接收方，进而尽早地进行重传。

  - 快恢复算法（`Fast Recovery`）:
    > 快恢复算法是在快重传算法之后提出的，主要用于快速恢复丢失报文段后的传输。当发送方连续收到三个重复确认（意味着有报文段丢失）后，不立即执行慢启动算法，而是把阈值设为当前拥塞窗口的一半，然后执行拥塞避免算法。这样避免了慢启动算法使窗口大小回到最初状态，而是让其在一个比较大的值开始，这样就加快了恢复速度。

注意：这四种算法，协同工作，共同管理和控制了 `TCP` 数据的传输，使其在充分利用网络资源的前提下，尽可能的避免网络拥塞，保证了传输的效率和可靠性。

:::


#### ❓在高宽带、高丢包的情况下，怎么保证 `TCP` 的性能

::: details 💡

  - 增大 `TCP` 窗口大小：`TCP` 窗口控制了发送方一次可以发送多少数据，所以通过扩大 `TCP` 窗口，可以提高 `TCP` 的吞吐量。
    > 注意：过大的 `TCP` 窗口可能会导致网络拥塞，因此需要谨慎使用这种策略。

  - 使用快速重传和快速恢复：当发送方多次连续收到对同一包的重复 `ACK` 时，可能代表接收方那边出现了乱序或者丢包。于是发送方可以不用等到超时就开始重传，这就是快速重传。快速重传后，发送方不再使用慢启动，而是直接进入拥塞避免，这就是快速恢复。

  - 使用拥塞控制算法：比如 `TCP NewReno`、`TCP Vegas`、`TCP BBR` 等，可以在丢包较高的情况下，仍然保持较好的网络吞吐性能。

  - 启用 `SACK`(`Selective Acknowledgements`) 选项：`SACK` 允许接收方告诉发送方，哪些特定的数据包已经被接收。这样，当数据包丢失时，发送方只需要重发那些未被确认的数据包，而不是所有的数据包。

  - 使用前向纠错（`FEC`）技术：`FEC` 技术可以在发送数据的时候额外发送一些冗余数据，这样即使在丢包较高的情况下，接收方也有可能从已接收的数据包中恢复出丢失的数据。

  - 使用多路径`TCP` (`MPTCP`)：`MPTCP` 可以在有多条路径可用的情况下，同时在多条路径上发送数据。这样即使一部分数据包丢失，其他路径上的数据包仍然可以达到目的地，从而提高 `TCP` 的吞吐性能。
    
:::

------

## QUIC

### ❓`QUIC` 是什么

::: details 💡

> `QUIC`(`Quick UDP Internet Connections`) 是由 `Google` 提出的一个运输层的网络协议，它是基于 `UDP`（用户数据报协议）进行实现的。

  在设计 `QUIC` 时，`Google` 的目标是减轻 `TCP`（传输控制协议）带来的延迟，特别是在移动和无线网络中。因此，`QUIC` 协议在 `UDP` 协议的基础上实现了类似 `TCP` 的可靠传输、拥塞控制、流控制等机制，同时还加入了如快速握手（`0-RTT` 握手）、前向纠错（`FEC`）、多路复用等优化。

主要特点：

  - 连接建立时延迟小：`UDP` 没有连接的概念，因此在数据传输之前，不需要像 `TCP` 那样进行三次握手。而 `QUIC` 用 `0-RTT` 或 `1-RTT` 完成握手，显著减少了连接建立的延时。

  - 内置 `TLS`：`QUIC` 协议本身就包含了 `TLS` 协议，这意味着所有的 `QUIC` 连接都是加密的。这不仅保护了数据的安全，而且因为减少了请求/响应的往返次数，也可以提高性能。
    
  - 多路复用与头部压缩：`QUIC` 支持多路复用，即在一个 `QUIC` 连接中可以并行发送多个独立的数据流。此外，`QUIC` 还支持协议头部的压缩，这可以减少协议的开销。

  - 前向纠错和拥塞控制：前向纠错可以帮助恢复丢失的数据包，减少了因重传引起的延迟。`QUIC` 协议还实现了一套类似 `TCP` 的拥塞控制机制，以保持网络的稳定性。

  - 连接迁移：由于 `QUIC` 协议的连接不再依赖于 `IP` 地址，因此当用户的网络环境改变（例如，从 `WiFi` 切换到 `4G`）时，`QUIC` 连接可以不中断地进行迁移。
    
:::

### ❓`QUIC` 的底层实现

::: details 💡

`QUIC`(`Quick UDP Internet Connections`)是一种新的运输层协议，目前主要由 `Google` 进行维护和发展。`QUIC` 并非使用 `TCP/IP` 作为底层依赖，而是重新设计并实现在 `UDP` 协议上。

底层实现：

  - 基础协议：`QUIC` 协议使用了 `UDP` 作为其底层传输协议。这是因为 `UDP` 协议简单且不会产生头阻塞问题，比如 `TCP` 协议中的队头阻塞问题。

  - 面向连接：尽管基于 `UDP`，`QUIC` 仍然是面向连接的。它使用特殊的连接 `ID` 进行标识，这使得在网络环境改变时，比如 `IP` 地址变化，`QUIC` 连接可以在不同的网络路径下继续。
    
  - 加密与安全：`QUIC` 协议天生就有加密机制，使用了基于 `TLS`(`Transport Layer Security`) 的机制。所有 `QUIC` 连接都是全加密的，这使得 `QUIC` 在保障数据安全性方面有很好的表现。
    
  - 流和多路复用：在一个 `QUIC` 连接中，可以有多个并发的流，同时进行数据的发送和接收，有点类似 `HTTP/2` 的多路径复用机制。

  - 快速握手：`QUIC` 使用 `0-RTT`(`Round-Trip Time`) 或者 `1-RTT` 的握手方式。新连接的建立只需要 `1-RTT`，对于已经建立过的连接，再次握手只需要 `0-RTT`，大大减少了握手的延时。

  - 拥塞控制：`QUIC` 在保留了 `TCP` 中 `Reno` 和 `Cubic` 等拥塞控制算法的基础上，又增加了自己的 `BBR` 拥塞控制算法。
    
  - 快速恢复与前向冗余校验：`QUIC` 协议在设计上尽可能的减少丢包对性能的影响，通过快速重传与前向冗余校验（`FEC`）等方式，尽可能快速恢复丢失的数据。

:::

### ❓`0-RTT` 握手过程

::: details 💡

> `0-RTT`(`Zero Round Trip Time`) 是一个网络通信的概念，用于描述在客户端和服务器之间建立连接时无需等待一次往返通信的过程。这种握手方式在一些现代的协议中被广泛使用，如`TLS 1.3` 和 `QUIC`。

> `QUIC` 在 `TLS 1.3` 的基础之上实现了 `0-RTT` 握手，它假定客户端和服务器最近有过一次成功的 TLS 握手，然后保存了对应的会话秘钥。

`0-RTT` 握手流程如下：

  - 在第一次连接时，客户端和服务器经过一次完全的 `TLS` 握手，创建出一个 `secure context`，也可以说是会话。包括一个 `master secret` 和其他派生参数。

  - 握手完成后，服务器会生成一个 `NewSessionTicket` 信息，这个票据（`ticket`）包含了服务器用于恢复 `secure context` 的所有必要信息（例如 `master secret`）, 然后给客户端。同时服务器会保存这个 `ticket` 以备后用。
    
  - 当客户端下一次再次向服务器发送请求时，它就可以发送之前服务器发送给它的 `session ticket`，以便服务器可以从这个 `ticket` 中恢复出当时的 `secure context`。

  - 客户端在发送 `session ticket` 的同时，因为它已经有了原来会话的所有秘钥，所以它已经可以加密数据然后进行传输了。

  - 服务器接收到客户端的请求后，从 `session ticket` 中恢复出 `secure context`，然后使用会话参数中相应的秘钥解密客户端传过来的数据。这样，就完成了 `0-RTT` 的握手过程，数据在建立连接的同时就已经传输完成。

注：`0-RTT` 的握手过程存在重放攻击的风险，因为攻击者可能会捕获并重放之前的 `0-RTT` 数据，只需要注意这个风险，就可以设计出避免重放攻击的机制，例如限制 `0-RTT` 数据只能用于非敏感操作，或者只接受一段时间内的 `0-RTT` 数据。

:::

### ❓`FEC` 是什么

::: details 💡

> `FEC`(`Forward Error Correction`): 前向纠错。这是一种在数据传输过程中用于纠正错误的技术。通过在数据发送端增加冗余信息，使接收端在接收到数据时可以检测并纠正一个或几个错误，而无需重新请求发送数据。

  前向纠错可以应用在无线通信、广播通信、网络通信和存储设备等多种实际应用中，以提高数据的准确性和信道的利用率。

  在 `QUIC` 协议中 `FEC` 技术被用来降低丢包率，减少数据的重传，从而提高通信效率。由于数据传输时会添加冗余数据，即使在网络环境较差的情况下，也能保证数据的正确传输，提升用户体验。

  🌰 假设有四个数据包A、B、C和D，可以在这四个数据包后面添加一个 `FEC` 包，这个 `FEC` 包是通过一定算法计算得到的，包括了A、B、C、D四个数据包的冗余信息。当接收端接收到这五个包后，如果其中的一个数据包（比如B）丢失了，那么它仍然可以通过剩下的三个数据包（A、C、D）和 `FEC` 包来恢复出丢失的数据包B。

:::

------

## IP

### ❓`IPv4` 和 `IPv6` 的区别

::: details 💡

> `IPv4` 和 `IPv6`都是用于网络通信的互联网协议。

主要区别：

  - 地址长度：
    * `IPv4` 的地址是 32 位的，最多可以支持约 42 亿个独立地址。
    * `IPv6` 的地址是 128 位的，可以支持非常多的独立地址，远远大于地球上的网络设备数量。

  - 地址表示：
    * `IPv4` 使用四段由点分隔的十进制数表示地址。
        > 例如`192.168.1.1`。
    * `IPv6` 则使用八组由冒号分隔的四位十六进制数表示地址。
        > 例如 `2001:0db8:85a3:0000:0000:8a2e:0370:7334`

  - 头信息：`IPv6` 的头信息比 `IPv4` 更加简单，固定为 40 字节。这种设计使得路由器进行数据包路由时的处理速度更快。

  -  安全性：`IPv6` 在设计时就考虑到了安全问题，支持 `IPsec` 等安全协议，而 `IPv4` 则需要额外添加这些支持。

  -  服务质量（`QoS`）：`IPv6` 原生支持对数据包的优先级进行编码，从而提供更好的服务质量，`IPv4` 则需要额外处理。

至于IPv6之所以诞生，主要是由于IPv4地址的耗尽。随着互联网的快速发展和物联网设备的大量增加，需要互联网地址的设备数量正在快速增加，IPv4的地址空间已经无法满足需求。此外，IPv6相比IPv4还有很多其他优势，例如自动配置、在设计上的安全性改进等。

:::

### ❓`IPv6` 的诞生的原因

::: details 💡

> `IPv6` 的诞生主要是由于 `IPv4` 的地址空间不足。


  - `IPv4` 使用 32 位地址，理论上可提供约 42.9亿 个全球唯一的 `IP` 地址。然而由于地址分配的不均匀和一些历史原因，实际可用的 `IPv4` 地址数量要少得多。随着互联网的迅速发展，尤其是智能手机、平板电脑、物联网设备等的大量涌现，`IPv4` 地址快速耗尽。

  - `IPv6` 使用 128 位长度的地址，理论上可以提供大约 340亿亿亿亿 个 `IP` 地址，这对于任何现在和未来的设备数量来说都是绰绰有余的。此外，`IPv6` 还引入了很多 `IPv4` 中没有的新特性，如本地链接地址、通过邻居发现协议为路由器提供的自动配置，以及改进的支持 `QoS` 的能力和对 `IPsec` 的直接支持等。

总结：`IPv6` 的诞生主要是为了解决 `IPv4` 地址耗尽的问题，同时也引入了一些新的特性和改进，以适应未来互联网的发展需求。

:::

### ❓`IP` 头部都有啥内容

::: details 💡

  - 版本（Version）：占4位，代表IP协议的版本，目前主要为IPV4或者IPv6。

  - 头部长度（IHL，Internet Header Length）：占4位，表示IP头部长度，因为有些IP头部带有选项，所以长度并非固定。

  - 区分服务（DSCP，Differentiated Services Code Point）与显式拥塞通知（ECN，Explicit Congestion Notification）：占8位，前6位是区分服务，后2位是显式拥塞通知。

  - 总长度（Total Length）：占16位，代表整个IP数据报的长度，包括头部和数据部分。

  - 标识（Identification）：占16位，用于标识属于同一个IP数据报的各片（fragment）。

  - 标志（Flags）与片偏移（Fragment Offset）：占3位和13位，用于实现IP数据报的分片和重组。

  - 生存时间（TTL，Time to Live）：占8位，限定IP数据报的寿命。

  - 协议（Protocol）：占8位，表示携带的数据所使用的协议，如TCP，UDP等。

  - 首部校验和（Header Checksum）：占16位，用于检查IP数据报在传输过程中是否出错。

  - 源IP地址和目标IP地址：各占32位，分别表示发送端和接收端的IP地址。

  - 选项（Options）：长度可变，一般不使用。

:::

### ❓除了好记以外，为什么要用域名访问服务器，直接用 `IP` 不行吗

::: details 💡

  - **易于记忆**：域名是由字符和数字组成的，通常与网站或公司的名称相关，更易于人类记忆。而 `IP` 地址则是由四组数字组成，不易于记忆。

  - **易于维护**：如果一个网站更换了服务器，`IP` 地址就会发生改变。如果直接使用 `IP` 地址访问，那么用户就需要知道新的 `IP` 地址才能访问该网站。如果使用域名，只要将域名的解析地址更新为新的 `IP` 地址，对用户来说是无感知的。

  - **支持负载均衡**：通过域名，可以将访问请求分发到不同的服务器上。
    > 比如，一个大型网站可能有成千上万的服务器，可以使用同一个域名，背后由 `DNS` 服务器将请求分发到不同的 `IP` 地址，以实现负载均衡。

  - **结构保密**：直接暴露 `IP` 地址可能会泄露一些网络结构信息，而使用域名可以更好地隐藏这些信息。

  - **支持虚拟主机**：同一 `IP` 地址上可以运行多个网站，通过域名可以区分和访问这些网站。如果只有 `IP` 地址，就无法做到这一点。
  
:::

### ❓判断一个字符串是不是 `IPv6` 地址

::: details 💡

> `IPv6` 地址是一个由 128 位数值组成的地址，通常表示为 8 个 16 进制的数，每个数由四个十六进制位表示，并用冒号 ":" 分隔。

```python
# 使用 ipaddress 模块中的 is_ipv6_address 函数来判断一个字符串是否为 IPv6 地址
import ipaddress

def is_ipv6_address(address):
    try:
        ipaddress.IPv6Address(address)
        return True
    except ipaddress.AddressValueError:
        return False

print(is_ipv6_address('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))   # 输出：True
print(is_ipv6_address('2001:db8:85a3:0:0:8a2e:370:7334'))           # 输出：True
print(is_ipv6_address('2001:db8:85a3::8a2e:370:7334'))              # 输出：True
print(is_ipv6_address('This is not an IP address'))                 # 输出：False
```

:::

### ❓`ping` 使用什么协议

::: details 💡

> `ping` 是一种用来检测网络连接质量(是否连通，网络延迟)的工具，基于 `ICMP` (`Internet Control Message Protocol`) 互联网控制报文协议。

工作原理：发送一种特殊的以 `ECHO_REQUEST` 被标记的数据包到指定的网络地址，然后等待接收回馈。如果网络连接正常，那么它将接收到一种被标记为 `ECHO_REPLY` 的数据包。

:::

------

## Socket

### ❓`Socket` 了解吗

::: details 💡

> `Socket`(套接字)是计算机网络数据结构，它是网络通信中数据发送和接收的基本操作单元，可以理解为网络通信的端口。

  `Socket` 原本是 `Unix/Linux` 系统下的一个系统调用，在 `Windows` 环境也有相对应的实现。它提供了在网络中进程之间进行通信的方式。一个 `Socket` 由一个 `IP` 地址和一个端口号 `Port` 唯一确定，形式如：`IP:Port`。

  一个网络连接的建立需要有一对 `Socket`，分别位于通信的两端，也就是客户端和服务器端。在网络应用中，服务器端一般采用固定的 `IP` 地址和端口号。客户端则由系统随机分配端口号，而 `IP` 地址就是机器的 `IP`。

`Socket` 通信过程：服务器监听，客户端请求，连接确认。

  - 服务器监听：服务器端的 `Socket` 绑定在一个特定端口，监听来自客户端的请求。

  - 客户端请求：客户端的 `Socket` 提出连接请求，要求与服务器端的 `Socket` 建立连接。

  - 连接确认：服务器端的 `Socket` 接受来自客户端 `Socket` 的请求，建立连接。
  
:::

### ❓对于服务器来说，`Socket` 通信有哪些具体的步骤

::: details 💡

服务器端的 Socket 通信一般具有以下几个步骤：

1. 创建套接字Socket：首先，服务器需要创建一个socket，这是所有网络通信的基础。

2. 绑定套接字到具体的IP地址和端口号：在创建套接字后，服务器需要将套接字与特定的IP地址和端口号绑定起来，以便客户端能够连接到正确的服务器。这个过程又称为监听(listen)特定的端口。

3. 开始监听连接请求：一旦套接字被绑定到了正确的IP地址和端口号，服务器就可以开始监听这个端口的连接请求了。一般来说，这个过程是阻塞性的，也就是说，如果没有客户端尝试连接，服务器会停在这一步不再向下执行。

4. 接受客户端的连接请求：当有客户端尝试连接服务器时，服务器会接收到一个connect请求。在这个时候，服务器会创建一个新的socket，并将其与请求连接的客户端关联起来，然后通过这个新的socket与客户端进行数据通信。

5. 数据通信：一旦连接被接受，服务器与客户端就可以通过新创建的连接进行数据通信。这里的通信可以是双向的，也就是说，客户端可以向服务器发送数据，服务器也可以向客户端发送数据。

6. 断开连接：通信结束后，服务器需要关闭与客户端的连接。通常是在完成所有通信后，服务器会先关闭连接，然后再结束程序。

以上就是服务器端进行Socket通信的主要步骤，需要注意的是，这些步骤可能会根据具体的编程语言、框架以及业务需求而有所不同。

:::

### ❓`Socket` vs `TCP`

::: details 💡

  - `Socket`（套接字）：这是在计算机上某个应用程序与网络协议（比如 `TCP`）进行数据交换的一个接口或者工具。当一个应用程序想要跟网络上的另一个应用程序通信时，会通过 `Socket` 来发送和接收数据。与 `TCP` 相比 `Socket` 是更高层次的概念。它不仅能够支持 `TCP` 协议，还能支持其他多种通信协议，比如 `UDP` 等。

  - `TCP`（`Transmission Control Protocol`，传输控制协议）：这是一种通信协议，属于网络模型中的传输层协议。它是面向连接的，可靠的，基于字节流的通信协议。主要用于在网络中建立可靠的沟通通道。
  
  总结：`Socket` 和 `TCP` 协议是相互关联的。`Socket` 提供了访问 `TCP/IP` 协议的接口，用于实现进程或应用程序之间的数据传输。

:::

### ❓`Socket` vs `RTMP`

::: details 💡

  - `Socket`是一种网络通信的基本模型，它是在网络中运行的程序间的通信接口。定义了很多函数和数据结构，用以设计和编写网络程序。它是 `OSI` 模型中的会话层和传输层的一个操作集，为通信组件提供了统一的接口。

  - `RTMP`（`Real Time Messaging Protocol`）则是一种专门用于音视频流媒体数据传输的协议，设计用于互联网上的实时流媒体传输，基于 `TCP`，支持带宽检测，并能自动适应网络状态。它设计之初，主要用于在Flash Player和服务器之间传输数据。

  在实际使用中，`Socket` 更底层，几乎可以用于任何类型的网络通信，适用性广泛；而 `RTMP` 更专注在音视频流的实时传输，更加高效和稳定。

区别：

  - 使用场景不同：`Socket` 更底层，适用于各类网络通信，`RTMP` 主要用于音视频流传输。

  - 技术侧重点不同：`Socket` 关注网络通信的基本模型，`RTMP` 更加关注流媒体数据的实时性。

  - 工作方式不同：`Socket` 工作在 `OSI` 模型的会话层和传输层，`RTMP` 则基于 `TCP` 工作在应用层。

  - 功能上的差异：`Socket` 提供的是一种通信接口，`RTMP` 不仅支持数据传输，还支持带宽检测和自动适应网络状态等高级功能。

:::

### ❓`WebSocket` 是什么

::: details 💡

> `WebSocket` 是一种网络通信协议，最早由 `Web` 浏览器和 `Web` 服务器之间进行全双工通信的技术。

发展历史：

  - 2008年，`WebSocket` 受到 `HTML5` 的影响开始诞生。
  - 2011年，该协议被 `IETF` 定为标准 `RFC 6455`，并被 `W3C` 用作 `Web IDL` 中一部分。

主要特点：

  - 建立在 `TCP` 协议之上，服务器网络流量压力较小。
  - 与 `HTTP` 协议有较好的兼容性。默认端口也是 `80` 和 `443`，并且握手阶段采用 `HTTP` 协议，使得其可以穿透大多数防火墙，同时也容易和现有的 `Web` 服务器融合。
  - 数据格式比较轻量，性能开销小，通信高效。
  - 可以发送文本，也可发送二进制数据。
  - 无同源限制（`cross-domain`），客户端可以与任意服务器通信。
  - 协议标识符是 `ws`（或 `wss` 表示使用了 `TLS` 加密），服务器网址就是 `URL`。

通信流程：

  - 客户端通过 `HTTP` 请求与 `WebSocket` 服务端协商加密握手。
  - 如果服务器支持 `WebSocket`，那么握手成功，服务器会返回 `Upgrade` 协议的 `HTTP` 状态码 `101`，即 `HTTP` 协议转换成 `WebSocket` 协议，此后，传输的数据就不再是 `HTTP` 协议，而是 `WebSocket` 协议。
  - 完成升级后，数据就直接从 `TCP` 通道传输，与 `HTTP` 无关了。

总结：`WebSocket` 提供了一种相较于 `AJAX` 更加实时、更加符合主流编程模型、开销更小的实时双向通信手段，使得在 `WEB` 页面上的实时通信变得更加容易。常用于即时通讯、在线游戏等需要实时交互的场景。

:::

------

## HTTP

### 版本

#### ❓`HTTP` 各个版本的区别

::: details 💡

- `HTTP/0.9`: 首个 `HTTP` 版本，只允许简单的请求，仅支持 `GET` 方法且无头部。

- `HTTP/1.0`: 该版本增加了很多新特性。
    * 增加了 `POST` 和 `HEAD` 方法。
    * 引入了 `HTTP` 头部机制，例如：`Content-Type`，`Content-Length` 等。
    * “非持续性连接”，每次请求都会重新创建 `TCP` 的连接的创建和释放，造成极大的资源消耗。

- `HTTP/1.1`: 相比于 `1.0`，版本 `1.1` 做了许多改进。
    * 增加了 `PUT, DELETE` 等新方法。
    * 引入 “持续性连接” 在一次 `TCP` 连接中处理多个 `HTTP` 请求。
    * 引入 “管道机制” (`pipeline`) 可以同时发送多个的请求，但是响应会按照请求队列的先后顺序进行，会存在 “队头阻塞” 问题。
    * 引入了分块传输编码机制，可以将请求分为多个部分分别发送，允许服务器在完全生成整个内容之前就开始回应。
    * 增加了请求头 `Host`，使得一台物理服务器可以承载多个虚拟的主机。

  > “队头阻塞” 问题：
    在 `HTTP/1.1` 引入 “持续性连接”（`Persistent Connection`）让多个 `HTTP` 请求和响应可以在一个 `TCP` 连接中传输，但是由于 `TCP` 协议的特性，数据包必须按照发送顺序进行接收，因此如果队头的包因为某些原因延迟到达，后面的包就必须等待，即使后面的包已经到达，也不能先接收。

- `HTTP/2.0`: 版本 `2.0` 基于 `Google` 的 `SPDY` 协议。
    * 二进制协议：不再是基于文本的协议，减少了解析复杂度和提升传输速度。(优化传输数据格式：文本 -> 二进制)
    * 多路复用：(`Multiplexing`) 在一次 `TCP` 连接中可以发送多个请求且接收多个响应，减少了 `TCP` 连接数量同时也减小了延迟。解决 `1.1` 协议中的 “队头阻塞” 问题。会存在 “同生同灭” 问题。
    * 头部压缩：采用 `HPACK` 算法对头信息压缩处理，减少数据体积。
    * 服务器推送：服务器可以对一个客户端请求发送多个响应。
    * 请求优先级：不同的请求可以有不同的优先级。

  > “同生同灭” 问题：
    在 `HTTP/2.0` 的单个连接中，如果有一个请求因为某种原因失败了（比如网络波动，服务器宕机），则这个 `TCP` 连接上的所有请求都会被关闭，从而导致大量的请求失败，这是由 `TCP` 协议的特性决定的。

- `HTTP/3.0`: 最新版本。
    * 基于 `QUIC` 协议 (`Quick UDP Internet Connections`)，解决 `TCP` 的 “队头阻塞” 问题。
        > 在 `QUIC` 协议中，数据包是独立传输的，即使有数据包丢失，也不会影响到其它数据包的传输和处理，从根本上解决了 “队头阻塞” 问题。
    * 底层协议改为 `UDP`，因此解决了 `HTTP/2.0` 中多路复用的 “同生同灭” 问题。
    
:::

#### ❓`HTTP` 是无状态的，怎么理解

::: details 💡

> `HTTP` (`HyperText Transfer Protocol`) 被称为无状态的，是因为在单一的 `HTTP` 请求和响应交互过程中，服务器并不会保存任何关于客户端的信息。

  - 无状态：每一次 `HTTP` 请求都是独立的，服务器不会记住之前的请求。也就是说，从客户端发出第一个请求到服务器，然后到第二个请求，服务器并不知道这两个请求是来自同一个客户端。无论客户端在前一个请求中做了什么，每个请求都被视为全新的、与其他请求没有关系的请求。

  - 优点：无状态设计使 `HTTP` 的结构变得简单、无复杂性和独立性。

  - 缺点：比如服务器无法记录用户的操作历史。为了解决这个问题，引入了 `Cookies`、`Session` 等技术，它们使得 `HTTP` 能够实现有状态的交互，比如用户认证、购物车功能等。

:::

#### ❓`HTTP 2.0` 针对同一个域名的多个请求，会建立多少个 `TCP` 连接

::: details 💡

  在 `HTTP 2.0` 中，只需要建立一个 `TCP` 连接就可以处理同一个域名的所有请求。`HTTP 2.0` 支持多路复用（`Multiplexing`），可以在一个 `TCP` 连接上同时处理多个 `HTTP` 请求和响应。

  - `HTTP 1.x` 中浏览器通常会对同一个域名建立多个并行的 `TCP` 连接，以便并行处理多个 `HTTP` 请求，但这种方式在 `TCP` 连接数过多时会导致资源消耗过大并影响性能。

  - `HTTP 2.0` 多路复用功能有效地解决了这个问题，它将不同的请求分割为更小的消息和帧，并在一个 `TCP` 连接中并行发起，从而减少了需要的连接数量，提升了网络传输效率。

:::

#### ❓`HTTP 3.0` 中的 `QUIC` 是什么

::: details 💡

> `QUIC`（`Quick UDP Internet Connections`）: 由 `Google` 提出并开发的一种基于 `UDP` (`User Datagram Protocol`) 的互联网传输层协议。

`QUIC` 相对于 `TCP/UDP` 的优点：

  - 低延迟：`QUIC` 通过减少传输层的握手步骤，可以实现无延迟、`0-RTT`（往返时间）的连接建立。
    
  - 弹性：`QUIC` 协议基于 `UDP`，所以每个 `QUIC` 数据包都是独立的，数据包之间没有顺序关系。这意味着，即使某个数据包丢失或者延迟，也不会导致 “队头阻塞” 问题。这使得 `QUIC` 协议在面对网络丢包等恶劣网络环境时，比 `TCP` 具有更好的弹性。

  - 多路复用：`QUIC` 协议支持流的概念，同一 `QUIC` 连接可以包含多个流，每个流都是独立的。这允许多个请求和响应在同一个连接上并行传输，从而避免了 `HTTP/2` 中同一个 `TCP` 连接上的 “同生同灭” 问题。

  - 安全：`QUIC` 协议集成了 `TLS` (`Transport Layer Security`) 协议，可以提供端到端的数据加密和身份验证。

:::

### 请求方法

#### ❓`GET` vs `POST`

::: details 💡

  - 作用：
    * `GET`：从指定的资源请求数据，通常用于获取数据。
    * `POST`：向指定的资源提交要被处理的数据，主要用于发送数据。

  - 数据传递方式：
    * `GET` 方法通常将参数直接附加在 `URL` 后面，并且用问号（`?`）分隔，键值对之间则以 `&` 符号进行分割
        > 例如：`http://example.com/test?name=test1&value=test2`。
    * `POST` 方法则将数据包含在 `HTTP` 请求体内。

  - 安全性：
    * `GET` 方法将参数直接暴露在 `URL` 中，所以它的安全性相对较低，更适合不包含隐私或者敏感信息的请求。
    * `POST` 方法由于将参数包含在请求体内，所以相对更加安全一些。

  - 数据大小：
    * `GET` 方法由于受到 `URL` 长度的限制（通常为 `2048` 字符），所以其发送的数据量有限。
    * `POST` 方法理论上没有数据大小的限制。

  - 数据类型：
    * `GET` 方法只允许发送文本类型的数据。
    * `POST`方法没有这样的限制，可以发送二进制数据。

  - 缓存和历史：
    * `GET` 方式发送的请求，浏览器会主动缓存，用户在 `URL` 地址栏生成历史记录。
    * `POST` 方式则不会被缓存，也不会留下历史记录。
    
  - 幂等性：
    * `GET` 请求是幂等的，即多次执行同一请求，不会改变服务器状态。
    * `POST` 请求不是幂等的，相同的 `POST` 请求被执行多次可能导致不同的结果。

:::

#### ❓`GET` 请求参数一定是放在 `URL` 中的吗

::: details 💡

  不一定。

  `GET` 请求的参数是放在 `URL` 中的，这是 `GET` 请求设计的初衷和最常见的使用方式。但是，并非所有情况下 `GET` 请求的参数都需要放在 `URL` 中，也可以通过请求头来传递。例如，可以通过 `Authorization` 字段在 `GET` 请求头中传递认证信息。

  注意：因为 `GET` 请求的参数是直接暴露在 `URL` 中的，因此有一定的安全风险，不适合用于传输敏感信息，如密码，银行卡号等。同时，`URL` 的长度在浏览器和服务器中都有限制，过长的 `URL` 可能会被截断，导致请求失败。在需要传输大量数据时，一般会使用 `POST` 请求，其参数通过请求体传输，相对安全又没有长度限制。

:::

#### ❓`GET` 不把参数放在 `URL` 里，可以放在 `body` 里吗，如果放在body中，可以被服务器解析吗

::: details 💡

在标准的HTTP协议中，GET请求的参数通常是放在URL中的。这是因为GET请求是用来请求特定的数据，而这些数据通常可以通过URL来指定。

将GET请求的参数放在body中，并不符合HTTP协议的规定。在实际的实践中，大部分的服务器和客户端（例如浏览器）也不支持将GET请求的参数放在body中。即使你真的把参数放在GET请求的body中，服务器也不会去解析它。

此外，将GET请求的参数放在body中也有一些其他的问题。例如，GET请求通常会被浏览器缓存，而缓存系统通常只会考虑URL，而不会考虑body。因此，即使你改变了body中的内容，浏览器也可能直接使用缓存的结果，而不会重新发起请求。

总的来说，GET请求的参数应该放在URL中，而不应该放在body中。如果你需要发送大量的数据，或者需要发送除了字符串以外的数据类型，那么应该使用POST请求。

:::

#### ❓`POST` 请求参数能放在 `URL` 中吗

::: details 💡

技术上可行，但不推荐。

不推荐原因：

  - 安全性：放在 `URL` 中的参数对他人是可见的，比如存储在浏览器的浏览历史中，或者在 `Web` 服务器的日志文件中，或者在网络上被截获。因此，这可能会泄露敏感信息。

  - 容量限制：对 `URL` 的大小，大部分浏览器都有一定的限制（通常为 `2000~4000` 字符）。将 `POST` 参数放在URL中可能会让 `URL` 过长，超过浏览器的处理能力。

  - 规范性：违反 `HTTP` 的语义，根据 `HTTP` 规范，`POST` 方法的语义是 “向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。”，这就意味着 `POST` 请求的数据应该放在请求体中。

:::

#### ❓`POST` 请求的 `body` 体使用 `form-urlencoded` 和 `multipart/form-data` 的区别

::: details 💡
  
  - `application/x-www-form-urlencoded`：无法进行二进制数据的传输，只能上传文本数据。
    > 在这种编码方式下，所有的键值对都会被合并到一个查询字符串中，查询字符串的格式和 `GET` 请求中 `URL` 的查询字符串格式一致。每个键值对之间用 `&` 符号分割，每个键与值之间用等号 `=` 分割，例如 `key1=value1&key2=value2`。如果值中包含一些特殊字符，这些字符需要被 `URL` 编码（比如空格被编码成 `+` 或 `%20`）。

  - `multipart/form-data`：不仅可以上传文本数据，还可以上传文件或其他二进制数据。
    > 在这种编码方式下，消息体会被分割成多个部分，每个部分对应一个字段。每个部分的开头都包含一个含有该字段名的 `Content-Disposition` 头部，然后是字段的值。各个部分之间用 `boundary` 字符串分隔，这个字符串在 `Content-Type` 头部中指定。

:::

#### ❓`POST` 为什么会发生两次请求

::: details 💡

两次请求：第一次是 `OPTIONS` 请求，第二次就是预期中的 `POST` 请求。
  
  > `OPTIONS`：用于请求获得由 `Request-URI` 标识的资源在请求/响应的通信过程中可以使用的功能选项。
  
产生 `OPTIONS` 请求的原因：
    
  - 添加了自定义头部 `Header`
    > 例如：在头部添加一下 `token` 信息来校验用户信息
    
  - 发生了跨域
  
:::

> ❓如何避免 `OTPIONS` 请求

::: details 💡

通过确保请求是一个“简单请求” (`simple request`)，来避免不会触发预检请求。

  - 请求方法为 `GET`、`HEAD` 或 `POST`。
  - 使用自动设置的头（如 `Connection`、`Content-Type`、`User-Agent`...）。
  - `Content-Type` 的值只限于以下三者之一：`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`。如果需要发送一个 `JSON` 格式的数据，可能需要在服务器端改变一些设置，比如使用 `text/plain` 来接收 `JSON` 数据。
    
:::

#### ❓`HTTP` 中的简单请求和复杂请求

::: details 💡

  - 简单请求：
    * `HTTP` 方法为 `HEAD`、`GET` 或 `POST`。
    * `HTTP` 头信息不超出以下字段：`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`（但只限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）以及`DPR`、`Downlink`、`Save-Data`、`Viewport-Width`、`Width`。

  - 复杂请求：不满足上述条件的请求，就视为复杂请求。

跨域资源共享 (`CORS`) 请求
  
  - 简单请求，浏览器直接发出 `CORS` 请求。具体来说，就是在头信息中，增加一个 `Origin` 字段。
  - 复杂请求，`CORS` 请求会在正式通信之前，增加一次 `HTTP` 查询请求，称为"预检"请求（`preflight`）。浏览器首先会向服务器发送一个 `HTTP OPTIONS` 请求头，检测服务端是否支持跨域请求，之后才会发出实际的 `HTTP` 请求。
    
:::

### 状态码

#### ❓`HTTP` 状态码 `2XX，3XX，4XX，5XX` 分别代表什么

::: details

> `HTTP` 状态码：服务器在处理客户端请求时，对该请求的响应状态进行标识的一种方式。

  - `2XX`（成功）- 表示成功处理了请求的状态码。
    * 200 `OK`，表示请求成功。
    * 201 `Created`，表示已创建成功。
    * 204 `No Content`，表示处理成功，但无需返回内容。

  - `3XX`（重定向）- 表示需要客户端进行额外操作的状态码。
    * 301 `Moved Permanently`，表示资源已被永久移动。
    * 302 `Found`，表示资源临时移动。
    * 304 `Not Modified`，表示资源未更改(缓存)。

  - `4XX`（客户端错误） - 表示客户端请求有错误的状态码。
    * 400 `Bad Request`，表示请求格式错误。
    * 401 `Unauthorized`，表示请求未被授权。
    * 404 `Not Found`，表示请求的资源不存在。

  - `5XX`（服务器错误） - 表示服务器在处理请求时发生错误的状态码。
    * 500 `Internal Server Error`，表示服务器内部错误。
    * 502 `Bad Gateway`，表示网关错误。
    * 503 `Service Unavailable`，表示服务器当前无法处理请求。

:::

#### ❓为什么要设计 `304` 这个状态码

::: details

> `HTTP 304` 状态码也被称作 `Not Modified`，即 “未被修改”。当客户端发送一个带有 `If-Modified-Since` 或` If-None-Match` 头的条件请求时，服务器可以使用这个状态码来告知客户端，自从上次获取资源以来，资源没有任何改变，所以客户端可以继续使用它的本地拷贝。

设计原因：
    
  - 提高效率：如果资源自上次获取以来没有发生改变，那么重新发送该资源显然是一种浪费，特别是对于大型资源（如图像、视频、大型 `CSS` 或 `JavaScript` 文件）而言。`304` 状态码让服务器有可能仅仅通过发送一个小的 `HTTP` 头来满足请求，这显著减少了数据量，节省了带宽，提高了响应速度。

  - 减少服务器负载：对于很多动态生成的资源（比如基于数据库的网页内容），每次请求都生成和发送新资源可能会给服务器带来很大的计算负担，通过发送一个 `304` 状态，服务器可以避开这个负担。
    
总结：`304` 状态码为了提高 `Web` 性能，优化用户体验，减少服务器负载而设计。

:::

### 功能知识

#### ❓`HTTP` 的请求报文结构

::: details 💡

  - 请求行（`Request Line`）：包括请求方法、请求 `URI`、协议版本，三者通过空格分隔。
    > 例如 `GET /index.html HTTP/1.1`

  - 请求头部（`Request Headers`）：包括一系列的键值对，每对键值之间使用冒号":"分隔。
    > 例如 `Host: www.example.com`

  - 空行（`CR+LF`）：使用回车（`CR`）和换行（`LF`）表示，表示请求头部结束。

  - 请求体（Request Body）：也叫消息体，主要用于POST和PUT请求中，提交的数据通常放在此处。

🌰 一个 `POST` 请求，请求资源是主页，`HTTP` 协议版本是1.1 。头部字段中包含了主机名、用户代理、接受的内容类型等信息。请求体中包含了表单提交的数据。

```
POST / HTTP/1.1
Host: www.example.com
User-Agent: curl/7.43.0
Accept: */*
Content-Length: 11
Content-Type: application/x-www-form-urlencoded

key1=value1
```

:::

#### ❓`HTTP` 如何实现长连接

::: details 💡

> `HTTP` 长连接，又称为 “持续性连接”（`Persistent Connection`）

实现：

  - `HTTP/1.0` 版本要支持 “持续性连接”，必须在 `HTTP` 头信息中指定 `Connection: keep-alive`。

  - `HTTP/1.1` 版本中所有的连接默认都是 “持续性连接”，除非明确指定 `Connection: close` 关闭它。要实现长连接，服务器和客户端不必做任何特别的处理。

优点：复用已建立的 `TCP` 连接，减少 `TCP` 连接的创建和关闭所带来的额外开销，降低了延迟，提高了网页加载速度。

缺点：如果服务端和客户端之间没有数据交换，这个连接将会一直占用资源，可能会引发一些问题，比如连接数过多导致服务器资源耗尽。

应用：`Websocket` 和服务器推送(`Server Sent Event`)等实时通信技术中，它们对连接的保持时间和交互模式等有更具体的要求。

:::

#### ❓`HTTP` 断点续传涉及到哪些字段

::: details 💡

断点续传 `Header` 字段：

  - `Content-Length`：标识整个实体文件的大小，单位为字节。

  - `Content-Range`：在整个实体中本次发送的字节位置和总大小。
    > 例如，`Content-Range: bytes 0-499/1234`，表示本次请求是请求第 `0-499` 字节，整个文件大小为 `1234` 字节。

  - `Accept-Ranges`：表示服务器是否支持范围请求，及其支持的单位，通常为`bytes`。
  
  - `ETag`：表示资源的特定版本，通常是由资源内容的哈希值计算得到。

:::

> ❓怎么确保分片全部传输完后，文件的完整性和无篡改

::: details 💡
    
  - 使用 `Content-Length` 和 `Content-Range` 确认接收到的数据段的正确性。
   
  - 使用 `ETag` 。在整个传输过程中，`ETag` 应该保持不变。如果在传输过程中 `ETag` 发生改变，说明文件已经被修改，需要重新开始传输。

  - 在所有分片传输完毕后，对接收到的文件进行校验，比如使用 `MD5` 或者 `SHA` 验证其完整性。如果校验结果和预期相符，说明文件传输完整并且没有被篡改。

:::

------

## HTTPS

### ❓`HTTPS` vs `HTTP`

::: details 💡

概念：

  - `HTTP`: 是基于 `TCP/IP` 通信协议的一种数据传输协议。
  - `HTTPS` : `= HTTP + SSL`，在 `HTTP` 协议的基础加上了加密处理。

区别：

  - 安全性：
   
    * `HTTP`（超文本传输协议）：明文传输，数据在传输过程中如果被拦截，就可以直接查看内容，这就存在安全隐患。

    * `HTTPS`（超文本传输安全协议）：在 `HTTP` 的基础上增加了 `SSL/TLS` 协议，通过证书来验证服务器的身份，并对客户端和服务器之间传输的数据进行加密，保护了数据的私密性和完整性。

  - 性能：

    * `HTTP`：处理速度更快，延迟更低，但这是以安全性为代价的。

    * `HTTPS`：需要处理加密和解密过程，增加了一些处理开销，可能对性能产生影响。但随着技术的发展，这点性能影响在很多应用中已经几乎可以忽略不计。

  - 成本
  
    * `HTTP`：不要证书
    * `HTTPS`：需要证书，虽然有免费的证书，但高级的证书可能需要付费。

:::

### ❓`HTTPS` 比起 `HTTP` 有什么缺陷

::: details 💡

  - 建立连接时需要花费更长的时间：`HTTPS` 需要进行一次 "握手" 过程来建立一个安全连接。这个过程需要客户端和服务器之间来回传输多次信息，可能会导致连接的延迟。然而，现代技术如 `HTTP/2`、`TLS 1.3` 及 `QUIC` 已经大大缩短了这个延迟。

  - 更高的服务器资源消耗：由于 `HTTPS` 在传输数据前需要进行加密处理，因此会使用更多的 `CPU` 和内存资源。这可能会对处理能力有限的服务器造成一定的负担。

  - 证书的获取和管理：`HTTPS` 需要从认证机构获取 `SSL/TLS` 证书。虽然有一些免费的证书供网站使用，但如果需要高级的证书，可能需要额外付费。此外，证书的定期更新和管理也需要投入一定的维护成本。

  - 兼容性：有些老的设备或者系统可能不支持 `HTTPS` 或者只支持老的、安全性较低的 `SSL/TLS` 版本。
    
:::

### ❓`CA` 证书是什么解释一下

::: details 💡

> `CA` 证书，全称为证书授权（`Certificate Authority`）证书，是一个可信任的第三方机构发放的数字证书。`CA` 证书的作用主要是验证网站服务器的身份信息，保障信息在网络传输过程中的安全性。

  `CA` 证书中包含了公钥、身份信息和签名等内容。公钥用于加密信息或者验证数字签名，身份信息则是证明服务器的身份，签名则是 `CA` 机构对证书内容的认证。

互联网上的很多交互都需要数字证书的验证，比如HTTPS协议就需要用到。用户在访问一个HTTPS网站时，会先获取到网站的CA证书，通过验证证书的签名，确认证书的有效性和服务器的身份，之后再使用证书中的公钥加密信息进行传输，从而保证信息的安全。

总的来说，CA证书就像是一个网络世界的身份证，用来保证信息安全和身份验证。

:::

### ❓`CA` 证书申请流程

::: details 💡

  - 选择证书服务商：首先需要选择一个可信任的证书服务商（`Certificate Authority`，`CA`），如`DigiCert`、`Symantec`、`Let's Encrypt`等。

  - 生成 `CSR`：在服务器上生成一个证书签名请求（`Certificate Signing Request`，`CSR`）。`CSR` 包含了你的公钥和一些实体信息（例如你的组织名称、域名等）。

  - 提交 `CSR`：将生成的 `CSR` 提交给所选择的证书服务商。

  - 验证域名所有权：证书服务商会验证域名的所有权。验证方式通常有通过邮件验证、`DNS` 记录验证、`HTTP` 文件验证等。

  - 提供公司资质（可选）：如果是企业级的证书，像是`OV`（`Organization Validation`）或者`EV`（`Extended Validation`）证书，还需要提供一些相关的公司资质，如营业执照副本等，以供证书服务商进行审核。

  - 审核通过后获取证书：审核通过后，证书服务商会提供一个数字证书（通常是 `.crt` 或 `.pem` 文件）。这个证书包括了公钥和 `CA` 的签名等信息。

  - 安装证书：将得到的 `CA` 证书安装到服务器上。安装的方式和步骤根据服务器和使用的服务有所不同。

  - 测试验证：安装完证书后，可以通过浏览器来测试验证，看是否能正常访问 `https` 的网址并且显示出正确的证书信息。
    
:::

### ❓如何将 `CA` 证书安装到服务器上

::: details 💡

> 安装 `CA` 证书到服务器上的具体步骤主要取决于你的服务器类型和使用的 `web` 服务器软件。

  - `Nginx` 服务器的安装步骤：

    * 获取证书：
        > 假设已从 `CA` 获取了证书文件，通常是分别以`.crt` （您的域服务器证书）和 `.ca-bundle` （`CA` 链证书）为后缀的两个文件。
    * 上传证书文件：
        > 将这两个证书文件上传到 `Nginx` 服务器上，并存放在一个安全的目录下。例如：`/etc/nginx/certs`。
    * 合并证书文件：
        > 因为 `Nginx` 期望服务器证书和中间证书（`CA` 链证书）在同一个文件中，所以需要将两个文件合并到一起。 
        
        ```shell
        cat yourdomain.crt yourdomain.ca-bundle > yourdomain_with_chain.crt
        ```

    * 配置 `Nginx`：
        > 打开 `Nginx` 的配置文件，可能在 `/etc/nginx/nginx.conf` 或 `/etc/nginx/sites-available/default` 或者其他位置，找到 `server` 部分，并添加或修改以下行，使其指向你的证书文件和私钥文件：
        
        ```shell
        server {
           listen 443 ssl;
           server_name yourdomain.com;
           # ssl_certificate 指向证书
           ssl_certificate /etc/nginx/certs/yourdomain_with_chain.crt;
           # ssl_certificate_key 指向私钥文件
           ssl_certificate_key /etc/nginx/certs/yourdomain.key;
           ...
        }
        ```

    * 重启 `Nginx`：
        > 完成上述配置后，保存配置文件，并重启 `Nginx` 使其生效。
    
        ```shell
        sudo service nginx restart
        # 或
        sudo /etc/init.d/nginx restart
        ```
        
    * 验证证书安装：
        > 安装完成后，可以通过浏览器访问 `HTTPS` 网站来验证证书是否已被成功安装。在地址栏应该会显示一个绿色的锁图标，可以点击图标查看证书详情。
    

  - `Apache` 服务器按照流程
    
    * 获取证书：
        > 从 `CA` 获取的证书通常包括两个文件：一个是以 `.crt` 文件（服务器证书），包含你的公钥和网站信息；另一个是以 `.ca-bundle` 为后缀的文件（`CA` 链证书），包含了为证书签名的中级 `CA` 和根 `CA` 的公开证书。
    * 上传证书文件：
        > 将获取到的证书文件上传到服务器上，保存在一个安全的目录下。常见的目录包括 `/etc/apache2`、`/etc/httpd`、`/etc/nginx` 等，具体取决于你的服务器设置。
    * 修改 `Apache` 配置文件：
        > 打开 `Apache` 的配置文件（例如 `httpd.conf`，也可能是在 `sites-available` 或者其他地方的虚拟主机配置文件），找到或者添加一段关于SSL的配置。指定 `SSLCertificateFile` 指向刚刚上传的 `.crt` 文件，`SSLCertificateChainFile` 指向 `.ca-bundle`文件。
        
        ```xml
        <VirtualHost _default_:443>
            ...
            ServerName www.yourdomain.com
            ServerAlias yourdomain.com 
            SSLCertificateFile /path-to-your-file/yourdomain.crt 
            SSLCertificateChainFile /path-to-your-file/yourdomain.ca-bundle 
            ...
        </VirtualHost>
        ```
        
    * 重启 `Apache` 服务器：
        > 保存配置文件，然后重启Apache服务器来应用更改。在命令行输入`sudo service apache2 restart`（也可能是httpd，具体取决于你的设置）。

    * 测试证书安装：
        > 使用浏览器访问你的网站，查看是否显示了正确的锁标识和证书信息。或者可以使用在线的SSL检测工具进行检查。

:::

### ❓`SSL` 证书除了压缩加密，还有什么别的用处

::: details 💡

> `SSL`（Secure Sockets Layer）证书是一种安全协议。
  
  - 加密：`SSL` 证书可以用来对客户端与服务器之间的通信进行加密，防止数据在传输过程中被拦截与窃取。

  - 身份验证：`SSL` 证书包含了网站的公钥以及网站所有者的信息。
    > 当用户访问一个使用 `SSL` 证书的网站时，用户的浏览器会对这个证书进行检查，确认其有效性以及由可信的机构颁发，从而验证网站的真实身份。在这个过程中，网站所有者的信息对用户是可见的，提高了网站的可信度。

  - 完整性保护：`SSL` 证书还用来保护数据的完整性，确保数据在传输过程中没有被篡改。

注意：虽然说 "`SSL` 证书加密"，实际上更准确的说法应该是 “`SSL` 证书提供了一种方式，让服务器和客户端之间可以建立安全的加密通信”。因为证书本身并不进行加密操作，它包含的公钥和私钥才是用来加密和解密通信数据的工具。

:::

------

## FTP

### ❓`FTP` 和 `HTTP` 的区别

::: details 💡
    
  - `FTP`（`File Transfer Protocol`）: 文件传输协议

    * `FTP` 是文件传输协议，它是互联网上用于传输文件的协议之一。可以用于上传和下载文件。
    * `FTP` 使用两个不同的连接，一个用于传输数据，另一个用于控制断开和重新连接。
    * `FTP` 需要登录认证，即需要用户名和密码才能访问和控制文件。
    * `FTP` 可以经过配置以支持匿名访问，这使得任何人都可以下载公开的文件。

  - `HTTP`（`Hypertext Transfer Protocol`）

    * `HTTP` 是超文本传输协议，它是互联网上用于传输超文本（如 `HTML` 页面）的协议之一。
    * `HTTP` 使用一个连接进行所有的数据传输。
    * `HTTP` 通常不需要认证，可以直接访问网页并获取信息。
    * `HTTP` 不能实现像 `FTP` 那样的文件管理操作，如移动、删除、重命名等。
    * `HTTP` 使用的是明文传输，而 `HTTPS`（`HTTP Secure`）则是在 `HTTP` 上构建的使用 `SSL/TLS` 的安全版本。

总结：`FTP` 主要用于文件的传输和管理，而 `HTTP` 主要用于网页的浏览和信息的获取。

:::

------

## DNS

### ❓`DNS` 是什么

::: details 💡

> `DNS`（`Domain Name System`，域名系统）是互联网的一项核心服务，主要负责将易于人类理解的域名转换为计算机可理解的 `IP` 地址。这种将域名解析成 `IP` 地址的过程就称为 `DNS` 解析。

  `DNS` 是一个分布式数据库，由全球众多的 `DNS` 服务器组成，它们之间相互协作，将所有的域名和 `IP` 地址信息互相传递。当在浏览器中输入一个网址时，计算机会先向 `DNS` 服务器发送一个请求，询问这个域名对应的 `IP` 地址，然后 `DNS` 服务器会返回该 `IP` 地址，最后计算机会使用这个 `IP` 地址与网站服务器建立连接。

优点：
  
  - 可以使用容易记忆的域名来访问需要的信息，而不需要记住复杂的 `IP` 地址。
  - 由于是分布式的，`DNS` 系统具有很高的可扩展性和可靠性，使得可以随时随地访问互联网上的信息。

:::

### ❓`DNS` 解析过程

::: details 💡

  - 本地缓存查询：客户端浏览器会在本地缓存中查询此前是否有请求过这个域名的记录，如果有，直接返回对应的 `IP` 地址，然后进行连接访问。
    > 本地缓存通常有有效期，超过一段时间后会自动清空。

  - 向本地 `DNS` 服务器查询：如果本地缓存中没有找到，客户端浏览器会向本地的 `DNS` 服务器发送请求。
    > 本地 `DNS` 服务器通常由用户的 `ISP`（`Internet Service Provider`，互联网服务提供商）提供。

  - 转发请求到根服务器：如果本地 `DNS` 服务器中也没有相应的记录，它就会将这个请求转发到根 `DNS` 服务器。

  - 转发到顶级域服务器：根 `DNS` 服务器接收到请求后，会告诉本地 `DNS` 服务器，应该去顶级域（`TLD`，`Top-Level Domain`）服务器查询，比如 `.com` 的服务器。

  - 转发到权威服务器：顶级域服务器收到请求后会告诉本地 `DNS` 服务器，应该去请求 `example.com` 域的权威 `DNS` 服务器。

  - 在权威服务器查询并返回解析结果：权威服务器找到对应的 `IP` 并返回到本地 `DNS` 服务器，本地 `DNS` 服务器将解析结果返回给客户端，同时将结果缓存到本地，以便下次查询时快速返回。
  
  - 客户端收到 `IP` 地址后和服务器建立连接，从而访问网站。
  
总结：整个 `DNS` 解析过程实际上是一个递归和迭代查找的过程，如果某一步已经找到了对应的 `IP` 地址，则不需再进行下一步。

:::

### ❓接收到 `DNS` 查询结果之后还做了什么

::: details 💡

接收到 `DNS` 查询结果后，浏览器或操作系统会执行以下步骤：
  
  - 存储结果: 接收到的 `DNS` 结果会被存储到 `DNS` 缓存池中，以便将来再次访问相同域名时可以直接从缓存中获取，而无需再次进行 `DNS` 查询。这可以大大提高访问速度。

  - 使用 `IP` 地址: 浏览器会开始利用接收到的 `IP` 地址发起与目标服务器的连接请求。在这个过程中，可能还会使用到其他协议，例如 `TCP/IP` 协议，以确保数据包能够正确、完整地发送到目标 `IP` 地址并接收回应。

  - `HTTP` 请求: 一旦与目标服务器建立了连接，浏览器就会向服务器发送 `HTTP` 请求，请求下载网页内容或进行其他操作。
    
  - 解析和显示: 服务器返回 `HTML、CSS、JavaScript` 等文件后，浏览器会对这些文件进行解析并渲染网页，最后将网页内容显示给用户。
  
:::

### ❓`DNS` 缓存存在哪，有效期多少，可以设置吗

::: details 💡

`DNS` 缓存位置：

  - 浏览器缓存：当访问一个网站时，浏览器会存储该网站的 `DNS` 记录，直到其有效期到达，此后的查询可以直接在缓存中查找，而不必再向 `DNS` 服务器发送请求。

  - 操作系统缓存：如果浏览器缓存中没有找到，则会去操作系统的 `DNS` 缓存中查找。

  - 路由器缓存：如果操作系统缓存中也没有找到，会去路由器缓存中查找。

  - `ISP DNS` 服务器：如果以上步骤都没有找到，最后会去 `ISP`（互联网服务提供商）的 `DNS` 服务器中查找。

`DNS` 缓存的有效期
  >`DNS` 缓存的有效期（`TTL`，`time-to-live`）是可以被设置的，一般由 `DNS` 记录的所有者设置。`TTL` 的值表示了 `DNS` 记录在被重新查询和更新之前的存活时间。当 `DNS` 记录的 `TTL` 到达时，缓存中的该 `DNS` 记录会被清除，下一次查询时会直接向 `DNS` 服务器请求，以获取最新的记录信息。
  
  - 对于一些经常改变 `IP` 地址的网站，可能设置较短的 `TTL`，例如五分钟或十分钟；
  - 对于一些 `IP` 地址相对稳定的网站，可能设置较长的 `TTL` ，例如一天或一周。
    
:::

### ❓`DNS` 劫持

::: details 💡

> `DNS` 劫持，又称为域名劫持，是一种恶意行为。它是通过篡改 `DNS`（域名系统）服务器上网站的解析路径，将用户访问请求引导到恶意服务器或者错误的网页上，从而获取用户的个人信息或者进行网络攻击。

🌰 比如在浏览器中输入网址（比如 `www.google.com`）时，设备会首先查询 `DNS` 服务器以获取与该网址关联的 `IP` 地址。这是因为网络通信实际上是通过 `IP` 地址进行的，而不是直接通过网址。然而，如果 `DNS` 服务器被恶意篡改，那么查询到的 `IP` 地址可能会被引导到一个错误的或恶意的地方，这就是 `DNS` 劫持。

`DNS` 劫持的后果：

  - 用户被误导到仿冒网站，输入密码等个人信息 ，造成信息被盗取。

  - 用户访问速度变慢，被劫持的网页可能会弹出大量的广告。

  - 用户无法访问到真实的网站，影响正常的网络访问。

:::

### ❓常见的 `DNS` 格式

::: details 💡

  - **A 记录（Address Record）**：这是最常见的 `DNS` 记录类型。它将一个主机名映射为一个` IPv4` 地址。

  - **AAAA 记录（Quad A Record）**：这是一种用于 `IPv6` 地址的 `DNS` 记录类型。它将一个主机名映射为一个 `IPv6` 地址。

  - **CNAME 记录（Canonical Name Record）**：也称为别名记录，将一个域名映射为另一个真正的域名。

  - **MX 记录（Mail Exchanger Record）**：该记录用于告诉发送邮件的邮件服务器应将邮件投递到哪个主机或域。

  - **NS 记录（Name Server Record）**：该记录指示该域的 `DNS` 服务器是什么。

  - **TXT 记录（Text Record）**：该记录主要用于包含针对机器的有用文本信息，例如 `SPF` 数据或验证 `Google` 等的所有权。

  - **SRV 记录（Service Record）**：用于定义指定服务的服务器位置。

  - **SOA 记录（Start of Authority Record）**：记录某个服务器对某个区域负责

  - **PTR 记录（Pointer Record）**：与 `A、AAAA` 记录相反，它将一个 `IP` 地址映射为一个主机名。通常用于反向 `DNS` 查找。

:::

### ❓`DNS` 为什么用 `UDP` 而不用 `TCP`

::: details 💡

  - **速度**：`UDP` 相比 `TCP` 更轻量级，无需进行连接建立和断开的过程，因此在传输速度上优于 `TCP`。`DNS` 查询需要快速返回结果，因此 `DNS` 选择了更为高效的 `UDP`。

  - **资源占用**：`TCP` 连接需要维护连接状态，对于服务器来说，如果有大量的 `TCP` 连接，将需要维护大量的连接状态，而且 `TCP` 连接在断开后还需要维持一段时间的 `TIME_WAIT` 状态，这都是对资源的一种额外开销。而 `UDP` 是无连接的，对服务器端的资源占用更小。

  - **简单应用适合UDP**：`DNS` 查询一般只需要发送一次请求，然后接受一次响应。对于这种简单的请求/响应模式，`UDP` 比 `TCP` 更适合。

注意：虽然 `DNS` 主要使用 `UDP`，但在某些情况下也会使用 `TCP`，比如当 `UDP` 包无法容纳全部的 `DNS` 响应数据时，就需要使用 `TCP`。`TCP` 也会在区域传输（`zone transfers`）等场景下使用。

:::

### ❓`DNS` 中迭代查询和递归查询的区别

::: details 💡

  - **迭代查询**：`DNS` 客户端（通常是一个 `resolver` 或者另一个 `DNS` 服务器）发送请求到 `DNS` 服务器，如果这个 `DNS` 服务器本身无法回答这个问题（比如需要查询的域名它并没有缓存），它会提供一个"最好的答案"给客户端。这个答案通常是查询域名的权威服务器的一个引用。然后客户端针对这个引用再发起另外一个请求。在迭代查询中，本质上客户端是轮询 `DNS` 服务器，获取最后的查询结果，整个过程中客户端做了更多的工作。

  - **递归查询**：`DNS` 客户端发送请求到 `DNS` 服务器，如果这个 `DNS` 服务器本身无法回答这个问题，它会替客户端询问其他 `DNS` 服务器，并向客户端返回最终的查询结果，整个过程对客户端来说是透明的，所以在递归查询中， `DNS` 服务器执行了更多的工作。
    
总结：迭代查询是“去找别人”，递归查询是“帮你去找别人”。

:::

------

## 抓包

### ❓抓包工具抓取 `HTTPS` 的原理

::: details 💡

原理：通过 “中间人攻击”（`Man-in-the-middle attack`, `MITM`）方式。

  - 当客户端向服务器发出 `HTTPS` 请求时，抓包工具会插入到它们之间，生成一对新的公钥和私钥，并向客户端发送公钥以及伪造的服务器证书，客户端由于信任这个伪造的证书，接受公钥并用它来加密发送的数据。

  - 当抓包工具收到客户端加密后的数据，会用自己的私钥解密数据，然后读取并记录明文信息。此时的抓包工具就像是客户端向其发送 `HTTPS` 请求的服务器。接着，抓包工具用真正的服务器的公钥把数据重新加密后，发送给真正的服务器。

  - 当真正的服务器响应以后，抓包工具再次插入到通信的过程中，使用真正的服务器的公钥解密响应消息，然后再用自己的私钥加密并发送给客户端。

注意：这种方法需要客户端能够信任抓包工具生成的伪造证书，否则客户端将无法信任并接受这个公钥和伪造的服务器证书，通信就会失败。在实际操作中，这通常是通过在客户端安装一个由抓包工具颁发的根证书来实现的。

:::

### ❓`Charles` 抓包软件的原理

::: details 💡

  可以将它理解成中间人攻击。客户端将 `Charles` 作为代理服务器(中间人)。客户端所有请求都会先发送给 `Charles`，`Charles` 再将客户端的请求转发给服务器。`Charles` 收到服务器响应之后，再将从服务器收到的回复内容转发给客户端。这样请求和响应数据都被 `Charles` 记录下来，再通过界面展示即可。
  
  对于 `HTTP` 相对来说比较简单，直接进行接收和转发即可。而 `HTTPS` 中涉及 `CA` 认证，所以客户端需要进行的操作信任 `Charles` 的证书，这样通过 `Charles` 发送给客户端的公钥就可以通过这个证书校验成功，从而完成通信。

:::

### ❓不使用 `Charles`，`4G` 网络如何抓包

::: details 💡

  -  `Wireshark`：这是一种广泛使用的网络封包分析软件，它可以捕获网络封包，并尽可能显示出最为详细的封包数据。使用 `Wireshark` 可以在设备（需要配合其他工具如 `tcpdump`）和无线路由器（如果它被配置为 `Wireshark` 可以在其上运行）之间抓取流量。

  - `Tcpdump`：一个 `Powerful` 的命令行抓包工具，可以获得传输在网络上的 `TCP/IP` 数据包的详细信息。

  - 使用 `Android` 手机的抓包应用，例如 `Packet Capture`, `tPacketCapture` 等。

  - 使用代理服务器，把手机的网络流量通过代理服务器，然后在代理服务器上抓包。一些云服务提供商(例如`AWS`，`GCP`，`Azure` 等)可以提供方便的网络流量采集功能。

:::

### ❓为什么 `Wireshark` 不能直接抓取 `SSL` 的原始数据

::: details 💡

> `SSL`（`Secure Sockets Layer`，安全套接字层），以及其继任者`TLS`（`Transport Layer Security`，传输层安全），是用于保护网络通信的加密协议。所有通过 `SSL` 或 `TLS` 通信的数据在网络上的传输过程中是被加密的。

  只有当数据到达目标服务器或客户端，并且使用正确的私钥进行解密后，数据的内容才可以被读取。因此，使用 `Wireshark` 等抓包工具直接抓取 `SSL/TLS` 通信的数据包，只能看到加密后的数据，而不是原始的明文数据。

  如果有服务器或客户端的私钥，或者能在客户端和服务器之间设置一个可以解密数据的代理（例如“中间人攻击”方式），那么 `Wireshark` 是可以解析并显示 `SSL/TLS` 加密通信的原始明文数据。只要在 “协议” 属性中设置对应的私钥文件，或者配置  `SSLKEYLOGFILE` 环境变量，使其指向一个由浏览器或其他应用生成的密钥日志文件，就可以看到解密后的明文数据。

总结：由于 `SSL` 的设计初衷是保护网络通信的安全，防止数据在传输过程中被窃取或篡改，所以 `Wireshark` 等抓包工具不能直接抓取 `SSL` 的原始数据。这也确保了在使用 `HTTPS`、`IMAPS`、`POPS`、`FTPS` 等基于 `SSL/TLS` 的服务时，通信的安全性和隐私性。

:::

### ❓如何设计一个 `HTTPS` 抓包

::: details 💡

  设计一个 `HTTPS` 抓包工具，实际上是要设计一个中间人（`Man-In-The-Middle`，即 `MITM`）攻击的代理服务器。前提是必须要获得客户端的信任，让客户端愿意接受我们的证书，否则客户端将无法访问 `HTTPS` 服务。

  - 创建一个服务器，用于接收来自客户端的 `HTTP` 或 `HTTPS` 请求。根据请求的协议和头信息，判断是否需要进行 `HTTPS` 抓包。

  - 当接收到 `HTTPS` 请求时，先向 `HTTPS` 服务器发送一个连接请求，获取服务器的证书和公钥。

  - 创建一个自签名的 `SSL` 证书，并将步骤 2 中获取的公钥填入其中。这样，就拥有了一个具有目标服务器公钥的证书。

  - 返回这个自签名证书给客户端。相当于告诉客户端：“我就是你想访问的服务器，把你的数据加密后给我”。

  - 客户端收到证书后，会验证证书的有效性。在这里有两种情况：
    * 手动安装：如果抓包工具是用户自愿使用的（如调试工具），那么用户可能会主动将证书添加到受信任的证书列表中。在这种情况下，客户端会认为证书有效，并继续与服务器进行通信。
    * 非手动安装：在网络攻击的情况下，无法控制客户端的行为。如果客户端没有将证书加入到受信任的列表中，客户端会拒绝与服务器通信。

  - 客户端验证通过后，服务器就可以接收到客户端加密后的数据。由于拥有证书的私钥，可以对加密数据进行解密，实现了 `HTTPS` 的抓包。

:::

------

## 情景题

### 通信流程

#### ❓文件下载一般用什么协议，`UDP` 还是 `TCP`

::: details 💡

> 文件下载一般使用的是 `TCP` 协议。

  `TCP`（`Transmission Control Protocol`，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在 `TCP` 协议中，发送者和接收者会在数据交换前建立一条连接，确保数据能按照顺序后且未被破坏的送达目的地。

  文件下载通常需要高可靠性，`TCP` 提供这种可靠性，且 `TCP` 能够处理网络拥塞和数据出错的问题。例如，`HTTP` 和 `FTP` 都是基于 `TCP` 的协议，通常用于文件下载。

  相较之下，虽然 `UDP`（`User Datagram Protocol`，用户数据报协议）的传输速度可能会比 `TCP` 更快（因为 `UDP` 不需要进行复杂的错误检查和包确认等流程），但 `UDP` 不保证数据包的到达，因此通常不用于文件下载。`UDP` 更常用于实时应用，如音视频流传输、游戏等，这些应用对于数据丢失有一定的容忍度，但对时间敏感。
    
:::

#### ❓访问一个网站的详细过程

::: details 💡

  - 浏览器解析 `URL`：在浏览器中输入网址（`URL`），浏览器首先需要解析这个 `URL`，确定要请求的是哪个网站。

  - `DNS` 解析：浏览器通过 `DNS`（`Domain Name System`，域名系统）将网站的域名解析成服务器的 `IP` 地址。`DNS` 解析通常会在本地缓存、操作系统缓存、路由器缓存、`ISP DNS` 服务器等多个层面进行。
    
  - 建立 `TCP` 连接：得到服务器的 `IP` 地址后，浏览器会向服务器发起一个 `TCP` 连接请求，通常是三次握手。

  - 发送 `HTTP` 请求：`TCP` 连接建立好后，浏览器就可以向服务器发送 `HTTP` (`Hypertext Transfer Protocol`，超文本传输协议) 请求了。这个请求中包括要获取的资源（比如一个 `HTML` 页面）、请求的方法（比如 `GET` 或 `POST`），以及一些其他的头信息。

  - 服务器处理请求并返回 `HTTP` 响应：服务器接收到 `HTTP` 请求后，会解析请求，然后查找请求的资源并返回给浏览器。返回的 `HTTP` 响应中包括一个状态码（比如 `200` 表示成功，`404` 表示找不到页面），以及请求的资源内容，比如一个 `HTML` 页面。
    
  - 浏览器渲染页面：浏览器接收到服务器返回的 `HTML` 页面后，会对其进行解析和渲染，显示给用户。如果页面中还包含其他资源的链接（比如图片、`CSS` 样式、`JavaScript` 脚本等），浏览器会再次发起 `HTTP` 请求获取这些资源，然后一起渲染到页面上。

  - 断开连接：如果没有设置持久连接（`HTTP 1.1`默认为持久连接），浏览器和服务器会断开 `TCP` 连接，等待下一次请求。如果是持久连接，那么在一段时间内，浏览器和服务器的 `TCP` 连接会保持，便于传输更多的资源。

:::

#### ❓打开浏览器，输入网址到看到网站首页都经历那些过程，你觉得最耗时是哪里，怎么优化

::: details 💡
  
访问流程：
  
  - **DNS 查询**：浏览器需要解析输入的 `URL` 中的域名到对应的 `IP` 地址，这个过程需要通过网络进行 `DNS` 查询。

  - **建立TCP连接**：浏览器使用解析得到的 `IP` 地址与服务器建立 `TCP` 连接，也即进行三次握手。

  - **发送HTTP请求**：浏览器通过建立好的 `TCP` 连接向服务器发送 `HTTP` 请求，包括 `GET、POST` 等请求。

  - **服务器处理请求并返回HTTP响应**：服务器接收到请求后进行处理，并返回一个 `HTTP` 响应，包含了请求的文件、数据等信息。

  - **浏览器处理返回的响应**：浏览器接收并处理来自服务器的 `HTTP` 响应，对响应中的 `HTML`、`CSS` 和 `JavaScript` 等资源进行解析和渲染，如果有其他资源（如图片、音视频资源），可能还需要进行额外的 `HTTP` 请求。

  - **断开连接或者在请求其他资源后保持连接**，如果没有设置持久连接，浏览器和服务器会断开 `TCP` 连接，如果是持久连接，线路会在传输更多资源后保持。

优化方案：

  - **优化DNS查询**：使用更快的 `DNS` 服务器，使用 `DNS` 缓存，使用 `DNS` 预读取等方法。

  - **减少TCP连接次数**：使用 `HTTP` 持久连接（`HTTP/1.1` 默认开启），利用浏览器并行连接的特性，使用 `HTTP/2` 多路复用等。

  - **优化服务器处理**：提高服务器硬件性能，优化后端代码，使用服务器缓存，使用 `CDN` 等。

  - **减少HTTP请求以及减小请求/响应大小**：合并文件、压缩文件、使用浏览器缓存，使用更高效的文件格式等。

  - **优化页面渲染**：避免重排和重绘，使用懒加载、异步加载等技术，对 `JS/CSS` 进行优化等。

:::

#### ❓使用 `ssh` 连接云服务器，整个网络通信过程

::: details 💡

> `SSH`(`Secure Shell)`: 一种网络协议，用于计算机用户通过加密的方式进行远程登录到另一台计算机上。

  - **地址解析**：连接的云服务器的IP地址或者域名。如果你使用的是域名，那么会通过 `DNS` 服务解析出服务器的真实 `IP` 地址。

  - **TCP握手**：设备会向这个 `IP` 地址发起一个 `TCP` 连接。这个过程包括三次握手，确保双方都已经准备好开始通信。

  - **SSH连接**：`TCP` 连接建立后，设备会发起 `SSH` 的连接请求。在这个请求中，会包含计算机的公钥（如果设置了密钥登录的话）或者用户名和密码信息。

  - **身份验证**：云服务器接收到 `SSH` 请求后，如果使用的是密钥登录，那么服务器会使用存储的公钥信息来验证私钥是否匹配；如果使用的是用户名和密码，那么服务器就会验证用户名和密码是否正确。只有在验证通过后，才会允许 `SSH` 连接。

  - **会话开始**：一旦获得许可，一个 `SSH` 会话就会建立，就可以开始在这个终端会话中运行命令，操作云服务器了。

  - **会话结束**：当结束这个 `SSH` 会话时（比如输入 `exit` 命令），那么这个 `SSH` 连接就会关闭，并释放这个 `TCP` 连接。

注意：`SSH` 协议提供了一种安全的、加密的网络通信机制，所以在整个通信过程中，所有的数据都是被加密的，这就保证了数据的安全性和隐私性。

:::

### 音视频

#### ❓在整个视频面试的过程中，可能会用到哪些协议，都在哪几层

::: details 💡

  - **物理层和链路层**：`Ethernet`（以太网）协议用于实现局域网中的设备交互，`Wi-Fi` 用于无线网络通信。这些通常在物理层和数据链路层起作用。

  - **网络层**：`IP` 协议（Internet Protocol）用于在网络中定位设备，并在设备之间传输数据包，它在网络层起作用。

  - **传输层**：`TCP` 协议（传输控制协议）用于在网络中创建连接并提供可靠的数据传输。而 `UDP` 协议（用户数据报协议）则提供无连接的快速数据传输，用于实时通信，如音视频传输。

  - **会话层和表示层**：这两层在现代网络中并不明确区分，不过 `SSL/TLS` 协议提供了数据加密的服务，可视为在此两层中。

  - **应用层**：`HTTP/HTTPS` 协议用于网络浏览器与服务器之间的通信，`RTMP`(`Real Time Messaging Protocol`) 或者 `WebRTC`（`Web` 实时通信）等是专为流媒体和通信设计的协议，用于实时音视频数据传输。

:::

#### ❓为什么视频会议用 `UDP`

::: details 💡

  - 实时性：视频会议要求音频和视频数据能够尽快地传输和播放，这需要低延迟的传输协议。`UDP` 协议是一种无连接协议，不需要建立和维护复杂的连接状态，因此可以减少很多网络延迟。

  - 容忍数据丢失：在视频会议中，如果偶尔丢失一些音频或视频数据包，并不会对整体的通信质量产生太大影响，相反，如果使用了 `TCP` 协议，`TCP` 会尝试重传丢失的数据包，这可能引入更多的网络延迟，影响通信的实时性。

  - 简单高效：和 `TCP` 相比，`UDP` 的协议头部更简单，处理起来更高效，可以用于构建高性能的实时应用。

  - 处理网络拥塞：`UDP` 不会像 `TCP` 那样根据网络拥塞来调整数据的发送速率，这样即使在网络不稳定的环境下，也可以保证视频会议的流畅性。

  - 更好的支持多播和广播：视频会议常常需要同时向多个端点发送同样的数据，这种场景下 `UDP` 比 `TCP` 更有优势。

结论：由于 `UDP` 协议的实时性、容错性、简单高效和对多播和广播的良好支持，视频会议通常会选择使用 `UDP` 协议。然后，通过在应用层添加一些错误控制和恢复机制，来确保通信质量。

:::

#### ❓用 `UDP` 实现音视频，有什么方法可以保证通话质量

::: details 💡

  - 应用层的重传：在关键数据流（例如关键帧）丢失时，应用可以选择重新发送丢包。

  - 使用前向纠错（`FEC`）：`FEC` 可以在发送端加入冗余数据，即使部分数据丢失，也能借助冗余数据进行恢复。

  - 使用差错控制编码：如 `RS`(`Reed-Solomon`) 编码等，可以帮助接收端修复部分丢失的数据。

  - 交错和抖动缓冲：将数据打包为更大的单位并交错发送，可以减少丢包率对于解码的影响。另外，应用可以在客户端使用抖动缓冲区，对接收的数据包进行排序和缓冲，以适应网络延迟的变化。

  - 利用 `QoS`(`Quality of Service`)：通过对网络进行优化，如设置优先级，保证音视频流的带宽、延迟等。

  - 码率自适应：根据网络状态动态调整音视频的编码率。

  - 使用实时传输协议（`RTP`）以及实时传输控制协议（`RTCP`）
    * `RTP` 提供了标准化的包结构用于音视频数据。
    * `RTCP` 提供关于网络状况的反馈。

:::

#### ❓如果用 `TCP` 实现音视频，需要建立几次连接

::: details 💡

> 至少需要建立一次连接。

  - `TCP` 是一种面向连接的协议，它需要在传输数据前与另一台设备建立一个连接。
    > 在一个音视频通话场景中，至少需要建立一次连接，这个连接用来传输音频和视频数据。

  - 某些情况下，可能需要建立多个TCP连接。
    > 例如，如果音频和视频数据需要由不同的服务器分别处理，那么就可能需要分别对每个服务器建立一个连接。又或者，如果需要在音视频传输的同时进行其他的数据交换（比如文本聊天，文件传输等），那么也可能需要额外建立一个或多个 `TCP` 连接。

  - `TCP` 连接的数量也可能与特定的应用架构或协议有关。
    > 例如，在 `WebRTC`（一种用于实时通信的开放源代码项目）中，音频和视频流通常会使用单独的连接，以便单独控制它们的传输质量。

:::

### 故障分析

#### ❓如果发现微信和 QQ 都可以正常使用，但是浏览器网页打不开，可能是什么原因，有什么排查的办法

::: details 💡

  - 浏览器设置问题：可能浏览器的代理设置被修改，或者被某些恶意软件更改了网络设置。

  - `DNS` 解析问题：微信和 `QQ` 服务器的 `IP` 地址可能已经在本地缓存中，不需要 `DNS` 解析，但是浏览器访问网站需要 `DNS` 解析域名到 `IP`，如果 `DNS` 解析出现问题，就会导致网页无法打开。

  - 网络连接类型：有些网络环境对不同类型的网络连接有限制，可能对浏览器使用的 `HTTP/HTTPS` 协议进行了限制。

:::

>❓有什么排查的办法

::: details 💡

  - 检查并重置浏览器设置：确认浏览器的网络设置是正确的，没有被错误的代理服务或 `VPN` 干扰。也可以尝试重置浏览器设置，或者使用另外一种浏览器试试。

  - 更换 `DNS`：试着更换一下 `DNS` 服务器地址。
    > 例如，更改为 `Google` 的公共 `DNS` 地址 `8.8.8.8` 或 `8.8.4.4`。

  - 使用命令行工具：可以使用 `Ping` 命令检查网络连接，使用 `nslookup` 命令检查 `DNS` 解析是否正常。

  - 查看防火墙设置：检查一下个人电脑的防火墙或者路由器设置，看看是否对 `HTTP/HTTPS` 协议有所限制。

  - 在移动设备上测试：如果有条件的话，可以尝试在手机或者其他电脑上连同样的网络，看看能否正常使用浏览器访问网页。

:::

#### ❓在北京 `HTTP` 请求服务器响应快，可能离服务器距离近；而在上海访问就非常慢，会是什么原因
::: details

  - 网络路径和距离：尽管距离在物理上相近，但在网络传输上，信息可能要经过多个节点才能到达目的地。网络堵塞、路由器性能、网络提供商等都会影响网络的传输速度。从上海到服务器的网络路径可能比从北京到服务器的网络路径复杂，进而造成延迟增加。

  - 服务器负载：如果服务器在处理上海的请求时负载过高，可能会导致响应速度下降。
    > 比如，如果服务器同时处理的请求太多，或者服务器上运行的其他应用占用了大量资源，都可能导致服务器处理请求的速度降低。

  - `CDN` 配置：如果服务器使用了内容分发网络（`CDN`），但没有在上海或者附近地区设置节点，那么上海的用户就需要从远处的服务器获取数据，这会增加延迟。

  - `DNS` 解析：如果服务器的 `DNS` 解析服务在上海的效率较低，也会使得上海用户在获取服务器地址时花费更多的时间。
    
:::

>❓如果用户投诉，怎么分析这个问题

::: details

  - 网络状况检测：首先可以进行一些基础的网络性能测试。
    > 比如 `Ping` 和 `Traceroute`，用来检测数据包到达服务器所需的时间以及经过的节点。`Ping` 可以查看网络延迟，`Traceroute` 可以看到数据包到达服务器所经过的所有路由节点。如果发现某一跳的延迟特别高，可能就是出问题的地方。

  - `CDN` 是否使用：如果服务器使用了内容分发网络 (`CDN`)，检查 `CDN` 是否在有问题的地方正常工作。
    > `CDN` 运营商通常会在全国各地设立节点，如果某个地方的节点出现问题，可能会导致该地区的访问速度变慢。

  - 带宽查看：查看服务器的带宽使用情况，如果带宽使用过高，可能会导致访问速度变慢。

  - 服务器性能查看：分析服务器性能指标。
    > 如 `CPU` 使用率、内存使用情况、`I/O`等，如果服务器负载过高，可能会影响服务的响应时间。
   
  - 投诉用户所在网络环境分析：了解投诉用户的网络环境。
    > 如网络运营商，网络类型（光纤、`ADSL`、`4G`等），或者在其他网络环境下访问情况，以排除是用户本身网络原因导致的问题。

  - 应用层面的检查：除了硬件和网络，还要检查应用层面。
    > 比如服务器是不是出现了错误、是否有大量的请求等。

  - 最后，如果问题还是无法定位，或者是跨越多个网络运营商的问题，则需要与网络服务提供商进行沟通，可能能提供更多的信息或者解决方案。

:::

#### ❓整个网络过程中，网络耗时会在什么地方，怎么优化

::: details 💡

  - `DNS` 查询：当你向一个 `URL` 发送请求时，浏览器或应用需要首先通过 `DNS` 查询这个 `URL` 的 `IP` 地址。`DNS` 查询有时会非常耗时，特别是在初次查询或 `DNS` 缓存失效的情况下。
    > 优化方法：可以在服务端的解析服务器采用 `CDN` 来加速 `DNS` 的解析速度，或者使用 `DNS` 预获取技术，在加载页面或者应用的时候，预先进行 `DNS` 查询。

  - 建立连接：根据协议的不同（`HTTP/HTTPs`），建立连接需要消耗不同的时间，特别是在握手过程中。
    > 优化方法：可以使用 `HTTP/2`，支持单一连接上并行交错（`multiplexing`）请求和响应，从而避免 `HTTP/1.1` 中的队头阻塞（`Head-of-line blocking`）问题。

  - 服务器处理：服务器处理请求并生成响应数据也会需要一些时间。特别是在处理复杂查询或生成大量数据时，这部分时间可能会非常长。
    > 优化方法：在于服务端的性能优化，例如使用合适的算法和数据结构，以及适当的系统和应用层缓存。针对数据库查询，可以优化 `SQL` 语句或者进行合适的数据库设计和索引。

  - 数据传输：数据在网络传输中耗时，取决于数据量和网络带宽。
    > 优化方法：可以使用数据压缩技术，尽量减少传输的数据量。还可以使用分块传输编码（`Chunked transfer encoding`），让服务器生成响应时就可以开始发送数据。

:::

#### ❓如果手机应用与服务器通过 `TCP` 连接，这个时候手机切换为飞行模式，服务器可以短时间内知道到手机离线状态吗

::: details 💡

  服务器通过 `TCP` 短时间内是不能知晓手机的离线状态的。因为 `TCP` 主要是为了保证数据的可靠传输，通信双方是通过数据交换来了解对方状态。而 `TCP` 并没有设计心跳检测机制，所有就没有实时检测对方是否离线的能力。

  回到 `TCP` 的运行机制，当一方断开连接时，通常会发送一个 `FIN` 包到另一方。但是当手机进入飞行模式时，它并没有发送任何类型的 `TCP` 包到服务器，所以服务器并没有明显的迹象表明手机已经离线。

两种机制：

  - `TCP` 超时：`TCP` 连接有一个超时机制，一旦连接上没有数据传输并且超过了给定的时间限制，那么连接就会被关闭，服务器会知道手机已经离线。

  - `Keep-Alive`：如果在服务器和手机之间启用了 `TCP` 或应用层的 `Keep-Alive` 机制，服务器会定期向手机发送小的数据包来检查连接是否仍然有效。如果手机没有响应这些数据包，服务器将知道手机已经离线。

结论：两种机制都需要一段时间才能工作。因此，如果手机切换到飞行模式，服务器并不能立即知道这一点。但是经过一段时间后，一旦服务器尝试向手机发送数据或者执行 `Keep-Alive` 检查并且失败，那么服务器就会知道手机已经离线。
   
:::

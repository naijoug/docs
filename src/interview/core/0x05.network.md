---
title: network - “网络”
icon: hashtag

index: true

---

<!-- more -->

## 概念知识

### 网络模型

#### ❓`OSI` 七层模型

::: details 💡

> `OSI`(`Open Systems Interconnection` - 开放系统互连) 模型，是描述和理解复杂网络系统交互和通信机制的重要工具。该模型将网络通信分解为七层，每个层次完成特定的功能，提供下一层所需的接口和服务。

自顶向下：

  - 应用层：负责与软件应用程序（例如 `Web` 浏览器、电子邮件客户端等）交互，以确保发送和接收有效的数据。
  
  - 表示层：负责定义数据格式和加密。
  
  - 会话层：负责在数据封装的端点之间建立、管理和终止连接。
  
  - 传输层：负责提供端到端的可靠传输。主要协议有 `TCP` 和 `UDP`。
  
  - 网络层：负责决定数据的路径和转发，包括 `IP` 地址处理和路由。
  
  - 数据链路层：负责在数据网络中传输数据包，包括错误检测和修正。
  
  - 物理层：负责传输比特流（数据的二进制形式），包括如何通过通信媒介（如电缆、光纤等）进行物理连接，如何识别设备等。

注意：`OSI` 模型并不是任何一个实际的网络协议族，而是作为一个参考模型，帮助人们描述和理解不同网络协议的功能和如何协同工作。

:::

#### ❓`TCP/IP` 五层模型

::: details 💡

自顶向下：

  - 应用层 : `DNS`、`HTTP`、`HTTPS`、`RPC`、`P2P` (`DHCP`、`RTMP`、`GTP`)
    > 应用层包括许多协议，如 `HTTP` 协议，`FTP` 协议，`DNS` 协议，它负责如何处理特定类型的网络连接，即应用程序和网络之间的通信协议。
    
    `OSI` 七层模型中，将应用层细分为(应用层、表示层、会话层)
    
      * 应用层：负责与软件应用程序交互，以确保发送和接收有效的数据。
      * 表示层：负责定义数据格式和加密。
      * 会话层：负责在数据封装的端点之间建立、管理和终止连接。

  - 传输层 : `TCP`、`UDP`、`QUIC`
    > 传输层负责将数据进行分段，并保证这些分段正确无误的到达目的地，再在目的地将这些分段重新组合。`TCP` 和 `UDP` 协议就在这一层。
    
  - 网络层 : (`IP` 层) `IP` (`ICMP`、`OSPF`、`BGP`、`IPSec`、`GRE`)
    > 网络层控制子网的操作，处理将数据包从源传送到目的地的任务，这包括在复杂的网络中处理路由和全局地址。

  - 链路层 : (`MAC` 层) `ARP`、`VLAN`、`STP`
    > 数据链路层在物理层之上，它负责如何在两个节点之间传输数据，处理由物理层的硬件错误产生的问题，例如数据错误，数据丢失等。

  - 物理层 : 
    > 提供了网络通信所需的硬件接口，负责把帧数据转换为适合物理介质的形式，即用来传输比特流。不同的介质和具体的设备有许多协议，例如 `Ethernet`、`Wi-Fi`、`Bluetooth` 等。

:::

#### ❓`TCP/IP` 模型 vs `OSI` 模型

::: details 💡

 `TCP/IP` 模型和 `OSI` 模型都是网络通信模型，都有对网络通信进行分层的思想，但是两者的层数以及每一层承担的责任有所不同。

  - `TCP/IP` 模型是一个五层结构（物理层、数据链路层、网络层、传输层、应用层）；`OSI` 模型则是一个七层结构（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）

  - `TCP/IP` 模型是在 `OSI` 模型基础上简化而来的。在 `TCP/IP` 模型中，`OSI` 模型中的 (会话层、表示层和应用层) 统一归为了应用层，因此 `TCP/IP` 模型的应用层比较复杂。
    
  - 两者在层次划分上的哲学不同。`OSI` 模型倾向于详尽地将网络通信过程中的所有可能的环节进行分层；而 `TCP/IP` 模型更倾向于从实用的角度，基于实际的网络硬件和网络协议进行分层。
  
:::

### ❓为什么能通过一个 `URL` 就能请求到对应的资源

::: details 💡

> `URL`（`Uniform Resource Locator` - 统一资源定位符），它给出了网络上某一资源的绝对位置，其结构包含了请求资源所需的所有信息，因此能够通过 `URL` 向服务器请求并获取资源。

`URL`的基本结构：`protocol://hostname:port/path?query#fragment`

  - `Protocol`（协议）：指定了客户端与服务器需要遵循的通信规则。
    > 例如 `HTTP`、`HTTPS`、`FTP` 等。

  - `Hostname`（主机名）：标识了网络上机器的位置。服务器和客户端通过网络连接进行通信，主机名作为服务器的标识，可以让客户端找到正确的服务器。
    > 例如 `www.google.com`

  - `Port`（端口号）：指定了服务器上的特定服务，每个服务在服务器上都有一个唯一的端口号。

  - `Path`（路径）：指定了服务器上的特定资源。它通常包含了相关文件或者页面的目录结构信息。

  - `Query`（查询）：这部分以 `?` 开头，用于传递额外的参数。在访问动态网页的时候，查询字符串通常用于指定查询参数。
    
  - `Fragment`（片段）：这部分以 `#` 开头，只在客户端浏览器中起作用，用于定位特定的页面元素。

结论：通过以上元素组成的 `URL` 可以精确地定位到网络上的资源，因此可以通过一个 `URL` 就能请求到对应的资源。

:::

### ❓`MTU` 了解吗

::: details 💡

  > `MTU`(Max Transfer Unit)：最大传输单元，指的是网络中一种协议可以在不进行分片的情况下发送的最大数据包大小。

  在网络中，数据包的大小不能超过 `MTU` 大小，否则在发送过程中数据包会被分片。`MTU` 大小的设置取决于发送这些数据包的物理媒介或者网络协议。
  
  > 例如，在以太网中，`MTU` 的大小通常设置为 `1500` 字节。

  当数据包在网络中传输时，可能会经过不同的网络设备，这些设备可能有各自的 `MTU` 大小。为了避免数据包被分片，或者减少数据包的分片次数，路由器和其他网络设备可能采用最小 `MTU`（所有设备中 `MTU` 最小的值）进行发送。

  - 过大的 `MTU`：会导致数据包在传输过程中过于庞大，增大网络负担和延迟。
  - 过小的 `MTU`：会使得数据包过小，分片过多，影响网络效率。

  > 例如：`POST` 请求增加 `Content-Length` 参数后，数据传输过大时可能导致 `Broken pipe` 报错，调整 `MTU` 值可以解决这个问题。 

:::

### ❓全双工和半双工模式是什么

::: details 💡

“双工”：数据传输的两个方向的工作状态。

  - 全双工（`Full-Duplex`）模式：通信系统中的两个设备可以同时进行发送和接收操作。两个方向是独立的，可以同时进行。
    > 例如：电话，我们可以同时听对方说话，同时跟对方说话，这就是全双工的例子。

  - 半双工（`Half-Duplex`）模式：通信系统中的设备不能同时发送和接收数据。两个方向是互斥的，一次只能有一个方向在进行数据传输。
    > 例如，对讲机，就是一种半双工设备，当一个人按下按钮说话时，其他人只能听，不能同时说话。

:::

### ❓`Cookie` vs `Session`

::: details 💡

> `Cookie` 和 `Session`都用于跟踪用户的状态。

区别：

  - **存储位置**：
    * `Cookie`  保存在客户端（浏览器）。
    * `Session` 保存在服务端。

  - **生命周期**：
    * `Cookie`  的生命周期：由创建时设定的过期时间决定，可以持久化存储，即使关闭浏览器或者关机，只要还未到达过期时间就能继续使用。
    * `Session` 的生命周期：以服务器为准，当浏览器关闭，或者` Session` 超时（根据服务器设置），`Session` 就会失效。

  - **安全性**：
    * `Cookie`  存储在客户端，较容易被恶意用户分析和篡改，所以敏感信息通常不存储在 `Cookie` 中。
    * `Session` 存储在服务端，相对来说保密性更好。

  - **容量**：
    * `Cookie`  对大小有限制，每个站点的 `Cookie` 总量大致在 `4KB` 左右。
    * `Session` 没有大小的限制，可以存储大量数据。

  - **对服务器压力**：
    * `Cookie`  是保存在客户端，对服务器压力较小。
    * `Session` 是存储在服务端，如果并发访问用户很多，服务器的压力就会变大。

  - **应用场景**：
    * `Cookie`  经常用于保存用户一些偏好设置，用户名等非敏感信息。
    * `Session` 经常用于需要记录的敏感信息，如用户的登录状态。

实际应用：往往会结合两者使用。
  
  > 例如，服务器创建一个 `Session` 发送给客户端(浏览器)，然后客户端将 `Session` 的唯一标识符存储在 `Cookie` 中，这样既利用了 `Cookie` 方便的客户端存储，也避免了在 `Cookie` 中存储敏感信息的风险。

:::

### ❓流量控制和拥塞避免的区别

::: details 💡

  - **流量控制**：点对点（从一台主机到另一台主机）的通信机制。常在网络的传输层（如 `TCP` 协议）进行。
    > 主要目的：防止发送方发送过多的数据给接收方，以免接收方无法处理这么多数据。其中，接收方将根据其处理能力，反馈给发送方一个“接收窗口”大小，告诉发送方它应该发送多少数据。发送方根据这个反馈来调整发送速率。

  - **拥塞控制**：是全局性的，包括了所有主机和所有的网络链路。在网络层，涉及整个网络的运行状态。
    > 主要目的：防止过多的数据在网络中传输，以免导致网络拥塞和性能下降。其中，网络的通信节点（如路由器或交换机）或发送方将根据网络的拥塞情况，调整数据的发送速率。

总结：流量控制更关注发送方和接收方之间的平衡，而拥塞控制则关注整个网络的健康运行状态。

:::

------

## UDP

### ❓`UDP`

::: details 💡

> `UDP` (`User Datagram Protocol`)：用户数据报协议，是一种无连接的网络通信协议，位于 `OSI` 模型的传输层。与 `TCP` 协议不同，`UDP` 不提供数据正确性保证和顺序保证，也不进行流量控制和拥塞控制。

主要特性：

  - 无连接：`UDP` 发送数据前无需建立连接，每个数据报都独立处理，因此可以支持同时向多个接收者发送数据。
  - 少量开销：`UDP` 不需要进行复杂的错误检查和恢复机制，头部开销只有 8 字节，比 `TCP` 更简单也更快。
  - 不可靠性：`UDP` 不保证数据的到达和顺序，数据可能会丢失或者乱序。
  - 支持一对一、一对多、多对一和多对多的交互通信。

应用：比如实时应用（如 `VoIP` 和在线游戏），广播和多播应用，以及需要快速传输且不太关心丢包的应用（如 `DNS` 和 `DHCP`）。

:::

### ❓`TCP` vs `UDP`
  
::: details 💡
  
`TCP` 特点
  
  - 可靠性 : 通过确认应答、超时重传等机制保证数据的可靠传输。
  - 有序性 : 通过数据序号来保证数据有序，传输完成后通过排序来保证数据的正确性。
  - 双全工 : 通信双方(服务端和客户端)都具备发送和接受数据的能力。(三次握手来保证)
  
`UDP` 特点

  - 不可靠 : 通信通信双方不需要建立连接，不能保证数据准确送达。
  - 无序性 : 每次发送的数据包相互独立，没有特定的顺序。
  - 速度快 : 由于数据包结构简单，保证的 `UDP` 传输速度优于 `TCP`
  
  一些游戏、直播和需要低延迟实时性要求较高的应用，会使用 `UDP`。

两者区别：

  - 连接方式：
    * `TCP` 是一种面向连接的协议，在正式收发数据之前，必须和对方建立可靠的连接。
        > 一个TCP连接必须要经过三次“对话”才能建立起来。我们通常所说的“三次握手”（`three-way handshake`）就是指建立一个TCP连接，这种机制保证了两端系统在通信开始之前就已知了对方的存在。
    * `UDP` 则是面向非连接的协议，它不与对端建立连接，而是直接就发送数据包，尽管如此，`UDP` 数据包的到达和顺序也不能被保证。

  - 可靠性和速度：
    * `TCP` 提供了全面的错误检查和确认机制，并且有重发机制，所以它能提供可靠的数据传输，适合对可靠性要求很高的场景，如文件传输。
    * `UDP` 则不提供必要的检查，也不保证数据的顺序, 因此它的性能更高，传输速度更快，适用于对实时性要求高的场景，如视频通话，直播等。

  - 数据交互方式：
    * `TCP` 是双向通信的，即 A 主机到 B 主机和 B 主机到 A 主机的交互都可以。
    * `UDP` 则主要用于单向发送数据，如声明性（datagram）服务。

  - 流控制：
    * `TCP` 提供了流量控制的机制，既有发送端控制发送速率使接收端来得及接收，又有接收端通过滑动窗口控制接收速率，防止接收端处理不过来。
    * `UDP` 则没有提供流量控制的机制，数据发送之后也无法获得发送是否成功的反馈。

总结：如果需要可靠性和数据完整性，应该用 `TCP`；如果需要速度，那么应该用 `UDP`。

:::

### ❓有人认为 `TCP` 一定比 `UDP` 更快，你觉得呢

::: details 💡

不对，一般情况来说，`TCP` 比 `UDP` 更慢。

  - `TCP`（`Transmission Control Protocol`）是一种面向连接、可靠的传输协议，它提供了数据完整性和顺序保证，适合于对数据传输准确性要求高的场景。但是，`TCP` 为了确保这种可靠性，引入了确认（`ACK`）、重传等机制，这些处理会消耗一定的时间，对性能有所影响。

  - `UDP`（`User Datagram Protocol`）是一种无连接、不可靠的传输协议，它不保证数据的到达和顺序。因此，`UDP` 相比 `TCP` 有较小的协议开销，对于那些要求实时性，可以容忍丢包，但对传输延迟和效率要求较高的场景（如流媒体传输、在线游戏）来说，`UDP` 可能会比 `TCP` 更快。

:::

------

## TCP

### ❓`TCP`

::: details 💡

> `TCP` (`Transmission Control Protocol`)：传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议，位于 `OSI` 模型的传输层。在 `Internet` 协议家族（`TCP/IP` 协议家族）中，`TCP` 与网络层的 `IP` 协议共同构成了 `Internet` 的核心。

主要特性：

  - 三次握手：建立连接，经过 “三次握手”，确保双方都准备好进行数据交换。
  - 使用序列号和确认应答：`TCP` 为每个字节赋予一个序列号，并期望收到接收端的确认应答。如果发送端没有收到确认应答，就会重发数据。
  - 窗口大小和滑动窗口机制：为了控制数据的流量和避免网络拥塞，`TCP` 使用了窗口大小和滑动窗口的机制。
  - 流量控制：通过适时调整窗口大小，`TCP` 能够根据接收端的处理能力，来控制发送端的发送速率。
  - 检错和重传：`TCP` 通过检验和和定时器等机制来实现数据的无差错传输，如果出现错误或者丢包，`TCP` 会自动进行重传。
  - 四次挥手：断开连接，`TCP` 会通过 “四次挥手” 来安全地关闭连接。

应用：需要高可靠性的网络通信，比如 `Web` 浏览、邮件传输、文件传输等。

:::

### 建立连接

#### ❓三次握手

::: details 💡

`TCP` 三次握手过程：建立连接的过程。
   
  - 第一次握手：客户端发送 `SYN` 包（序列号 `seq` 为 `X`）到服务器，并进入 `SYN_SEND` 状态。

  - 第二次握手：服务器收到 `SYN` 包，必须确认客户的 `SYN`(`ACK` = `X+1`)，同时自己也发送一个 `SYN` 包（序列号 `seq` 为 `Y`），即 `SYN + ACK `包，服务器此时进入 `SYN_RECV` 状态。

  - 第三次握手：客户端收到服务器的 `SYN + ACK` 包，向服务器发送确认包 `ACK`(`ACK`= `Y+1`)，此包发送完毕，客户端和服务器进入 `ESTABLISHED` 状态，完成三次握手。

:::

#### ❓为什么要三次握手

::: details 💡

  -  确保双方都准备好进行通信：在三次握手的过程中，客户端和服务器都会发送并确认接收到了对方的消息。这确保了两边都有能力收发信息，即两边的发送和接收功能都正常。

  - 防止已经失效的连接请求报文段突然又传到了服务端，由于服务端误认为客户端又发出一次连接请求，于是就向客户端发送确认报文段，同意连接。这种情况下，如果没有三次握手，则会建立一个无用的连接，浪费服务器资源。

  - 确定序列号：三次握手还可以帮助通信的双方确定数据包的序列号。在TCP通信中，每个数据包都有一个序列号，接收方根据序列号来重新组织数据包。通过三次握手，双方都能知道对方期待接收的初始序列号。

总结：`TCP` 协议选择使用了三次握手这种方式来建立连接，以确保数据的正确、可靠传输。

:::

#### ❓三次握手，第三次丢失会怎么样

::: details 💡

第三次握手客户端发送的 `ACK` 包在传输过程中丢失：

  - 服务器一直处于 `SYN_RECV` 状态下，同时等待客户端再次发送 `ACK` 包。默认情况下，服务器在 75 秒后会关闭等待连接。

  - 客户端的 `ACK` 丢失，但是连接已经建立，在 `ESTABLISHED` 状态。接下来如果客户端开始发送数据，服务器就知道连接已经建立了。

  - 如果服务器在等待 `ACK` 的过程中，系统的连接队列已经满了，那么新的 `SYN` 包将无法得到响应，这会导致客户端无法建立新的连接。

结论：如果第三次握手的 `ACK` 包丢失，对于已经建立好的 `TCP` 连接影响并不大，但可能会影响新的连接建立。

:::

#### ❓三次握手，可以携带数据吗

::: details 💡

  `TCP` 三次握手过程主要是为了建立连接，同时确定数据包的序列号，从而保证数据传输的正确性和完整性。在三次握手的过程中，理论上说第三次握手时，可以携带数据并将数据传给接收方。因为此时已经建立了连接，而且握手的 `ACK` 和数据部分在 `TCP` 的设计里面并不是强相关的。

  是否携带数据、何时携带数据，这个取决于网络协议栈的设计，也跟上层应用有关。在很多实际的网络协议栈实现中，并不在三次握手时携带数据，主要是因为需要等待握手成功后，才能确认双方具备了接收数据和处理数据的能力。所以通常情况下，三次握手不包括数据的发送。

结论：从是否可行的角度看，三次握手过程中是可以携带数据的。但在实际操作中，一般并不这么做。

:::

### 断开连接

#### ❓四次挥手

::: details 💡

`TCP` 四次挥手过程：结束连接的过程。

  - 第一次挥手：当某一端完成数据发送后（假设是客户端），会向另一端（服务器）发送 `FIN` 包，请求关闭连接。
  
  - 第二次挥手：服务器收到 `FIN` 包后，并不是立即关闭连接，而是先向客户端回复确认包 `ACK`，告诉客户端 “你的请求我收到了”。然而，此刻服务器可能还有数据要发送，所以并不直接发送 `FIN` 包。

  - 第三次挥手：等服务器所有数据都发送完了以后，再向客户端发送 `FIN` 包，请求关闭连接。

  - 第四次挥手：最后客户端收到 `FIN` 包后，也不是立即关闭连接，而是先回复一个 `ACK` 给服务器，然后等待一段时间（等待`2MSL`，也就是报文最大生存时间的两倍时间，约1-4分钟）再关闭连接。

:::

#### ❓为什么要四次挥手

::: details 💡

  因为 `TCP` 连接是全双工的，即数据可以在两个方向上独立地进行传输。这意味着每个方向都需要单独关闭，这样的设计使得 `TCP` 连接的关闭更为可靠。

  - 每个方向的关闭都需要发送一个 `FIN` 包和一个 `ACK` 包。
    * 发送 `FIN` 包表示我已经没有数据要发送了，并请求关闭连接。
    * 发送 `ACK` 包则是确认接收到对方的 `FIN` 包。

  - 一个方向的连接关闭就需要两次挥手，而一个 `TCP` 连接由于是全双工的（双方都可以发送数据），所以两个方向都需要关闭，因此总的来说需要四次挥手。

  - 为了保证能够让未完全传输的数据能够被接收，接收到 `FIN` 包的一方会进入到一个叫做 `TIME-WAIT` 的状态，在这个状态中，它会等待一段时间以确保对方接收到了 `ACK` 包。这就是为什么有时候会看到一些还处于 `TIME-WAIT` 状态的 `TCP` 连接，那是因为它们在等待最终的确认。

  - 能处理双方同时发起关闭连接请求的情况。

:::

#### ❓`TCP` 双方同时发起关闭连接请求的情况，是如何处理的

::: details 💡

  四次挥手是 `TCP` 协议用来结束连接的过程。理想情况下，一般是由其中一方（比如客户端）先发起关闭连接请求。然而，`TCP` 连接的每一方都能独立地关闭它们的发送通道，所以双方都可以发送 `FIN` 报文来请求关闭连接。

同时发起关闭请求处理流程：

  - 主机 A 发送一个 `FIN`，并进入 `FIN-WAIT-1` 状态。
  - 主机 B 在收到这个 `FIN` 后，返回一个 `ACK`，并让 A 进入 `FIN-WAIT-2` 状态。
  - 几乎同时，主机 B 也发送一个 `FIN`，并进入 `LAST-ACK` 状态。
  - 主机 A 收到 B 的 `FIN` 后，返回一个 `ACK`，并进入 `TIME-WAIT` 状态，同时 B 收到这个 `ACK` 后关闭连接。
  - 对于 A 后续的行为，会根据具体实现，可能会继续等待一段时间，或者直接关闭连接。

:::

### 运行机制

#### ❓`TCP` 的 `Keep-Alive` 机制

::: details 💡

  > `Keep-Alive`: 顾名思义是否还活着，是一种心跳检测机制。用于判断连接方是否还处于活动状态，以便断开已经失活连接释放资源。发送探测包后，如果处于活动状态，接收方会发送确认信号；如果处于失活状态，则会再连续再发送几次探测包如果均无响应则证明对方已断开连接，可以释放资源。
  
注意：

  - `Keep-Alive` 机制的时长一般默认为 **2 小时**。所以，不能使用使用该机制来确认实时性较高的保活探测。

  - `Keep-Alive` 并不是默认开启的。在一般情况下，如果两端的 `TCP` 都正常工作，是不需要使用到 `Keep-Alive` 机制的。只有在网络不稳定，或者是需要维持长连接的应用中，比如数据库连接，`Keep-Alive` 才会显得比较有用。

:::

#### ❓什么情况下发送方的滑动窗口会后移

::: details 💡

  > `TCP` 发送方的滑动窗口 : 用来控制网络通信流量和确保信息可靠传输的一种机制。防止网络拥塞，确保在有限的网络带宽中，数据能够被高效、有序、可靠地传输。

滑动窗口后移的两种情况：

  - 当接收到确认(`ACK`)消息时
    > 当发送方接收到接收方发送的确认消息(`ACK`)，说明发送方发送的数据已经被接收方正确接收，此时发送方的滑动窗口的左边界会按照收到的确认信息进行移动。相应地，滑动窗口的右边界也会移动，使窗口大小保持不变。这样可以控制发送方继续发送未被确认的数据，或者发送新的数据。

  - 当窗口内数据全部被确认时
    > 如果滑动窗口中的所有数据都已经被接收方确认接收，那么滑动窗口会往右移动，来为新的数据腾出空间。

🌰 比如发送方发送了 `1、2、3、4` 这 4 个包，那么初始的窗口便是 `[1, 4]`，当接收方收到 `1、2` 两个包后，并向发送方发送了 `ACK` 确认报文，那么发送方的滑动窗口就会后移，变成 `[3, 6]`。在整个过程中，窗口的大小(4 个包的大小)保持不变，只是随着数据传输的进行，窗口在数据流上滑动。

:::

#### ❓解释下 `TCP` 的慢启动特性

::: details 💡

> `TCP` 的慢启动是一种防止网络拥塞的机制。

工作原理：当一个 `TCP` 连接刚开始的时候，发起方不会立即以最大速度发送数据，而是会首先以较慢的速度发送，然后逐渐提高发送速度，直到找到网络的最大负载能力。

  慢启动的名字可能会让人误解，实际上它不是真的 “慢”，而是一个加速过程。`TCP` 连接开始时的发送窗口不是非常大，意味着一次能发送的数据量较小，这就是 “慢” 启动的含义。每当收到一个确认（`ACK`）报文，发送窗口就增大一点，这样下一次就可以发送更多的数据。这个过程不断重复，发送窗口的大小以指数级别增长，也就是说传输速度会迅速提升。

  为了防止网络拥塞，当达到一个阈值（`ssthresh`，`slow start threshold`）后，`TCP` 将不再指数级别增长，而是转为线性增长，这就是进入 “拥塞避免” 阶段。如果出现了网络拥塞的信号（例如丢包，超时等），`TCP` 会降低传输速度，重新回到慢启动阶段。

总结：`TCP` 的慢启动特性是一种通过动态调整传输速度来适应网络状况，防止网络拥塞的有效机制。

:::

#### ❓讲一下 `TCP` 的四种拥塞控制算法

::: details 💡

  - 慢启动算法（`Slow Start`）:
    > 慢启动算法使用了一个 “拥塞窗口” 且初始值为一个报文段。每当确认数目到达，拥塞窗口就增加一，即每经过一个往返时间 `RTT`，拥塞窗口就加倍。这样就实现了在网络并未出现拥塞的情况下，数据报的传送速率逐渐加快。但是当拥塞窗口大到一定程度后，就有可能导致网络拥塞。

  - 拥塞避免算法（`Congestion Avoidance`）:
    > 拥塞避免算法主要是为了预防因慢开始算法加速过快导致网络拥塞，所以在拥塞窗口到达阈值后，改用拥塞避免算法，让拥塞窗口每经过一个 `RTT` 只增加一，也就是以线性的速度增长，这样增长速率就放慢了，避免了慢开始算法过快的增长导致的拥塞。
    
  - 快重传算法（`Fast Retransmit`）:
    > 快重传算法在接收方收到一个失序的报文段后，就会立即发出重复确认，而不是等到自己需要发送数据时才捎带确认。在发送方，只要连续收到三个重复确认，就立即重传没有被确认的报文段，而不必等待设置的重传计时器到期。这样可以尽早地知道有报文段没有到达接收方，进而尽早地进行重传。

  - 快恢复算法（`Fast Recovery`）:
    > 快恢复算法是在快重传算法之后提出的，主要用于快速恢复丢失报文段后的传输。当发送方连续收到三个重复确认（意味着有报文段丢失）后，不立即执行慢启动算法，而是把阈值设为当前拥塞窗口的一半，然后执行拥塞避免算法。这样避免了慢启动算法使窗口大小回到最初状态，而是让其在一个比较大的值开始，这样就加快了恢复速度。

注意：这四种算法，协同工作，共同管理和控制了 `TCP` 数据的传输，使其在充分利用网络资源的前提下，尽可能的避免网络拥塞，保证了传输的效率和可靠性。

:::


#### ❓在高宽带、高丢包的情况下，怎么保证 `TCP` 的性能

::: details 💡

  - 增大 `TCP` 窗口大小：`TCP` 窗口控制了发送方一次可以发送多少数据，所以通过扩大 `TCP` 窗口，可以提高 `TCP` 的吞吐量。
    > 注意：过大的 `TCP` 窗口可能会导致网络拥塞，因此需要谨慎使用这种策略。

  - 使用快速重传和快速恢复：当发送方多次连续收到对同一包的重复 `ACK` 时，可能代表接收方那边出现了乱序或者丢包。于是发送方可以不用等到超时就开始重传，这就是快速重传。快速重传后，发送方不再使用慢启动，而是直接进入拥塞避免，这就是快速恢复。

  - 使用拥塞控制算法：比如 `TCP NewReno`、`TCP Vegas`、`TCP BBR` 等，可以在丢包较高的情况下，仍然保持较好的网络吞吐性能。

  - 启用 `SACK`(`Selective Acknowledgements`) 选项：`SACK` 允许接收方告诉发送方，哪些特定的数据包已经被接收。这样，当数据包丢失时，发送方只需要重发那些未被确认的数据包，而不是所有的数据包。

  - 使用前向纠错（`FEC`）技术：`FEC` 技术可以在发送数据的时候额外发送一些冗余数据，这样即使在丢包较高的情况下，接收方也有可能从已接收的数据包中恢复出丢失的数据。

  - 使用多路径`TCP` (`MPTCP`)：`MPTCP` 可以在有多条路径可用的情况下，同时在多条路径上发送数据。这样即使一部分数据包丢失，其他路径上的数据包仍然可以达到目的地，从而提高 `TCP` 的吞吐性能。
    
:::

------

## IP

### ❓除了好记以外，为什么要用域名访问服务器，直接用 `IP` 不行吗

::: details 💡

  - **易于记忆**：域名是由字符和数字组成的，通常与网站或公司的名称相关，更易于人类记忆。而 `IP` 地址则是由四组数字组成，不易于记忆。

  - **易于维护**：如果一个网站更换了服务器，`IP` 地址就会发生改变。如果直接使用 `IP` 地址访问，那么用户就需要知道新的 `IP` 地址才能访问该网站。如果使用域名，只要将域名的解析地址更新为新的 `IP` 地址，对用户来说是无感知的。

  - **支持负载均衡**：通过域名，可以将访问请求分发到不同的服务器上。
    > 比如，一个大型网站可能有成千上万的服务器，可以使用同一个域名，背后由 `DNS` 服务器将请求分发到不同的 `IP` 地址，以实现负载均衡。

  - **结构保密**：直接暴露 `IP` 地址可能会泄露一些网络结构信息，而使用域名可以更好地隐藏这些信息。

  - **支持虚拟主机**：同一 `IP` 地址上可以运行多个网站，通过域名可以区分和访问这些网站。如果只有 `IP` 地址，就无法做到这一点。
  
:::

### ❓判断一个字符串是不是 `IPv6` 地址

::: details 💡

> `IPv6` 地址是一个由 128 位数值组成的地址，通常表示为 8 个 16 进制的数，每个数由四个十六进制位表示，并用冒号 ":" 分隔。

```python
# 使用 ipaddress 模块中的 is_ipv6_address 函数来判断一个字符串是否为 IPv6 地址
import ipaddress

def is_ipv6_address(address):
    try:
        ipaddress.IPv6Address(address)
        return True
    except ipaddress.AddressValueError:
        return False

print(is_ipv6_address('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))   # 输出：True
print(is_ipv6_address('2001:db8:85a3:0:0:8a2e:370:7334'))           # 输出：True
print(is_ipv6_address('2001:db8:85a3::8a2e:370:7334'))              # 输出：True
print(is_ipv6_address('This is not an IP address'))                 # 输出：False
```

:::

### ❓`ping` 使用什么协议

::: details 💡

> `ping` 是一种用来检测网络连接质量(是否连通，网络延迟)的工具，基于 `ICMP` (`Internet Control Message Protocol`) 互联网控制报文协议。

工作原理：发送一种特殊的以 `ECHO_REQUEST` 被标记的数据包到指定的网络地址，然后等待接收回馈。如果网络连接正常，那么它将接收到一种被标记为 `ECHO_REPLY` 的数据包。

:::

------

## Socket

### ❓`Socket` 了解吗

::: details 💡

> `Socket`(套接字)是计算机网络数据结构，它是网络通信中数据发送和接收的基本操作单元，可以理解为网络通信的端口。

  `Socket` 原本是 `Unix/Linux` 系统下的一个系统调用，在 `Windows` 环境也有相对应的实现。它提供了在网络中进程之间进行通信的方式。一个 `Socket` 由一个 `IP` 地址和一个端口号 `Port` 唯一确定，形式如：`IP:Port`。

  一个网络连接的建立需要有一对 `Socket`，分别位于通信的两端，也就是客户端和服务器端。在网络应用中，服务器端一般采用固定的 `IP` 地址和端口号。客户端则由系统随机分配端口号，而 `IP` 地址就是机器的 `IP`。

`Socket` 通信过程：服务器监听，客户端请求，连接确认。

  - 服务器监听：服务器端的 `Socket` 绑定在一个特定端口，监听来自客户端的请求。

  - 客户端请求：客户端的 `Socket` 提出连接请求，要求与服务器端的 `Socket` 建立连接。

  - 连接确认：服务器端的 `Socket` 接受来自客户端 `Socket` 的请求，建立连接。
  
:::

### ❓`WebSocket` 是什么

::: details 💡

> `WebSocket` 是一种网络通信协议，最早由 `Web` 浏览器和 `Web` 服务器之间进行全双工通信的技术。

发展历史：

  - 2008年，`WebSocket` 受到 `HTML5` 的影响开始诞生。
  - 2011年，该协议被 `IETF` 定为标准 `RFC 6455`，并被 `W3C` 用作 `Web IDL` 中一部分。

主要特点：

  - 建立在 `TCP` 协议之上，服务器网络流量压力较小。
  - 与 `HTTP` 协议有较好的兼容性。默认端口也是 `80` 和 `443`，并且握手阶段采用 `HTTP` 协议，使得其可以穿透大多数防火墙，同时也容易和现有的 `Web` 服务器融合。
  - 数据格式比较轻量，性能开销小，通信高效。
  - 可以发送文本，也可发送二进制数据。
  - 无同源限制（`cross-domain`），客户端可以与任意服务器通信。
  - 协议标识符是 `ws`（或 `wss` 表示使用了 `TLS` 加密），服务器网址就是 `URL`。

通信流程：

  - 客户端通过 `HTTP` 请求与 `WebSocket` 服务端协商加密握手。
  - 如果服务器支持 `WebSocket`，那么握手成功，服务器会返回 `Upgrade` 协议的 `HTTP` 状态码 `101`，即 `HTTP` 协议转换成 `WebSocket` 协议，此后，传输的数据就不再是 `HTTP` 协议，而是 `WebSocket` 协议。
  - 完成升级后，数据就直接从 `TCP` 通道传输，与 `HTTP` 无关了。

总结：`WebSocket` 提供了一种相较于 `AJAX` 更加实时、更加符合主流编程模型、开销更小的实时双向通信手段，使得在 `WEB` 页面上的实时通信变得更加容易。常用于即时通讯、在线游戏等需要实时交互的场景。

:::

------

## HTTP

### 版本

#### ❓`HTTP` 各个版本的区别

::: details 💡

- `HTTP/0.9`: 首个 `HTTP` 版本，只允许简单的请求，仅支持 `GET` 方法且无头部。

- `HTTP/1.0`: 该版本增加了很多新特性。
    * 增加了 `POST` 和 `HEAD` 方法。
    * 引入了 `HTTP` 头部机制，例如：`Content-Type`，`Content-Length` 等。
    * “非持续性连接”，每次请求都会重新创建 `TCP` 的连接的创建和释放，造成极大的资源消耗。

- `HTTP/1.1`: 相比于 `1.0`，版本 `1.1` 做了许多改进。
    * 增加了 `PUT, DELETE` 等新方法。
    * 引入 “持续性连接” 在一次 `TCP` 连接中处理多个 `HTTP` 请求。
    * 引入 “管道机制” (`pipeline`) 可以同时发送多个的请求，但是响应会按照请求队列的先后顺序进行，会存在 “队头阻塞” 问题。
    * 引入了分块传输编码机制，可以将请求分为多个部分分别发送，允许服务器在完全生成整个内容之前就开始回应。
    * 增加了请求头 `Host`，使得一台物理服务器可以承载多个虚拟的主机。

  > “队头阻塞” 问题：
    在 `HTTP/1.1` 引入 “持续性连接”（`Persistent Connection`）让多个 `HTTP` 请求和响应可以在一个 `TCP` 连接中传输，但是由于 `TCP` 协议的特性，数据包必须按照发送顺序进行接收，因此如果队头的包因为某些原因延迟到达，后面的包就必须等待，即使后面的包已经到达，也不能先接收。

- `HTTP/2.0`: 版本 `2.0` 基于 `Google` 的 `SPDY` 协议。
    * 二进制协议：不再是基于文本的协议，减少了解析复杂度和提升传输速度。(优化传输数据格式：文本 -> 二进制)
    * 多路复用：(`Multiplexing`) 在一次 `TCP` 连接中可以发送多个请求且接收多个响应，减少了 `TCP` 连接数量同时也减小了延迟。解决 `1.1` 协议中的 “队头阻塞” 问题。会存在 “同生同灭” 问题。
    * 头部压缩：采用 `HPACK` 算法对头信息压缩处理，减少数据体积。
    * 服务器推送：服务器可以对一个客户端请求发送多个响应。
    * 请求优先级：不同的请求可以有不同的优先级。

  > “同生同灭” 问题：
    在 `HTTP/2.0` 的单个连接中，如果有一个请求因为某种原因失败了（比如网络波动，服务器宕机），则这个 `TCP` 连接上的所有请求都会被关闭，从而导致大量的请求失败，这是由 `TCP` 协议的特性决定的。

- `HTTP/3.0`: 最新版本。
    * 基于 `QUIC` 协议 (`Quick UDP Internet Connections`)，解决 `TCP` 的 “队头阻塞” 问题。
        > 在 `QUIC` 协议中，数据包是独立传输的，即使有数据包丢失，也不会影响到其它数据包的传输和处理，从根本上解决了 “队头阻塞” 问题。
    * 底层协议改为 `UDP`，因此解决了 `HTTP/2.0` 中多路复用的 “同生同灭” 问题。
    
:::

#### ❓`HTTP` 是无状态的，怎么理解

::: details 💡

> `HTTP` (`HyperText Transfer Protocol`) 被称为无状态的，是因为在单一的 `HTTP` 请求和响应交互过程中，服务器并不会保存任何关于客户端的信息。

  - 无状态：每一次 `HTTP` 请求都是独立的，服务器不会记住之前的请求。也就是说，从客户端发出第一个请求到服务器，然后到第二个请求，服务器并不知道这两个请求是来自同一个客户端。无论客户端在前一个请求中做了什么，每个请求都被视为全新的、与其他请求没有关系的请求。

  - 优点：无状态设计使 `HTTP` 的结构变得简单、无复杂性和独立性。

  - 缺点：比如服务器无法记录用户的操作历史。为了解决这个问题，引入了 `Cookies`、`Session` 等技术，它们使得 `HTTP` 能够实现有状态的交互，比如用户认证、购物车功能等。

:::

#### ❓`HTTP 2.0` 针对同一个域名的多个请求，会建立多少个 `TCP` 连接

::: details 💡

  在 `HTTP 2.0` 中，只需要建立一个 `TCP` 连接就可以处理同一个域名的所有请求。`HTTP 2.0` 支持多路复用（`Multiplexing`），可以在一个 `TCP` 连接上同时处理多个 `HTTP` 请求和响应。

  - `HTTP 1.x` 中浏览器通常会对同一个域名建立多个并行的 `TCP` 连接，以便并行处理多个 `HTTP` 请求，但这种方式在 `TCP` 连接数过多时会导致资源消耗过大并影响性能。

  - `HTTP 2.0` 多路复用功能有效地解决了这个问题，它将不同的请求分割为更小的消息和帧，并在一个 `TCP` 连接中并行发起，从而减少了需要的连接数量，提升了网络传输效率。

:::

#### ❓`HTTP 3.0` 中的 `QUIC` 是什么

::: details 💡

> `QUIC`（`Quick UDP Internet Connections`）: 由 `Google` 提出并开发的一种基于 `UDP` (`User Datagram Protocol`) 的互联网传输层协议。

`QUIC` 相对于 `TCP/UDP` 的优点：

  -  低延迟：`QUIC` 通过减少传输层的握手步骤，可以实现无延迟、`0-RTT`（往返时间）的连接建立。
    
  - 弹性：`QUIC` 协议基于 `UDP`，所以每个 `QUIC` 数据包都是独立的，数据包之间没有顺序关系。这意味着，即使某个数据包丢失或者延迟，也不会导致 “队头阻塞” 问题。这使得 `QUIC` 协议在面对网络丢包等恶劣网络环境时，比 `TCP` 具有更好的弹性。

  - 多路复用：`QUIC` 协议支持流的概念，同一 `QUIC` 连接可以包含多个流，每个流都是独立的。这允许多个请求和响应在同一个连接上并行传输，从而避免了 `HTTP/2` 中同一个 `TCP` 连接上的 “同生同灭” 问题。

  - 安全：`QUIC` 协议集成了 `TLS` (`Transport Layer Security`) 协议，可以提供端到端的数据加密和身份验证。

:::

### 请求方法

#### ❓`GET` vs `POST`

::: details 💡

  - 作用：
    * `GET`：从指定的资源请求数据，通常用于获取数据。
    * `POST`：向指定的资源提交要被处理的数据，主要用于发送数据。

  - 数据传递方式：
    * `GET` 方法通常将参数直接附加在 `URL` 后面，并且用问号（`?`）分隔，键值对之间则以 `&` 符号进行分割
        > 例如：`http://example.com/test?name=test1&value=test2`。
    * `POST` 方法则将数据包含在 `HTTP` 请求体内。

  - 安全性：
    * `GET` 方法将参数直接暴露在 `URL` 中，所以它的安全性相对较低，更适合不包含隐私或者敏感信息的请求。
    * `POST` 方法由于将参数包含在请求体内，所以相对更加安全一些。

  - 数据大小：
    * `GET` 方法由于受到 `URL` 长度的限制（通常为 `2048` 字符），所以其发送的数据量有限。
    * `POST` 方法理论上没有数据大小的限制。

  - 数据类型：
    * `GET` 方法只允许发送文本类型的数据。
    * `POST`方法没有这样的限制，可以发送二进制数据。

  - 缓存和历史：
    * `GET` 方式发送的请求，浏览器会主动缓存，用户在 `URL` 地址栏生成历史记录。
    * `POST` 方式则不会被缓存，也不会留下历史记录。

  - 幂等性：
    * `GET` 请求是幂等的，即多次执行同一请求，不会改变服务器状态。
    * `POST` 请求不是幂等的，相同的 `POST` 请求被执行多次可能导致不同的结果。

:::

#### ❓`GET` 请求参数一定是放在 `URL` 中的吗

::: details 💡

  不一定。

  `GET` 请求的参数是放在 `URL` 中的，这是 `GET` 请求设计的初衷和最常见的使用方式。但是，并非所有情况下 `GET` 请求的参数都需要放在 `URL` 中，也可以通过请求头来传递。例如，可以通过 `Authorization` 字段在 `GET` 请求头中传递认证信息。

  注意：因为 `GET` 请求的参数是直接暴露在 `URL` 中的，因此有一定的安全风险，不适合用于传输敏感信息，如密码，银行卡号等。同时，`URL` 的长度在浏览器和服务器中都有限制，过长的 `URL` 可能会被截断，导致请求失败。在需要传输大量数据时，一般会使用 `POST` 请求，其参数通过请求体传输，相对安全又没有长度限制。

:::

#### ❓`POST` 请求参数能放在 `URL` 中吗

::: details 💡

技术上可行，但不推荐。

不推荐原因：

  - 安全性：放在 `URL` 中的参数对他人是可见的，比如存储在浏览器的浏览历史中，或者在 `Web` 服务器的日志文件中，或者在网络上被截获。因此，这可能会泄露敏感信息。

  - 容量限制：对 `URL` 的大小，大部分浏览器都有一定的限制（通常为 `2000~4000` 字符）。将 `POST` 参数放在URL中可能会让 `URL` 过长，超过浏览器的处理能力。

  - 规范性：违反 `HTTP` 的语义，根据 `HTTP` 规范，`POST` 方法的语义是 “向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。”，这就意味着 `POST` 请求的数据应该放在请求体中。

:::

#### ❓`POST` 请求的 `body` 体使用 `form-urlencoded` 和 `multipart/form-data` 的区别

::: details 💡
  
  - `application/x-www-form-urlencoded`：无法进行二进制数据的传输，只能上传文本数据。
    > 在这种编码方式下，所有的键值对都会被合并到一个查询字符串中，查询字符串的格式和 `GET` 请求中 `URL` 的查询字符串格式一致。每个键值对之间用 `&` 符号分割，每个键与值之间用等号 `=` 分割，例如 `key1=value1&key2=value2`。如果值中包含一些特殊字符，这些字符需要被 `URL` 编码（比如空格被编码成 `+` 或 `%20`）。

  - `multipart/form-data`：不仅可以上传文本数据，还可以上传文件或其他二进制数据。
    > 在这种编码方式下，消息体会被分割成多个部分，每个部分对应一个字段。每个部分的开头都包含一个含有该字段名的 `Content-Disposition` 头部，然后是字段的值。各个部分之间用 `boundary` 字符串分隔，这个字符串在 `Content-Type` 头部中指定。

:::

#### ❓`POST` 为什么会发生两次请求

::: details 💡

两次请求：第一次是 `OPTIONS` 请求，第二次就是预期中的 `POST` 请求。
  
  > `OPTIONS`：用于请求获得由 `Request-URI` 标识的资源在请求/响应的通信过程中可以使用的功能选项。
  
产生 `OPTIONS` 请求的原因：
    
  - 添加了自定义头部 `Header`
    > 例如：在头部添加一下 `token` 信息来校验用户信息
    
  - 发生了跨域
  
:::

> ❓如何避免 `OTPIONS` 请求

::: details 💡

通过确保请求是一个“简单请求” (`simple request`)，来避免不会触发预检请求。

  - 请求方法为 `GET`、`HEAD` 或 `POST`。
  - 使用自动设置的头（如 `Connection`、`Content-Type`、`User-Agent`...）。
  - `Content-Type` 的值只限于以下三者之一：`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`。如果需要发送一个 `JSON` 格式的数据，可能需要在服务器端改变一些设置，比如使用 `text/plain` 来接收 `JSON` 数据。
    
:::

#### ❓`HTTP` 中的简单请求和复杂请求

::: details 💡

  - 简单请求：
    * `HTTP` 方法为 `HEAD`、`GET` 或 `POST`。
    * `HTTP` 头信息不超出以下字段：`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`（但只限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）以及`DPR`、`Downlink`、`Save-Data`、`Viewport-Width`、`Width`。

  - 复杂请求：不满足上述条件的请求，就视为复杂请求。

跨域资源共享 (`CORS`) 请求
  
  - 简单请求，浏览器直接发出 `CORS` 请求。具体来说，就是在头信息中，增加一个 `Origin` 字段。
  - 复杂请求，`CORS` 请求会在正式通信之前，增加一次 `HTTP` 查询请求，称为"预检"请求（`preflight`）。浏览器首先会向服务器发送一个 `HTTP OPTIONS` 请求头，检测服务端是否支持跨域请求，之后才会发出实际的 `HTTP` 请求。
    
:::

### 状态吗

#### ❓`HTTP` 状态码 `2XX，3XX，4XX，5XX` 分别代表什么

::: details

> `HTTP` 状态码：服务器在处理客户端请求时，对该请求的响应状态进行标识的一种方式。

  - `2XX`（成功）- 表示成功处理了请求的状态码。
    * 200 `OK`，表示请求成功。
    * 201 `Created`，表示已创建成功。
    * 204 `No Content`，表示处理成功，但无需返回内容。

  - `3XX`（重定向）- 表示需要客户端进行额外操作的状态码。
    * 301 `Moved Permanently`，表示资源已被永久移动。
    * 302 `Found`，表示资源临时移动。
    * 304 `Not Modified`，表示资源未更改(缓存)。

  - `4XX`（客户端错误） - 表示客户端请求有错误的状态码。
    * 400 `Bad Request`，表示请求格式错误。
    * 401 `Unauthorized`，表示请求未被授权。
    * 404 `Not Found`，表示请求的资源不存在。

  - `5XX`（服务器错误） - 表示服务器在处理请求时发生错误的状态码。
    * 500 `Internal Server Error`，表示服务器内部错误。
    * 502 `Bad Gateway`，表示网关错误。
    * 503 `Service Unavailable`，表示服务器当前无法处理请求。

:::

#### ❓为什么要设计 `304` 这个状态码

::: details

> `HTTP 304` 状态码也被称作 `Not Modified`，即 “未被修改”。当客户端发送一个带有 `If-Modified-Since` 或` If-None-Match` 头的条件请求时，服务器可以使用这个状态码来告知客户端，自从上次获取资源以来，资源没有任何改变，所以客户端可以继续使用它的本地拷贝。

设计原因：
    
  - 提高效率：如果资源自上次获取以来没有发生改变，那么重新发送该资源显然是一种浪费，特别是对于大型资源（如图像、视频、大型 `CSS` 或 `JavaScript` 文件）而言。`304` 状态码让服务器有可能仅仅通过发送一个小的 `HTTP` 头来满足请求，这显著减少了数据量，节省了带宽，提高了响应速度。

  - 减少服务器负载：对于很多动态生成的资源（比如基于数据库的网页内容），每次请求都生成和发送新资源可能会给服务器带来很大的计算负担，通过发送一个 `304` 状态，服务器可以避开这个负担。
    
总结：`304` 状态码为了提高 `Web` 性能，优化用户体验，减少服务器负载而设计。

:::

### 功能知识

#### ❓`HTTP` 如何实现长连接

::: details 💡

> `HTTP` 长连接，又称为 “持续性连接”（`Persistent Connection`）

实现：

  - `HTTP/1.0` 版本要支持 “持续性连接”，必须在 `HTTP` 头信息中指定 `Connection: keep-alive`。

  - `HTTP/1.1` 版本中所有的连接默认都是 “持续性连接”，除非明确指定 `Connection: close` 关闭它。要实现长连接，服务器和客户端不必做任何特别的处理。

优点：复用已建立的 `TCP` 连接，减少 `TCP` 连接的创建和关闭所带来的额外开销，降低了延迟，提高了网页加载速度。

缺点：如果服务端和客户端之间没有数据交换，这个连接将会一直占用资源，可能会引发一些问题，比如连接数过多导致服务器资源耗尽。

应用：`Websocket` 和服务器推送(`Server Sent Event`)等实时通信技术中，它们对连接的保持时间和交互模式等有更具体的要求。

:::

#### ❓`HTTP` 断点续传涉及到哪些字段

::: details 💡

断点续传 `Header` 字段：

  - `Content-Length`：标识整个实体文件的大小，单位为字节。

  - `Content-Range`：在整个实体中本次发送的字节位置和总大小。
    > 例如，`Content-Range: bytes 0-499/1234`，表示本次请求是请求第 `0-499` 字节，整个文件大小为 `1234` 字节。

  - `Accept-Ranges`：表示服务器是否支持范围请求，及其支持的单位，通常为`bytes`。
  
  - `ETag`：表示资源的特定版本，通常是由资源内容的哈希值计算得到。

:::

> ❓怎么确保分片全部传输完后，文件的完整性和无篡改

::: details 💡
    
  - 使用 `Content-Length` 和 `Content-Range` 确认接收到的数据段的正确性。
   
  - 使用 `ETag` 。在整个传输过程中，`ETag` 应该保持不变。如果在传输过程中 `ETag` 发生改变，说明文件已经被修改，需要重新开始传输。

  - 在所有分片传输完毕后，对接收到的文件进行校验，比如使用 `MD5` 或者 `SHA` 验证其完整性。如果校验结果和预期相符，说明文件传输完整并且没有被篡改。

:::

------

## HTTPS

### ❓`HTTPS` vs `HTTP`

::: details 💡

概念：

  - `HTTP`: 是基于 `TCP/IP` 通信协议的一种数据传输协议。
  - `HTTPS` : `= HTTP + SSL`，在 `HTTP` 协议的基础加上了加密处理。

区别：

  - 安全性：
   
    * `HTTP`（超文本传输协议）：明文传输，数据在传输过程中如果被拦截，就可以直接查看内容，这就存在安全隐患。

    * `HTTPS`（超文本传输安全协议）：在 `HTTP` 的基础上增加了 `SSL/TLS` 协议，通过证书来验证服务器的身份，并对客户端和服务器之间传输的数据进行加密，保护了数据的私密性和完整性。

  - 性能：

    * `HTTP`：处理速度更快，延迟更低，但这是以安全性为代价的。

    * `HTTPS`：需要处理加密和解密过程，增加了一些处理开销，可能对性能产生影响。但随着技术的发展，这点性能影响在很多应用中已经几乎可以忽略不计。

  - 成本
  
    * `HTTP`：不要证书
    * `HTTPS`：需要证书，虽然有免费的证书，但高级的证书可能需要付费。

:::

### ❓`HTTPS` 比起 `HTTP` 有什么缺陷

::: details 💡

  - 建立连接时需要花费更长的时间：`HTTPS` 需要进行一次 "握手" 过程来建立一个安全连接。这个过程需要客户端和服务器之间来回传输多次信息，可能会导致连接的延迟。然而，现代技术如 `HTTP/2`、`TLS 1.3` 及 `QUIC` 已经大大缩短了这个延迟。

  - 更高的服务器资源消耗：由于 `HTTPS` 在传输数据前需要进行加密处理，因此会使用更多的 `CPU` 和内存资源。这可能会对处理能力有限的服务器造成一定的负担。

  - 证书的获取和管理：`HTTPS` 需要从认证机构获取 `SSL/TLS` 证书。虽然有一些免费的证书供网站使用，但如果需要高级的证书，可能需要额外付费。此外，证书的定期更新和管理也需要投入一定的维护成本。

  - 兼容性：有些老的设备或者系统可能不支持 `HTTPS` 或者只支持老的、安全性较低的 `SSL/TLS` 版本。
    
:::

### ❓`SSL` 证书除了压缩加密，还有什么别的用处

::: details 💡

> `SSL`（Secure Sockets Layer）证书是一种安全协议。
  
  - 加密：`SSL` 证书可以用来对客户端与服务器之间的通信进行加密，防止数据在传输过程中被拦截与窃取。

  - 身份验证：`SSL` 证书包含了网站的公钥以及网站所有者的信息。
    > 当用户访问一个使用 `SSL` 证书的网站时，用户的浏览器会对这个证书进行检查，确认其有效性以及由可信的机构颁发，从而验证网站的真实身份。在这个过程中，网站所有者的信息对用户是可见的，提高了网站的可信度。

  - 完整性保护：`SSL` 证书还用来保护数据的完整性，确保数据在传输过程中没有被篡改。

注意：虽然说 "`SSL` 证书加密"，实际上更准确的说法应该是 “`SSL` 证书提供了一种方式，让服务器和客户端之间可以建立安全的加密通信”。因为证书本身并不进行加密操作，它包含的公钥和私钥才是用来加密和解密通信数据的工具。

:::

------

## DNS

### ❓`DNS` 是什么

::: details 💡

> `DNS`（`Domain Name System`，域名系统）是互联网的一项核心服务，主要负责将易于人类理解的域名转换为计算机可理解的 `IP` 地址。这种将域名解析成 `IP` 地址的过程就称为 `DNS` 解析。

  `DNS` 是一个分布式数据库，由全球众多的 `DNS` 服务器组成，它们之间相互协作，将所有的域名和 `IP` 地址信息互相传递。当在浏览器中输入一个网址时，计算机会先向 `DNS` 服务器发送一个请求，询问这个域名对应的 `IP` 地址，然后 `DNS` 服务器会返回该 `IP` 地址，最后计算机会使用这个 `IP` 地址与网站服务器建立连接。

优点：
  
  - 可以使用容易记忆的域名来访问需要的信息，而不需要记住复杂的 `IP` 地址。
  - 由于是分布式的，`DNS` 系统具有很高的可扩展性和可靠性，使得可以随时随地访问互联网上的信息。

:::

### ❓`DNS` 解析过程

::: details 💡

  - **本地缓存查询**：首先，客户端浏览器会在本地缓存中查询此前是否有请求过这个域名的记录，如果有，直接返回对应的 `IP` 地址，然后进行连接访问。本地缓存通常有有效期，超过一段时间后会自动清空。

  - **向本地DNS服务器查询**：如果本地缓存中没有找到，客户端浏览器会向本地的 `DNS` 服务器发送请求。本地 `DNS` 服务器通常由用户的 `ISP`（`Internet Service Provider`，互联网服务提供商）提供。

  - **转发请求到根服务器**：如果本地 `DNS` 服务器中也没有相应的记录，它就会将这个请求转发到根 `DNS` 服务器。

  - **转发到顶级域服务器**：根 `DNS` 服务器接收到请求后，会告诉本地 `DNS` 服务器，应该去顶级域（`TLD`，`Top-Level Domain`）服务器查询，比如 `.com` 的服务器。

  - **转发到权威服务器**：顶级域服务器收到请求后会告诉本地 `DNS` 服务器，应该去请求 `example.com` 域的权威 `DNS` 服务器。

  - **在权威服务器查询并返回解析结果**：权威服务器找到对应的 `IP` 并返回到本地 `DNS` 服务器，本地 `DNS` 服务器将解析结果返回给客户端，同时将结果缓存到本地，以便下次查询时快速返回。

  - 客户端收到 `IP` 地址后和服务器建立连接，从而访问网站。

总结：整个 `DNS` 解析过程实际上是一个递归和迭代查找的过程，如果某一步已经找到了对应的 `IP` 地址，则不需再进行下一步。

:::

### ❓`DNS` 为什么用 `UDP` 而不用 `TCP`

::: details 💡

  - **速度**：`UDP` 相比 `TCP` 更轻量级，无需进行连接建立和断开的过程，因此在传输速度上优于 `TCP`。`DNS` 查询需要快速返回结果，因此 `DNS` 选择了更为高效的 `UDP`。

  - **资源占用**：`TCP` 连接需要维护连接状态，对于服务器来说，如果有大量的 `TCP` 连接，将需要维护大量的连接状态，而且 `TCP` 连接在断开后还需要维持一段时间的 `TIME_WAIT` 状态，这都是对资源的一种额外开销。而 `UDP` 是无连接的，对服务器端的资源占用更小。

  - **简单应用适合UDP**：`DNS` 查询一般只需要发送一次请求，然后接受一次响应。对于这种简单的请求/响应模式，`UDP` 比 `TCP` 更适合。

注意：虽然 `DNS` 主要使用 `UDP`，但在某些情况下也会使用 `TCP`，比如当 `UDP` 包无法容纳全部的 `DNS` 响应数据时，就需要使用 `TCP`。`TCP` 也会在区域传输（`zone transfers`）等场景下使用。

:::

------

## 抓包

### ❓抓包工具抓取 `HTTPS` 的原理

::: details 💡

原理：通过 “中间人攻击”（`Man-in-the-middle attack`, `MITM`）方式。

  - 当客户端向服务器发出 `HTTPS` 请求时，抓包工具会插入到它们之间，生成一对新的公钥和私钥，并向客户端发送公钥以及伪造的服务器证书，客户端由于信任这个伪造的证书，接受公钥并用它来加密发送的数据。

  - 当抓包工具收到客户端加密后的数据，会用自己的私钥解密数据，然后读取并记录明文信息。此时的抓包工具就像是客户端向其发送 `HTTPS` 请求的服务器。接着，抓包工具用真正的服务器的公钥把数据重新加密后，发送给真正的服务器。

  - 当真正的服务器响应以后，抓包工具再次插入到通信的过程中，使用真正的服务器的公钥解密响应消息，然后再用自己的私钥加密并发送给客户端。

注意：这种方法需要客户端能够信任抓包工具生成的伪造证书，否则客户端将无法信任并接受这个公钥和伪造的服务器证书，通信就会失败。在实际操作中，这通常是通过在客户端安装一个由抓包工具颁发的根证书来实现的。

:::

### ❓`Charles` 抓包软件的原理

::: details 💡

  可以将它理解成中间人攻击。客户端将 `Charles` 作为代理服务器(中间人)。客户端所有请求都会先发送给 `Charles`，`Charles` 再将客户端的请求转发给服务器。`Charles` 收到服务器响应之后，再将从服务器收到的回复内容转发给客户端。这样请求和响应数据都被 `Charles` 记录下来，再通过界面展示即可。
  
  对于 `HTTP` 相对来说比较简单，直接进行接收和转发即可。而 `HTTPS` 中涉及 `CA` 认证，所以客户端需要进行的操作信任 `Charles` 的证书，这样通过 `Charles` 发送给客户端的公钥就可以通过这个证书校验成功，从而完成通信。

:::

### ❓不使用 `Charles`，`4G` 网络如何抓包

::: details 💡

  -  `Wireshark`：这是一种广泛使用的网络封包分析软件，它可以捕获网络封包，并尽可能显示出最为详细的封包数据。使用 `Wireshark` 可以在设备（需要配合其他工具如 `tcpdump`）和无线路由器（如果它被配置为 `Wireshark` 可以在其上运行）之间抓取流量。

  - `Tcpdump`：一个 `Powerful` 的命令行抓包工具，可以获得传输在网络上的 `TCP/IP` 数据包的详细信息。

  - 使用 `Android` 手机的抓包应用，例如 `Packet Capture`, `tPacketCapture` 等。

  - 使用代理服务器，把手机的网络流量通过代理服务器，然后在代理服务器上抓包。一些云服务提供商(例如`AWS`，`GCP`，`Azure` 等)可以提供方便的网络流量采集功能。

:::

### ❓为什么 `Wireshark` 不能直接抓取 `SSL` 的原始数据

::: details 💡

> `SSL`（`Secure Sockets Layer`，安全套接字层），以及其继任者`TLS`（`Transport Layer Security`，传输层安全），是用于保护网络通信的加密协议。所有通过 `SSL` 或 `TLS` 通信的数据在网络上的传输过程中是被加密的。

  只有当数据到达目标服务器或客户端，并且使用正确的私钥进行解密后，数据的内容才可以被读取。因此，使用 `Wireshark` 等抓包工具直接抓取 `SSL/TLS` 通信的数据包，只能看到加密后的数据，而不是原始的明文数据。

  如果有服务器或客户端的私钥，或者能在客户端和服务器之间设置一个可以解密数据的代理（例如“中间人攻击”方式），那么 `Wireshark` 是可以解析并显示 `SSL/TLS` 加密通信的原始明文数据。只要在 “协议” 属性中设置对应的私钥文件，或者配置  `SSLKEYLOGFILE` 环境变量，使其指向一个由浏览器或其他应用生成的密钥日志文件，就可以看到解密后的明文数据。

总结：由于 `SSL` 的设计初衷是保护网络通信的安全，防止数据在传输过程中被窃取或篡改，所以 `Wireshark` 等抓包工具不能直接抓取 `SSL` 的原始数据。这也确保了在使用 `HTTPS`、`IMAPS`、`POPS`、`FTPS` 等基于 `SSL/TLS` 的服务时，通信的安全性和隐私性。

:::

### ❓如何设计一个 `HTTPS` 抓包

::: details 💡

  设计一个 `HTTPS` 抓包工具，实际上是要设计一个中间人（`Man-In-The-Middle`，即 `MITM`）攻击的代理服务器。前提是必须要获得客户端的信任，让客户端愿意接受我们的证书，否则客户端将无法访问 `HTTPS` 服务。

  - 创建一个服务器，用于接收来自客户端的 `HTTP` 或 `HTTPS` 请求。根据请求的协议和头信息，判断是否需要进行 `HTTPS` 抓包。

  - 当接收到 `HTTPS` 请求时，先向 `HTTPS` 服务器发送一个连接请求，获取服务器的证书和公钥。

  - 创建一个自签名的 `SSL` 证书，并将步骤 2 中获取的公钥填入其中。这样，就拥有了一个具有目标服务器公钥的证书。

  - 返回这个自签名证书给客户端。相当于告诉客户端：“我就是你想访问的服务器，把你的数据加密后给我”。

  - 客户端收到证书后，会验证证书的有效性。在这里有两种情况：
    * 手动安装：如果抓包工具是用户自愿使用的（如调试工具），那么用户可能会主动将证书添加到受信任的证书列表中。在这种情况下，客户端会认为证书有效，并继续与服务器进行通信。
    * 非手动安装：在网络攻击的情况下，无法控制客户端的行为。如果客户端没有将证书加入到受信任的列表中，客户端会拒绝与服务器通信。

  - 客户端验证通过后，服务器就可以接收到客户端加密后的数据。由于拥有证书的私钥，可以对加密数据进行解密，实现了 `HTTPS` 的抓包。

:::

------

## 情景题

### 通信流程

#### ❓访问一个网站的详细过程

::: details 💡

  - 浏览器解析 `URL`：在浏览器中输入网址（`URL`），浏览器首先需要解析这个 `URL`，确定要请求的是哪个网站。

  - `DNS` 解析：浏览器通过 `DNS`（`Domain Name System`，域名系统）将网站的域名解析成服务器的 `IP` 地址。`DNS` 解析通常会在本地缓存、操作系统缓存、路由器缓存、`ISP DNS` 服务器等多个层面进行。
    
  - 建立 `TCP` 连接：得到服务器的 `IP` 地址后，浏览器会向服务器发起一个 `TCP` 连接请求，通常是三次握手。

  - 发送 `HTTP` 请求：`TCP` 连接建立好后，浏览器就可以向服务器发送 `HTTP` (`Hypertext Transfer Protocol`，超文本传输协议) 请求了。这个请求中包括要获取的资源（比如一个 `HTML` 页面）、请求的方法（比如 `GET` 或 `POST`），以及一些其他的头信息。

  - 服务器处理请求并返回 `HTTP` 响应：服务器接收到 `HTTP` 请求后，会解析请求，然后查找请求的资源并返回给浏览器。返回的 `HTTP` 响应中包括一个状态码（比如 `200` 表示成功，`404` 表示找不到页面），以及请求的资源内容，比如一个 `HTML` 页面。
    
  - 浏览器渲染页面：浏览器接收到服务器返回的 `HTML` 页面后，会对其进行解析和渲染，显示给用户。如果页面中还包含其他资源的链接（比如图片、`CSS` 样式、`JavaScript` 脚本等），浏览器会再次发起 `HTTP` 请求获取这些资源，然后一起渲染到页面上。

  - 断开连接：如果没有设置持久连接（`HTTP 1.1`默认为持久连接），浏览器和服务器会断开 `TCP` 连接，等待下一次请求。如果是持久连接，那么在一段时间内，浏览器和服务器的 `TCP` 连接会保持，便于传输更多的资源。

:::

#### ❓打开浏览器，输入网址到看到网站首页都经历那些过程，你觉得最耗时是哪里，怎么优化

::: details 💡
  
访问流程：
  
  - **DNS 查询**：浏览器需要解析输入的 `URL` 中的域名到对应的 `IP` 地址，这个过程需要通过网络进行 `DNS` 查询。

  - **建立TCP连接**：浏览器使用解析得到的 `IP` 地址与服务器建立 `TCP` 连接，也即进行三次握手。

  - **发送HTTP请求**：浏览器通过建立好的 `TCP` 连接向服务器发送 `HTTP` 请求，包括 `GET、POST` 等请求。

  - **服务器处理请求并返回HTTP响应**：服务器接收到请求后进行处理，并返回一个 `HTTP` 响应，包含了请求的文件、数据等信息。

  - **浏览器处理返回的响应**：浏览器接收并处理来自服务器的 `HTTP` 响应，对响应中的 `HTML`、`CSS` 和 `JavaScript` 等资源进行解析和渲染，如果有其他资源（如图片、音视频资源），可能还需要进行额外的 `HTTP` 请求。

  - **断开连接或者在请求其他资源后保持连接**，如果没有设置持久连接，浏览器和服务器会断开 `TCP` 连接，如果是持久连接，线路会在传输更多资源后保持。

优化方案：

  - **优化DNS查询**：使用更快的 `DNS` 服务器，使用 `DNS` 缓存，使用 `DNS` 预读取等方法。

  - **减少TCP连接次数**：使用 `HTTP` 持久连接（`HTTP/1.1` 默认开启），利用浏览器并行连接的特性，使用 `HTTP/2` 多路复用等。

  - **优化服务器处理**：提高服务器硬件性能，优化后端代码，使用服务器缓存，使用 `CDN` 等。

  - **减少HTTP请求以及减小请求/响应大小**：合并文件、压缩文件、使用浏览器缓存，使用更高效的文件格式等。

  - **优化页面渲染**：避免重排和重绘，使用懒加载、异步加载等技术，对 `JS/CSS` 进行优化等。

:::

#### ❓使用 `ssh` 连接云服务器，整个网络通信过程

::: details 💡

> `SSH`(`Secure Shell)`: 一种网络协议，用于计算机用户通过加密的方式进行远程登录到另一台计算机上。

  - **地址解析**：连接的云服务器的IP地址或者域名。如果你使用的是域名，那么会通过 `DNS` 服务解析出服务器的真实 `IP` 地址。

  - **TCP握手**：设备会向这个 `IP` 地址发起一个 `TCP` 连接。这个过程包括三次握手，确保双方都已经准备好开始通信。

  - **SSH连接**：`TCP` 连接建立后，设备会发起 `SSH` 的连接请求。在这个请求中，会包含计算机的公钥（如果设置了密钥登录的话）或者用户名和密码信息。

  - **身份验证**：云服务器接收到 `SSH` 请求后，如果使用的是密钥登录，那么服务器会使用存储的公钥信息来验证私钥是否匹配；如果使用的是用户名和密码，那么服务器就会验证用户名和密码是否正确。只有在验证通过后，才会允许 `SSH` 连接。

  - **会话开始**：一旦获得许可，一个 `SSH` 会话就会建立，就可以开始在这个终端会话中运行命令，操作云服务器了。

  - **会话结束**：当结束这个 `SSH` 会话时（比如输入 `exit` 命令），那么这个 `SSH` 连接就会关闭，并释放这个 `TCP` 连接。

注意：`SSH` 协议提供了一种安全的、加密的网络通信机制，所以在整个通信过程中，所有的数据都是被加密的，这就保证了数据的安全性和隐私性。

:::

### 音视频

#### ❓在整个视频面试的过程中，可能会用到哪些协议，都在哪几层

::: details 💡

  - **物理层和链路层**：`Ethernet`（以太网）协议用于实现局域网中的设备交互，`Wi-Fi` 用于无线网络通信。这些通常在物理层和数据链路层起作用。

  - **网络层**：`IP` 协议（Internet Protocol）用于在网络中定位设备，并在设备之间传输数据包，它在网络层起作用。

  - **传输层**：`TCP` 协议（传输控制协议）用于在网络中创建连接并提供可靠的数据传输。而 `UDP` 协议（用户数据报协议）则提供无连接的快速数据传输，用于实时通信，如音视频传输。

  - **会话层和表示层**：这两层在现代网络中并不明确区分，不过 `SSL/TLS` 协议提供了数据加密的服务，可视为在此两层中。

  - **应用层**：`HTTP/HTTPS` 协议用于网络浏览器与服务器之间的通信，`RTMP`(`Real Time Messaging Protocol`) 或者 `WebRTC`（`Web` 实时通信）等是专为流媒体和通信设计的协议，用于实时音视频数据传输。

:::

#### ❓为什么视频会议用 `UDP`

::: details 💡

  - 实时性：视频会议要求音频和视频数据能够尽快地传输和播放，这需要低延迟的传输协议。`UDP` 协议是一种无连接协议，不需要建立和维护复杂的连接状态，因此可以减少很多网络延迟。

  - 容忍数据丢失：在视频会议中，如果偶尔丢失一些音频或视频数据包，并不会对整体的通信质量产生太大影响，相反，如果使用了 `TCP` 协议，`TCP` 会尝试重传丢失的数据包，这可能引入更多的网络延迟，影响通信的实时性。

  - 简单高效：和 `TCP` 相比，`UDP` 的协议头部更简单，处理起来更高效，可以用于构建高性能的实时应用。

  - 处理网络拥塞：`UDP` 不会像 `TCP` 那样根据网络拥塞来调整数据的发送速率，这样即使在网络不稳定的环境下，也可以保证视频会议的流畅性。

  - 更好的支持多播和广播：视频会议常常需要同时向多个端点发送同样的数据，这种场景下 `UDP` 比 `TCP` 更有优势。

结论：由于 `UDP` 协议的实时性、容错性、简单高效和对多播和广播的良好支持，视频会议通常会选择使用 `UDP` 协议。然后，通过在应用层添加一些错误控制和恢复机制，来确保通信质量。

:::

#### ❓用 `UDP` 实现音视频，有什么方法可以保证通话质量

::: details 💡

  - 应用层的重传：在关键数据流（例如关键帧）丢失时，应用可以选择重新发送丢包。

  - 使用前向纠错（`FEC`）：`FEC` 可以在发送端加入冗余数据，即使部分数据丢失，也能借助冗余数据进行恢复。

  - 使用差错控制编码：如 `RS`(`Reed-Solomon`) 编码等，可以帮助接收端修复部分丢失的数据。

  - 交错和抖动缓冲：将数据打包为更大的单位并交错发送，可以减少丢包率对于解码的影响。另外，应用可以在客户端使用抖动缓冲区，对接收的数据包进行排序和缓冲，以适应网络延迟的变化。

  - 利用 `QoS`(`Quality of Service`)：通过对网络进行优化，如设置优先级，保证音视频流的带宽、延迟等。

  - 码率自适应：根据网络状态动态调整音视频的编码率。

  - 使用实时传输协议（`RTP`）以及实时传输控制协议（`RTCP`）
    * `RTP` 提供了标准化的包结构用于音视频数据。
    * `RTCP` 提供关于网络状况的反馈。

:::

#### ❓如果用 `TCP` 实现音视频，需要建立几次连接

::: details 💡

> 至少需要建立一次连接。

  - `TCP` 是一种面向连接的协议，它需要在传输数据前与另一台设备建立一个连接。
    > 在一个音视频通话场景中，至少需要建立一次连接，这个连接用来传输音频和视频数据。

  - 某些情况下，可能需要建立多个TCP连接。
    > 例如，如果音频和视频数据需要由不同的服务器分别处理，那么就可能需要分别对每个服务器建立一个连接。又或者，如果需要在音视频传输的同时进行其他的数据交换（比如文本聊天，文件传输等），那么也可能需要额外建立一个或多个 `TCP` 连接。

  - `TCP` 连接的数量也可能与特定的应用架构或协议有关。
    > 例如，在 `WebRTC`（一种用于实时通信的开放源代码项目）中，音频和视频流通常会使用单独的连接，以便单独控制它们的传输质量。

:::

### 故障分析

#### ❓如果发现微信和 QQ 都可以正常使用，但是浏览器网页打不开，可能是什么原因，有什么排查的办法

::: details 💡

  - 浏览器设置问题：可能浏览器的代理设置被修改，或者被某些恶意软件更改了网络设置。

  - `DNS` 解析问题：微信和 `QQ` 服务器的 `IP` 地址可能已经在本地缓存中，不需要 `DNS` 解析，但是浏览器访问网站需要 `DNS` 解析域名到 `IP`，如果 `DNS` 解析出现问题，就会导致网页无法打开。

  - 网络连接类型：有些网络环境对不同类型的网络连接有限制，可能对浏览器使用的 `HTTP/HTTPS` 协议进行了限制。

:::

>❓有什么排查的办法

::: details 💡

  - 检查并重置浏览器设置：确认浏览器的网络设置是正确的，没有被错误的代理服务或 `VPN` 干扰。也可以尝试重置浏览器设置，或者使用另外一种浏览器试试。

  - 更换 `DNS`：试着更换一下 `DNS` 服务器地址。
    > 例如，更改为 `Google` 的公共 `DNS` 地址 `8.8.8.8` 或 `8.8.4.4`。

  - 使用命令行工具：可以使用 `Ping` 命令检查网络连接，使用 `nslookup` 命令检查 `DNS` 解析是否正常。

  - 查看防火墙设置：检查一下个人电脑的防火墙或者路由器设置，看看是否对 `HTTP/HTTPS` 协议有所限制。

  - 在移动设备上测试：如果有条件的话，可以尝试在手机或者其他电脑上连同样的网络，看看能否正常使用浏览器访问网页。

:::

#### ❓在北京 `HTTP` 请求服务器响应快，可能离服务器距离近；而在上海访问就非常慢，会是什么原因
::: details

  - 网络路径和距离：尽管距离在物理上相近，但在网络传输上，信息可能要经过多个节点才能到达目的地。网络堵塞、路由器性能、网络提供商等都会影响网络的传输速度。从上海到服务器的网络路径可能比从北京到服务器的网络路径复杂，进而造成延迟增加。

  - 服务器负载：如果服务器在处理上海的请求时负载过高，可能会导致响应速度下降。
    > 比如，如果服务器同时处理的请求太多，或者服务器上运行的其他应用占用了大量资源，都可能导致服务器处理请求的速度降低。

  - `CDN` 配置：如果服务器使用了内容分发网络（`CDN`），但没有在上海或者附近地区设置节点，那么上海的用户就需要从远处的服务器获取数据，这会增加延迟。

  - `DNS` 解析：如果服务器的 `DNS` 解析服务在上海的效率较低，也会使得上海用户在获取服务器地址时花费更多的时间。
    
:::

>❓如果用户投诉，怎么分析这个问题

::: details

  - 网络状况检测：首先可以进行一些基础的网络性能测试。
    > 比如 `Ping` 和 `Traceroute`，用来检测数据包到达服务器所需的时间以及经过的节点。`Ping` 可以查看网络延迟，`Traceroute` 可以看到数据包到达服务器所经过的所有路由节点。如果发现某一跳的延迟特别高，可能就是出问题的地方。

  - `CDN` 是否使用：如果服务器使用了内容分发网络 (`CDN`)，检查 `CDN` 是否在有问题的地方正常工作。
    > `CDN` 运营商通常会在全国各地设立节点，如果某个地方的节点出现问题，可能会导致该地区的访问速度变慢。

  - 带宽查看：查看服务器的带宽使用情况，如果带宽使用过高，可能会导致访问速度变慢。

  - 服务器性能查看：分析服务器性能指标。
    > 如 `CPU` 使用率、内存使用情况、`I/O`等，如果服务器负载过高，可能会影响服务的响应时间。
   
  - 投诉用户所在网络环境分析：了解投诉用户的网络环境。
    > 如网络运营商，网络类型（光纤、`ADSL`、`4G`等），或者在其他网络环境下访问情况，以排除是用户本身网络原因导致的问题。

  - 应用层面的检查：除了硬件和网络，还要检查应用层面。
    > 比如服务器是不是出现了错误、是否有大量的请求等。

  - 最后，如果问题还是无法定位，或者是跨越多个网络运营商的问题，则需要与网络服务提供商进行沟通，可能能提供更多的信息或者解决方案。

:::

#### ❓整个网络过程中，网络耗时会在什么地方，怎么优化

::: details 💡

  - `DNS` 查询：当你向一个 `URL` 发送请求时，浏览器或应用需要首先通过 `DNS` 查询这个 `URL` 的 `IP` 地址。`DNS` 查询有时会非常耗时，特别是在初次查询或 `DNS` 缓存失效的情况下。
    > 优化方法：可以在服务端的解析服务器采用 `CDN` 来加速 `DNS` 的解析速度，或者使用 `DNS` 预获取技术，在加载页面或者应用的时候，预先进行 `DNS` 查询。

  - 建立连接：根据协议的不同（`HTTP/HTTPs`），建立连接需要消耗不同的时间，特别是在握手过程中。
    > 优化方法：可以使用 `HTTP/2`，支持单一连接上并行交错（`multiplexing`）请求和响应，从而避免 `HTTP/1.1` 中的队头阻塞（`Head-of-line blocking`）问题。

  - 服务器处理：服务器处理请求并生成响应数据也会需要一些时间。特别是在处理复杂查询或生成大量数据时，这部分时间可能会非常长。
    > 优化方法：在于服务端的性能优化，例如使用合适的算法和数据结构，以及适当的系统和应用层缓存。针对数据库查询，可以优化 `SQL` 语句或者进行合适的数据库设计和索引。

  - 数据传输：数据在网络传输中耗时，取决于数据量和网络带宽。
    > 优化方法：可以使用数据压缩技术，尽量减少传输的数据量。还可以使用分块传输编码（`Chunked transfer encoding`），让服务器生成响应时就可以开始发送数据。

:::

#### ❓如果手机应用与服务器通过 `TCP` 连接，这个时候手机切换为飞行模式，服务器可以短时间内知道到手机离线状态吗

::: details 💡

  服务器通过 `TCP` 短时间内是不能知晓手机的离线状态的。因为 `TCP` 主要是为了保证数据的可靠传输，通信双方是通过数据交换来了解对方状态。而 `TCP` 并没有设计心跳检测机制，所有就没有实时检测对方是否离线的能力。

  回到 `TCP` 的运行机制，当一方断开连接时，通常会发送一个 `FIN` 包到另一方。但是当手机进入飞行模式时，它并没有发送任何类型的 `TCP` 包到服务器，所以服务器并没有明显的迹象表明手机已经离线。

两种机制：

  - `TCP` 超时：`TCP` 连接有一个超时机制，一旦连接上没有数据传输并且超过了给定的时间限制，那么连接就会被关闭，服务器会知道手机已经离线。

  - `Keep-Alive`：如果在服务器和手机之间启用了 `TCP` 或应用层的 `Keep-Alive` 机制，服务器会定期向手机发送小的数据包来检查连接是否仍然有效。如果手机没有响应这些数据包，服务器将知道手机已经离线。

结论：两种机制都需要一段时间才能工作。因此，如果手机切换到飞行模式，服务器并不能立即知道这一点。但是经过一段时间后，一旦服务器尝试向手机发送数据或者执行 `Keep-Alive` 检查并且失败，那么服务器就会知道手机已经离线。
   
:::

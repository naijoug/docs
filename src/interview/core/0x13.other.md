---
title: 其它知识点
icon: hashtag

index: true

---

<!-- more -->

### ❓在不知道二进制文件格式的情况下如何区分文件

::: details 💡

对于不知道二进制文件格式的情况，有以下一些方法可以尝试区分文件：

1.文件扩展名：虽然文件扩展名不能百分之百保证文件类型，但是它却是一种最便捷的方式。例如，.jpg和.png常常是图片文件，.exe通常是Windows下的可执行文件，.txt通常是文本文件等。

2.文件头信息：许多文件类型（如JPEG、PNG、MP3等）都含有特定的文件头(Binary Signature / Magic Number)，这是一段位于文件开头的特定的二进制信息。通过读取二进制数据的前几个字节，就可以得到一些线索。需要注意的是，要有对应的文件头信息数据库作为对照才行。

3.文件大小：某些类型的文件有其特定的大小范围，例如简单的文本文件通常不会很大，而一些图像、视频或者音频文件则通常较大。

4.使用文件命令：在Unix/Linux操作系统中，文件命令可以用来查看文件类型。这个命令会读取文件的文件头的二进制信息来推断文件类型。

5.使用专业工具：有很多专业的文件分析工具，例如TrID、DROID等，它们有大规模的文件类型数据库，可以识别上千种文件类型。

请注意，这些方法只能提供关于文件类型的一些线索，而不能提供绝对的确定。而且，如果文件被故意改名或者文件头被篡改，这些方法可能都不准确。

:::

### ❓一个文件有哪些属性，怎么获取（文件描述符）

::: details 💡

一个文件通常具有以下属性：

1. 名称：文件的名称，包括文件的扩展名。
2. 大小：文件的大小。通常以字节为单位。
3. 创建日期和时间：创建文件的日期和时间。
4. 修改日期和时间：文件最后修改的日期和时间。
5. 访问日期和时间：最后访问文件的日期和时间。
6. 文件类型：文件的类型，如普通文件、目录文件、链接文件等。
7. 所有者：文件的所有者，通常指的是创建该文件的用户。
8. 文件权限：对文件的访问权限，包括读、写、执行。

可以通过文件描述符来获取文件的一些基本属性。在 Unix 或类 Unix 系统（如 Linux）中，你可以使用 fstat、stat、lstat 这样的系统调用来获取文件的属性。例如：

```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    struct stat fileStat;
    if(stat("/path/to/your/file",&fileStat) < 0)    
        return 1;

    printf("Informations of the file: \n");
    printf("File Size: \t\t%d bytes\n",fileStat.st_size);
    printf("Number of Links: \t%d\n",fileStat.st_nlink);
    printf("File inode: \t\t%d\n",fileStat.st_ino);

    printf("File Permissions: \t");
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf( (fileStat.st_mode & S_IRGRP) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWGRP) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXGRP) ? "x" : "-");
    printf( (fileStat.st_mode & S_IROTH) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWOTH) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n\n");

    printf("The file %s a symbolic link\n", (S_ISLNK(fileStat.st_mode)) ? "is" : "is not");
    return 0;
}
```

在这个例子中，我们使用了 stat 系统调用，它接收一个文件路径和一个指向 struct stat 的指针，然后填充这个结构体的字段以反映指定文件的属性。例如，st_size 字段表示文件的大小，st_mode 字段表示文件的权限等。

此外，Windows 系统的文件属性获取方式与此略有不同。一般可以使用 Windows API 中的获取文件信息的函数来获取。

:::

### ❓怎么将彩色的图片转化为黑白的

::: details 💡

将彩色图片转换为黑白图片的基本方法是将图片的颜色信息转换为灰度信息。以下是一个使用Python的PIL库进行彩色到黑白转换的简单示例：

```py
from PIL import Image
img = Image.open('input.jpg').convert('L')
img.save('output.jpg')
```

这里, 'L'模式表示灰度信息。PIL库会使用一个算法把每个像素的红绿蓝(RGB)值转换为一个灰度值。

如果你想手动做这种转换，对于图片中的每一个像素，你可以把它的红绿蓝(RGB)值转换为一个单独的灰度值。一种常用的转换方式是通过计算加权平均值，如下公式所示：

```py
Gray = R*0.299 + G*0.587 + B*0.114
```

这个公式中的权重取决于人眼对不同颜色的敏感程度。在这里，绿色的权重最高，因为人眼对绿色最敏感。

以上就是将彩色图片转换为黑白图片的基本原理和方法。

:::

### ❓图像的压缩方式有哪些

::: details 💡

图像压缩方式主要有两种：  

1. 无损压缩：在这种方式中，原始图像的所有信息都被保留下来，压缩和解压缩之后的图像与原图像完全一样。典型的无损压缩格式有GIF和PNG。

    无损压缩主要使用以下方法：
    - 游程编码：游程编码是将连续的相同的数据值编码为一个数据值和它的长度。例如，对于黑白图像，大片的黑/白区域就可以通过游程编码进行压缩。
    - 霍夫曼编码：霍夫曼编码是一种效率很高的编码方式，在jpeg中也用到了霍夫曼编码。
    - 预测编码：在预测编码中，每个像素被编码成原始值与预测值之间的差。

2. 有损压缩：这种方式会丢弃图像中的一部分信息，通常是一些对于视觉影响较小的部分。这种方式压缩后的图像与原图像有所区别，但视觉效果往往相差不大。有损压缩可以实现比无损压缩更高的压缩率。典型的有损压缩格式有JPEG和WebP。

    有损压缩的方法主要有：
    - 转换编码：如使用离散余弦变换（DCT）等方法把像素的色彩和亮度信息转换为频率信息，然后丢弃一些频率信息。
    - 量化：这是一种精度降低的方法。高的量化级别会增加压缩比，但也会降低图像质量。
    - 子采样：这是减少色度信息的方法。人眼对颜色的敏感度低于亮度，所以可以降低色度信息的精度以达到压缩的目的。

以上就是常见的图像压缩方式，无损压缩和有损压缩各有优缺点，需要根据具体的应用场景来选择。

:::

### ❓图片格式有哪些，有什么区别

::: details 💡

以下是一些常见的图片格式以及他们的特点和用途：

1. JPEG（Joint Photographic Experts Group）：使用有损压缩，通常用于存储照片和复杂图像。优点是可以根据需要调整压缩级别以达到理想的文件大小，缺点是如果压缩级别过高可能导致图像质量明显降低。

2. PNG（Portable Network Graphics）：使用无损压缩，可以支持透明度（alpha通道）。通常用于网页设计和需要透明效果的地方。
 
3. GIF（Graphics Interchange Format）：使用无损压缩，支持动画和透明度，但只有256种颜色。通常用于简单动画和图标。

4. BMP（Bitmap）：是一种未经压缩的格式，通常用于Windows中的简单图像和图标，文件较大。

5. TIFF（Tagged Image File Format）：常用于出版、印刷或者其他专业领域，可以使用无损压缩或者无压缩，支持多页和图层。

6. RAW：用于存储数码相机捕获的全部数据的未处理图像文件，未经压缩或者只进行轻微压缩，质量高但文件大。

7. SVG (Scalable Vector Graphics): 是一种基于XML，用于描述二维向量图形的图像格式。向量图像的优点是可无损缩放。

8. WebP：是谷歌开发的一种旨在加快图像加载速度的图像格式。WebP支持有损压缩。

每种格式都有自己的优点和应用场景，需要根据图像类型（例如是照片、图标、简单动画或者复杂的艺术作品等），以及最终的用途（例如是要上传到网页还是打印出来）来选择合适的格式。

:::

### ❓`Git` 工作流

::: details 💡

Git是最流行的版本控制系统之一，也因此出现了很多种不同的Git工作流程。

1. 中央式工作流：这是最简单的工作流模型。中央式工作流使用一个中央仓库，所有开发者直接与中央仓库进行交互。所有的变更都直接提交到这个中央仓库的主分支上。

2. 功能分支工作流：在这个模型中，每个新的功能都拥有自己的分支。这样可以将功能开发与主代码库隔离开，使得开发者可以在自己的功能分支上独立工作。

3. Gitflow工作流：这是一种复杂但结构化的工作流模型。Gitflow工作流定义了一个围绕项目发布的严格分支模型。除了需要维护feature，develop，master等不同的分支外，还需要有专门用于准备、维护、修复发布版本的release、hotfix等分支。

4. Forking工作流：这是开源项目中常见的工作流模型。每个开发者都会派生（fork）出自己的公开仓库，然后在这个派生仓库中工作，完成后发起拉取请求（pull request）合并回主仓库。

5. Pull Request工作流：类似Forking工作流，但是每个开发者直接在原始仓库创建新的分支进行开发，开发后发起 Pull Request，待其他开发者审核后，才能被合并到主分支。

这些工作流程只是一些通用的模型，具体应用时可以根据项目的需求对这些模型进行微调。

:::

### ❓你知道哪些编码方式

::: details 💡

常见的字符编码方式有以下几种：

1. ASCII编码：最早最基础的字符编码方式，只使用7位，可以表示128个字符，主要用来表示英文字符。

2. ISO 8859-1：也叫Latin-1编码，一种8位的编码方式，可以表示256个字符，用以表示大部分欧洲语言。

3. Unicode：为了解决不同字符集转换和文本处理问题，提出了Unicode这种编码方式。Unicode可以用来表示世界上几乎所有的文字。

4. UTF-8：是Unicode的一种实现方式。UTF-8使用1到4个字节表示一个字符，长度可变。

5. UTF-16：是Unicode的另一种实现方式，使用2或4个字节表示一个字符，包含音节和补充平面字符。

6. GB2312/GBK/GB18030：主要用于表示简体中文字符。其中，GB2312用于表示6763个简体中文字符，GBK包含了更多的字符，而GB18030则完全兼容Unicode。

7. Big5：主要用于表示繁体中文字符。

以上就是常见的字符编码方式，底层存储都是通过二进制实现的，每种编码方式有其特定的应用场景，编程时需要根据实际需求选择合适的字符编码。

:::


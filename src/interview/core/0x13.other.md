---
title: 其它知识点
icon: hashtag

index: true

---

<!-- more -->

## reference

- []()[2019-11-21 为什么 MD5 不能用于存储密码](https://draveness.me/whys-the-design-password-with-md5)

------

## 字符编码

### ❓字符编码都知道哪些

::: details 💡

  - `ASCII` 编码：最早最基础的字符编码方式，只使用 7 位，可以表示 128 个字符，主要用来表示英文字符。

  - `ISO 8859-1`：也叫 `Latin-1` 编码，一种 8 位的编码方式，可以表示 256 个字符，用以表示大部分欧洲语言。

  - `Unicode`：为了解决不同字符集转换和文本处理问题，提出了 `Unicode` 这种编码方式。`Unicode` 可以用来表示世界上几乎所有的文字。
    
    * `UTF-8`：是 `Unicode`的一种实现方式。`UTF-8` 使用 1 到 4 个字节表示一个字符，长度可变。

    * `UTF-16`：是 `Unicode` 的另一种实现方式，使用 2 或 4 个字节表示一个字符，包含音节和补充平面字符。

  - `GB2312/GBK/GB18030`：主要用于表示简体中文字符。
    
    * `GB2312` 用于表示 6763 个简体中文字符
    * `GBK` 包含了更多的字符
    * `GB18030` 完全兼容 `Unicode`。

  - `Big5`：主要用于表示繁体中文字符。

:::

------

## 文件格式

### ❓在不知道二进制文件格式的情况下如何区分文件

::: details 💡

  - 文件扩展名：虽然文件扩展名不能百分之百保证文件类型，但是它却是一种最便捷的方式。
    > 例如，`.jpg` 和 `.png` 常常是图片文件，`.exe` 通常是 `Windows` 下的可执行文件，`.txt` 通常是文本文件等。

  - 文件头信息：许多文件类型（如`JPEG`、`PNG`、`MP3`等）都含有特定的文件头(`Binary Signature / Magic Number`)，这是一段位于文件开头的特定的二进制信息。通过读取二进制数据的前几个字节，就可以得到一些线索。
    > 前提：要有对应的文件头信息数据库作为对照才行。

  - 文件大小：某些类型的文件有其特定的大小范围。
    > 例如简单的文本文件通常不会很大，而一些图像、视频或者音频文件则通常较大。

  - 文件命令：在 `Unix/Linux` 操作系统中，文件命令可以用来查看文件类型。
    > 这个命令会读取文件的文件头的二进制信息来推断文件类型。

  - 专业工具：有很多专业的文件分析工具。
    > 例如 `TrID`、`DROID` 等，它们有大规模的文件类型数据库，可以识别上千种文件类型。

:::

### ❓一个文件有哪些属性，怎么获取（文件描述符）

::: details 💡

文件属性：

  - 名称：文件的名称，包括文件的扩展名。
  - 大小：文件的大小。通常以字节为单位。
  - 创建日期和时间：创建文件的日期和时间。
  - 修改日期和时间：文件最后修改的日期和时间。
  - 访问日期和时间：最后访问文件的日期和时间。
  - 文件类型：文件的类型，如普通文件、目录文件、链接文件等。
  - 所有者：文件的所有者，通常指的是创建该文件的用户。
  - 文件权限：对文件的访问权限，包括读、写、执行。

```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    // 在 Unix 或 Linux 中，可以使用 fstat、stat、lstat 来获取文件的属性
    struct stat fileStat;
    if(stat("/path/to/your/file",&fileStat) < 0)    
        return 1;

    printf("Informations of the file: \n");
    printf("File Size: \t\t%d bytes\n",fileStat.st_size); // 文件的大小
    printf("Number of Links: \t%d\n",fileStat.st_nlink);
    printf("File inode: \t\t%d\n",fileStat.st_ino);

    printf("File Permissions: \t");
    // 文件的权限
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf( (fileStat.st_mode & S_IRGRP) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWGRP) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXGRP) ? "x" : "-");
    printf( (fileStat.st_mode & S_IROTH) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWOTH) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n\n");

    printf("The file %s a symbolic link\n", (S_ISLNK(fileStat.st_mode)) ? "is" : "is not");
    return 0;
}
```

:::

------

## 图片

### ❓`bitmap` 的结构

::: details 💡

> 位图（`Bitmap`）是一种将图像根据每个像素点分别存储和表示的方式。位图由许多称为像素的矩阵组成，每个像素表示一个点的颜色。

基本结构：

  - 位图文件头（`Bitmap File Header`）：包含位图文件的类型、大小和处理方式的信息。
  - 位图信息头（`Bitmap Information Header`）：包含位图的尺寸、颜色、压缩方式等图像的详细信息。
  - 颜色表（`Color Table`）：包含整个图像可能使用的所有颜色信息。
  - 像素数据（`Pixel Data`）：真正的位图数据，记录了位图中每一个像素的颜色信息。

`Bitmap` 有着良好的图像效果和兼容性，但与矢量图形相比，其缺点是文件相对较大，且如果将位图进行放大操作，可能会出现失真和马赛克现象。

:::

### ❓了解bitmap吗，结构是什么样的，有对做过什么优化吗

::: details 💡

> `Bitmap`: 位图，是一种像素按照高和宽排列，其上每个像素存储特定位置颜色值的图片格式。

每一个像素可以由不同的位来表示，常见的有1位，4位，8位，16位，24位和32位。

  - 1 位位图每个像素只能取黑色或白色，
  - 8 位位图每个像素可以取 256 种颜色，
  - 24 位位图每个像素可以取接近 1700 万种颜色，即真彩色。

位图的基本结构包括：文件头信息(`BITMAPFILEHEADER`)，信息头(`BITMAPINFOHEADER`),调色盘，位图数据四个部分。

优化：

  - **空间优化**：近似色彩的合并可减少图片中的颜色数量，根据颜色数量来选择合适的位数表示位图。
    > 例如，如果图片只有 256 色，那么就没必要使用 24 位色彩表示，改用 8 位来存储每个像素的颜色足矣。

  - **时间优化**： 使用缓存技术，把经常使用或者最近使用的图片缓存在内存中，可以加快图片的读取速度。

  - **压缩技术**：像是有损压缩和无损压缩，如 `JPEG`，`PNG` 等图像格式都用到了压缩技术。
    > 对于不透明的 `PNG` 图片，可以转成 `JPG` 格式来减小体积

:::

### ❓图片格式有哪些，有什么区别

::: details 💡

  - `BMP`(Bitmap): 是一种未经压缩的格式.
    > 通常用于 `Windows` 中的简单图像和图标，文件较大。

  - `JPEG` (`Joint Photographic Experts Group`): 使用有损压缩，通常用于存储照片和复杂图像。
    * 优点：可以根据需要调整压缩级别以达到理想的文件大小。
    * 缺点：如果压缩级别过高可能导致图像质量明显降低。

  - `PNG` (`Portable Network Graphics`): 使用无损压缩，可以支持透明度（alpha通道）。
    > 通常用于网页设计和需要透明效果的地方。
 
  - `GIF` (`Graphics Interchange Format`): 使用无损压缩，支持动画和透明度，但只有 `256` 种颜色。
    > 通常用于简单动画和图标。

  - `WebP`: 是谷歌开发的一种旨在加快图像加载速度的图像格式。`WebP` 支持有损压缩。

  - `SVG` (`Scalable Vector Graphics`): 是一种基于 `XML`，用于描述二维向量图形的图像格式。
    > 优点是可无损缩放。

  - `TIFF` (`Tagged Image File Format`): 可以使用无损压缩或者无压缩，支持多页和图层。
    > 常用于出版、印刷或者其他专业领域.。

  - `RAW`: 未经压缩或者只进行轻微压缩，质量高但文件大。
    > 用于存储数码相机捕获的全部数据的未处理图像文件。

:::

### ❓图像的压缩方式有哪些

::: details 💡

  - 无损压缩：原始图像的所有信息都被保留下来，压缩和解压缩之后的图像与原图像完全一样。
    > 典型的无损压缩格式有 `GIF` 和 `PNG`。

    无损压缩方法：
    
    * 游程编码：游程编码是将连续的相同的数据值编码为一个数据值和它的长度。
        > 例如，对于黑白图像，大片的黑/白区域就可以通过游程编码进行压缩。
    * 霍夫曼编码：霍夫曼编码是一种效率很高的编码方式，在 `JPEG` 中也用到了霍夫曼编码。
    * 预测编码：在预测编码中，每个像素被编码成原始值与预测值之间的差。

  - 有损压缩：会丢弃图像中的一部分信息，通常是一些对于视觉影响较小的部分。这种方式压缩后的图像与原图像有所区别，但视觉效果往往相差不大。有损压缩可以实现比无损压缩更高的压缩率。
    > 典型的有损压缩格式有 `JPEG` 和 `WebP`。
    
    有损压缩的方法：
    
    * 转换编码：如使用离散余弦变换（`DCT`）等方法把像素的色彩和亮度信息转换为频率信息，然后丢弃一些频率信息。
    * 量化：这是一种精度降低的方法。高的量化级别会增加压缩比，但也会降低图像质量。
    * 子采样：这是减少色度信息的方法。人眼对颜色的敏感度低于亮度，所以可以降低色度信息的精度以达到压缩的目的。

:::

### ❓怎么将彩色的图片转化为黑白的

::: details 💡

基本方法：将图片的颜色信息转换为灰度信息。

  - 手动转换
    > 对于图片中的每一个像素，把它的红绿蓝(`RGB`)值转换为一个单独的灰度值。

    ```c
    // 通过计算加权平均值，公式中的权重取决于人眼对不同颜色的敏感程度。绿色的权重最高，因为人眼对绿色最敏感。
    Gray = R*0.299 + G*0.587 + B*0.114
    ```

  - 使用 `Python` 库

    ```py
    # 使用 Python 的 PIL 库进行彩色到黑白转换
    from PIL import Image
    img = Image.open('input.jpg').convert('L')
    img.save('output.jpg')
    # 'L'模式表示灰度信息。PIL 库会使用一个算法把每个像素的红绿蓝(RGB)值转换为一个灰度值。
    ```

:::

------

## 密码学

### ❓对称加密和非对称加密有哪些

::: details 💡

  - 对称加密：

    * `DES`(数据加密标准)：已经被认为不是一种安全的加密方式，主要是密钥太短。

    * `3DES`(即Triple DES)：是DES向AES过渡的加密算法，是DES的一个更安全的变形。

    * `AES`(高级加密标准)：美国联邦政府采用的一种区块加密标准。

    * `RC4`，`RC5`，`RC6`：快速且较为安全，主要用于网络传输层安全和应用层安全。

    * `Blowfish`，`Twofish`：快速且强度较大，主要用于文件加密。

  - 非对称加密：

    * `RSA`：非对称密码算法的一个早期并且非常著名的算法，广泛应用于现今的电子商务系统中。

    * `Elgamal`：一个基于迪菲-赫尔曼密钥交换的加密算法。

    * `DSA`(数字签名算法)：主要用于数字签名。

    * `ECC`(椭圆曲线密码算法)：基于椭圆曲线数学的一种公钥加密算法。
    
总结：通常情况下，对称加密速度较快，适合大量数据的加解密；非对称加密虽然慢，但安全性更高，常用于进行身份验证和密钥交换等操作。

:::

### ❓加密算法具体的过程了解吗

::: details 💡

> 加密算法的过程通常涉及到一些复杂的数学计算和逻辑操作。以著名的


  - 对称加密算法：`AES`（`Advanced Encryption Standard`，高级加密标准）

    * 填充：加密的信息需要被分成长度为 128 比特的块，如果不足则进行填充；
    * 初始处理：将明文块与密钥进行异或操作；
    * 正式处理：包括 “代替字节”，“行转移”，“列混合” 和 “添加轮密钥” 这四个步骤，除了最后一轮外，其他轮都执行这四个步骤；
    * 最后一轮处理：执行 “代替字节”，“行转移”，和 “添加轮密钥” 步骤。
    * 这样，明文就被加密为密文了。解密过程是加密过程的逆过程。

    
  - 非对称加密算法：`RSA`（由创始人 `Rivest, Shamir` 和 `Adleman` 的名字命名）
    
    * 选择两个大质数 `p` 和 `q`，计算 `n = p * q`；
    * 根据欧拉函数，计算 `φ(n) = (p-1) * (q-1)`；
    * 选择一个 `e`，要求 `1 < e < φ(n)`，且 `e` 和 `φ(n)` 互质；根据 `e` 产生私钥 `d`，要求满足 `e*d ≡ 1 (mod φ(n))`；
    * 加密过程：公钥是 `(n, e)`，私钥是 `(n, d）`。给定明文 `M`，计算密文 `C = M^e mod n`；
    * 解密过程：已知密文 `C`，计算明文 `M = C^d mod n`。
    
:::

### ❓`PKI` 体系当中加密和签名有什么区别

::: details 💡

> 公钥基础设施（`PKI`）是一种用于实现数字签名、身份验证、加密等功能的技术框架。

主要区别：

  - **加密：** 主要用于确保信息的保密性。消息发送者使用接收者的公钥进行加密，接收者使用自己的私钥进行解密。这样，即使信息被第三方截获，由于没有私钥，他们也无法解读信息内容。

  - **签名：** 主要用于验证信息的完整性和消息的发送者身份。消息发送者使用自己的私钥对原始信息进行加密，得到的结果就是签名。接收者使用发送者的公钥对签名进行解密，并与自己独立得到的初始信息摘要进行对比，如果一致，那么说明信息没有被篡改，发送者身份也得到了验证。

总结：加密主要是为了保护信息内容的保密性，防止被第三方窃取，而签名主要是为了验证信息的来源和完整性，防止被第三方伪造或篡改。

:::
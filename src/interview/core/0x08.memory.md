---
title: memory - “内存”
icon: hashtag

index: true

---

<!-- more -->
 
## 概念知识
 
### ❓介绍下内存的几大区域

::: details 💡

在计算机中，内存被划分为若干个不同的部分，来存储不同种类的数据，下面是最常见的内存部分：

1. **代码区（Text Section）**：这里存储的是程序的机器代码，也就是编译后的二进制代码，执行的指令通常都存储在这个区域。

2. **数据区（Data Section）/静态区**：用于存储程序运行期间的全局变量和静态变量。静态存储区，在程序的生命周期内，始终存在。它包含了全局变量区和静态变量区，全局``区中存放的是全局数据，静态数据区中存放的是static数据。

3. **堆区（Heap）**：这部分的内存是动态分配的，也就是说，当你在程序中创建一个新的对象时，新的内存就会在堆内存中被分配（如C/C++中的malloc/new，Java中的new），当不再需要这部分内存时，它会被回收（如C/C++中的free/delete，Java中由GC自动回收）。

4. **栈区（Stack）**：用于存储局部变量、函数参数等数据。当一个函数被调用时，一个新的栈帧会被创建，用来存储函数的局部变量和参数。当函数返回时，栈帧会被销毁。

5. **常量区**：这部分内存通常存储常量值，如字符串常量、常量表达式等。

6. **BSS (Block Started by Symbol)**：这部分内存用于存储未初始化的全局变量和静态变量。

注意：不同的编程语言和操作系统可能有不同的内存布局，不同的编程语言对内存的管理也不同，例如，C/C++允许手动管理内存而Java和Python等语言则使用垃圾回收机制。

:::

### ❓栈区地址排列是从低到高吗

::: details 💡

事实上，相对于整个内存空间，栈区的物理地址布局由操作系统决定，操作系统可以决定从高地址开始向低地址分配，也可以决定从低地址开始向高地址分配。

但通常在大多数系统中，栈区是从高地址开始向低地址分配的。也就是说，每当在栈上分配新的空间（如函数调用产生新的栈帧或创建局部变量时），栈指针通常会向下（即向内存地址更小的方向）移动。

重要的是要明白，各个变量在栈上的相对位置关系是确定的，无论绝对的栈空间是向低地址扩张还是向高地址扩张。例如，一个函数内部的各个局部变量，在相对于该函数开始地址（函数的栈帧起始地址）的位置是确定的，每次函数调用都会有类似的布局。

这种从高地址到低地址的分配方式主要考虑的是性能与兼容性等问题。栈和堆在地址空间中通常是相邻的，堆从低向高地址分配，栈从高向低地址分配，两者相向而行，有效地利用了处理器的地址空间。哪一部分超出了分配的限制（即堆和栈发生溢出），都能直接触发处理器的地址保护机制。如果反过来，需要额外的机制来检测栈是否溢出，这在早期的系统设计中会带来额外的复杂度。

:::

### ❓什么是内存对齐

::: details 💡

内存对齐（Memory Alignment）是计算机内存分配的一种策略，主要是为了提高内存存取的效率。

在许多计算机体系结构中，直接访问对齐的内存比访问未对齐的内存要快。原因是，CPU从内存或高速缓存中取数据时，一次能取的最小单位是字（Word）。一个字通常是一个int的大小（取决于平台，可以是32位或64位）。

所谓的对齐，就是让变量的起始地址能够被字的长度整除。例如，地址为0，4，8，12的变量都是对齐的，而地址为2，6等的变量则是未对齐的。未对齐的变量可能跨越两个字，CPU需要进行两次内存访问才能将其取出，因此效率低下。

例如：

假设字长为4字节，那么：

- 如果在地址2处访问一个int，那么CPU需要：

  - 从地址0读取一个字；
  - 从地址4读取一个字；
  - 合并以上两个字，然后屏蔽不需要的部分。

- 如果在地址4处访问一个int，那么CPU只需要从地址4读取一个字。

因此，为了提高存取效率，编译器在为属性分配内存或者进行内存读写操作时，都会按照一定的规则（一般是基本数据类型的大小）对齐。这就是内存对齐。

然而，内存对齐也并非没有代价，它会浪费一部分内存。但这种浪费通常被认为是可以接受的，因为带来的好处比损失更大。

:::

### ❓内存中存在栈区和堆区，数据结构中存在栈和堆，那么这两者有什么关系
  
::: details 💡
  
  对于内存栈区来说，确实底层工作方式使用了栈的数据结构。遵循后进先出 `LIFO`(Last In First Out) 的原则。函数调用过程中，局部变量会被压入栈区，函数调用结束后，会从栈顶弹出。这也是栈区访问效率高于堆区的原因。
  
  而内存堆区，其实与堆这种数据结构就没有太大关系了。`heap` 在英语中表示一堆、许多的意思，表示一堆可以供程序员自由支配使用的内存区域。堆区的内存分配管理方案就与底层的操作系统以及所使用的编程语言有关了。使用的数据结构包括链表、位图、平衡二叉搜素树等。常用的内存分配算法：最佳适配算法、最差适配算法、首次适配算法、循环首次适配算法等。
  
:::
  
### ❓什么情况下会发生“栈溢出”
  
::: details 💡
  
  程序运行时，操作系统会分配一块固定大小的内存作为栈区。如果递归层数较多、申请临时变量过大等都可能触发栈溢出的问题。
  
  "栈溢出"是一种常见的程序执行错误，发生在程序试图使用超过了栈的大小限制的内存时。它可以发生于以下的几种情况：

1. **无限递归或深度过大的递归**：每次函数调用都需要在栈上分配内存用于存储函数的信息（如返回地址，局部变量等）。如果存在无限的递归调用或者递归深度过大，就可能会耗尽栈的空间。

2. **过大的局部变量**：如果你在一个函数中声明了一个非常大的局部数组或者其他数据结构，可能会超出栈的大小，触发栈溢出。

3. **过多的函数调用层级**：如果一个函数调用另一个函数，然后又调用另一个函数，层级太多的话，可能会超出栈空间。

4. **操作系统栈空间分配问题**：在某些特殊情况下，由于操作系统的内存分配问题，栈的空间可能会小于正常情况，也会引发栈溢出。

为了避免栈溢出，应避免过深的递归，过大的栈对象，以及过多的函数层级。另外，合理地设定启动参数中的栈大小也是一种有效的方法。在有些情况下，可以考虑将部分数据结构从栈区移到堆区，例如使用动态分配内存的方式来创建大型数组。
  
:::
  
### ❓什么情况下会发生“内存不足”
  
::: details 💡
  
  堆区内存大小，是可以动态扩容的。但是这个大小也是有限，当程序发生内存泄漏，申请堆区内存不断增长，当达到操作系统设自动的内存阈值，就会触发内存不足的问题。
  
  “内存不足”错误通常在以下情况发生：

1. **程序申请的内存超出系统能提供的上限**：如果程序试图动态申请超出系统可提供的内存，将会抛出内存不足的错误。这通常发生在程序加载大文件、创建大数组或大对象等时。

2. **内存泄漏**：程序没有正确地释放不再需要的内存，导致可用内存逐渐减少，最后导致内存不足。

3. **高内存消耗程序**：某些程序需要大量内存来处理任务，比如大数据处理、高清视频处理或大型游戏等。这些程序运行时如果可用内存不足，也会引发内存不足的错误。

4. **过多的程序同时运行**：如果开启过多的程序，系统的可用内存可能会被耗尽，导致程序无法获取足够的内存来运行。

5. **虚拟内存设置不当**：操作系统通常会使用硬盘空间作为虚拟内存来临时存储数据，如果虚拟内存设置不足，也可能导致内存不足的错误。

解决“内存不足”的方法包括：关闭不需要的应用、优化程序中的内存使用方式、增加物理内存、调整虚拟内存设置等等。对于内存泄漏问题要通过调试和内存分析工具寻找并修复代码中的内存管理错误。
  
:::
  
### ❓一次寻址过程会访问几次内存
  
::: details 💡

一次寻址过程通常访问一次内存。寻址就是通过地址找到存储器中相应的存储单元。

例如，对于直接寻址，地址是操作数本身的情况，此寻址方式只访问内存一次。你有一个地址，你直接访问这个地址的内容，就完成了寻址过程。

然而，对于其他复杂的寻址模式，如间接寻址，访问内存的次数可能会增加。间接寻址是指先从一个地址读出另一个地址，然后再从该地址读取(或者写入)数据，这样的寻址方式需要访问内存两次。

所以，访问内存的次数取决于具体的寻址方式。但在大多数情况下，一次寻址操作会访问一次内存。

:::
  
### ❓字节序有了解吗
  
::: details 💡

字节序是指在计算机系统中表示多字节数据（例如：16位、32位、64位数据）时，字节的排列顺序。根据字节的排列顺序，字节序主要分为两种：大端字节序（Big-Endian）和小端字节序（Little-Endian）。

1. **大端字节序（Big-Endian）**
  
  在大端字节序中，最高位字节存储在内存的最低地址处，最低位字节存储在内存的最高地址处。举例来说，假设我们有一个16位的数字0x1234，它存储在内存中的两个字节地址为0x1000和0x1001，则在大端字节序的系统中，0x12将会存储在地址0x1000下，0x34会存储在地址0x1001下。

2. **小端字节序（Little-Endian）**
  
  在小端字节序中，最低位字节存储在内存的最低地址处，最高位字节存储在内存的最高地址处。同样以数字0x1234为例，其存储在内存中的两个字节地址为0x1000和0x1001，则在小端字节序的系统中，0x34会存储在地址0x1000下，0x12会存储在地址0x1001下。

了解字节序的重要性主要体现在网络通信和跨平台数据交换中，这是因为不同的平台可能使用不同的字节序，如果不对字节序进行处理，直接传递数值，会导致接收端解析出错误的数值。所以在进行网络传输或者跨平台操作时，常常需要进行字节序的转换。例如，在网络中传输数据，无论发送端或接收端的系统字节序如何，按照网络协议，发送的数据都需要转为大端字节序（网络字节序）。

:::

------

## 内存计算
  
### ❓如何计算图片加载内存中所占的大小
  
::: details 💡

图片在内存中的大小是由以下几个因素决定的：

1. **图片的尺寸**：图片的宽度和高度以像素为单位，宽度和高度相乘就是图片的像素总数。

2. **每个像素的位数**：每个像素的位数取决于图像的颜色深度（彩色类型）。例如，一个像素如果是32-bit ARGB，那么就是4个字节（8 bits = 1 byte）。

根据以上两项，你可以通过以下公式来计算图像在内存中占用的空间：

图片占用内存大小 = 图片宽度 x 图片高度 x 每个像素的字节数。

举个例子，如果你有一张分辨率为1024x768的图片，颜色深度为32-bit（即，每个像素4个字节）。那么这张图片在内存中所占的大小就是：1024 x 768 x 4 = 3145728字节，也就是约3MB。

注意，这只是计算未经过压缩的图像在内存中的大小，如果图片进行了压缩，实际占用的内存大小会有所减少。

:::
  
### ❓一张图片的内存占用大小是由什么决定的
  
::: details 💡

图片在内存中占据的空间大小由其分辨率、颜色深度（bits per pixel，简称bpp）和压缩方法等因素决定。

在未经压缩的情况下，可以通过以下计算公式进行估算：

内存占用（字节） = 宽度（像素） * 高度（像素） * 颜色深度（字节）

常见的彩色图片颜色深度一般为24bit（即3字节，RGB各8bit）或32bit（即4字节，RGBA各8bit）。

例如，一张1000 * 1000像素，颜色深度为32bit的图片，其在内存中的占用大概为：

1000 * 1000 * 4 = 4,000,000字节，也就是约4MB。

需要注意的是这是未经压缩的情况，实际中许多图片格式（如JPEG，PNG等）都使用了压缩算法，实际占用的内存大小会小于这个计算结果。同时，如果程序使用了图像金字塔、缩略图等技术，那么实际占用的内存也会有所不同。

:::
  
### ❓一张 100*100 的 RGBA 格式的图片占用多少内存

::: details 💡

  首先计算每个像素点占用内存，RGBA 格式的图片由于占用 4 个字节，
  然后图片大小为 100*100 = 10000 像素点 (≈ 10240 = 10 * 1024 = 10kb)
  所有最后结果为: 4 * 10kb = 40kb

:::
  
### ❓如何计算一个像素点的大小和一张图的大小

::: details 💡

一般来说，一个像素点的大小取决于图片的颜色模式或位深度。例如，如果一个图像是8位索引色彩的（即使用颜色查找表），那么一个像素点就是1字节；如果图像是24位真彩色的，那么每个像素点是3字节（每种颜色信道8位，红、蓝、绿各一）；如果是32位RGBA模式的图片，一个像素点是4字节。

一张图的大小可以通过以下的公式来计算：
图像大小(字节) = 图像宽度（像素） x 图像高度（像素） x 每个像素的字节数

这是计算原始，未压缩图像大小的方式，如果图像进行了压缩（比如jpg，png等格式），那么实际的文件大小则会根据压缩算法和压缩比率有所减小。

:::
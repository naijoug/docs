---
title: network - “网络”
icon: hashtag

index: true

---

<!-- more -->

## `TCP`

### `TCP/IP` 五层模型

1. 应用层 : `DNS`、`HTTP`、`HTTPS`、`RPC`、`P2P` (`DHCP`、`RTMP`、`GTP`)
    > `OSI` 七层模型中，将应用层细分为(应用层、表示层、会话层)
    * 表示层 : 
    * 会话层 : 
2. 传输层 : `TCP`、`UDP`、`QUIC`
3. 网络层 : (IP 层) `IP` (`ICMP`、`OSPF`、`BGP`、`IPSec`、`GRE`)
4. 链路层 : (MAC 层) `ARP`、`VLAN`、`STP`
5. 物理层 : 网络跳线

### `TCP` vs `UDP`
  
> `TCP` 特点
  
  * 可靠性 : 通过确认应答、超时重传等机制保证数据的可靠传输。
  * 有序性 : 通过数据序号来保证数据有序，传输完成后通过排序来保证数据的正确性。
  * 双全工 : 通信双方(服务端和客户端)都具备发送和接受数据的能力。(三次握手来保证)
  
> `UDP` 特点

  * 不可靠 : 通信通信双方不需要建立连接，不能保证数据准确送达。
  * 无序性 : 每次发送的数据包相互独立，没有特定的顺序。
  * 速度快 : 由于数据包结构简单，保证的 `UDP` 传输速度优于 `TCP`
  
  一些游戏、直播和需要低延迟实时性要求较高的应用，会使用 `UDP`。
  
> `TCP` 的 `keepalive` 机制

  `keepalive` 顾名思义是否还活着，是一种心跳检测机制。用于判断连接方是否还处于活动状态，以便断开已经失活连接释放资源。发送探测包后，如果处于活动状态，接收方会发送确认信号；如果处于失活状态，则会再连续再发送几次探测包如果均无响应则证明对方已断开连接，可以释放资源。
  
  需要注意的一点是，这个 `keepalive` 机制的时长一般默认为 2 小时。所以，不能使用使用该机制来确认实时性较高的保活探测。

### 解释下 `TCP` 的慢启动特性?

### 如果手机应用与服务器通过 `TCP` 连接，这个时候手机切换为飞行模式，服务器可以短时间内知道到手机离线状态吗？

::: details 💡

  服务器通过 `TCP` 短时间内是不能知晓手机的离线状态的。因为 `TCP` 主要是为了保证数据的可靠传输，通信双方是通过数据交换来了解对方状态。而 `TCP` 并没有设计心跳检测机制，所有就没有实时检测对方是否离线的能力。
  
:::

## `HTTP`

### 三次握手可以携带数据吗？

### `HTTP` vs `HTTPS`

  `HTTP`: 是基于 `TCP/IP` 通信协议的一种数据传输协议。
  `HTTPS` : `= HTTP + SSL`，在 `HTTP` 协议的基础加上了加密处理。

### ❓`HTTP` 中 `GET`、`POST` 区别

### `HTTP` 中的 `POST` 请求的 `body` 体使用 `form-urlencoded` 和 `multipart/form-data` 的区别？

### 如何用 `HTTP` 实现长连接？

### `HTTP2.0` 针对同一个域名的多个请求，会建立多少个 `TCP` 连接？

### ❓`HTTP` 各个版本的区别

::: details 💡

  * `HTTP` 1.0 : 最早期版本，每次请求都会重新创建 `TCP` 的连接的创建和释放，造成极大的资源消耗。属于“非持续性连接”。
  * `HTTP` 1.1 : 改善了 1.0 版本的问题，修正为“持续性连接”。一次 `TCP` 连接可以发送多个请求和回复。引入 `pipeline` (管道)机制，可以同时发送多个请求，但是响应会按照请求队列的先后顺序进行，被称为“队头阻塞”问题。
  * `HTTP` 2.0 : 优化了传输数据格式(1.x 文本 -> 二进制)，减少了解析复杂度和提升传输速度。通过多路复用机制，解决了 1.0 “队头阻塞” 的问题，一次连接可以同时进行多个请求和响应。头信息压缩处理，减少数据体积。添加了服务器推送功能。
  * `HTTP` 3.0 : 开发中... `TCP` -> `QUIC`

:::

## 其它知识点

### 打开浏览器，输入网址到看到网站首页都经历那些过程？

### ❓`Cookie` vs `Session`

### ❓`Socket`

### 网络模型了解么？有哪几种？说说你的看法？


### 使用 `ssh` 连接云服务器，整个网络通信过程？

### `Charles` 抓包软件的原理

::: details 💡

  可以将它理解成中间人攻击。客户端将 `Charles` 作为代理服务器(中间人)。客户端所有请求都会先发送给 `Charles`，`Charles` 再将客户端的请求转发给服务器。`Charles` 收到服务器响应之后，再将从服务器收到的回复内容转发给客户端。这样请求和响应数据都被 `Charles` 记录下来，再通过界面展示即可。
  
  对于 `HTTP` 相对来说比较简单，直接进行接收和转发即可。而 `HTTPS` 中涉及 `CA` 认证，所以客户端需要进行的操作信任 `Charles` 的证书，这样通过 `Charles` 发送给客户端的公钥就可以通过这个证书校验成功，从而完成通信。

:::

### 不使用 `Charles`，`4G` 网络如何抓包？


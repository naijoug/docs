---
title: 0000 ~ 0099
icon: hashtag

index: true

---

<!-- more -->

## 0000

// #region 0000

- [🟢🟠🔴 - ]()

::: details 💡

:::

// #endregion 0000

## 0001 ✅

// #region 0001

- [🟢 1 - 两数之和](https://leetcode.cn/problems/two-sum)

::: details 💡

【思路1】暴力法，两次遍历，外层循环固定其中一个值，内层循环遍历元素进行求和比较

【思路2】哈希表，遍历元素 num 时，将 target - num 作为键，值为索引，存入哈希表；继续遍历下一个元素，判断哈希表中是否存在与该元素键相等的数据存在，如果存在则返回结果

【思路3】双指针，这种方案需要先排序，然后首尾指针进行大小调整与 target 值进行比对，不过最后还需要通过结果值去原数组中找到目标索引。这种方法比较适用于直接求解目标值。

::: code-tabs

@tab swift 解法1
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        for i in 0..<nums.count {
            for j in i+1..<nums.count {
                if (nums[i] + nums[j] == target) {
                    return [i, j]
                }
            }
        }
        return []
    }
}
```

@tab swift 解法2
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        let nums = nums
        var map = [Int: Int]()
        for i in 0..<nums.count {
            let num = nums[i]
            guard let index = map[num] else {
                map[target - num] = i
                continue
            } 
            return [index, i]
        }
        return []
    }
}
```

@tab java 解法2
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap();
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[] { map.get(num), i };
            } else {
                map.put(target - num, i);
            }
        }
        return new int[] {};
    }
}
```

@tab swift 解法3
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        // 先对数组进行排序
        let sortedNums = nums.sorted()
        var left = 0
        var right = sortedNums.count - 1
        // 双指针定位前后值
        while left < right {
            let sum = sortedNums[left] + sortedNums[right]
            if sum == target {
                break
            } else if sum < target {
                // 和小于目标值，调整左边范围
                left += 1
            } else { // sum > target
                // 和大于目标值，调整右边范围
                right -= 1
            }
        }
        // 获取值索引
        var leftIndex: Int?
        var rightIndex: Int?
        for i in 0..<nums.count {
            if leftIndex == nil, sortedNums[left] == nums[i] {
                leftIndex = i
            } else if sortedNums[right] == nums[i] {
                rightIndex = i
            }
            guard let leftIndex = leftIndex, let rightIndex = rightIndex else {
                continue
            }
            return [leftIndex, rightIndex]
        }

        return [left, right]
    }
}
```

:::

// #endregion 0001

## 0002

// #region 0002

- [🟠 2 - 两数相加](https://leetcode.cn/problems/add-two-numbers)

::: details 💡

:::

// #endregion 0002

## 0003

// #region 0003

- [🟠 3 - 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)

::: details 💡

:::

// #endregion 0003

## 0004

// #region 0004

- [🔴 4 - 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays)
    > 给定两个正序数组，返回这两个正序数组的中位数。

::: details 💡

【思路1】暴力法，将两个数组合并，当合并到两个数组的一半时，就是中位数。

:::

// #endregion 0004

## 0005

// #region 0005

- [🟠 5 - 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
    > 给定一个字符串，返回该字符串中最长的回文串。

::: details 💡

【思路】需要查找最长的回文串，如果已一个字符为中心去查找最长的回文串，使用双指针朝两个方向去判断，存在两种情况。

  - 以该索引为中心的奇数回文串，则从该索引左右索引开始去匹配。
  - 以该索引为中心的偶数回文串，则将该索引作为左边索引，下一个索引为右边索引开启去进行匹配。

  匹配到该索引下的最长回文串，然后比较保留住最长的回文串。
  
  > 可以进一步优化，判断一下剩余索引是否少于当前保留的最长回文串的一半，几不需要继续判断了。

::: code-tabs

@tab java
```java
class Solution {
    public String longestPalindrome(String s) {
        String result = "";
        for (int i = 0; i < s.length(); i++) {
            String str = longestPalindrome(s, i);
            if ( str.length() > result.length() ) {
                result = str;
            }
            // 如果剩余索引长度不足保留的最长回文串长度的一半，不需要再做判断
            if ( result.length() > (s.length() - i - 1) * 2 ) {
                break;
            }
        }
        return result;
    }

    /// 指定索引为中心的最长回文串
    String longestPalindrome(String s, int i) {
        // 以 i 为中心的奇数回文串
        int left = i - 1;
        int right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str1 = s.substring(left + 1, right);
        // 以 i 为中心的偶数回文串
        left = i;
        right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str2 = s.substring(left + 1, right);
        return str1.length() > str2.length() ? str1 : str2;
    }
}
```

:::

// #endregion 0005

## 0006

// #region 0006

- [🟠 6 - N 字形变换](https://leetcode.cn/problems/zigzag-conversion)

::: details 💡

:::

// #endregion 0006

## 0007

// #region 0007

- [🟠 7 - 整数反转](https://leetcode.cn/problems/reverse-integer)

::: details 💡

:::

// #endregion 0007

## 0008

// #region 0008

- [🟠 8 - 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi)

::: details 💡

:::

// #endregion 0008

## 0009

// #region 0009

- [🟢 9 - 回文数](https://leetcode.cn/problems/palindrome-number)

::: details 💡

:::

// #endregion 0009

## 0010

// #region 0010

- [🔴 10 - 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)

::: details 💡

:::

// #endregion 0010

## 0011

// #region 0011

- [🟠 11 - 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water)

::: details 💡

:::

// #endregion 0011

## 0012

// #region 0012

- [🟠 12 - 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman)

::: details 💡

:::

// #endregion 0012

## 0013

// #region 0013

- [🟢 13 - 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer)

::: details 💡

:::

// #endregion 0013

## 0014

// #region 0014

- [🟢 14 - 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix)

::: details 💡

:::

// #endregion 0014

## 0015

// #region 0015

- [🟠 15 - 三数之和](https://leetcode.cn/problems/3sum)

::: details 💡

:::

// #endregion 0015

## 0016

// #region 0016

- [🟠 16 - 最接近的三数之和](https://leetcode.cn/problems/3sum-closest)

::: details 💡

:::

// #endregion 0016

## 0017

// #region 0017

- [🟠 17 - 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)

::: details 💡

:::

// #endregion 0017

## 0018

// #region 0018

- [🟠 18 - 四数之和](https://leetcode.cn/problems/4sum)

::: details 💡

:::

// #endregion 0018

## 0019 ✅

// #region 0019

- [🟢 19 - 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
    > 删除单链表的倒数第 N 个节点，并返回头结点。

::: details 💡

【思路1】遍历一次链表得到链表长度 len，第二次就能遍历到 len - n 的节点，进行删除操作即可。

【思路2】栈，先将所有链表节点入栈，出栈时进行计数，当到第 n 个元素时进行删除处理。

【思路3】快慢指针，快指针先走 n 步之后，快慢指针开始同时向前走，当快指针走到链表尾部，这慢指针刚好指向要删除的节点。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚头节点，解决删除后链表为空的特殊情况，减少判断逻辑
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode p = dummy;
        ListNode target = dummy;
        // p 指针先走 n 步
        for (int i = 0; i < n; i++) {
            p = p.next;
        }
        // p 指针和目标指针开始同时走
        while (p.next != null) {
            p = p.next;
            target = target.next;
        }
        // 删除目标节点后面节点
        target.next = target.next.next;
        return dummy.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {
        let dummy = ListNode(0, head)
        var p1: ListNode? = head
        var p2: ListNode? = dummy
        var count = 0
        while p1?.next != nil {
            p1 = p1?.next
            count += 1
            guard count >= n else { continue }
            p2 = p2?.next
        }
        p2?.next = p2?.next?.next
        return dummy.next
    }
}
```

:::

// #endregion 0019

## 0020

// #region 0020

- [🟢 20 - 有效的括号](https://leetcode.cn/problems/valid-parentheses)

::: details 💡

:::

// #endregion 0020

## 0021 ✅

// #region 0021

- [🟢 21 - 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)
    > 合并两个有序的链表。

::: details 💡

【思路】创建一个结果链表头，并用一个指针指向这个结果链表用于指向添加位置。然后分别使用两个指针指向两个链表，每次比较比较链表中的值，将较小的链表中的节点添加到结果链表中。直到其中一个链表中已为空，最后将剩下不为空的链表全部添加到结果链表中。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 头结点：指向结果链表头部
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = list1;
        ListNode p2 = list2;
        while ( p1 != null && p2 != null ) {
            // 比较两个链表中值小的添加到结果链表中
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        // 将不为空的链表添加到结果链表尾部
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        guard let l1 = l1, let l2 = l2 else {
            return l1 ?? l2
        }
        let head = ListNode(0)
        var p: ListNode? = head
        var op1: ListNode? = l1
        var op2: ListNode? = l2
        // 遍历两个链表，并将较小值节点添加到结果链表
        while let p1 = op1, let p2 = op2 {
            if p1.val <= p2.val {
                p?.next = p1
                op1 = op1?.next
            } else {
                p?.next = p2
                op2 = op2?.next
            }
            p = p?.next
        }
        // 将不为空的链表添加到结果链表后面
        p?.next = op1 ?? op2
        return head.next
    }
}
```

:::

// #endregion 0021

## 0022 

// #region 0022

- [🟠 22 - 括号生成](https://leetcode.cn/problems/generate-parentheses)

::: details 💡

:::

// #endregion 0022

## 0023 ✅

// #region 0023

- [🔴 23 - 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)
    > 给定一个升序链表数组，合并得到一个升序链表，并返回头结点。

::: details 💡

【思路1】合并两个升序链表比较容易解决。合并多个链表，可以先两个两个合并，最后就合并成一个了。

【思路2】分治思想，类似归并排序，两两合并，最后合并成为结果链表。

【思路3】优先级队列，每次将 K 个链表的头结点放入优先级队列中，那么可以每次从优先级队列中取出最小值节点放入结果链表，然后再将该节点的下一个节点放入优先级队列，直到合并完成。

::: code-tabs

@tab 解法1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if ( lists.length == 0 ) { return null; }
        if ( lists.length == 1 ) { return lists[0]; }
        // 遍历链表数组，每次取出一个链表，进行两条链表合并
        ListNode l1 = lists[0];
        for ( int i = 1; i < lists.length; i++ ) {
            ListNode l2 = lists[i];
            l1 = mergeTwoLists(l1, l2);
        }
        return l1;
    }

    // 合并两个升序链表
    ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = l1;
        ListNode p2 = l2;
        while ( p1 != null && p2 != null ) {
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

:::

// #endregion 0023

## 0024

// #region 0024

- [🟠 24 - 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs)

::: details 💡

:::

// #endregion 0024

## 0025

// #region 0025

- [🔴 - K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group)

::: details 💡

:::

// #endregion 0025

## 0026 ✅

// #region 0026

- [🟢 26 - 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)
    > 给定一个有序数组，删除数组中的重复项，并返回数组新长度。

        🌰
            输入：nums = [1,1,2]
            输出：2, nums = [1,2]
        🌰
            输入：nums = [0,0,1,1,1,2,2,3,3,4]
            输出：5, nums = [0,1,2,3,4]

::: details 💡

【思路1】遍历数组，使用一个额外数组保存不重复的元素，使用了额外空间，空间复杂度 O(n)。

【思路2】双指针法，一个遍历索引指针遍历数组，另一个结果索引指针指向未重复的元素。遍历时，如果两个索引位置值相等，则仅移动遍历索引；如果值不等，则往前移动位置索引，将遍历索引指向的元素赋值给结果索引位置，之后再移动遍历索引。遍历结束，结果索引 + 1 就是数组的新长度。

::: code-tabs

@tab java
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        var i = 0; // 遍历索引
        var j = 0; // 结果索引
        while ( i < nums.length ) {
            if ( nums[i] != nums[j] ) {
                // 遍历值不等于结果值，结果索引往前移动，将遍历值赋值给结果索引位置
                j += 1;
                nums[j] = nums[i];
            } 
            // 遍历索引往前移动
            i += 1;
        }
        return j + 1;
    }
}
```

@tab swift
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        var slow = 0 
        var fast = 0
        while ( fast < nums.count ) {
            if ( nums[fast] != nums[slow] ) {
                slow += 1
                nums[slow] = nums[fast] 
            }
            fast += 1
        }
        return slow + 1
    }
}
```

:::

// #endregion 0026

## 0027 ✅

// #region 0027

- [🟢 27 - 移除元素](https://leetcode.cn/problems/remove-element)
    > 给定一个数组和目标值，需要将数组中的与目标值相等的元素移除，返回数组新长度。

        示例：
            输入：nums = [0,1,2,2,3,0,4,2], val = 2
            输出：5, nums = [0,1,3,0,4]

::: details 💡

【思路】双指针法，遍历时将如果值不等于目标值，则将慢指针往前移动，将快指针值复制到慢指针对应索引位置。

::: code-tabs

@tab java
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( nums[fast] != val ) {
                // 遍历值不等于目标值，慢指针往前移动，将快指针位置值移动到慢指针位置
                slow += 1;
                nums[slow] = nums[fast];
            } 
            fast += 1;
        }
        return slow + 1;
    }
}
```

@tab swift
```swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        var count = -1
        for i in 0..<nums.count {
            if nums[i] != val {
                count += 1
                if count != i { // 优化，减少不必要的赋值
                    nums[count] = nums[i]
                }
            }
        }
        return count + 1
    }
}
```

:::

// #endregion 0027

## 0028

// #region 0028

- [🟢 28 - 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)

::: details 💡

:::

// #endregion 0028

## 0029

// #region 0029

- [🟠 29 - 两数相除](https://leetcode.cn/problems/divide-two-integers)

::: details 💡

:::

// #endregion 0029

## 0030

// #region 0030

- [🔴 30 - 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)

::: details 💡

:::

// #endregion 0030

## 0031

// #region 0031

- [🟠 31 - 下一个排列](https://leetcode.cn/problems/next-permutation)

::: details 💡

:::

// #endregion 0031

## 0032

// #region 0032

- [🔴 32 - 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses)

::: details 💡

:::

// #endregion 0032

## 0033

// #region 0033

- [🟠 33 - 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array)

::: details 💡

:::

// #endregion 0033

## 0034

// #region 0034

- [🟢 34 - 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)
    > 给定一个非递减数组和一个目标值，查找该目标值在数组中的开始位置和结束位置，如果存在则返回 [start, end]，如果不存在返回 [-1, -1]。
    
::: details 💡

:::

// #endregion 0034

## 0035

// #region 0035

- [🟢 35 - 搜索插入位置](https://leetcode.cn/problems/search-insert-position)
    > 给定一个升序数组和一个目标值，如果目标值在数组中存在返回目标值索引，如果不存在返回插入位置索引。
    
::: details 💡

:::

// #endregion 0035

## 0036

// #region 0036

- [🟠 36 - 有效的数独](https://leetcode.cn/problems/valid-sudoku)

::: details 💡

:::

// #endregion 0036

## 0037

// #region 0037

- [🔴 37 - 解数独](https://leetcode.cn/problems/sudoku-solver)

::: details 💡

:::

// #endregion 0037

## 0038

// #region 0038

- [🟠 38 - 外观数列](https://leetcode.cn/problems/count-and-say)

::: details 💡

:::

// #endregion 0038

## 0039

// #region 0039

- [🟠 39 - 组合总和](https://leetcode.cn/problems/combination-sum)
    
::: details 💡

:::

// #endregion 0039

## 0040

// #region 0040

- [🟠 40 - 组合总和 II](https://leetcode.cn/problems/combination-sum-ii)
    
::: details 💡

:::

// #endregion 0040

## 0041

// #region 0041

- [🔴 41 - 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive)

::: details 💡

:::

// #endregion 0041

## 0042

// #region 0042

- [🔴 42 - 接雨水](https://leetcode.cn/problems/trapping-rain-water)

::: details 💡

:::

// #endregion 0042

## 0043

// #region 0043

- [🟠 43 - 字符串相乘](https://leetcode.cn/problems/multiply-strings)

::: details 💡

:::

// #endregion 0043

## 0044

// #region 0044

- [🔴 44 - 通配符匹配](https://leetcode.cn/problems/wildcard-matching)

::: details 💡

:::

// #endregion 0044

## 0045

// #region 0045

- [🟠 45 - 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii)

::: details 💡

:::

// #endregion 0045

## 0046 ✅

// #region 0046

- [🟠 46 - 全排列](https://leetcode.cn/problems/permutations)
  > 给定一个没有重复数字的数组，返回其所有可能的全排列。

        🌰
            输入：nums = [1,2,3]
            输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    int[] nums;
    List<Integer> list = new LinkedList(); // 一个排列列表
    List<List<Integer>> result = new LinkedList(); // 全排列结果

    public List<List<Integer>> permute(int[] nums) {
        this.nums = nums;
        boolean[] used = new boolean[nums.length];
        backtrack(used);
        return result;
    }
    
    void backtrack(boolean[] used) {
        if (list.size() == nums.length) {
            // 已经是一个排列，加入结果列表
            result.add(new LinkedList(list));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if (used[i]) continue; // 已经使用过的数字，跳过
            // 未使用的数字，加入排列列表
            list.add(nums[i]);
            used[i] = true;
            // 继续选中下一个数字
            backtrack(used);
            // 选择完，从排列列表中移除
            list.removeLast();
            used[i] = false;
        }
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[Int]]()
    func permute(_ nums: [Int]) -> [[Int]] {
        backtrack(nums, track: [], used: [:])
        return res
    }
    private func backtrack(_ nums: [Int], track: [Int], used: [Int: Bool]) {
        guard track.count != nums.count else {
            res.append(track)
            return
        }
        var track = track
        var used = used
        for num in nums {
            guard !(used[num] ?? false) else { continue }
            used[num] = true
            track.append(num)
            backtrack(nums, track: track, used: used)
            track.removeLast()
            used[num] = false
        }
    } 
}
```

:::

// #endregion 0046

## 0047

// #region 0047

- [🟠 47 - 全排列 II](https://leetcode.cn/problems/permutations-ii)
  > 给定一个包含重复数字的数组，返回所有不重复的全排列。

::: details 💡

:::

// #endregion 0047

## 0048

// #region 0048

- [🟠 48 - 旋转图像](https://leetcode.cn/problems/rotate-image)

::: details 💡

:::

// #endregion 0048

## 0049

// #region 0049

- [🟠 49 - 字母异位词分组](https://leetcode.cn/problems/group-anagrams)

::: details 💡

:::

// #endregion 0049

## 0050

// #region 0050

- [🟠 50 - Pow(x, n)](https://leetcode.cn/problems/powx-n)

::: details 💡

:::

// #endregion 0050

## 0051

// #region 0051

- [🔴 51 - N 皇后](https://leetcode.cn/problems/n-queens)
    > 将 n 个皇后棋子，放置在 nxn 的棋盘中。'Q'代表皇后，'.'代表空位，返回所有的不同的解决方案。
    > 国际象棋的规则 : 皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
    
        🌰
            输入：n = 4
            输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
            输入：n = 1
            输出：[["Q"]]
    
::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<String>> result = new LinkedList(); // 所有结果列表
    char[][] chessboard; // 记录棋盘棋子

    public List<List<String>> solveNQueens(int n) {
        // 创建棋盘，初始化都为空 '.'
        chessboard = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                chessboard[i][j] = '.';
            }
        }
        // 进行回溯求解
        backtrack(n, 0);
        return result;
    }

    void backtrack(int n, int row) {
        if (row == n) {
            // 棋盘已下完
            List<String> list = new LinkedList();
            for (int i = 0; i < n; i++) {
                list.add(new String(chessboard[i]));
            } 
            result.add(list);
            return;
        }
        // 遍历这行每一列
        for (int i = 0; i < n; i++) {
            if (!isValid(n, row, i)) continue; // 无效位置，跳过
            // 加入棋盘
            chessboard[row][i] = 'Q';
            // 进行下一行求解
            backtrack(n, row + 1);
            // 从棋盘中移除
            chessboard[row][i] = '.';
        }
    }
    
    /// 根据行列坐标判断该位置是否合法
    boolean isValid(int n, int row, int column) {
        // 判断行 - 是否存在 Q (row 行还未下，不需要判断)
        // 判断列 | 是否存在 Q (row 行以下还没下，只需要判断 row 以上行)
        for (int i = 0; i < row; i++) {
            if (chessboard[i][column] == 'Q')
                return false;
        }
        // 判断左斜方向 / 是否存在 Q (只需要判断 row 以上)
        int i = row - 1;
        int j = column + 1;
        while (i >= 0 && j < n) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j += 1;
        }
        // 判断右斜方向 \ 是否存在 Q (只需要判断 row 以上)
        i = row - 1;
        j = column - 1;
        while (i >= 0 && j >= 0) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j -= 1;
        }
        return true;
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[String]]()
    func solveNQueens(_ n: Int) -> [[String]] {
        var board = [[Character]].init(repeating: [Character].init(repeating: Character("."), count: n), count: n)
        backtrack(&board, row: 0)
        return res
    }
    
    private func backtrack(_ board: inout [[Character]], row: Int) {
        guard row < board.count else {
            res.append(board.map({ String($0) }))
            return
        }
        for col in 0..<board[row].count {
            guard isValid(board, row: row, col: col) else { continue }
            board[row][col] = Character("Q")
            backtrack(&board, row: row + 1)
            board[row][col] = Character(".")
        }
    }
    private func isValid(_ board: [[Character]], row: Int, col: Int) -> Bool {
        func chess(row: Int, col: Int) -> Character? {
            guard 0 <= row, row < board.count, 
                  0 <= col, col < board[row].count else { return nil }
            return board[row][col]
        }
        func isQ(row: Int, col: Int) -> Bool {
            guard let chess = chess(row: row, col: col) else { return false }
            return String(chess) == "Q"
        }
        // -
        for i in 0..<col {
            guard isQ(row: row, col: i) else { continue }
            return false
        }
        // |
        for i in 0..<row {
            guard isQ(row: i, col: col) else { continue }
            return false
        }
        // \
        var i = row
        var j = col
        while i >= 0, j >= 0 {
            i -= 1
            j -= 1
            guard isQ(row: i, col: j) else { continue }
            return false
        }
        // /
        var m = row
        var n = col
        while m >= 0, n < board.count {
            m -= 1
            n += 1
            guard isQ(row: m, col: n) else { continue }
            return false
        }

        return true
    }
}
```

:::

// #endregion 0051

## 0052

// #region 0052

- [🔴 52 - N 皇后 II](https://leetcode.cn/problems/n-queens-ii)
    > 返回 N 皇后问题的解决方案数量
    
::: details 💡

:::

// #endregion 0052

## 0053

// #region 0053

- [🟠 53 - 最大子数组和](https://leetcode.cn/problems/maximum-subarray)

::: details 💡

:::

// #endregion 0053

## 0054

// #region 0054

- [🟠 54 - 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix)

::: details 💡

:::

// #endregion 0054

## 0055

// #region 0055

- [🟠 55 - 跳跃游戏](https://leetcode.cn/problems/jump-game)

::: details 💡

:::

// #endregion 0055

## 0056

// #region 0056

- [🟠 56 - 合并区间](https://leetcode.cn/problems/merge-intervals)

::: details 💡

:::

// #endregion 0056

## 0057

// #region 0057

- [🟠 57 - 插入区间](https://leetcode.cn/problems/insert-interval)

::: details 💡

:::

// #endregion 0057

## 0058

// #region 0058

- [🟢 58 - 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word)

::: details 💡

:::

// #endregion 0058

## 0059

// #region 0059

- [🟠 59 - 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii)

::: details 💡

:::

// #endregion 0059

## 0060

// #region 0060

- [🔴 60 - 排列序列](https://leetcode.cn/problems/permutation-sequence)

::: details 💡

:::

// #endregion 0060

## 0061

// #region 0061

- [🟠 61 - 旋转链表](https://leetcode.cn/problems/rotate-list)

::: details 💡

:::

// #endregion 0061

## 0062

// #region 0062

- [🟠 62 - 不同路径](https://leetcode.cn/problems/unique-paths)

::: details 💡

:::

// #endregion 0062


## 0063

// #region 0063

- [🟠 63 - 不同路径 II](https://leetcode.cn/problems/unique-paths-ii)

::: details 💡

:::

// #endregion 0063

## 0064

// #region 0064

- [🟠 64 - 最小路径和](https://leetcode.cn/problems/minimum-path-sum)

::: details 💡

:::

// #endregion 0064

## 0065

// #region 0065

- [🔴 65 - 有效数字](https://leetcode.cn/problems/valid-number)

::: details 💡

:::

// #endregion 0065

## 0066

// #region 0066

- [🟢 66 - 加一](https://leetcode.cn/problems/plus-one)

::: details 💡

:::

// #endregion 0066

## 0067

// #region 0067

- [🟢 67 - 二进制求和](https://leetcode.cn/problems/add-binary)

::: details 💡

:::

// #endregion 0067

## 0068

// #region 0068

- [🔴 68 - 文本左右对齐](https://leetcode.cn/problems/text-justification)

::: details 💡

:::

// #endregion 0068

## 0069

// #region 0069

- [🟢 69 - x 的平方根](https://leetcode.cn/problems/sqrtx)

::: details 💡

:::

// #endregion 0069

## 0070 ✅

// #region 0070 

- [🟢 70 - 爬楼梯](https://leetcode.cn/problems/climbing-stairs)

::: details 💡

::: code-tabs

【思路1】动态规划，自顶向下，递归解法

【思路2】动态规划，自底向上，迭代解法

@tab java 解法1
```java
class Solution {
    Map<Integer, Integer> dp = new HashMap();
    public int climbStairs(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (dp.containsKey(n)) return dp.get(n);
        // 到达第 n 阶台阶方法 = 到达 n-1 阶台阶方法数(再爬1阶) + 到达 n-2 阶台阶方法数(再爬2阶)
        int fn = climbStairs(n - 1) + climbStairs(n - 2);
        dp.put(n, fn);
        return fn;
    }
}
```

@tab java 解法2
```java
class Solution {
    public int climbStairs(int n) {
        if (n < 3) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

:::

// #endregion 0070

## 0071

// #region 0071

- [🟠 71 - 简化路径](https://leetcode.cn/problems/simplify-path)

::: details 💡

:::

// #endregion 0071

## 0072

// #region 0072

- [🔴 72 - 编辑距离](https://leetcode.cn/problems/edit-distance)

::: details 💡

:::

// #endregion 0072

## 0073

// #region 0073

- [🟠 73 - 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes)

::: details 💡

:::

// #endregion 0073

## 0074

// #region 0074

- [🟠 74 - 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix)

::: details 💡

:::

// #endregion 0074

## 0075 ✅

// #region 0075

- [🟠 75 - 颜色分类](https://leetcode.cn/problems/sort-colors)
    > 给定一个包含红色、白色和蓝色的是数组，使用整数 0、 1 和 2 分别表示红色、白色和蓝色，按照红色、白色、蓝色顺序排列。
    
        🌰
            输入：nums = [2,0,2,1,1,0]
            输出：[0,0,1,1,2,2]

::: details 💡

> 荷兰国旗问题

【思路】统计法，先统计各种颜色的个数，再按照颜色个数给数组重新赋值。

::: code-tabs

@tab java
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        int white = 0;
        int blue = 0;
        /// 统计三种颜色个数
        for (int i = 0; i < nums.length; i++) {
            if ( nums[i] == 0 ) {
                red += 1;
            } else if ( nums[i] == 1 ) {
                white += 1;
            } else if ( nums[i] == 2 ) {
                blue += 1;
            }
        }
        // 按照个数重新给数组赋值
        for ( int i = 0; i < red; i++ ) {
            nums[i] = 0;
        }
        for ( int i = red; i < red + white; i++ ) {
            nums[i] = 1;
        }
        for ( int i = red + white; i < nums.length; i++ ) {
            nums[i] = 2;
        }
    }
}
```

:::

> 进阶：仅使用常数空间的一趟扫描算法吗？

::: details 💡

【思路1】双指针法，数组头指针用于指向 0，尾指针用于指向 2。一次遍历数组，如果值为 0 与头指针位置交换，如果值为 2 与尾指针位置交换。

【思路2】刷油漆法，其实这个方法类似统计法，将其优化为了一次遍历。遍历数组，先保留该值。

  - 先将该位置刷为 2。
  - 如果值 <2，将 1 索引下刷为 1，刷 1 的索引增加。(为什么不是 == 1？当值为 0 时，相等于将刷 1 的范围往后移动了一位，因为后面 <1 的判断，刷 0 的长度会加 1)
  - 如果值 <1，将 0 索引下刷为 0，刷 0 的索引需要增加。

::: code-tabs

@tab java 解法1
```java
class Solution {
    public void sortColors(int[] nums) {
        if ( nums.length <= 1 ) return;
        int head = 0;
        int tail = nums.length - 1;
        for ( int i = 0; i < nums.length; i++ ) {
            if ( nums[i] == 0 ) {
                // 如果索引位置值为 0，则先进行头部交换并将头部指针往前移动
                swap(nums, head, i);
                head += 1;
                // 交换之后，再进行尾部交换
                if ( nums[i] == 2 ) {
                    swap(nums, i, tail);
                    tail -= 1;
                }
            } else if ( nums[i] == 2 ) {
                // 如果索引位置值为 2，则先进行尾部交换并将尾部指针往后移动
                swap(nums, i, tail);
                tail -= 1;
                // 交换之后，再进行头部交换
                if ( nums[i] == 0 ) {
                    swap(nums, head, i);
                    head += 1;
                }
            }
            // 遍历索引已经尾部索引相遇，不需要再进行处理
            if ( i >= tail ) break;
        }
    }
    void swap(int[] nums, int i, int j) {
        if ( i == j ) return;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

@tab java 解法2
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0; // 刷红色的长度
        int white = 0;  // 刷白色的长度
        for ( int i = 0; i < nums.length; i++ ) {
            int num = nums[i]; 
            nums[i] = 2; // 先将全部刷为 blue = 2
            // 如果值为 0 或 1，则白色索引下刷为 white = 1，白色长度增加
            if ( num < 2 ) { 
                nums[white] = 1;
                white += 1;
            }
            // 如果值为 0，则红色索引下刷为 red = 0，红色长度增加
            if ( num < 1 ) {
                nums[red] = 0;
                red += 1;
            }
        }
    }
}
```

:::

// #endregion 0075

## 0076

// #region 0076

- [🔴 76 - 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)

::: details 💡

:::

// #endregion 0076

## 0077

// #region 0077

- [🟠 77 - 组合](https://leetcode.cn/problems/combinations)
    
::: details 💡

:::

// #endregion 0077

## 0078

// #region 0078

- [🟠 78 - 子集](https://leetcode.cn/problems/subsets)
    
::: details 💡

:::

// #endregion 0078

## 0079

// #region 0079

- [🟠 79 - 单词搜索](https://leetcode.cn/problems/word-search)

::: details 💡

:::

// #endregion 0079

## 0080 ✅

// #region 0080

- [🟠 80 - 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii)
    > 给定一个有序数组，删除数组中重复元素(保留两个)。
    
        🌰
            输入：nums = [1,1,1,2,2,3]
            输出：5, nums = [1,1,2,2,3]

::: details 💡

【思路1】双指针法，核心点在于如何将重复元素保留两个。快指针索引为遍历指针，

  - 当遍历值与下一个值是否相等，不相等时，需要移动慢指针，将快指针值赋值到慢指针为止
  - 相等时，先将快指针位置赋值到慢指针位置；跳过中间重复元素；然后将最后一个重复元素也赋值到慢指针位置。

【思路2】也是双指针，但是不是添加第一个和最后一个重复元素，而是保证间隔为 2 的元素不相等即可。

  - 判断数组长度是否大于 2，小于 2 不需要处理。
  - 大于 2 时，判断快指针索引位置元素，与慢指针索引 - 2 的位置元素是否相等。
    * 如果相等，则跳过该元素
    * 如果不相等，则将快指针元素赋值给慢指针位置，移动慢指针。

::: code-tabs

@tab java
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                // 是重复元素
                //  1> 添加第一个重复元素
                slow += 1;
                nums[slow] = nums[fast];
                //  2> 跳过中间的重复元素
                while ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                    fast += 1;
                }
                //  3> 添加最后一个重复元素
                slow += 1;
                nums[slow] = nums[fast];
                //  4> 跳过最后一个重复元素
                fast += 1;
            } else {
                // 不是重复元素，移动慢指针，将快指针元素赋值到慢指针索引位置
                slow += 1;
                nums[slow] = nums[fast];
                fast += 1;
            }
        }
        return slow + 1;
    }
}
```

@tab swift
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        let count = nums.count
        // 输出大于 2 时才需要处理
        guard count > 2 else { return count }
        var slow = 2
        var fast = 2
        while ( fast < count ) {
            
            if ( nums[slow - 2] != nums[fast] ) {
                nums[slow] = nums[fast] 
                slow += 1
            }
            fast += 1
        }
        return slow
    }
}
```

:::

// #endregion 0080

## 0081

// #region 0081

- [🟠 81 - 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii)

::: details 💡

:::

// #endregion 0081

## 0082 ✅

// #region 0082

- [🟠 82 - 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)
    > 给定一个已排序的链表，删除链表中的重复元素(重复元素全部删除)。

        🌰
            输入：1 -> 1 -> 1 -> 2 -> 3
            输出：2 -> 3

::: details 💡

【思路】双指针法，创建已伪头结点，用于解决链表为空或全部为重复元素的情况；然后慢指针指向伪头结点，快指针从头结点开始遍历。

  - 如果快指针节点与后面节点值相等，则跳过全部重复节点。特殊情况处理，跳过之后如果链表已经结束，则需要将慢指针指向 null。
  - 如果快指针节点与后面节点不相等，则表明不是重复节点。则将慢指针的后继节点指向快指针节点，然后将快慢指针都往前移动一步。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy.next;
        while ( fast != null ) {
            // 快指针去探测不重复的节点
            if ( fast.next != null && fast.val == fast.next.val ) {
                // 探测到重复节点，跳过重复元素
                while ( fast.next != null && fast.val == fast.next.val ) {
                    fast = fast.next;
                }
                // 指向了最后一个重复节点，往前移动一步
                fast = fast.next;
                // 后面为空，则将慢指针指向 null
                if ( fast == null ) {
                    slow.next = null;
                }
            } else {
                // 探测到不重复节点，将慢指针指向节点，并往前移动
                slow.next = fast;
                slow = slow.next;
                fast = fast.next;
            }
        }
        return dummy.next;
    }
}
```

:::

// #endregion 0082

## 0083 ✅

// #region 0083

- [🟢 83 - 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)
  > 给定一个已排序的链表，删除链表中的重复元素(重复元素保留一个)。

        🌰
            输入：1 -> 1 -> 1 -> 2 -> 3
            输出：1 -> 2 -> 3

::: details 💡

【思路1】双指针法，取巧方案，类似排序数组中的删除重复元素方案，每次判断值不一样时，将慢指针往前移动，将快指针中的值赋值到慢指针位置。

【思路2】思路 1 虽然得到结果是正确，但是却改变了节点。 优化思路 1 方案，每次判断值不一样时，不进行赋值，直接将慢指针指向快指针节点。

::: code-tabs

@tab java 思路1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // 快指针值与慢指针指不一样时，将慢指针往前移动，
            if ( fast.val != slow.val ) {
                slow = slow.next;
                slow.val = fast.val;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

@tab java 思路2
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // 值不相等时，将慢指针指向快指针节点，并将慢指针往前移动
            if ( fast.val != slow.val ) {
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

:::

// #endregion 0083

## 0084

// #region 0084

- [🔴 84 - 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram)

::: details 💡

:::

// #endregion 0084

## 0085

// #region 0085

- [🔴 85 - 最大矩形](https://leetcode.cn/problems/maximal-rectangle)

::: details 💡

:::

// #endregion 0085

## 0086 ✅

// #region 0086

- [🟠 86 - 分隔链表](https://leetcode.cn/problems/partition-list)
  > 根据给定值将链表元素分割为小于和大于等于该值的两部分。并保持节点元素相对位置。

::: details 💡

【思路】将原链表按照值大小分隔成两条链表，最后合并成结果链表。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode l1 = new ListNode(); // 小于 x 链表
        ListNode l2 = new ListNode(); // 大于 x 链表
        ListNode p1 = l1;
        ListNode p2 = l2;
        // 遍历链表，按照大小将原链表分成两条链表，分解时需要注意分解节点与原链表的断开问题。
        ListNode p = head;
        while ( p != null ) {
            if ( p.val < x ) {
                p1.next = p;    // 将节点添加到小于 x 链表
                p = p.next;     // 链表指针前进
                p1 = p1.next;   // 小于 x 链表指针前进
                p1.next = null; // 并将小于 x 链表与原链表断开
            } else {
                p2.next = p;    
                p = p.next;
                p2 = p2.next;
                p2.next = null;
            }
        }
        // 合并成一条
        p1.next = l2.next;
        return l1.next; 
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {
        let minHead = ListNode(0)
        var min: ListNode? = minHead
        let maxHead = ListNode(0)
        var max: ListNode? = maxHead
        var node = head
        // 根据值大小创建了两条新链表，最后合并。这样不需要处理链表断开的问题。
        while node != nil {
            guard let n = node  else { break }
            if n.val < x {
                min?.next = ListNode(n.val)
                min = min?.next
            } else {
                max?.next = ListNode(n.val)
                max = max?.next
            }
            node = n.next
        }
        min?.next = maxHead.next
        return minHead.next
    }
}
```

:::

// #endregion 0086

## 0087

// #region 0087

- [🔴 87 - 扰乱字符串](https://leetcode.cn/problems/scramble-string)

::: details 💡

:::

// #endregion 0087

## 0088

// #region 0088

- [🟢 88 - 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array)

::: details 💡

:::

// #endregion 0088

## 0089

// #region 0089

- [🟠 89 - 格雷编码](https://leetcode.cn/problems/gray-code)

::: details 💡

:::

// #endregion 0089

## 0090

// #region 0090

- [🟠 90 - 子集 II](https://leetcode.cn/problems/subsets-ii)
    
::: details 💡

:::

// #endregion 0090

## 0091

// #region 0091

- [🟠 91 - 解码方法](https://leetcode.cn/problems/decode-ways)

::: details 💡

:::

// #endregion 0091

## 0092

// #region 0092

- [🟠 92 - 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)
  > 通过单链表的头结点 head 和两个整数 left 和 right (left <= right)，反转链表从 left 到 right 位置的链表节点，返回反转后的链表。

::: details 💡

  > 如果使用迭代，上面两个题应该怎么处理？

:::

// #endregion 0092

## 0093

// #region 0093

- [🟠 93 - 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses)

::: details 💡

:::

// #endregion 0093

## 0094 ✅

// #region 0094

- [🟢 94 - 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

::: details 💡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);
        return list;
    }

    void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        list.add(root.val); // 中序位置，添加值
        traversal(root.right);
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func inorderTraversal(_ root: TreeNode?) -> [Int] {
        guard let root = root else { return [] }
        var result = [Int]()
        result.append(contentsOf: inorderTraversal(root.left))
        result.append(root.val)
        result.append(contentsOf: inorderTraversal(root.right))
        return result
    }
}
```

:::

// #endregion 0094

## 0095

// #region 0095

- [🟠 95 - 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii)

::: details 💡

:::

// #endregion 0095

## 0096

// #region 0096

- [🟠 96 - 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees)

::: details 💡

:::

// #endregion 0096

## 0097

// #region 0097

- [🟠 97 - 交错字符串](https://leetcode.cn/problems/interleaving-string)

::: details 💡

:::

// #endregion 0097

## 0098

// #region 0098

- [🟠 98 - 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree)

::: details 💡

:::

// #endregion 0098

## 0099

// #region 0099

- [🟠 99 - 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree)

::: details 💡

:::

// #endregion 0099
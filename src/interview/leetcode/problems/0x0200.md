---
title: 0200 ~ 0299
icon: hashtag

index: true

---

<!-- more -->

## 0200

// #region 0200

- [🟠 200 - 岛屿数量](https://leetcode.cn/problems/number-of-islands)

::: details 💡

:::

// #endregion 0200

## 0203 ✅

// #region 0203

- [🟢 203 - 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements)

        示例：
            输入：head = [1,2,6,3,4,5,6], val = 6
            输出：[1,2,3,4,5]

::: details 💡

【思路】双指针法

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode fast = head;
        ListNode slow = dummy;
        while ( fast!= null ) {
            if ( fast.val != val ) {
                // 不等于目标值时，将慢节点后继节点指向快指针节点
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
            // 如果已经是最后节点，需要将 slow 后继节点设为 null
            if ( fast == null ) {
                slow.next = null;
            }
        }
        return dummy.next;
    }
}
```

:::

// #endregion 0203

## 0204

// #region 0204

- [🟠 204 - 计数质数](https://leetcode.cn/problems/count-primes)

::: details 💡

:::

// #endregion 0204

## 0206

// #region 0206

- [🟢 206 - 反转链表](https://leetcode.cn/problems/reverse-linked-list)
  > 通过单链表的头结点 head 进行反转链表，返回反转后的链表。
  
::: details 💡

【思路】

:::

// #endregion 0206

## 0207

// #region 0207

- [🟠 207 - 课程表](https://leetcode.cn/problems/course-schedule)

::: details 💡

:::

// #endregion 0207

## 0208

// #region 0208

- [🟠 208 - 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree)

::: details 💡

:::

// #endregion 0208


## 0210

// #region 0210

- [🟠 210 - 课程表 II](https://leetcode.cn/problems/course-schedule-ii)

::: details 💡

:::

// #endregion 0210

## 0211

// #region 0211

- [🟠 211 - 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure)

::: details 💡

:::

// #endregion 0211


## 0213

// #region 0213

- [🟠 213 - 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii)

::: details 💡

:::

// #endregion 0213

## 0214

// #region 0214

- [🔴 214 - 最短回文串](https://leetcode.cn/problems/shortest-palindrome)

::: details 💡

:::

// #endregion 0214

## 0215

// #region 0215

- [🟠 215 - 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array)

::: details 💡

:::

// #endregion 0215

## 0216

// #region 0216

- [🟠 216 - 组合总和 III](https://leetcode.cn/problems/combination-sum-iii)

::: details 💡

:::

// #endregion 0216

## 0222

// #region 0222

- [🟠 222 - 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes)

::: details 💡

:::

// #endregion 0222

## 0224

// #region 0224

- [🔴 224 - 基本计算器](https://leetcode.cn/problems/basic-calculator)

::: details 💡

:::

// #endregion 0224

## 0225

// #region 0225

- [🟢 225 - 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues)

::: details 💡

:::

// #endregion 0225

## 0226

// #region 0226

- [🟠 226 - 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree)

::: details 💡

:::

// #endregion 0226

## 0227

// #region 0227

- [🟠 227 - 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii)

::: details 💡

:::

// #endregion 0227

## 0230

// #region 0230

- [🟠 230 - 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst)

::: details 💡

:::

// #endregion 0230


## 0231

// #region 0231

- [🟢 231 - 2 的幂](https://leetcode.cn/problems/power-of-two)
  > 判断一个整数是否为 2 的幂次方

::: details 💡
:::

// #endregion 0231

## 0232

// #region 0232

- [🟢 232 - 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks)

::: details 💡

:::

// #endregion 0232

## 0234

// #region 0234

- [🟢 234 - 回文链表](https://leetcode.cn/problems/palindrome-linked-list)

::: details 💡

:::

// #endregion 0234

## 0235

// #region 0235

- [🟠 235 - 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)

::: details 💡

:::

// #endregion 0235

## 0236

// #region 0236

- [🟠 236 - 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)

::: details 💡

:::

// #endregion 0236

## 0237 ✅

// #region 0237

- [🟠 237 - 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list)
    > 给定链表中的一个节点，删除这个节点(确保不是链表最后一个节点)

        示例：
            输入：head = [4,5,1,9], node = 5
            输出：[4,1,9]

::: details 💡

【思路】取巧方案，只需将后续节点的值赋值给当前节点，然后将删除节点的后继节点指向，后继节点的后继节点。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        ListNode p = node;
        while ( p.next != null ) {
            p.val = p.next.val;
            if ( p.next.next == null) {
                // 后继节点是最后一个节点，直接指向 null
                p.next = null;
            } else {
                // 后继节点不是最后一个节点，往后移动
                p = p.next;
            }
        }
    }
}
```

:::

// #endregion 0237

## 0239

// #region 0239

- [🔴 239 - 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum)

::: details 💡

:::

// #endregion 0239

## 0241

// #region 0241

- [🟠 241 - 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses)

::: details 💡

:::

// #endregion 0241

## 0253

// #region 0253

- [🟠 253 - 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii)

::: details 💡

:::

// #endregion 0253

## 0256

// #region 0256

- [🟠 256 - 粉刷房子](https://leetcode.cn/problems/paint-house)

::: details 💡

:::

// #endregion 0256

## 0260

// #region 0260

- [🟠 260 - 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii)
  > 一个非空的整数数组中，除了两个元素只出现一次外，其余元素均出现两次。找出两个只出现一次的数字
  > 时间复杂度: O(n)  空间复杂度: O(1)

::: details 💡


  > 升级版
    一个非空的整数数组，除了三个元素只出现一次外，其余元素均出现两次。找出三个只出现一次的数字。
    时间复杂度: O(n)  空间复杂度: O(1)

:::

// #endregion 0260

## 0261

// #region 0261

- [🟠 261 - 以图判树](https://leetcode.cn/problems/graph-valid-tree)

::: details 💡

:::

// #endregion 0261

## 0264

// #region 0264

- [🟠 264 - 丑数 II](https://leetcode.cn/problems/ugly-number-ii)

::: details 💡

:::

// #endregion 0264

## 0268

// #region 0268

- [🟢 268 - 丢失的数字](https://leetcode.cn/problems/missing-number)
  > 给定一个包含 [0, n] 中的 n 个数的数组 nums，找出 [0, n] 这个范围中没有出现在数组中的那个数。

::: details 💡

【思路】
  由于这个数组的值范围为[0, n]，则表明刚好是长度为 n+1 长度的数组。数字刚好与所在的索引的位置匹配，而缺失的数表明该位置没有数。那么使用 `x ^ x = 0` 的特性。只要将数组中数值与所有的索引进行异或操作，那么结果刚好就是缺失的那个数。
  代码实现时，必须要构造一个 0~n 的数组，可以在循环变量数组时，直接使用索引值。需要注意的是 nums 长度为 n，不是 n+1。所以遍历时索引值只能到 n-1，所以可以将进行异或操作的结果值初始值设置为 n。

  > 升级版
    给定一个包含 [0, n] 中的 n-1 个数的数组 nums，找出 [0, n] 这个范围中没有出现在数组中的两个数。

:::

// #endregion 0268

## 0277

// #region 0277

- [🟠 277 - 搜寻名人](https://leetcode.cn/problems/find-the-celebrity)

::: details 💡

:::

// #endregion 0277

## 0278 

// #region 0278

- [🟢 278 - 第一个错误的版本](https://leetcode.cn/problems/first-bad-version)
    > 软件已经发行版本号 [1, 2, 3, ..., n]，通过函数 `bool isBadVersion(version)` 可以判断该版本是否发生该错误，现在需要查找到第一个发生该错误的版本。

::: details 💡

:::

// #endregion 0278

## 0283 ✅

// #region 0283

- [🟢 283 - 移动零](https://leetcode.cn/problems/move-zeroes/)
    > 给定一个数组，将数组中的 0 都移动到数组后面，其它元素相对位置保持不变。

::: details 💡

【思路1】双指针法，遍历数组，快指针遇到 0 时，将慢指针往前移动，并将快指针值赋值到慢指针索引位置。快指针遍历完，最后将慢指针后面的元素全部置为0。

【思路2】也是双指针，遍历数组将不为 0 的元素不停地进行交换处理。

::: code-tabs

@tab java
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( nums[fast] != 0 ) {
                slow += 1;
                nums[slow] = nums[fast];
            }
            fast += 1;
        }
        // 将 slow 后面值均置为 0
        slow += 1;
        while ( slow < nums.length ) {
            nums[slow] = 0;
            slow += 1;
        }
    }
}
```

@tab swift
```swift
class Solution {
    func moveZeroes(_ nums: inout [Int]) {
        var i = 0
        var j = 0
        while j < nums.count {
            guard nums[j] != 0 else { 
                j += 1
                continue 
            }
            // 查找不为 0 的元素，并进行交换
            if i != j {
                let temp = nums[i]
                nums[i] = nums[j]
                nums[j] = temp
            }
            i += 1
            j += 1
        }
    }
}
```

:::

// #endregion 0283

## 0295

// #region 0295

- [🔴 295 - 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream)

::: details 💡

:::

// #endregion 0295

## 0292

// #region 0292

- [🟢 292 - Nim 游戏](https://leetcode.cn/problems/nim-game)

::: details 💡

:::

// #endregion 0292

## 0297

// #region 0297

- [🔴 297 - 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree)

::: details 💡

:::

// #endregion 0297
---
title: 0100 ~ 0199
icon: hashtag

index: true

---

<!-- more -->

## 0100

// #region 0100

- [ğŸŸ¢ 100 - ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree)

::: details ğŸ’¡

:::

// #endregion 0100

## 0101

// #region 0101

- [ğŸŸ¢ 101 - å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree)

::: details ğŸ’¡

:::

// #endregion 0101

## 0102 âœ…

// #region 0102

- [ğŸŸ  102 - äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal)
  > è‡ªé¡¶å‘ä¸‹çš„å±‚åºéå†

        ğŸŒ°
            è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
            è¾“å‡ºï¼š[[3],[9,20],[15,7]]
                3
               / \
              9  20
                 / \
                15  7 

::: details ğŸ’¡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList();
        if (root == null) return result;
        List<TreeNode> queue = new LinkedList();
        queue.add(root);
        while (!queue.isEmpty()) {
            List<Integer> levelList = new LinkedList();
            int levelCount = queue.size();
            while (levelCount > 0) { 
                TreeNode node = queue.removeFirst();
                // å°†è¯¥å±‚èŠ‚ç‚¹æ·»åŠ è¿›å…¥æ•°ç»„
                levelList.add(node.val);
                // å°†èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹ç»§ç»­æ”¾å…¥é˜Ÿåˆ—ä¸­
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                levelCount -= 1;
            }
            result.add(levelList);
        }
        return result;
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func levelOrder(_ root: TreeNode?) -> [[Int]] {
        guard let root = root else { return [] }
        var queue = [root]
        var result = [[Int]]()
        while !queue.isEmpty {
            var levelCount = queue.count
            var levelResult = [Int]()
            while levelCount > 0 {
                let node = queue.removeFirst()
                levelResult.append(node.val)
                levelCount -= 1
                if let left = node.left {
                    queue.append(left)
                }
                if let right = node.right {
                    queue.append(right)
                }
            }
            result.append(levelResult)
        }
        return result
    }
}
```

:::

// #endregion 0102

## 0103 âœ…

// #region 0103

- [ğŸŸ  103 - äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal)

        ğŸŒ°
            è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
            è¾“å‡ºï¼š[[3],[20,9],[15,7]]
                3
               / \
              9  20
                 / \
                15  7 

::: details ğŸ’¡

ã€æ€è·¯ã€‘éå†çš„æ€è·¯ä¸å±‚åºéå†çš„æ€è·¯ä¸€è‡´ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ç”¨ä¸€ä¸ªå¸ƒå°”å€¼å»æ§åˆ¶æ¯ä¸€å±‚å…ƒç´ æ·»åŠ æ—¶çš„æ–¹å‘ï¼Œæ¯å¤„ç†å®Œä¸€å±‚å°±è¿›è¡Œåè½¬å¤„ç†ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList();
        if (root == null) return result;
        List<TreeNode> queue = new LinkedList();
        queue.add(root);
        boolean isPositive = true; // é€šè¿‡å¸ƒå°”å€¼æ§åˆ¶æ¯ä¸€å±‚çš„å…ƒç´ æ·»åŠ æ–¹å‘
        while(!queue.isEmpty()) {
            List<Integer> levelList = new LinkedList();
            int levelCount = queue.size();
            while (levelCount > 0) {
                TreeNode node = queue.removeFirst();
                if (isPositive) {
                    levelList.add(node.val);
                } else {
                    levelList.add(0, node.val);
                }
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                levelCount -= 1;
            }
            isPositive = !isPositive; // åè½¬æ–¹å‘
            result.add(levelList);
        }
        return result;
    }
}
```

:::

// #endregion 0103

## 0104 âœ…

// #region 0104

- [ğŸŸ¢ 104 - äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree)
    >ã€€ç»™å®šä¸€ä¸ªäºŒå‰æ ‘æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€‚
    > äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ : æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘é€’å½’ï¼Œæ¯ä¸ªèŠ‚ç‚¹é€’å½’éå†å·¦å³å­èŠ‚ç‚¹ï¼Œå–å·¦å³åˆ†æ”¯ä¸­è¾ƒé•¿çš„åŠ  1ï¼Œå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Integer.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return 0 }
        return 1 + max(maxDepth(root.left), maxDepth(root.right))
    }
}
```

:::

// #endregion 0104

## 0105

// #region 0105

- [ğŸŸ  105 - ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

::: details ğŸ’¡

:::

// #endregion 0105

## 0106

// #region 0106

- [ğŸŸ  106 - ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

::: details ğŸ’¡

:::

// #endregion 0106

## 0107 âœ…

// #region 0107

- [ğŸŸ  107 - äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii)
  > è‡ªåº•å‘ä¸Šçš„å±‚åºéå†
  
        ğŸŒ°
            è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
            è¾“å‡ºï¼š[[15,7],[9,20],[3]]
                3
               / \
              9  20
                 / \
                15  7 

::: details ğŸ’¡

ã€æ€è·¯1ã€‘å…ˆæŒ‰ç…§è‡ªé¡¶å‘ä¸‹çš„å±‚åºå¾—åˆ°ç»“æœï¼Œç„¶ååè½¬ç»“æœæ•°ç»„ã€‚

ã€æ€è·¯2ã€‘ä¹Ÿæ˜¯è‡ªé¡¶å‘ä¸‹çš„å±‚åºéå†çš„æ€è·¯ï¼Œä½†æ˜¯æ¯æ¬¡å°†ç»“æœæ’å…¥åˆ°ç»“æœæ•°ç»„å‰é¢ï¼Œè¿™æ ·å°±ä¸ç”¨å°†ç»“æœæ•°ç»„åè½¬ã€‚

::: code-tabs

@tab java è§£æ³•1
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = levelOrder(root);
        Collections.reverse(result); // åè½¬è‡ªé¡¶å‘ä¸‹çš„éå†ç»“æœ
        return result;
    }

    List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList();
        if (root == null) return result;
        List<TreeNode> queue = new LinkedList();
        queue.add(root);
        while (!queue.isEmpty()) {
            List<Integer> levelList = new LinkedList();
            int levelCount = queue.size();
            while (levelCount > 0) {
                TreeNode node = queue.removeFirst();
                levelList.add(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                levelCount -= 1;
            }
            result.add(levelList);
        }
        return result;
    }
}
```

@tab java è§£æ³•2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new LinkedList();
        if (root == null) return result;
        List<TreeNode> queue = new LinkedList();
        queue.add(root);
        while (!queue.isEmpty()) {
            List<Integer> levelList = new LinkedList();
            int levelCount = queue.size();
            while (levelCount > 0) {
                TreeNode node = queue.removeFirst();
                levelList.add(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                levelCount -= 1;
            }
            result.add(0, levelList); // å°†æ¯ä¸€å±‚ç»“æœæ’å…¥åˆ°ç»“æœåˆ—è¡¨å‰é¢
        }
        return result;
    }
}
```

:::

// #endregion 0107

## 0108

// #region 0108

- [ğŸŸ¢ 108 - å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree)

::: details ğŸ’¡

:::

// #endregion 0108

## 0109

// #region 0109

- [ğŸŸ  109 - æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree)

::: details ğŸ’¡

:::

// #endregion 0109

## 0110

// #region 0110

- [ğŸŸ¢ 110 - å¹³è¡¡äºŒå‰æ ‘](https://leetcode.cn/problems/balanced-binary-tree)

::: details ğŸ’¡

:::

// #endregion 0110

## 0111 âœ…

// #region 0111

- [ğŸŸ¢ 111 - äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree)
    > ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚
    > äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ : ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
            è¾“å‡ºï¼š2
                3
              /   \
            9      20
                  /   \
                 15    7 
        ğŸŒ°
            è¾“å…¥ï¼šroot = [2,null,3,null,4,null,5,null,6]
            è¾“å‡ºï¼š5
                2
                 \
                  3
                   \
                    4
                     \
                      5
                       \
                        6
::: details ğŸ’¡

ã€æ€è·¯1ã€‘`DFS` æ·±åº¦ä¼˜å…ˆéå†ï¼Œè¿™ä¸ªé¢˜ä¸æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦çš„ä¸åŒç‚¹åœ¨äºï¼Œä¸èƒ½ç®€å•åœ°è¿›è¡Œé€’å½’åˆ¤æ–­å·¦å³ä¸¤è¾¹æœ€å°ï¼Œä¼šå‡ºç°ä¸ºç©ºçš„æƒ…å†µã€‚

ã€æ€è·¯2ã€‘`BFS` å¹¿åº¦ä¼˜å…ˆéå†ï¼Œ

::: code-tabs

@tab java è§£æ³•1
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return 1;
        int min = Integer.MAX_VALUE;
        if (root.left != null) {
            min = Integer.min(minDepth(root.left), min);
        }
        if (root.right != null) {
            min = Integer.min(minDepth(root.right), min);
        }
        return min + 1;
    }
}
```

@tab java è§£æ³•2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int depth = 0;
        List<TreeNode> queue = new LinkedList();
        queue.add(root);
        while ( !queue.isEmpty() ) {
            depth += 1;
            int count = queue.size(); // äºŒå‰æ ‘è¯¥å±‚èŠ‚ç‚¹æ•°
            while(count > 0) {
                TreeNode node = queue.removeFirst();
                // èŠ‚ç‚¹å·¦å³å­èŠ‚ç‚¹å‡ä¸º nullï¼Œåˆ™è¡¨æ˜ä¸ºå·²è¾¾åˆ°å¶å­èŠ‚ç‚¹æœ€çŸ­è·¯å¾„
                if (node.left == null && node.right == null) 
                    return depth;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                count -= 1;
            }
        }
        return depth;
    }
}
```

@tab swift è§£æ³•2
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func minDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return 0 }
        var depth = 1
        var queue = [TreeNode]()
        queue.append(root)
        while !queue.isEmpty {
            var count = queue.count
            while count != 0 {
                count -= 1
                let node = queue.removeFirst()
                if node.left == nil, node.right == nil {
                    return depth
                }
                if let left = node.left {
                    queue.append(left)
                }
                if let right = node.right {
                    queue.append(right)
                }
            }
            depth += 1
        }
        return depth
    }
}
```

:::

// #endregion 0111

## 0112

// #region 0112

- [ğŸŸ¢ 112 - è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum)

::: details ğŸ’¡

:::

// #endregion 0112

## 0113

// #region 0113

- [ğŸŸ  113 - è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii)

::: details ğŸ’¡

:::

// #endregion 0113

## 0114

// #region 0114

- [ğŸŸ  114 - äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list)

::: details ğŸ’¡

:::

// #endregion 0114

## 0115

// #region 0115

- [ğŸ”´ 115 - ä¸åŒçš„å­åºåˆ—](https://leetcode.cn/problems/distinct-subsequences)

::: details ğŸ’¡

:::

// #endregion 0115


## 0116

// #region 0116

- [ğŸŸ  116 - å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node)

::: details ğŸ’¡

:::

// #endregion 0116

## 0117

// #region 0117

- [ğŸŸ  117 - å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii)

::: details ğŸ’¡

:::

// #endregion 0117

## 0118

// #region 0118

- [ğŸŸ¢ 118 - æ¨è¾‰ä¸‰è§’](https://leetcode.cn/problems/pascals-triangle)

::: details ğŸ’¡

:::

// #endregion 0118

## 0119

// #region 0119

- [ğŸŸ¢ 119 - æ¨è¾‰ä¸‰è§’ II](https://leetcode.cn/problems/pascals-triangle-ii)

::: details ğŸ’¡

:::

// #endregion 0119

## 0120

// #region 0120

- [ğŸŸ  120 - ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ](https://leetcode.cn/problems/triangle)

::: details ğŸ’¡

:::

// #endregion 0120

## 0121

// #region 0121

- [ğŸŸ¢ 121 - ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock)

::: details ğŸ’¡

:::

// #endregion 0121

## 0122

// #region 0122

- [ğŸŸ  122 - ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)

::: details ğŸ’¡

:::

// #endregion 0122

## 0123

// #region 0123

- [ğŸ”´ 123 - ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii)

::: details ğŸ’¡

:::

// #endregion 0123

## 0124

// #region 0124

- [ğŸ”´ 124 - äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

::: details ğŸ’¡

:::

// #endregion 0124

## 0125 âœ…

// #region 0125

- [ğŸŸ¢ 125 - éªŒè¯å›æ–‡ä¸²](https://leetcode.cn/problems/valid-palindrome)
    > åˆ¤æ–­å­—ç¬¦ä¸²ä¸­çš„å­—æ¯(å¤§å°ä¸æ•æ„Ÿï¼Œå¤§å†™å­—æ¯ä¸å°å­—å¯ä»¥çœ‹ä½œç›¸ç­‰)å’Œæ•°å­—æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Œå­—ç¬¦ä¸­çš„çš„å…¶å®ƒå­—ç¬¦ä¸å‚ä¸å›æ–‡ä¸²æ ¡éªŒã€‚

::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution
  public boolean isPalindrome(String s) {
    int left = 0;
    int right = s.length() - 1;
    while ( left < right ) {
        // å¯»æ‰¾å·¦è¾¹ç¬¬ä¸€ä¸ªå­—æ¯æˆ–æ•°å­—
        while ( left < right && !Character.isLetterOrDigit(s.charAt(left)) ) {
            left += 1;
        }
        // å¯»æ‰¾å³è¾¹ç¬¬ä¸€ä¸ªå­—æ¯æˆ–æ•°å­—
        while ( left < right && !Character.isLetterOrDigit(s.charAt(right)) ) {
            right -= 1;
        }
        if ( left >= right ) { return true; }
        // å·¦å³æŒ‡é’ˆï¼Œåˆ¤æ–­å­—ç¬¦æ˜¯å¦ç›¸ç­‰
        if ( Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)) ) {
            return false; // ä¸ç›¸ç­‰ï¼Œåˆ™è¡¨æ˜ä¸æ˜¯å›æ–‡ä¸²
        } 
        // ç›¸ç­‰ï¼Œè·³è½¬åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦è¿›è¡ŒåŒ¹é…
        left += 1;
        right -= 1;
    }
    return true;
  }
}
```

:::

// #endregion 0125

## 0126

// #region 0126

- [ğŸ”´ 126 - å•è¯æ¥é¾™ II](https://leetcode.cn/problems/word-ladder-ii)

::: details ğŸ’¡

:::

// #endregion 0126

## 0127

// #region 0127

- [ğŸ”´ - å•è¯æ¥é¾™](https://leetcode.cn/problems/word-ladder)

::: details ğŸ’¡

:::

// #endregion 0127

## 0128

// #region 0128

- [ğŸŸ  128 - æœ€é•¿è¿ç»­åºåˆ—](https://leetcode.cn/problems/longest-consecutive-sequence)

::: details ğŸ’¡

:::

// #endregion 0128

## 0129

// #region 0129

- [ğŸŸ  129 - æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers)

::: details ğŸ’¡

:::

// #endregion 0129

## 0130

// #region 0130

- [ğŸŸ  130 - è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode.cn/problems/surrounded-regions)

::: details ğŸ’¡

:::

// #endregion 0130

## 0131

// #region 0131

- [ğŸŸ  131 - åˆ†å‰²å›æ–‡ä¸²](https://leetcode.cn/problems/palindrome-partitioning)

::: details ğŸ’¡

:::

// #endregion 0131

## 0132

// #region 0132

- [ğŸ”´ 132 - åˆ†å‰²å›æ–‡ä¸² II](https://leetcode.cn/problems/palindrome-partitioning-ii)

::: details ğŸ’¡

:::

// #endregion 0132

## 0133

// #region 0133

- [ğŸŸ  133 - å…‹éš†å›¾](https://leetcode.cn/problems/clone-graph)

::: details ğŸ’¡

:::

// #endregion 0133

## 0134

// #region 0134

- [ğŸŸ  134 - åŠ æ²¹ç«™](https://leetcode.cn/problems/gas-station)

::: details ğŸ’¡

:::

// #endregion 0124

## 0135

// #region 0135

- [ğŸ”´ 135 - åˆ†å‘ç³–æœ](https://leetcode.cn/problems/candy)

::: details ğŸ’¡

:::

// #endregion 0135

## 0136

// #region 0136

- [ğŸŸ¢ 136 - åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—](https://leetcode.cn/problems/single-number/)
  > ä¸€ä¸ªéç©ºçš„æ•´æ•°æ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºåªå‡ºç°ä¸€æ¬¡çš„æ•°å­— 

::: details ğŸ’¡

ã€æ€è·¯ã€‘
  ç”±äºå­˜åœ¨ç›¸åŒçš„å…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ï¼Œåˆšå¥½å¯ä»¥ä½¿ç”¨ `x ^ x = 0` çš„ç‰¹æ€§ã€‚å°†æ‰€æœ‰æ•°å­—è¿›è¡Œå¼‚æˆ–æ“ä½œï¼Œåˆ™ç›¸åŒçš„æ•°å­—å¼‚æˆ–ç»“æœä¸º 0ï¼Œåªå‡ºç°ä¸€æ¬¡çš„æ•°ä¸ 0 è¿›è¡Œå¼‚æˆ–ç»“æœå°±æ˜¯åªå‡ºç°ä¸€æ¬¡çš„æ•°ã€‚
  æ—¶é—´å¤æ‚åº¦: O(n)  ç©ºé—´å¤æ‚åº¦: O(1)

::: code-tabs

@tab java
```java

```

:::

// #endregion 0136

## 0137

// #region 0137

- [ğŸŸ  137 - åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— II](https://leetcode.cn/problems/single-number-ii)
  > ä¸€ä¸ªéç©ºçš„æ•´æ•°æ•°ç»„ä¸­ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ å‡å‡ºç°ä¸‰æ¬¡ã€‚æ‰¾å‡ºåªå‡ºç°ä¸€æ¬¡çš„æ•°å­— 
  > æ—¶é—´å¤æ‚åº¦: O(n)  ç©ºé—´å¤æ‚åº¦: O(1)

::: details ğŸ’¡

ã€æ€è·¯ã€‘
  è¿™é“é¢˜æ˜¯ 136 çš„å˜å½¢ç‰ˆæœ¬ï¼Œä¸èƒ½ä½¿ç”¨ `x ^ x = 0` ç‰¹æ€§ã€‚ä½†æ˜¯ä½†æ˜¯è¿˜æ˜¯å¯ä»¥ä½¿ç”¨ä½è¿ç®—çš„ç‰¹æ€§è¿›è¡Œæ±‚è§£ã€‚
  
::: code-tabs

@tab java
```java

```
  
:::

// #endregion 0137

## 0138

// #region 0138

- [ğŸŸ  138 - éšæœºé“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/copy-list-with-random-pointer)

::: details ğŸ’¡

:::

// #endregion 0138

## 0139

// #region 0139

- [ğŸŸ  139 - å•è¯æ‹†åˆ†](https://leetcode.cn/problems/word-break)

::: details ğŸ’¡

:::

// #endregion 0139

## 0140

// #region 0140

- [ğŸ”´ 140 - å•è¯æ‹†åˆ† II](https://leetcode.cn/problems/word-break-ii)

::: details ğŸ’¡

:::

// #endregion 0140

## 0141 âœ…

// #region 0141

- [ğŸŸ¢ 141 - ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle)
  > åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦æœ‰ç¯ï¼Ÿ

::: details ğŸ’¡

ã€æŠ€å·§ã€‘ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œfast æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œslow æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ï¼Œåˆ™è¡¨æ˜é“¾è¡¨æœ‰ç¯ã€‚å¦‚æœæ²¡æœ‰ç›¸é‡ï¼Œfast ç›´æ¥èµ°åˆ°é“¾è¡¨æœ€å nil ç©ºæŒ‡é’ˆï¼Œåˆ™è¡¨æ˜é“¾è¡¨æ²¡æœ‰ç¯ã€‚
  
ã€åŸç†ã€‘ 

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        // éœ€è¦æ ¡éªŒ fast.next ä¸ºç©ºï¼Œéç¯è¡Œé“¾è¡¨çš„æƒ…å†µä¸‹ï¼Œè¡¨æ˜å·²ç»æ˜¯æœ€åèŠ‚ç‚¹
        while ( fast != null && fast.next != null ) {
            // å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥
            fast = fast.next.next;
            slow = slow.next;
            if ( fast == slow ) {
                return true;
            }
        }
        return false;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */

class Solution {
    func hasCycle(_ head: ListNode?) -> Bool {
        var fast = head
        var slow = head
        // swift å¯é€‰ç±»å‹ï¼Œç®€åŒ–äº† java ä¸­çš„ä¸ºç©ºåˆ¤æ–­
        while fast?.next != nil {
            fast = fast?.next?.next
            slow = slow?.next
            guard fast === slow else { continue }
            return true
        }
        return false
    }
}
```

:::

// #endregion 0141

## 0142 âœ…

// #region 0142

- [ğŸŸ  142 - ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii) 
  > æ±‚ç¯å½¢é“¾è¡¨å…¥ç¯ä½ç½®çš„èŠ‚ç‚¹ï¼Ÿ

::: details ğŸ’¡

ã€ç»“è®ºã€‘ç›¸é‡ç‚¹ ~ è¿æ¥ç‚¹ = å¤´æŒ‡é’ˆ ~ è¿æ¥ç‚¹

ã€æ€è·¯ã€‘å…ˆä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ(å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥)å®šä½åˆ°ç›¸é‡ç‚¹ï¼›ç„¶åå°†æ…¢æŒ‡é’ˆé‡æ–°æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œå¿«æ…¢æŒ‡é’ˆå¼€å§‹åŒæ—¶å¾€å‰èµ°(éƒ½èµ°ä¸€æ­¥)ï¼Œç›¸é‡ç‚¹å°±æ˜¯ç¯çš„å…¥å£ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 1> å¿«æ…¢æŒ‡é’ˆå®šä½ç¯çš„ç›¸é‡ç‚¹
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null && fast.next != null ) {
            fast = fast.next.next;
            slow = slow.next;
            if ( fast == slow ) {
                break;
            }
        }
        // 2> æ ¡éªŒç¡®ä¿ç¯çš„å­˜åœ¨
        if ( fast == null || fast.next == null ) {
            return null;
        }
        // 3> æ…¢æŒ‡é’ˆæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¿«æ…¢æŒ‡é’ˆå¼€å§‹é½æ­¥èµ°
        slow = head;
        while ( fast != slow ) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */

class Solution {
    func detectCycle(_ head: ListNode?) -> ListNode? {
        // å…ˆä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå®šä½åˆ°ç›¸é‡ç‚¹
        var fast = head
        var slow = head
        while fast?.next != nil {
            fast = fast?.next?.next
            slow = slow?.next
            guard fast === slow else { continue }
            break
        }
        guard fast != nil && fast?.next != nil else {
            return nil
        }
        // å°†æ…¢æŒ‡é’ˆç§»åŠ¨åˆ°å¤´ç»“ç‚¹ï¼Œå¿«æ…¢æŒ‡é’ˆéƒ½å¼€å§‹èµ°ä¸€æ­¥ï¼Œç›¸é‡ç‚¹å°±æ˜¯ç¯çš„å…¥å£
        slow = head
        while fast !== slow {
            fast = fast?.next
            slow = slow?.next
        }
        return fast
    }
}
```

  > æ±‚ç¯å½¢é“¾è¡¨çš„ç¯é•¿ï¼Ÿ

ã€æ€è·¯1ã€‘slow æŒ‡é’ˆè§†è§’ï¼Œè®°å½•ç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹ä½ç½®ï¼Œä¹‹åä½¿ç”¨è®¡æ•°å™¨è®°å½•æ­¥é•¿ï¼Œå½“ slow æŒ‡é’ˆå†æ¬¡èµ°åˆ°è¯¥ä½ç½®æ—¶ï¼Œåˆ™è®¡æ•°å™¨æ­¥é•¿å°±æ˜¯ç¯é•¿ã€‚

ã€æ€è·¯2ã€‘fast æŒ‡é’ˆè§†è§’ï¼Œç”±äº fast åˆšå¥½æ¯” slow æŒ‡é’ˆå¤šèµ°ä¸€å€ï¼Œæ‰€ä»¥å½“ä¸¤ä¸ªæŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶ï¼Œåˆ™ fast åˆšå¥½èµ°äº†ç¯é•¿çš„ä¸¤å€ã€‚

:::

// #endregion 0142

## 0143

// #region 0143

- [ğŸŸ  143 - é‡æ’é“¾è¡¨](https://leetcode.cn/problems/reorder-list)

::: details ğŸ’¡

:::

// #endregion 0143

## 0144 âœ…

// #region 0144

- [ğŸŸ¢ 144 - äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal)
    
::: details ğŸ’¡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> preorderTraversal(TreeNode root) {
        traversal(root);
        return list;
    }

    void traversal(TreeNode root) {
        if (root == null) return;
        list.add(root.val); // å‰åºä½ç½®ï¼Œæ·»åŠ å€¼
        traversal(root.left);
        traversal(root.right);
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func preorderTraversal(_ root: TreeNode?) -> [Int] {
        guard let root = root else { return [] }
        var result = [Int]()
        result.append(root.val)
        result.append(contentsOf: preorderTraversal(root.left))
        result.append(contentsOf: preorderTraversal(root.right))
        return result
    }
}
```

:::

// #endregion 0144

## 0145 âœ…

// #region 0145

- [ğŸŸ¢ 145 - äºŒå‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal)

::: details ğŸ’¡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> postorderTraversal(TreeNode root) {
        traversal(root);
        return list;
    }
    
    void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        traversal(root.right);
        list.add(root.val); // ååºä½ç½®ï¼Œæ·»åŠ å€¼
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func postorderTraversal(_ root: TreeNode?) -> [Int] {
        guard let root = root else { return [] }
        var result = [Int]()
        result.append(contentsOf: postorderTraversal(root.left))
        result.append(contentsOf: postorderTraversal(root.right))
        result.append(root.val)
        return result
    }
}
```

:::

// #endregion 0145

## 0146

// #region 0146

- [ğŸŸ  146 - LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache)
  > `get` `put` æ“ä½œéœ€è¦ O(1) çš„å¹³å‡æ—¶é—´å¤æ‚åº¦

::: details ğŸ’¡

ã€æ€è·¯ã€‘: å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨
  * é¦–å…ˆè§£å†³æ•°æ®çš„ç¼“å­˜é—®é¢˜ã€‚ç”±äºéœ€è¦ O(1) çš„æ—¶é—´å¤æ‚åº¦ï¼Œæ‰€ä»¥åº”è¯¥å¾ˆè‡ªç„¶çš„æƒ³åˆ°äº†ä½¿ç”¨å“ˆå¸Œè¡¨æ¥ä¿å­˜æ•°æ®ã€‚è¿™æ ·ä¿å­˜å’ŒæŸ¥è¯¢éƒ½å¯ä»¥åšåˆ° O(1) çš„æ—¶é—´å¤æ‚åº¦ã€‚
  * å†æ¥è§£å†³æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é—®é¢˜ã€‚è¿™éœ€è¦ä½¿ç”¨åŒå‘é“¾è¡¨çš„ç»“æ„æ¥ä¿å­˜æ•°æ®ï¼Œé“¾è¡¨å¤´éƒ¨ä¸ºæœ€å°‘ä½¿ç”¨çš„æ•°æ®ï¼Œé“¾è¡¨å°¾éƒ¨ä¸ºæœ€è¿‘ä½¿ç”¨çš„æ•°æ®ã€‚
    + æŸ¥è¯¢æ•°æ®æ—¶ï¼Œè¿™ä¸ªæŸ¥è¯¢è¿‡çš„æ•°æ®ä¸ºæœ€è¿‘ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯éœ€è¦ç§»é™¤å°±ä¹‹å‰é“¾è¡¨ä¸­çš„è¿™ä¸ªæ•°æ®ï¼Œå°†è¿™ä¸ªæ•°æ®é‡æ–°åŠ å…¥åˆ°é“¾è¡¨å°¾éƒ¨ã€‚
    + æ·»åŠ æ•°æ®æ—¶ï¼Œå¦‚æœè¿™ä¸ª key å·²å­˜åœ¨ï¼Œåˆ™ç§»é™¤æ—§æ•°æ®ï¼Œå°†æ–°æ•°æ®åŠ å…¥é“¾è¡¨å°¾éƒ¨ï¼›å¦‚æœ key ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ¤æ–­ç¼“å­˜æ˜¯å¦å·²æ»¡ï¼Œå¦‚æœå·²æ»¡åˆ™ç§»é™¤é“¾è¡¨å¤´éƒ¨æœ€å°‘ä½¿ç”¨æ•°æ®ï¼Œæ·»åŠ æ–°æ•°æ®åˆ°é“¾è¡¨å°¾éƒ¨ï¼Œå¦‚æœæœªæ»¡åˆ™ç›´æ¥æ·»åŠ æ–°æ•°æ®åˆ°é“¾è¡¨å°¾éƒ¨ã€‚

::: code-tabs

@tab java
```java

```

:::

// #endregion 0146

## 0147 âœ…

// #region 0147

- [ğŸŸ  147 - å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº](https://leetcode.cn/problems/insertion-sort-list)

        ğŸŒ°
            è¾“å…¥ï¼š4 -> 2 -> 1 -> 3
            è¾“å‡ºï¼š1 -> 2 -> 3 -> 4

::: details ğŸ’¡

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if ( head == null ) return null;
        ListNode dummy = new ListNode(Integer.MIN_VALUE);
        dummy.next = head;
        ListNode sorted = head;
        ListNode p = head.next;
        while ( p != null ) {
            if ( p.val >= sorted.val ) {
                // æ¯”å·²æ’åºæœ€åèŠ‚ç‚¹å€¼å¤§ï¼Œç›´æ¥åŠ å…¥æ’åºé“¾è¡¨
                sorted = p;
            } else {
                // æ’åºèŠ‚ç‚¹æŒ‡å‘è¯¥èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹
                sorted.next = p.next;
                // æ¯”å·²æ’åºæœ€åèŠ‚ç‚¹å°ï¼Œåˆ™éœ€è¦ä»é“¾è¡¨å¤´ç»“ç‚¹æŸ¥è¯¢æ’å…¥èŠ‚ç‚¹ä½ç½®
                ListNode insert = dummy;
                while ( insert.next != null ) {
                    if ( insert.val < p.val && insert.next.val >= p.val ) {
                        break;
                    }
                    insert = insert.next;
                }
                p.next = insert.next;
                insert.next = p;
            }
            p = sorted.next;
        }
        return dummy.next;
    }
}
```

:::

// #endregion 0147

## 0148

// #region 0148

- [ğŸŸ  148 - æ’åºé“¾è¡¨](https://leetcode.cn/problems/sort-list)

        ğŸŒ°
            è¾“å…¥ï¼š-1 -> 5 -> 3 -> 4 -> 0
            è¾“å‡ºï¼š-1 -> 0 -> 3 -> 4 -> 5

> è¿›é˜¶ï¼šO(nlogn)æ—¶é—´å¤æ‚åº¦ + å¸¸æ•°çº§ç©ºé—´å¤æ‚åº¦ï¼Œå¯¹é“¾è¡¨è¿›è¡Œæ’åºã€‚

::: details ğŸ’¡

ã€æ€è·¯1ã€‘ åŒ 147 é¢˜ï¼Œä½¿ç”¨æ’å…¥æ’åºè¿›è¡Œæ’åºï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nÂ²)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)

::: code-tabs

@tab java
```java

```

:::



// #endregion 0148

## 0149

// #region 0149

- [ğŸ”´ 149 - ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹æ•°](https://leetcode.cn/problems/max-points-on-a-line)

::: details ğŸ’¡

:::

// #endregion 0149

## 0150

// #region 0150

- [ğŸŸ  150 - é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](https://leetcode.cn/problems/evaluate-reverse-polish-notation)

::: details ğŸ’¡

:::

// #endregion 0150

## 0151

// #region 0151

- [ğŸŸ  151 - åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯](https://leetcode.cn/problems/reverse-words-in-a-string)

::: details ğŸ’¡

:::

// #endregion 0151

## 0160 âœ…

// #region 0160

- [ğŸŸ¢ 160 - ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists)
    > æ±‚ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦å­˜åœ¨äº¤ç‚¹ï¼Ÿå¦‚æœå­˜åœ¨è¿”å›ç›¸äº¤èµ·å§‹èŠ‚ç‚¹ï¼Œä¸å­˜åœ¨è¿”å› `null`ï¼Ÿ(å·²ç¡®å®šä¸å­˜åœ¨ç¯ç»“æ„)

        ğŸŒ°
              a1 -> a2 
                      \
                        -> c1 -> c2 -> c3
                      /
        b1 -> b2 -> b3
        
        c1 ä¸ºäº¤ç‚¹

::: details ğŸ’¡

ã€æ€è·¯1ã€‘éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œå˜é‡çš„åŒæ—¶å°†èŠ‚ç‚¹æ”¾å…¥ `Set` ä¸­ï¼Œå¦‚æœå­˜å…¥æ—¶å·²å­˜åœ¨ `Set` ä¸­ï¼Œåˆ™è¡¨æ˜æ˜¯äº¤ç‚¹ã€‚è¿™ç§è§£æ³•æ—¶é—´å¤æ‚åº¦ O(n), éœ€è¦ä½¿ç”¨é¢å¤–ç©ºé—´ ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚

ã€æ€è·¯2ã€‘ç”±äºç›¸äº¤ä¹‹åå†…å®¹ç›¸åŒï¼Œè¿™å¯ä»¥å…ˆè®¡ç®—ä¸¤ä¸ªé“¾è¡¨é•¿åº¦ï¼Œå…ˆè®©é•¿ä¸€ç‚¹çš„é“¾è¡¨å…ˆèµ°ä¸¤ä¸ªé“¾è¡¨å·®å€¼ã€‚ç„¶åä¸¤ä¸ªé“¾è¡¨æŒ‡é’ˆåŒæ—¶å‘å‰èµ°ï¼Œç„¶åæ¯”è¾ƒèŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒå°±æ˜¯äº¤ç‚¹ã€‚

ã€æ€è·¯3ã€‘æ‰©å±•æ€è·¯3ï¼Œæ ¸å¿ƒç‚¹åœ¨äºå¯¹é½é“¾è¡¨ï¼Œç„¶åå°±å¯ä»¥å¼€å§‹æ¯”è¾ƒã€‚å¦‚æœå°†ä¸¤ä¸ªé“¾è¡¨å‰åç›¸åŠ (A+B  B+A) è¿™æ ·ä¹Ÿèµ·åˆ°äº†å¯¹é½æ•ˆæœï¼Œä»£ç å®ç°å¹¶ä¸éœ€è¦çœŸæ­£ç›¸åŠ ï¼Œä¸¤ä¸ªæŒ‡é’ˆï¼Œåªéœ€è¦å…ˆéå†ä¸€ä¸ªé“¾è¡¨ç„¶åå†ä»å¦å¤–ä¸€ä¸ªé“¾è¡¨å¤´å¼€å§‹å¾€éå†ã€‚

        [a1 -> a2 -> c1 -> c2 -> c3] -> b1 -> b2 -> b3 -> {c1} -> c2 -> c3
        [b1 -> b2 -> b3 -> c1 -> c2 -> c3] -> a1 -> a2 -> {c1} -> c2 -> c3


::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pa = headA;
        ListNode pb = headB;
        while ( pa != pb ) {
            if ( pa == null ) {
                pa = headB;
            } else {
                pa = pa.next;
            }
            if ( pb == null ) {
                pb = headA;
            } else {
                pb = pb.next;
            }
        }
        return pa;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */

class Solution {
    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
        var pa = headA
        var pb = headB
        while pa !== pb { // swift ä¸­éœ€è¦ä½¿ç”¨ !== åˆ¤æ–­ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦ç›¸ç­‰
            // éå†å®Œä¸€ä¸ªé“¾è¡¨åï¼Œå¼€å§‹éå†å¦ä¸€ä¸ªé“¾è¡¨
            pa = pa == nil ? headB : pa?.next
            pb = pb == nil ? headA : pb?.next
        }
        return pa
    }
}
```

:::

// #endregion 0160

## 0167 âœ…

// #region 0167

- [ğŸŸ  167 - ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)
    > ç»™å®šç›®æ ‡å€¼ï¼Œåœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ä¸¤ä¸ªç´¢å¼•å¯¹åº”çš„å€¼ç›¸åŠ ç­‰äºç›®æ ‡å€¼ã€‚

::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while ( left < right ) {
            int sum = numbers[left] + numbers[right];
            if ( sum == target ) { 
                return new int[] {left + 1, right + 1};
            } else if ( sum < target ) {
                // å°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹
                left += 1;
            } else { // sum > target
                // å¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹
                right -= 1;
            }
        }
        return new int[] {};
    }
}
```

@tab swift
```swift
class Solution {
    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {
        var left = 0
        var right = numbers.count - 1
        while left < right {
            let sum = numbers[left] + numbers[right]
            if sum == target {
                return [left + 1, right + 1]
            } else if sum < target {
                // å’Œå°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹ç´¢å¼•
                while left + 1 < right, numbers[left + 1] == numbers[left] {
                    // å¾ªç¯è·³åˆ°ä¸å½“å‰åˆ¤æ–­å·¦è¾¹ç•Œå€¼ç›¸ç­‰çš„å€¼æœ€åä¸€ä¸ª
                    left += 1
                }
                // å† +1 è·³è¿‡å·²ç»åˆ¤æ–­çš„è¯¥å€¼
                left += 1
            } else { // sum > target
                // å’Œå¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹ç´¢å¼•
                while left < right - 1, numbers[right - 1] == numbers[right] {
                    right -= 1
                }
                right -= 1
            }
        }
        return []
    }
}
```

:::

// #endregion 0167

## 0172

// #region 0172

- [ğŸŸ  172 - é˜¶ä¹˜åçš„é›¶](https://leetcode.cn/problems/factorial-trailing-zeroes)

::: details ğŸ’¡

:::

// #endregion 0172

## 0174

// #region 0174

- [ğŸ”´ 714 - åœ°ä¸‹åŸæ¸¸æˆ](https://leetcode.cn/problems/dungeon-game)

::: details ğŸ’¡

:::

// #endregion 0174

## 0187

// #region 0187

- [ğŸŸ  187 - é‡å¤çš„DNAåºåˆ—](https://leetcode.cn/problems/repeated-dna-sequences)

::: details ğŸ’¡

:::

// #endregion 0187

## 0188

// #region 0188

- [ğŸ”´ 188 - ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv)

::: details ğŸ’¡

:::

// #endregion 0188

## 0189

// #region 0189

- [ğŸŸ  189 - æ‰“å®¶åŠ«èˆ](https://leetcode.cn/problems/house-robber)

::: details ğŸ’¡

:::

// #endregion 0189

## 0191

// #region 0191

- [ğŸŸ¢ 191 - ä½1çš„ä¸ªæ•°](https://leetcode.cn/problems/number-of-1-bits)

::: details ğŸ’¡

:::

// #endregion 0191
---
title: Dart
icon: hashtag

index: true

---

<!-- more -->

------

## 概念知识

### ❓`Dart` 中 `library` 与 `package` 区别

::: details 💡 

  - `library`: 一个关键字，它表示一个库（`Library`），每个文件就是一个库。
    > 库主要是为了把相关的代码组织在一起，方便使用和管理。可以在库中定义函数、变量、类、接口等，并用 `import` 关键字在其他库中导入这个库。
    > 一个 `Dart` 库可以由多个部分组成，这些部分用 `part` 和 `part of` 进行标识。

  - `package`: 一个包管理系统，它可以帮助我们更好地组织和分享 `Dart` 代码。一个包就是一些以特定方式组织起来的 `Dart` 代码——通常包含多个库、样例文件、文档等。
    > `package` 的主要目的是分享代码，它可以将相关的多个库组织到一起，并通过 `Dart` 的包管理工具（如 `pub`）进行版本管理和发布。
    
:::

------

## 数据类型

### ❓ `const` vs `final`

::: details 💡 

> `final` 和 `const` 都用于表示一个值是常量，也就是说这个值一旦被设置就不能被更改。

主要区别：

  - 赋值时机：
    * `const` 的赋值必须在编译期完成，因此 `const` 的值必须是一个编译期常量。
    * `final` 的赋值在第一次使用时计算，它的初始值可以通过计算而来，但只能赋值一次。

    ```dart
    // 编译时，确定为 double 类型常量
    const pi = 3.14159; 
    const date = DateTime().now(); // ❌ 编译错误，不能将一个动态值赋值给 const 常量
    // 运行时，获取运行时刻时间
    final date = DateTime().now(); 
    ```

  - 内存内常量的处理
    * `const` 会创建编译时常量。对于同一个值，不管它在哪里被使用，总是重用同一实例。所以使用 `identical()` 比较 `const` 对象总是返回 `true` 。
    * `final` 变量每次都会创建一个新的实例。

    ```dart
    const arr1 = [1, 2, 3];
    const arr2 = [1, 2, 3];
    identical(name1, name2); // true，指向同一内存地址
    final arr1 = [1, 2, 3];
    final arr2 = [1, 2, 3];
    identical(arr1, arr2); // false，分配不同的内存地址
    ```

  - 可变性： 
    * `const` 对象以及其字段必须全部是不可变的。
    * `final` 对象的字段可以是可变的。
    
    ```dart
    const arr = [1, 2, 3];
    arr[0] = 0; // ❌
    final arr = [1, 2, 3];
    arr[0] = 0; // ✅
    ```

  - 初始化方式： 
    * `const` 变量的值必须在声明的时候就确定下来。
    * `final` 变量可以在构造器中进行初始化，但 `const` 变量不能。
    
    ```dart
    class Student {
        final String name;
        final int age;
        const Student({this.name, this.age});
    }
    ```
    
:::

### ❓`var` vs `Object` vs `dynamic`

::: details 💡 

  - `var` : 使用 `var` 关键字，会根据第一次赋予的值来推断该变量的类型。一旦类型被推断后，就不能改变该变量的类型。

    ```dart
    var name = 'Bob';
    name = 'Alice'; // ✅
    name = 10;  // ❌
    ```
    
  - `Object`: 在 `Dart` 中所有类型都是 `Object` 的子类型。所以可以将任何类型的值赋给一个 `Object` 类型的变量。但对于 `Object` 类型的变量，只能调用 `Object` 中定义的方法，即使实际的值可能有更多的方法。

    ```dart
    Object name = 'Bob';
    name = 'Alice';  // ✅
    name = 10;  // ✅
    name.length; // ❌
    ```

  - `dynamic`: 使用 `dynamic` 声明的变量可以赋予任何类型的值，并可以调用任何方法 (无论这个方法是否存在，如果不存在运行时会抛出异常）。`Dart` 在编译时不会检查 `dynamic` 类型变量的类型安全，所有的检查都留到了运行时。

    ```dart
    dynamic name = 'Bob';
    name = 'Alice';  // ✅
    name = 10;   // ✅
    name.length; // ✅
    name.foo();  // Runtime ❌
    ```
:::

------

## 函数

### ❓`Dart` 中 `..` 表示什么意思

::: details 💡 

> `..` : 级联运算符 (`Cascade notation`)。

级联运算符允许在同一个对象上执行一系列操作。这可以使代码更加简洁，只需要引用对象一次，然后执行多个操作。

```dart
var myObject = SomeClass();
myObject.method1();
myObject.method2();
myObject.method3();

// 使用级联操作符
var myObject = SomeClass()
  ..method1()
  ..method2()
  ..method3();
  
// 注意：级联操作的结果是表达式的目标，也就是说依然是 myObject，而不是最后一条语句的返回值。
```

:::

### ❓`Dart` 的作用域

::: details 💡 

> 作用域：是一种规定变量，函数和对象的可访问范围的机制。

  - 局部作用域：在函数或方法中声明的变量只能在其内部使用。

    ```dart
    void main() {
      // 局部变量
      var x = 'Hello World'; // x is only accessible within main() function
      print(x);
    }
    ```

  - 全局作用域：在函数或方法外部声明的变量可以在程序的任意位置使用。

    ```dart
    // 全局变量
    var x = 'Hello World';  // x is accessible anywhere in the code
    
    void main() {
      print(x);  // can access x within main() function
    }
    ```

  - 词法作用域：这意味着变量的作用范围是静态的，由代码的布局决定。

    ```dart
    var x = 'Hello World';  // x is accessible anywhere in the code
    
    void main() {
      var x = 'Hello Dart';  // This x variable is not the same as the global x
      print(x);  // This will print 'Hello Dart'
    }
    ```

  - 块作用域：大括号 `{}` 内部声明的变量具有块级作用域，也就是它们仅在这个块中可见。

    ```dart
    void main() {
      if(true) {
        var x = 'Hello';  // x is only accessible within this if block
        print(x);  // This will print 'Hello'
      }
      print(x);  // Error: x is not accessible outside the if block
    }
    ``` 
    
:::

------

## 类

### ❓`Dart` 中的 `callable` 了解吗

::: details 💡 

> `callable` 类通过实现 `call` 方法来使类实例可以像函数那样被调用。

```dart
class Increment {
  final int incrementBy;

  Increment(this.incrementBy);

  // 定义 call 方法
  int call(int value) => value + incrementBy;
}

var incrementByTwo = Increment(2);
print(incrementByTwo(3)); // Output: 5
```

:::

### ❓`Dart` 中使用抽象类 `extends` 和 `implements` 的区别

::: details 💡 

  - `extends`：当一个类 `extends` 一个抽象类时，它从抽象类中继承了所有的方法(包括已实现的和未实现的方法)，并且必须实现所有未实现的方法。同时，由于 `Dart` 的单继承特性，一个类只能 `extends` 一个类，无论抽象类或者非抽象类。

  - `implements`：当一个类 `implements` 一个抽象类时，它必须实现抽象类中的所有方法，因为 `implements` 就好比是一个契约，承诺的类将提供某些功能。可以同时 `implements` 多个类或抽象类，但不存在任何方法或属性的继承。

```dart
abstract class Animal {
  void makeSound();
  void eat() => print("Eating...");
}

// 继承形式使用抽象类
class Dog extends Animal {
  @override
  void makeSound() => print("Woof!!!");
}

// 接口形式使用抽象类
class Cat implements Animal {
  @override
  void makeSound() => print("Meow!!!");

  @override
  void eat() => print("The cat is eating...");
}

void main() {
  Dog dog = Dog();
  dog.makeSound();  // Woof!!!
  dog.eat();        // Eating...

  Cat cat = Cat();
  cat.makeSound();  // Meow!!!
  cat.eat();        // The cat is eating...
}
```
:::

### ❓说一下 `mixin`

::: details 💡 

> `mixin`: “混入”，一种在多个类之间重用代码的方式。它提供了一种实现方法重用的方式，并且不需要创建和使用复杂的类层次。

  - 一个类可以混入多个 `mixin`，`mixin` 也可以继承其它 `mixin`。
  - `mixin` 不能定义构造函数，也不能从类扩展而来时。这是因为 `mixin` 本质上是一种对接口的补充，它描述的是行为，而不是状态。

```dart
mixin Flyable {
  fly() {
    print('I can fly!');
  }
}

// 使用 with 混入 Flyable
class Bird with Flyable { }

void main() {
  Bird b = Bird();
  b.fly();  // 打印 'I can fly!'
}
```

:::

### ❓`mixin` `extends` `implement` 之间的关系

::: details 💡 

  - `mixin`：一种将类的代码在多个类层次结构中复用的方法。使用 `mixin` 关键字定义类，然后使用 `with` 关键字将其混入另一个类。注意，`mixin` 类不能被实例化，也不能有构造函数。

    ```dart
    mixin Musical {
      void sing() {
        print('Singing...');
      }
    }
    
    class Musician extends Person with Musical {
      // We can now use the sing() method in Musician.
    }
    ```
    
  - `extends`：类可以通过 `extends` 关键字继承一个父类。不支持多继承，一个子类只能继承一个父类。

    ```dart
    class Vehicle {
      void drive() {
        print('Driving...');
      }
    }
    
    class Car extends Vehicle {
      void honk() {
        print('Honking...');
      }
      @override
      void drive() {
        print('Driving car...');
      }
    }
    ```

  - `implements`：用于实现一个接口。接口是方法和属性的集合，它被用作通用模板，一旦被类实现，这个类就必须实现接口中的所有方法和属性。 

    ```dart
    abstract class Animal {
      void walk();
      void makeNoise();
    }
    
    class Dog implements Animal {
      @override
      void walk() {
        print('The dog is walking.');
      }
      
      @override
      void makeNoise() {
        print('The dog is barking.');
      }
    }
    
    void main() {
      Dog dog = Dog();
      dog.walk();
      dog.makeNoise();
    }
    ```
    
:::

### ❓`Dart` 为啥没有反射

::: details 💡 

  > 因为反射会影响 `Dart` 的 `tree shaking`(摇树优化)。这是一种无用代码裁剪技术，有利于优化发布版本的 `App` 体积。如果反射机制存在，会存在隐式代码，`tree shaking` 时无法准确定位运行时哪些代码不会被调用，冗余代码就没法被裁剪。

注意：`Dart` 其实是支持反射的，反射在 `dart:mirrors` 库中实现，提供了一系列用于执行反射操作的类和方法。

:::
  
### ❓`Dart` 中如何使用反射

::: details 💡 

> 反射：一种动态语言特性，可以在运行时检查和修改程序。在 `dart:mirrors` 包中实现，该包提供了一系列用于执行反射操作的类和方法。
  
  - `ClassMirror` : 类
  - `InstanceMirror` : 实例 
  - `ClosureMirror` : 闭包
  - `DeclarationMirror` : 类属性
  - `IsolateMirror` : Isolate
  - `MethodMirror` : 方法

```dart
import 'dart:mirrors';

class MyClass {
  MyClass(String message) {
    print('New object created. Message: $message');
  }

  void myMethod(String message) {
    print('myMethod called. Message: $message');
  }
}

void main() {
  // 获取 MyClass 的类镜像
  ClassMirror classMirror = reflectClass(MyClass);

  // 用 MyClass 的构造函数创建新实例
  var myClassInstanceMirror = classMirror.newInstance(Symbol(''), ['Hello Constructor']);
  
  // 获取 MyClass 的实例
  MyClass myClassInstance = myClassInstanceMirror.reflectee;

  // 获取 MyClass.myMethod 的方法镜像
  var myMethodMirror = reflect(myClassInstance).type.instanceMembers[Symbol('myMethod')];

  // 通过反射调用 myMethod
  myMethodMirror.invoke(myClassInstanceMirror, ['Hello Method']);
}
```

  注意：`dart:mirrors` 库（以及所有的反射在 `Dart` 中）在 `web` 场景中并不被所有的编译目标(例如 `dart2js` 或 `flutter web`)支持，并且可能对程序的体积和性能有所影响。因此，在将代码部署到生产环境之前，应仔细考虑是否需要使用反射。

:::

### ❓`Dart` 中单例如何实现

::: details 💡 

```dart
class Singleton {
  // 创建 Singleton 类的一个对象
  static final Singleton _singleton = Singleton._internal();
  // 单例内部构造函数
  Singleton._internal(); 
  
  // 声明一个工厂构造函数并返回前面创建的对象
  factory Singleton() {
    return _singleton;
  }
}

void main() {
  var s1 = Singleton();
  var s2 = Singleton();
  
  print(identical(s1, s2));  // true
}
```

:::
  
------

## 异步编程
  
### ❓说一下 `Future`

::: details 💡 

> `Future`：一个代表未完成的计算的类。可以把它想象成一个会在将来某个时间返回一个值（或错误）的操作。

```dart
void main() {
  // 创建一个 Future
  Future<String> future = Future.delayed(
    Duration(seconds: 2),
    () => 'Hello, Future!',
  );
  
  // 注册回调
  future.then(print);  // 当 Future 完成时，会打印 'Hello, Future!'
}
```

:::

### ❓说一下 `Stream`

::: details 💡 

> `Stream`：用于序列化异步事件。与只完成一次的 `Future` 不同，`Stream` 能够发出多个值。

  - 可以把 `Stream` 理解成一个异步的数组，就像一个流水线，可以在流水线的一端投入数据，在另一端处理数据，数据在流水线上移动时并不会阻塁主线程的执行。  
  - 向 `Stream` 添加数据的最常用方式是使用 `StreamController`，可以使用 `StreamController` 管理数据的添加和 `Stream` 的监听。

```dart
void main() {
  // 创建一个 Stream 
  const data = [1, 2, 3, 4, 5];
  final stream = Stream.fromIterable(data);

  // 监听 Stream
  stream.listen(print);  // 打印 1, 2, 3, 4, 5
}
```

:::

### ❓`await for` 如何使用

::: details 💡 

> `await for` 循环用于异步迭代 `Stream` 的元素。使用 `await for` 会暂停函数的执行，直到整个 `Stream` 被处理完毕。

```dart
Future<void> printStream(Stream<int> stream) async {
  await for (var number in stream) {
    print(number);
  }
}

void main() {
  var stream = Stream.fromIterable([1, 2, 3, 4, 5]);
  printStream(stream);
}
```

:::

---
title: Flutter
icon: hashtag

index: true

---

<!-- more -->

## `Flutter`

### ❓命令式 `UI` vs 声明式 `UI`
  
::: details 💡 

  - 命令式 : 告诉程序一步一步如何搭建所需要的界面，类似做菜的教程
  - 声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单

命令式 `UI` 和声明式 `UI` 是两种不同的用户界面编程范式。

  - 命令式 `UI`: 一种更为**传统**的编程范式，开发者需要手动管理 `UI` 的状态，当状态发生变化时，也需要手动更新 `UI`。
    > 例如，开发者需要知道何时调用 `UI` 库的方法去创建部件，并且保存这些部件的引用，以便之后可以更新或删除它们。命令式 `UI` 编程的挑战是同步状态和 `UI` 视图的复杂性。

  - 声明式 `UI`: 一种更为**现代**的编程范式，开发者仅需要声明 `UI` 应该如何根据当前状态进行展示，而无需手动管理 `UI` 的创建和更新。如果状态发生变化，`UI` 框架会自动重新构建 `UI`。
    > 在声明式 `UI` 中，状态和 `UI` 视图的同步已经被内部处理，开发者可以专注于描述 `UI` 的外观和行为，而不需要关注如何同步状态和视图。

对比：

  - 命令式 `UI` 的优点包括更细粒度的控制，但缺点是需要手动管理 `UI` 和状态的同步。
  - 声明式 `UI` 的优点是简化了状态管理，使 `UI` 代码更清晰，但缺点是它通常需要更多的内存和 `CPU` 来处理 `UI` 的自动更新。

:::

### ❓`Flutter` 与 `RN` (`React Native`) 不同之处

::: details 💡 

  - 开发语言：
    * `React Native` 使用的是 `JavaScript
    * `Flutter` 使用的是 `Dart`

  - `UI` 组件
    * `React Native` 依赖于原生控件来呈现用户界面，这可能会导致在不同平台之间的 `UI` 和 `UX` 有所不同。
    * `Flutter` 有一套自己的 `Widget`（包含 `Material` 和 `Cupertino`），这些 `Widget` 完全用 `Dart` 实现，并且在不同的平台中有着一致的行为和外观。
  
  - 性能：由于 `Flutter` 使用 `Dart` 语言，并使用自身的高性能渲染引擎进行绘制，所以一般情况下，`Flutter` 的性能要优于 `React Native`。

  - 社区和生态系统
    * `React Native` 由于发布得更早，并且得益于庞大的 `JavaScript` 社区，其生态系统相对较成熟，提供的第三方库也更多。
    * `Flutter` 起步较晚，但由于其出色的设计和性能，社区发展也非常迅速，并且得到了 `Google` 的大力推广和支持。

  - 热重载：都支持热重载功能，但 `Flutter` 的热重载速度通常更快。

  - 学习曲线：
    * 对于已经熟悉 `JavaScript` 的开发者来说，`React Native` 的学习曲线可能会相对较缓和容易。
    * `Dart` 其语言特性与 `Java` 和 `C#` 等主流语言相近，因此对已有这些背景的开发者来说，学习曲线也并不陡峭。

:::

### ❓`Flutter` 跨平台是如何实现的

::: details 💡 

  `Flutter` 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。
  
  - 界面渲染 : 内置的高性能渲染引擎。
    * `Skia` 绘制引擎进行视图的统一渲染。
        > 相比于其他跨平台解决方案，如 `React Native` 或者 `Cordova` 这种依赖于原生控件的方式，`Flutter` 自己在引擎层面提供了一套 `2D` 渲染引擎，使用 `OpenGL` 或 `Vulkan` 等底层图形库直接与设备硬件交互，再加上其以 `Dart` 语言为基础的高效调度机制，使得 `Flutter` 可以在 `Android` 和 `iOS` 系统上执行高效的 `GPU` 渲染。
    * 丰富的组件。
        > 在Flutter中，所有的组件 (`Widget`) 都是由底层绘制，并提供了 `Material` 和 `Cupertino` 两套设计语言风格的控件。
    
  - 原生通信 : 通过 `Channel` 机制进行与原生进行交互，实现特定的 `Plugin` 来访问原生功能。
    * `BasicMessageChannel` : 用于基本的字符串信息通信
    * `MethodChannel` : 方法调用通信
    * `EventChannel` : 数据流通信
  
:::

### ❓为什么说 `Flutter` 是原生的

::: details 💡 

  - 性能接近原生：`Flutter` 使用 `Dart` 语言，`Dart` 代码会被直接编译为机器代码，无须额外的 `JavaScript` 桥接层，因此性能与原生接近。而且 `Flutter` 引擎中有自己的图形渲染引擎，直接利用 `GPU` 进行渲染，因此图形渲染性能非常高。

  - 访问原生功能：虽然 `Flutter` 的 `UI` 构建是独立于平台的，但是它的插件系统允许 `Flutter` 访问每个平台的原生代码，如相机、定位、蓝牙等。开发者也可以编写自定义插件，调用原生 `API`，实现自定义功能。

  - 构建原生应用：`Flutter` 构建的应用程序是真正的 `iOS` 和 `Android` 应用程序，它会被编译成 `ARM` 或 `x86` 二进制代码，可以直接在设备上运行，不依赖于任何 `WebView`。

  - 原生般的用户体验：`Flutter` 为 `Android` 和 `iOS` 提供了分别遵循 `Material` 和 `Cupertino` 设计语言的两套 `Widget`，它们完全用 `Dart` 实现，有着一致的行为和外观，细节也处理得非常好。最终给用户带来的就是与原生应用无异的体验。

:::

### ❓`Flutter` 的优缺点

::: details 💡 

优点：

  - 高性能： `Flutter` 使用 `Dart` 语言开发，`Dart` 语言执行效率高，节省了不少性能；`Flutter` 引擎中有自己的图形渲染引擎，直接利用 `GPU` 进行渲染，因此图形渲染性能非常高，避免了 `JavaScript` 桥接层。

  - 开发效率高：`Flutter` 支持热重载，进行小的更改可以在几秒内在设备或模拟器上看到效果。
    
  - 良好的用户体验：`Flutter` 不需要借助第三方库也可以实现良好的界面体验。引入了自己的设计和交互模式，使 `UI` 设计在不同的平台上看起来很一致。

  - 跨平台： 编写一套代码，即可在 `iOS` 和 `Android` 上运行。
    
  - 强大的社区支持：虽然 `Flutter` 还相对较新，但由于它是由 `Google` 建立并支持，因此已经有了一个很大，积极的社区。

缺点：

  - 编程语言：`Dart` 不如 `JavaScript` 那么流行，如果团队成员还不熟悉 `Dart` 的话，可能需要花一些时间去学。

  - 类库生态：由于 `Flutter` 比 `React` 或者 `React Native` 等其他一些框架发布得晚，所以 `Flutter` 提供的开放源代码库和框架没有那么多。

  - 包体积大小：`Flutter` 应用程序的基础大小相对较大，尽管团队正在努力进行优化，但是如果正在开发应该尽可能小的应用程序，这可能是需要考虑的因素。

:::

------

## `Widget`

### ❓`ListView` 与 `Sliver` 区别  

::: details 💡 

  - `ListView`: 一个常用的滚动列表控件，可以包含多个子控件并在垂直或水平方向滚动。
    > 最常用的长列表展示的控件，适用于大多数的滚动列表场景，例如新闻和社交应用里的信息流。

  - `Sliver`: 一种特殊类型的可滚动组件，在效果上可以实现更为复杂的滚动模型和高级效果。
    > 如折叠工具栏(`Collapsing Toolbar`)，或者在滚动时改变其他元素的布局。这些效果在  `ListView`中不能直接实现，需要使用 `Sliver Widget` 进行布局。

总结：`ListView`更简单直接，方便快速构建滚动列表；`Sliver`为开发者提供了更多的可能性和自由度，来构建高级和富交互的滚动效果，但使用和理解起来相对较复杂一些。

:::

------

## `lifecycle` - “生命周期”

### ❓`Flutter` 的生命周期

::: details 💡 

  - 应用级别的生命周期
    
    * `created`（应用程序启动）
    * `running`（应用程序处于激活状态，界面可见）
    * `paused`（应用程序处于非激活状态，界面不可见）
    * `suspended`（应用程序被系统暂停）。

  - `Widget` 级别的生命周期

    * `createState()`: 创建状态，当构建一个新的 `StatefulWidget` 时，会立即调用此方法。
    * `initState()`: 初始化，在创建 `State` 对象后调用，在整个生命周期中只会被调用一次。
    * `didChangeDependencies()`: 状态改变时调用，可能会被多次调用。
    * `build()`: 构建方法，用于构建 `UI` 界面，可能会被多次调用。
    * `didUpdateWidget()`: 当 `Widget` 中的配置改变时就会调用此函数。
    * `deactivate()`: 移除时调用，当 `State` 对象从树中被移除时，会调用此方法。
    * `dispose()`: 销毁时调用，当 `State` 对象永久从树中被移除时，会调用此方法，常用于资源清理。
    
:::

### ❓`Flutter` 中 `didChangeDependencies()` 哪些情况下会触发

::: details 💡

  - 第一次构建 `Widget` 时: 在生命周期内，这是 `State` 对象第一次创建完后会调用的方法，当 `State` 对象的依赖发生变化后也会调用此方法。

  - 调用 `initState` 后: 初始化状态后，系统总是马上调用 `didChangeDependencies` 函数。

  - `InheritedWidget`改变时: 如果当前 `State` 对象依赖的 `InheritedWidget` 发生改变（即数据发生改变），会重新构建当前 `Widget`（即调用 `build` 方法），之前会调用 `didChangeDependencies` 方法。

  - 使用 `Theme.of(context)` 或 `MediaQuery.of(context)` 等类似方法时，它们内部使用 `InheritedWidget` 来共享数据，所以它们可能会改变，然后触发 `didChangeDependencies()`。

  - 使用 `Navigator.of(context)` 调用时: 如果 `Widget` 的构造函数引用了与它有关联关系的数据，一旦这些数据改变， `didChangeDependencies()` 就会被触发。

:::

### ❓`Flutter` 如何统一管理错误页面

::: details 💡 

  - `ErrorWidget.builder`：`Flutter` 框架级别的错误页面处理方法，所有的 `Widget` 错误都会走这里，但这里只会处理非 `debug` 模式(生产模式)下的错误。

  - 使用 `FutureBuilder` 或 `StreamBuilder`：对于网络请求等异步操作产生的错误，通过 `builder` 属性中判断请求状态，如果发生错误，则展示错误页面。

  - 使用 `Flutter` 的路由管理：针对特定的路由展示特殊的错误页面。比如当路由到某页面时，预加载数据发生错误，可以直接展示错误页面。

  - 使用 `try-catch`：在可能发生异常的操作中使用 `try-catch`，如果捕获到异常就展示相应的错误页面。

  - 自定义预期内的错误：如网络请求返回码非成功码，可以抛出自定义异常，然后在上层统一捕获并处理。

  - 全局错误页面：可以通过设置 `Flutter` 的 `navigatorObservers`，当发生错误的时候，导航到特定的错误页面。

:::

------

## 触摸事件

### ❓`hitTest` 和 `dispatchEvent`

::: details 💡

> `hitTest` 和 `dispatchEvent` 是配合使用的。首先通过 `hitTest` 找到用户触摸的 `Widget`，然后通过  `dispatchEvent` 给找到的 `Widget` 分发事件。两者是构成 `Flutter` 触摸事件系统的重要组成部分。

  - `hitTest`: 主要用于检测用户的触摸操作是否击中了某个 `Widget`。
    > 当用户触摸屏幕时，会触发 `hitTest` 方法来确定用户究竟触摸到了哪个 `Widget`。`hitTest` 方法需要一个命中测试对象（一个表示屏幕上一个点的对象，比如一个 `Offset`）作为参数。`hitTest` 在 `Widget` 树中进行，从根节点开始，沿着树形结构，一直走到叶节点。结果存储在由 `HitTestResult` 类实例化的对象中，这个对象被称为 “命中测试结果”。

  - `dispatchEvent`: 主要用于分发触摸事件。
    > 当 `hitTest` 命中测试结束后，系统知道了用户触摸到的 `Widget`，然后就会将这个触摸事件分发给这个 `Widget`，这个过程就是通过调用 `dispatchEvent` 来完成的。`dispatchEvent` 需要一个触摸事件（`PointerEvent`）作为参数，它的分发是从命中测试路径的末尾（也就是最顶层的 `Widget`）开始的，然后一直往路径的开始返回，直到所有的 `Widget` 都收到了这个事件或者有一个 `Widget` 消耗了它（返回true）。
    
:::

------

## 滑动原理


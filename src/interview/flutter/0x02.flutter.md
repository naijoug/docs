---
title: Flutter
icon: hashtag

index: true

---

<!-- more -->

## `Flutter`

### ❓命令式 `UI` vs 声明式 `UI`
  
::: details 💡 

  - 命令式 : 告诉程序一步一步如何搭建我所需要的界面，类似做菜的教程
  - 声明式 : 告诉程序我需要一个怎样的界面，类似做菜的菜单

  命令式UI和声明式UI是两种不同的用户界面编程范式。

  命令式UI是一种更为传统的编程范式，开发者需要手动管理UI的状态，当状态发生变化时，也需要手动更新UI。例如，开发者需要知道何时调用UI库的方法去创建部件，并且保存这些部件的引用，以便之后可以更新或删除它们。命令式UI编程的挑战是同步状态和UI视图的复杂性。

  声明式UI则是一种更为现代的编程范式，开发者仅需要声明UI应该如何根据当前状态进行展示，而无需手动管理UI的创建和更新。如果状态发生变化，UI框架会自动重新构建UI。在声明式UI中，状态和UI视图的同步已经被内部处理，开发者可以专注于描述UI的外观和行为，而不需要关注如何同步状态和视图。

  Flutter采用的是声明式UI编程范式。在Flutter中，一切都是widget，UI的每个部分都由widget构建。当状态发生变化时，Flutter会自动更新UI。在这种模式下，开发者只需关心应用状态的维护，没必要去手动操作DOM，将更多精力放在业务逻辑的实现上。

综上所述，命令式UI和声明式UI各有利弊。命令式UI的优点包括更细粒度的控制，但缺点是需要手动管理UI和状态的同步。声明式UI的优点是简化了状态管理，使UI代码更清晰，但缺点是它通常需要更多的内存和CPU来处理UI的自动更新。

:::

### ❓`Flutter` 与 `RN` (`React Native`) 不同之处

::: details 💡 

Flutter和React Native都是现代的跨平台移动应用开发框架，它们都能在iOS和Android上创建原生性能级别的应用。但它们在许多方面也存在不同：

1. 开发语言：React Native使用的是JavaScript，而Flutter使用的是Dart。

2. UI组件：React Native依赖于原生控件来呈现用户界面，这可能会导致在不同平台之间的UI和UX有所不同。与此不同，Flutter有一套自己的Widget（包含Material Design和Cupertino），这些Widget完全用Dart实现，并且在不同的平台中有着一致的行为和外观。

3. 性能：由于Flutter使用Dart语言，并使用自身的高性能渲染引擎进行绘制，所以一般情况下，Flutter的性能要优于React Native。

4. 社区和生态系统：React Native由于发布得更早，并且得益于庞大的JavaScript社区，其生态系统相对较成熟，提供的第三方库也更多。虽然Flutter起步较晚，但由于其出色的设计和性能，社区发展也非常迅速，并且得到了Google的大力推广和支持。

5. 热重载：React Native和Flutter都支持热重载功能，但Flutter的热重载速度通常更快。

6. 学习曲线：对于已经熟悉JavaScript的开发者来说，React Native的学习曲线可能会相对较缓和容易。而Dart语言可能需要一些时间去学习，尤其是对于那些没有接触过的开发者。然而，其语言特性与Java和C#等主流语言相近，因此对已有这些背景的开发者来说，学习曲线也并不陡峭。

像大多数技术选择一样，Flutter和React Native的选择取决于项目的特定需要，如性能要求、开发时间、可用资源（如开发人员的技能和经验）以及社区和生态系统的支持等因素。

:::

### ❓`Widget` `Element` `RenderObject` 之间的关系

::: details 💡 

  `Flutter` 的三棵树，代表了使用树的数据结构构成的三种元素。

在Flutter中，`Widget`、`Element`和`RenderObject`三者是紧密相关的，它们一起构成了Flutter渲染UI的基础框架。

1. `Widget`： `Widget`是一个描述部件（用户界面元素）的配置数据。`Widget`本身是不可变的，当UI需要变化时，创建一个新的`Widget`实例。

2.  `Element`：`Element`是`Widget`在树形结构中的一个实例，可以认为`Element`是`Widget`的实例化，同时它也保存了子`Widget`的状态。`Element`使`Widget`获得了生命周期。

3. `RenderObject`：`RenderObject`是一个描述并实现了绘制操作的对象，也就是承担渲染工作的对象。

这三者之间的关系主要体现在如下过程：当我们在Flutter中构建UI时，我们会创建一组`Widget`。这组`Widget`会通过`createElement`方法创建对应的`Element`，并形成一个Element树（也就是`Widget`的具象化）。每个`Element`又会通过`createRenderObject`方法创建对应的`RenderObject`。在这个过程中，`Element`起到了桥梁的作用，它连接了`Widget`和`RenderObject`，使`Widget`的配置可以应用到`RenderObject`。

简单来说，`Widget`定义了他们的样式和行为，通过`Element`配置到`RenderObject`，然后由`RenderObject`进行实际的渲染。

:::

### ❓`Flutter` 跨平台是如何实现的

::: details 💡 

  `Flutter` 其实主要实现了两大块，一个是视图层的渲染，另一个调用原生功能。对于一款应用来说，核心就是展示给用户界面，再有就是与用户交互，交互过程中可能会涉及一些设备功能的调起(摄像头、麦克风、相册等)。
  
  - 界面渲染 : `Skia` 绘制引擎进行视图的统一渲染
  - 原生通信 : 通过 `Channel` 机制进行与原生进行交互
    * `BasicMessageChannel` : 用于基本的字符串信息通信
    * `MethodChannel` : 方法调用通信
    * `EventChannel` : 数据流通信
  
1. Flutter的跨平台能力主要依赖于其内置的高性能渲染引擎。相比于其他跨平台解决方案，如React Native或者Cordova这种依赖于原生控件的方式，Flutter自己在引擎层面提供了一套2D渲染引擎，使用OpenGL或Vulkan等底层图形库直接与设备硬件交互，再加上其以Dart语言为基础的高效调度机制，使得Flutter可以在Android和iOS系统上执行高效的GPU渲染。

2. Flutter的跨平台能力也离不开其组件丰富的特性。在Flutter中，所有的组件（在Flutter中叫做Widget）都是由底层绘制，整个UI系统和SDK都是用Dart语言实现的，所以在Android和iOS上的绘制效果和性能都是一致的。

3. 尽管Flutter所有组件都是自绘的，但是为了更好的交互体验，Flutter对Android和iOS上的控件分别实现，并提供了Material Design和Cupertino两套设计语言风格的控件。

4. 对于访问平台特性的需求，Flutter提供了plugins机制以支持开发者访问native SDK。Flutter本身也提供了大量常用的插件，比如访问GPS定位，读取传感器，播放视频，网络请求等，并且开发者也可以通过Flutter的插件机制轻松地封装自己的native代码。

5. 再加上Flutter的hot reload（热重载）机制，使得开发者在开发时可以对代码更改做到即时预览，极大地提高了跨平台开发的效率。

综上，通过自己维护一套独立的2D渲染引擎，提供丰富的Widget，支持热重载和插件等机制，Flutter实现了优秀的跨平台能力。

:::

### ❓为什么说 `Flutter` 是原生的

::: details 💡 

当我们说“Flutter是原生的”时，主要有以下几个方面的考虑：

1. 性能接近原生：Flutter使用Dart语言，Dart代码会被直接编译为机器代码，无须额外的JavaScript桥接层，因此性能与原生接近。而且Flutter引擎中有自己的图形渲染引擎，直接利用GPU进行渲染，因此图形渲染性能非常高。

2. 可以访问原生功能：虽然Flutter的UI构建是独立于平台的，但是它的插件系统允许Flutter访问每个平台的原生代码，如相机、定位、蓝牙等。开发者也可以编写自定义插件，调用原生API，实现自定义功能。

3. 构建真正的原生应用：Flutter构建的应用程序是真正的iOS和Android应用程序，它会被编译成ARM或x86二进制代码，可以直接在设备上运行，不依赖于任何web view。

4. 原生般的用户体验：Flutter为Android和iOS提供了分别遵循Material Design和Cupertino设计语言的两套Widget，它们完全用Dart实现，有着一致的行为和外观，细节也处理得非常好。最终给用户带来的就是与原生应用无异的体验。

这就是为什么我们可以说“Flutter是原生的”。尽管其开发体验是跨平台的，但它创建的应用程序在性能、功能和用户体验方面都能达到原生的效果。

:::

### ❓`Flutter` 的优缺点

::: details 💡 

Flutter的优点：

1. 高性能： Flutter 使用 Dart 语言开发，Dart 语言执行效率高，节省了不少性能，而且 Flutter 框架直接与嵌入式代码（native code）进行交互，避免了 JavaScript 桥接层，所以 Flutter 的性能接近原生。

2. 开发效率高：Flutter支持热重载，进行小的更改可以在几秒内在设备或模拟器上看到效果。

3. 良好的用户体验：Flutter 不需要借助第三方库也可以实现良好的界面体验。引入了自己的设计和交互模式，使 UI 设计在不同的平台上看起来很一致。

4. 跨平台： 编写一套代码，即可在 iOS 和 Android 上运行。

5. 强大的社区支持：虽然 Flutter 还相对较新，但由于它是由 Google 建立并支持，因此已经有了一个很大，积极的社区。

Flutter的缺点：

1. 可能需要学习一门新的语言：Dart 不如 JavaScript 那么流行，如果团队成员还不熟悉 Dart 的话，可能需要花一些时间去学。

2. 各类库的支持还不完全：由于 Flutter 比 React 或者 React Native 等其他一些框架发布得晚，所以 Flutter 提供的开放源代码库和框架没有那么多。

3. 大小：Flutter应用程序的基础大小相对较大，尽管团队正在努力进行优化，但是如果你正在开发应该尽可能小的应用程序，这可能是需要考虑的因素。

总的说，Flutter 的主要优势在于它允许快速开发，可以创建出具有原生性能的美观的用户界面。虽然 Flutter 还是新的，但是它正在增长，并且有许多大公司已经在使用它来构建应用，这已经证明了它是一个极具竞争力的移动开发框架。

:::

### ❓`Flutter` 的渲染原理

::: details 💡 

Flutter的应用程序界面渲染采用自下而上的方式，基于一个先进的2D渲染引擎（称为Skia）来创建视觉效果，包括文本、形状和颜色等。 

以下是Flutter渲染的基本过程：

1. 启动时，Flutter通过自身的高性能C++运行库加载并运行Dart代码。
2. Dart层采用声明式编程，这些声明（通常为在屏幕上显示的widget）全部保存在一个树状结构中，每当状态变化时，Flutter都会创建一个新的widget树。
3. 当widget树在Dart代码中有所更新，这些变化会转换为绘制命令。
4. 渲染引擎会按照widget树的层次顺序进行绘制，每一个widget都会映射为Skia画笔操作来进行渲染。
5. 最后生成的图像会在Flutter引擎中被组合在一起，并显示在设备的屏幕上。

这种方式使得Flutter可以轻松处理屏幕UI的更改，并允许开发人员非常灵活的操作和组合各种UI部件，而无需考虑设备屏幕的刷新率，也不需要努力在新旧屏幕帧之间进行过渡。类似游戏引擎的渲染方式，从而为应用带来极好的性能和视觉效果。

:::

### `Flutter` 中的 `Key` 可以说一下

::: details 💡 

Key 在 Flutter 中被用于控制框架在更新 widget 树时如何与旧的 widget 进行匹配。

默认情况下，在 Flutter 中，框架会根据当前 widget 的类型和位置来匹配旧的 widget。举个常见的例子，如果你有一个无 key 的 widget 列表，随后你向列表的起始位置添加一个新的项目，那么你会发现所有的项目都向下移动了一位，新的 widget 实际上被渲染到了列表的最后一个项目的位置。这发生的原因就在于 Flutter 没有一个唯一的方式来确定新加入的 widget 应该插入到列表的哪个位置。

这里就是 Key 起作用的地方。通过给每个 widget 添加一个全局唯一的 key，Flutter 可以唯一地确定 widget 树中的每一个节点，从而在新旧 widget 进行匹配更新时知道如何进行正确的匹配。

Key 在 Flutter 中主要有以下几种类型：

1. ValueKey：这是最常见的一种 key，它需要一个与当前 widget 相关联的值，并且这个值在整个 widget 树中是唯一的。

2. ObjectKey：这个 key 在它所关联的对象的整个生命周期内保持一致。

3. UniqueKey：这个 key 在每次创建时都是全局唯一的，通常用来控制“顺序无关”的列表。

4. GlobalKey：这个 key 不仅在整个 widget 树中保持一致，而且允许在树中的任何地方进行访问和操作。但是过度使用 GlobalKey 可能会导致性能问题。

总的来说，key 在许多需要保持 widget 状态的情况下是非常有用的。但是过度使用 key 也可能容易引发一些问题，如性能问题，正确的做法是在需要保持 widget 状态的情况下恰当地使用 key。

:::

------

## `Widget`

### ❓`ListView` 与 `Sliver` 区别  

::: details 💡 

`ListView`和`Sliver`都是Flutter的布局控件，但是它们服务的场景和用法是有差别的。

1.`ListView`是一个常用的滚动列表控件，可以包含多个子控件并在垂直或水平方向滚动。在Flutter开发中，他是最常用的长列表展示的控件，适用于大多数的滚动列表场景，例如新闻和社交应用里的信息流。

2.`Sliver`是Flutter中的一种特殊类型的可滚动组件，在效果上可以实现更为复杂的滚动模型和高级效果，如折叠工具栏(Collapsing Toolbar)，或者在滚动时改变其他元素的布局。这些效果在ListView中不能直接实现，需要使用Sliver Widget进行布局。

总体来说，`ListView`更简单直接，方便快速构建滚动列表，而`Sliver`为开发者提供了更多的可能性和自由度，来构建高级和富交互的滚动效果，但使用和理解起来相对较复杂一些。

:::

### ❓`InheritedWidget` 作用

::: details 💡 

`InheritedWidget`是Flutter 中一个非常重要的幕后角色，主要用于在Widget树中有效地传递数据。

Flutter中，widget是不可变的，由于其自身不能改变，所以如果有任何数据更改，总是按照从上到下的方式重新构建所有的widget。然而这可能导致重绘的性能问题，特别是对于大型树状结构来说。

`InheritedWidget`则为这个问题提供了解决方案。它允许开发者在Widget树的顶部或任何位置提供数据，然后这些数据可以在树的任何下层都能获取到。当`InheritedWidget`更新时，它会通知使用其数据的所有widget，这些widget只需通过`BuildContext`即可访问到这些数据，这个过程称为依赖。

换句话说，它可以让开发者更高效地分享数据，避免了不必要的widget重置，避免了一些性能问题，同时让widget树的状态管理更加清晰和方便。举个例子，Flutter本身的 `Theme` 和 `Locale` 就是通过 `InheritedWidget` 来传递的。

:::

------

## `lifecycle` - “生命周期”

### ❓`Flutter` 的生命周期

::: details 💡 

Flutter中的生命周期主要针对两个层面，一个是应用级别的生命周期，另一个是Widget级别的生命周期。

1. 应用级别的生命周期：主要的状态有`created`（应用程序启动）、`running`（应用程序处于激活状态，界面可见）、`paused`（应用程序处于非激活状态，界面不可见）以及`suspended`（应用程序被系统暂停）。

2. Widget级别的生命周期：主要的状态有：

- `createState()`: 创建状态，当我们构建一个新的StatefulWidget时，会立即调用此方法。

- `initState()`: 初始化，在创建State对象后调用，在整个生命周期中只会被调用一次。

- `didChangeDependencies()`: 状态改变时调用，可能会被多次调用。

- `build()`: 构建方法，用于构建UI界面，典型的Flutter函数式编程思维，可能会被多次调用。

- `didUpdateWidget()`: 当Widget中的配置改变时就会调用此函数。

- `deactivate()`: 移除时调用，当State对象从树中被移除时，会调用此方法。

- `dispose()`: 销毁时调用，当State对象永久从树中被移除时，Framework会调用此方法，常用于资源清理。

总的来说，理解和掌握Flutter应用和Widget的生命周期对于编写高效和优质的Flutter代码非常重要。

:::
  
------
  
## `state` - “状态管理”

### ❓说一下什么是状态管理

::: details 💡 

状态管理是处理应用中数据改变以及数据如何影响应用界面的过程。在开发应用程序时，我们操作的是用户的交互行为，后台数据，以及应用向用户展示的视图，这些因素的改变都需要被适当地管理。 数据管理和视图反馈的过程就是状态管理。

为什么我们需要状态管理？

1. 在复杂的应用中，有些数据需要在很多页面中使用。使用全局的状态管理可以使我们的应用保持同步，避免数据在各个页面之间产生不一致。

2. 状态管理利于代码的结构清晰，具有可控性、可预测性。在大型项目中尤其重要，因为它有助于降低调试和理解代码的复杂性。

3. 状态管理能提高渲染效iciency。在React或者Flutter这种声明式编程框架中，当本地状态发生变化时，会引起组件的重新渲染，而状态管理库通过维护一个单一的状态树，能够有选择性地通知某一部分的组件去更新，提高渲染效率。

状态管理的实现方式有很多，Flutter中常见的有 Provider, Redux, Bloc 等。

:::

### ❓`Provider` `BLoc` `GetX` 区别
  
::: details 💡 

`Provider`, `BLoC` 和 `GetX` 都是用于状态管理的Flutter库，他们执行相同的目的：帮助开发者管理和传递状态，但彼此之间存在一些差异。

`Provider` 是业界并且 Google 官方推荐的状态管理库，它是基于 InheritedWidget 的数据流传递。它可以直接使用状态，状态变化自动通知其依赖组件进行刷新，使用简直且入门容易。

`BLoC（Business Logic Component）` 是Google推出的一种应用程序架构设计模式。其核心概念是，通过使用dart的Stream，将数据的输入输出抽象为Sink和Stream，进行业务逻辑处理。BLoC相比Provider更适合大型项目，可以实现更大程度的代码解耦。

`GetX` 是来自社区的Flutter库，它不仅实现了状态管理，还提供了路由管理，依赖注入等功能。GetX优势在于其简洁的API、高效的性能以及对空安全的天然支持。不过GetX的缺点也比较明显，由于是来自社区，未来的维护以及发展不确定性较高。

总的来说，Provider, BLoC 和 GetX 都有各自适用的场景，开发者可以根据项目需求，自身技术水平和团队状况等来选择对应的状态管理解决方案。

:::
  
### ❓说一下 BLoC 模式

::: details 💡 

BLoC（Business Logic Component）是Google推出的一种应用程序架构设计模式。其核心概念是，将"事件(event)"流转换为"状态(state)"流。

在Flutter中使用BLoC模式，主要分以下几个步骤：

1. 定义事件（Event）：这些事件表示可以从用户界面发送到BLoC的各种操作，例如用户的点击，拖动以及其他行为。

2. 定义状态（State）：这些状态表示BLoC在接收事件后可能处于的不同状态，例如加载，成功，错误等。

3. 创建 BLoC：BLoC生产状态(state)流，并消费事件(event)流。在BLoC内部，我们使用一个或多个Stream来表示状态，使用Sink来接收事件。BLoC里面的业务逻辑就是将事件流转变为状态流。

4. 在UI中使用BLoC：在Flutter中，我们通常使用StreamBuilder和各种事件触发器如按钮点击，来连接BLoC和UI。

BLoC模式的优点是可以将业务逻辑完全从UI层中分离出来，使得代码更加模块化并且易于测试。同时，BLoC模式也提高了应用的响应性，因为它基于流，可以便捷地处理异步操作和各种事件。

:::

### ❓`Flutter` 如何统一管理错误页面

::: details 💡 

在Flutter中，管理错误页面主要采取以下几种方式：

1. 使用`ErrorWidget.builder`全局处理错误：`ErrorWidget.builder`是Flutter框架级别的错误页面处理方法，所有的widget错误都会走这里，但这里只会处理非debug模式(生产模式)下的错误。

2. 对于网络请求等异步操作产生的错误，我们可以使用`FutureBuilder`或`StreamBuilder`来进行统一处理。在`FutureBuilder`或`StreamBuilder`的`builder`属性中判断请求状态，如果发生错误，则展示错误页面。

3. 使用Flutter的路由管理，针对特定的路由展示特殊的错误页面。比如当路由到某页面时，预加载数据发生错误，我们可以直接展示错误页面。

4. 使用try-catch捕获错误并处理。在可能发生异常的操作中使用try-catch，如果捕获到异常就展示相应的错误页面。

5. 自定义预期内的错误，如网络请求返回码非成功码，可以抛出自定义异常，然后在上层统一捕获并处理。

6. 全局错误页面，可以通过设置 Flutter的 `navigatorObservers`，当发生错误的时候，导航到特定的错误页面。

总的来说，正确的错误处理可以显著提高程序的健壮性，并提供更好的用户体验。捕获并处理错误，展示友好的错误页面是十分有必要的。

:::
  
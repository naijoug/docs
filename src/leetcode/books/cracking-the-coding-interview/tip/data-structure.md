---
title: 数据结构
icon: hashtag

index: true
order: 1

---

## 0 ~ 99

#1. 1.2 描述两个字符串是否互为字符重排的含义。现在，看看你提供的定义，你能否根据这个定义检查字符串？

#2. 3.1 栈只是一个数据结构，其中最近添加的元素首先被删除。你能用一个数组来模拟单个栈吗？请记住，有很多可能的解法且每个解法都有其利弊。

#3. 2.4 这个问题有很多解法，其中大部分都有最优的运行时间。有些代码比其他代码更短，更干净。你可以想出不同的解法吗？

#4. 4.10 如果T2是T1的子树，它的中序遍历将如何与T1的比较？它的前序和后序遍历如何？

#5. 2.6 回文数在向前写和向后写时是相同的。如果你颠倒链表会怎样？

#6. 4.12 尝试简化问题。如果路径必须从根开始会如何？

#7. 2.5 当然，你可以将链表转换为整数，计算总和，然后将其转换回新的链表。如果你在面试中这样做，面试官可能会接受答案，然后看看你在不能将其转换为数字然后返回的情况下，还能否做到这一点。

#8. 2.2 如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？

#9. 2.1 你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。

#10. 4.8 如果每个节点都有一个到其父节点的链接，我们可以利用9.2节问题2.7的方法。然而，面试官可能不会让我们作出这样的假设。

#11. 4.10 中序遍历无法告诉我们更多。毕竟，每个具有相同值的二叉搜索树（不管结构如何）将具有相同的中序遍历。这也就是中序遍历的含义：内容是有序的（如果它在二叉搜索树这种特定情况下不起作用，那么对于一般二叉树来说它肯定不起作用）。然而，前序遍历更具指示性。

#12. 3.1 我们可以通过将数组的前三分之一分配到第一个栈、第二个三分之一分配到第二个栈、最后的第三个三分之一分配到第三个栈，来模拟数组中的三个栈。然而，实际上某个栈可能比其他的大得多。能更灵活地分配吗？

#13. 2.6 用栈试试。

#14. 4.12 不要忘记路径可能会重叠。例如，如果你正在寻找总和6，那么路径1-> 3->2和1-> 3->2-> 4-> 6-> 2都是有效的。

#15. 3.5 排序数组的一种方法是遍历数组，并将每个元素按排序顺序插入到一个新数组中。你可以用一个栈实现吗？

#16. 4.8 第一个共同的祖先是最深的节点，这样p和q都是后代。想想你要如何识别这个节点。

#17. 1.8 如果你在找到0时清除了行和列，则可能会清理整个矩阵。在对矩阵进行任何更改之前，首先尝试找到所有的0。

#18. 4.10 你可能得出结论，如果T2.preorderTraversal()是T1.preorderTraversal()的子字符串，则T2是T1的子树。这几乎是事实，除非树可能有重复的值。假设T1和T2具有所有重复值，但结构不同。即使T2不是T1的子树，前序遍历看起来也是一样的。你如何处理这样的情况？

#19. 4.2 最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？

#20. 2.7 你可以在O(A+B)的时间和额外的O(1)空间中做到这一点，也就是说，你不需要一个散列表（尽管你可以用一个散列表来完成）。

#21. 4.4 考虑平衡树的定义。你可以检查单个节点的条件吗？你可以检查每个节点吗？

#22. 3.6 可以考虑为狗和猫保留一个链表，然后遍历它找到第一只狗（或猫）。这样做的影响是什么？

#23. 1.5 从容易的事情开始。你能分别检查一下每一个条件吗？

#24. 2.4 考虑元素不必保持相同的相对顺序。我们只需要确保小于基准点的元素必须位于比基准点大的元素之前。这有助于你想出更多的解法吗？

#25. 2.2 如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？

#26. 4.7 构建表示依赖关系的有向图。每个节点都是一个项目，如果B依赖于A（A必须在B之前构建），则从A到B存在一个边。你也可以用其他对你而言更便捷的方式构建。

#27. 3.2 注意最小的元素不会经常变化。它只在添加更小的元素或最小的元素被弹出时才发生变化。

#28. 4.8 你如何弄清p是否为节点n的后代？

#29. 2.6 假设你有链表的长度。你可以实现这个递归吗？

#30. 2.5 尝试递归。假设你有两个链表，A=1-> 5-> 9（代表951）和B=2-> 3->6-> 7（代表7632），以及一个操作链表其余部分的函数（5-> 9和3-> 6->7）。你能用这个来创建求和方法吗？sum(1-> 5-> 9, 2-> 3-> 6-> 7)和sum(5-> 9, 3-> 6-> 7)之间有何关系？

#31. 4.10 尽管问题似乎源于重复的值，但不止如此。问题是，前序遍历是相同的，只是因为我们跳过了空节点（因为它们是空的）。考虑在访问到空节点时往前序遍历的字符串中插入一个占位符。把空节点记录为一个“真正的”节点，你就可以区分出不同的结构了。

#32. 3.5 假设二级栈已排序。你能按顺序插入元素吗？你可能需要一些额外的存储空间。你可以使用什么额外的存储？

#33. 4.4 如果你开发了一个蛮力解法，请注意它的运行时间。如果你是用于计算每个节点的子树的高度，那么该算法会很低效。

#34. 1.9 如果一个字符串是另一个字符串的旋转，那么它就是在某个特定点上的旋转。例如，字符串waterbottle在3处的旋转意味着在第三个字符处切割waterbottle，并在左半部分（wat）之前放置右半部分（erbottle）。

#35. 4.5 如果使用前序遍历来遍历树，元素的顺序是正确的，这是否表明树实际上是有序的？有重复元素会发生什么？如果允许重复元素，它们必须位于特定的一边（通常是左边）。

#36. 4.8 从根节点开始。你能确定根是第一个共同祖先吗？如果不是，你能分辨出第一个共同祖先在根节点的哪一边吗？

#37. 4.10 或者用递归法处理这个问题。给定一个特殊节点T1，可以检查它的子树是否匹配T2吗？

#38. 3.1 如果你想考虑灵活划分，可以移动栈。你能保证使用所有可用的容量吗？

#39. 4.9 每个数组中的第一个值是多少？

#40. 2.1 没有额外的空间，你需要O(N2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。

#41. 2.2 尝试用递归法实现。如果你能找到(k-1)到最后一个元素，可以找到第k个元素吗？

#42. 4.11 在这个问题中务必要小心，以确保每个节点的可能性相同，并且你的解法不会降低标准二叉搜索树算法的速度（如插入、查找和删除）。另外，请记住，即使你假设它是一个平衡的二叉搜索树，也不意味着树是满的、完整的、完美的。

#43. 3.5 保持二级栈的排序顺序，最大的元素在顶部。使用主栈进行额外的存储。

#44. 1.1 用散列表试试。

#45. 2.7 举例子能帮到你。画一个相交的链表和两个不相交的等价链表（值）的图片。

#46. 4.8 尝试递归方法。检查p和q是否为左子树和右子树的后代。如果它们是不同的树的后代，那么当前节点是第一个共同的祖先。如果它们是同一子树的后代，则该子树保存第一个共同祖先。现在，你该如何有效地实现它呢？

#47. 4.7 看看这个图。是否可以首先构建可识别的节点？

#48. 4.9 根是每个数组中必须包含的第一个值。相对于右子树中的值，左子树中的值顺序如何？左子树值是否需要在右子树之前插入？

#49. 4.4 如果你可以修改二叉树节点类，允许节点存储子树的高度，会如何？

#50. 2.8 这个问题实际上可以分为两个部分。首先，检测链表是否有循环。第二，找出循环开始的位置。

#51. 1.7 尝试逐层思考。你能旋转某个特定图层吗？

#52. 4.12 如果每条路径必须从根开始，就从根开始遍历所有可能的路径。可以在遍历的同时追踪和，每次找到一个路径满足我们的目标和，就增加totalpaths的值。现在，如何将它扩展到可以在任何地方开始呢？记住：只需要一个蛮力算法即可完成。你可以稍后再优化。

#53. 1.3 从尾到头开始修改字符串通常最容易。

#54. 4.11 这是你创建的二叉搜索树类，因此你可以在树结构或节点上维护任何信息（假如它没有其他的负面影响，比如插入速度变慢很多）。事实上，面试问题可能会说明这是你自己的类。你可能需要存储一些额外信息来达到这样的效率。

#55. 2.7 首先要确定是否有交叉点。

#56 3.6 让我们假设用不同的列表存储猫和狗。怎样才能找到所有物种中最老的动物呢？要有创意。

#57. 4.5 作为一个二叉搜索树，并不是说每个节点都满足left.value<=current.value<right就够了。左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。

#58. 3.1 试着把数组看作是循环的，这样数组的结尾就“环绕”到了数组的开始部分。

#59. 3.2 如果保持追踪每个栈节点的额外数据会怎么样？什么样的数据可能更容易解决这个问题呢？

#60. 4.7 如果你确定一个节点没有任何指进来的边，那么它肯定可以被构建。找到这个节点（可能是多个）并将其添加到构建的顺序中。那么，这对向外的边意味着什么呢？

#61. 2.6 在递归方法中（我们有链表的长度），中点是基线条件，即isPermutation(middle)是true。节点x是紧挨着middle的左侧的一个节点：该如何检查x -> middle-> y是否形成回文？现在假设检查通过。前一个节点a又该如何检查？如果x-> middle -> y是回文，怎么检查a -> x -> middle -> y -> b是回文？

#62. 4.11 作为一种朴素的“蛮力”算法，你能使用树遍历算法来实现这个算法吗？它的运行时间是多少？

#63. 3.6 想想现实生活中你是怎么做的。你有一个按时间排序的狗列表和一个按时间排序的猫列表。你需要什么数据才能找到最老的动物？你将如何维护这些数据？

#64. 3.3 你需要追踪每个子栈的大小。当一个栈已满时，你可能需要创建一个新栈。

#65. 2.7 注意，两个相交链表的最后节点始终相同。一旦它们相交，之后的所有节点将相等。

#66. 4.9 左子树值与右子树值之间本质上可以是任何关系。可以在右子树之前插入左子树值，也可以反转（右子树的值在左边）或采用任意其他顺序。

#67. 2.2 你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？

#68. 4.12 为了将其扩展到从任何地方开始的路径，我们可以对所有节点重复此过程。

#69. 2.8 要确定是否有一个循环，请尝试9.2.3节介绍的“快行指针”方法。让一个指针比另一个指针快。

#70. 4.8 在更简单的算法中，我们有一个方法表明x是n的后代，另一个方法是递归查找第一个共同的祖先。这样是在子树中反复搜索相同的元素。我们应该将其合并成一个firstCommonAncestor方法。那么什么样的返回值会给我们需要的信息？

#71. 2.5 确保你考虑到了链表的长度不同的情况。

#72. 2.3 列出清单1-> 5-> 9-> 12。删除9会使它看起来像1-> 5-> 12。你只能访问9节点。你能让它看起来像正确的答案吗？

#73. 4.2 你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？

#74. 1.8 你能只用额外的O(N)空间而不是O(N2)吗？在为0的单元格列表中你真正需要的是什么信息？

#75. 4.11 或者，你可以选择一个随机的深度来遍历，然后随机遍历，当你达到该深度时停止。不过，请考虑一下，这样能行吗？

#76. 2.7 你可以通过遍历到每个链表的末尾并比较它们的尾节点来确定两个链表是否相交。

#77. 4.12 如果你已经设计了以上描述的算法，那么在平衡树中你会有一个O(NlogN)的算法。这是因为共N个节点，在最坏情况下，每个节点的深度是O(logN)。节点上方的每个节点都会访问一次。因此，N个节点将被访问O(logN)的时间。有一种优化算法，其运行时间为O(N)。

#78. 3.2 考虑让每个节点知道它“子栈”的最小值（包括它下面的所有元素，以及它本身）。

#79. 4.6 想想中序遍历是如何工作的，并尝试对其进行“逆向工程”。

#80. 4.8 firstCommonAncestor函数可以返回第一个共同的祖先（如果p和q都包含在树里），如果p在树上而q不在，返回p；如果q在树上而p不在，返回q；否则，返回空。

#81. 3.3 在一个特定的子栈中弹出一个元素意味着一些栈没有满。这是个问题吗？没有正确的答案，但你应该考虑如何处理这个问题。

#82. 4.9 把这个分解成子问题。使用递归法。如果你有左右子树的所有可能的序列，那么如何为整个树创建所有可能的序列呢？

#83. 2.8 你可以使用两个指针，一个指针移动速度是另一个指针的两倍。如果有环，两个指针会碰撞。它们将同时降落在同一地点。它们在哪里相遇？为什么呢？

#84. 1.2 有一种解法需要O(NlogN)的时间。另一种解法需要使用一些空间，但需要运行时间为O(N)。

#85. 4.7 一旦决定构建一个节点，它的出边可以被删除。完成此操作后，你是否可以找到其他空闲且清晰的节点来构建？

#86. 4.5 如果左边的每个节点必须小于或等于当前节点，那么这就等于左边最大的节点必须小于或等于当前节点。

#87. 4.12 在当前的蛮力算法中重复了什么工作？

#88. 1.9 本质上，我们是在寻找是否有一种方式可以把第一个字符串分成两部分，即x和y，如此一来，第一个字符串就是xy，第二个字符串就是yx。例如，x=wat，y=erbottle。那么，第一个字符串xy=waterbottle，第二个字符串yx=erbottlewat。

#89. 4.11 选择一个随机的深度对我们没有多大帮助。首先，在较低深度比更高深度有更多的节点。其次，即使重新平衡了这些概率，也可能走到一个“死胡同”，我们原想在深度为5处选择一个节点，却在深度为3处命中一个叶子。尽管重新平衡概率是一件有趣的事。

#90. 2.8 如果你还没有确定两个指针的起始位置，请尝试使用链表1-> 2-> 3-> 4->5-> 6-> 7->8-> 9-> ?，其中？链接到另一个节点。试着让？成为第一个节点（即9指向1，使得整个链表是一个循环）。然后让？成为节点2，然后成为节点3，然后成为节点4。这一模式是什么？你能解释一下为什么会这样吗？

#91. 4.6 这只是逻辑方法中的一步：一个特定节点的后继节点是右子树的最左节点。如果没有右子树呢？

#92. 1.6 先做容易的事。压缩字符串，然后再比较长度。

#93. 2.7 现在，你需要查找链表在何处相交。假设链表长度相同。你可以怎么做？

#94. 4.12 从根开始考虑每个路径（有n个这样的路径）作为一个数组。该蛮力算法具体运作如下：拿着每个数组来寻找所有具有特定和的连续子序列。我们这样做是计算了所有子数组以及它们的和。把目光聚焦在这个小问题上可能会大有裨益。给定一个数组，你如何寻找具有特定和的所有连续子序列？同样，想想蛮力算法中的重复工作。

#95. 2.5 你的算法在形如9-> 7-> 8和6-> 8-> 5的链表上工作吗？仔细检查一下。

#96. 4.8 小心！你的算法处理只有一个节点的情况吗？会发生什么事？你可能要微调返回值。

#97. 1.5 “插入字符”选项和“删除字符”选项之间是何关系？这些需要分开检查吗？

#98. 3.4 队列和栈的主要区别是元素的顺序。队列删除最旧的项，栈删除最新的项。如果你只访问最新的项，那么如何从栈中删除最旧的项？

#99. 4.11 许多人提出的一种简单做法是从1到3之间选择一个随机数。如果是1，返回当前节点；如果是2，分支左；如果是3，分支右。该解法不起作用。为什么呢？你能调整一下使其运作吗？

## 100 ~ 136

#100. 1.7 旋转一个特定的层只意味着在4个数组中交换值。如果要求你在2个数组中交换值，你能做到吗？你能把它扩展到4个数组吗？

#101. 2.6 回到前面的提示。记住：返回多个值的方法有很多。你可以用一个新类来实现。

#102. 1.8 你可能需要一些数据存储来维护一个需要清零的行与列的列表。通过使用矩阵本身来存储数据，你是否可以把额外的空间占用减小到O(1)？

#103. 4.12 我们正在寻找和为targetSum的子数组。注意，可以在常数时间得到runningSumi的值，这是从元素0到元素i的和。一个从i到j的子数组和为targetSum，则runningSumi-1+targetSum必须等于runningSumj（试着画一个数组或一条数字线）。随着往下走，可以追踪runningSum，那么如何能快速查找i对应的使前面等式成立的值？

#104. 1.9 想想前面的提示。再想想当你将erbottlewat与它本身连接会发生什么。你得到了erbottlewaterbottlewat。

#105. 4.4 你不需要修改二叉树类来存储子树的高度。递归函数是否可以计算每个子树的高度，同时检查节点是否平衡？尝试让函数返回多个值。

#106. 1.4 你不必且也不应该生成所有的排列。这将极为低效。

#107. 4.3 尝试修改图形搜索算法，从根开始追踪深度。

#108. 4.12 尝试使用一个散列表，从runningSum的值映射到使用runningSum元素的个数。

#109. 2.5 对于后续问题：问题是，当链表的长度不一样时，一个链表的首部可能代表1000的位置，而另一个链表代表10的位置。如果你把它们做的一样长呢？有没有方法修改链表来做到这一点，而不改变它所代表的值？

#110. 1.6 注意不要把字符串重复连接在一起。这会非常低效。#111. 2.7 如果两个链表长度相同，则可以在每个链表中向前遍历，直到找到一个公共的元素。现在，面对长度不同的链表，你该怎样调整？

#112. 4.11 之前的解法（在1到3之间选择一个随机数）不起作用是因为节点的概率不相等。例如，根会以1/3的概率返回，即使树中有50个以上的节点。显然，并非所有节点都具有1/3的概率，因此这些节点将具有不相同的概率。我们可以通过选择一个1和size_of_tree之间的随机数解决这一问题。这只解决了根节点的问题。剩下的节点呢？

#113. 4.5 相比于根据leftTree.max和rightTree.min来验证当前节点的值，我们可以翻转逻辑吗？验证左子树的节点以确保其小于current.value。

#114. 3.4 我们可以通过不断地删除最新的项（将这些项插入临时栈中）来删除栈中最老的项，直到得到一个元素为止。然后，在检索到最新项后，将所有元素返回。与此有关的问题是，每次在一行中做几个弹出操作（pop）将需要O(n)的时间。我们可以优化在一行中连续弹出这一场景吗？

#115. 4.12 一旦你完成了这样的算法，找出了和为给定值的所有连续子数组，试着将它应用到一棵树上。请记住，在遍历和修改散列表时，你可能需要在遍历回来时将散列表的“损坏”逆转。

#116. 4.2 想象一下，我们有一个createMinimalTree方法可以返回给定数组的最小树（但由于一些奇怪的原因不在树的根上操作）。你能用这个操作树的根节点吗？你能写出函数的基线条件吗？非常好！那基本上是整个函数了。

#117. 1.1 位向量有用吗？

#118. 1.3 你可能需要知道空格的数量。你能数一下吗？

#119. 4.11 之前解法存在的问题是一个节点的一侧可能有比另一侧更多的节点。因此，我们需要根据每个边上的节点数来加权左右概率。具体该怎么做呢？我们如何知道节点的数目？

#120. 2.7 尝试使用两个链表长度之间的差异。

#121. 1.4 作为回文排列的字符串有什么特征？

#122. 1.2 散列表有用吗？

#123. 4.3 从层号映射到该层节点的散列表或数组也许有些用处。

#124. 4.4 其实，你只需要一个checkHeight函数即可，它既可以计算高度，也可以平衡检查。可以使用整数返回值表示两者。

#125. 4.7 作为一种完全不同的方法：考虑从任意节点开始进行深度优先搜索。深度优先搜索和合法的编译顺序之间有何关系？

#126. 2.2 你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？

#127. 4.1 有两个众所周知的算法可以做到这一点。其利弊是什么？

#128. 4.5 把checkBST函数当作一个递归函数，保证每个节点在允许范围内（最小，最大）。首先，这个范围是无限的。当我们遍历左边，最小的是负无穷大，最大的是root.value。你能实现这个递归函数，并且随着遍历而适当调整这些范围吗？

#129. 2.7 如果你通过长度差异向较长的链表中移动指针，则可以在链表相同时应用类似的方法。

#130. 1.5 你能一次完成三次检查吗？

#131. 1.2 两个重排的字符串应该具有相同的字符，但顺序不同。你可以让它们的顺序一样吗？

#132. 1.1 你能用O(NlogN)的时间复杂度解决它吗？这样的解法会是什么样呢？

#133. 4.7 选择任意节点并对其进行深度优先搜索。一旦到达一个路径的末端，我们就知道这个节点可能是最后一个节点，因为没有节点依赖它。这对前面的节点意味着什么？

#134. 1.4 你试过散列表吗？你应该能把它降到O(N)的时间。

#135. 4.3 你应该能够提出一个既包括深度优先搜索又包含广度优先搜索的算法。

#136. 1.4 使用位向量可以减少空间使用吗？
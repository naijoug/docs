---
title: 0000 ~ 0099
icon: hashtag

index: true

---

<!-- more -->

## 0000

// #region 0000

- [🟢🟠🔴 - ]()

::: details 💡

::: code-tabs

@tab java
```java

```

:::

// #endregion 0000

## 0001 ✅

// #region 0001

- [🟢 1 - 两数之和](https://leetcode.cn/problems/two-sum)
    > 给定一个整数数组和一个整数目标值，请找出和为目标值的两个整数，并返回它们的数组下标。

        🌰
            输入：nums = [2,7,11,15], target = 9
            输出：[0,1]
        🌰
            输入：nums = [3,2,4], target = 6
            输出：[1,2]

::: details 💡

【思路1】暴力法，两次遍历，外层循环固定其中一个值，内层循环遍历元素进行求和比较

【思路2】哈希表，遍历元素 num 时，将 target - num 作为键，值为索引，存入哈希表；继续遍历下一个元素，判断哈希表中是否存在与该元素键相等的数据存在，如果存在则返回结果

【思路3】双指针，这种方案需要先排序，然后首尾指针进行大小调整与 target 值进行比对，不过最后还需要通过结果值去原数组中找到目标索引。这种方法比较适用于直接求解目标值。

::: code-tabs

@tab swift 解法1
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        for i in 0..<nums.count {
            for j in i+1..<nums.count {
                if (nums[i] + nums[j] == target) {
                    return [i, j]
                }
            }
        }
        return []
    }
}
```

@tab swift 解法2
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        let nums = nums
        var map = [Int: Int]()
        for i in 0..<nums.count {
            let num = nums[i]
            guard let index = map[num] else {
                map[target - num] = i
                continue
            } 
            return [index, i]
        }
        return []
    }
}
```

@tab java 解法2
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap();
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[] { map.get(num), i };
            } else {
                map.put(target - num, i);
            }
        }
        return new int[] {};
    }
}
```

@tab swift 解法3
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        // 先对数组进行排序
        let sortedNums = nums.sorted()
        var left = 0
        var right = sortedNums.count - 1
        // 双指针定位前后值
        while left < right {
            let sum = sortedNums[left] + sortedNums[right]
            if sum == target {
                break
            } else if sum < target {
                // 和小于目标值，调整左边范围
                left += 1
            } else { // sum > target
                // 和大于目标值，调整右边范围
                right -= 1
            }
        }
        // 获取值索引
        var leftIndex: Int?
        var rightIndex: Int?
        for i in 0..<nums.count {
            if leftIndex == nil, sortedNums[left] == nums[i] {
                leftIndex = i
            } else if sortedNums[right] == nums[i] {
                rightIndex = i
            }
            guard let leftIndex = leftIndex, let rightIndex = rightIndex else {
                continue
            }
            return [leftIndex, rightIndex]
        }

        return [left, right]
    }
}
```

:::

// #endregion 0001

## 0002 ✅

// #region 0002

- [🟠 2 - 两数相加](https://leetcode.cn/problems/add-two-numbers)
    > 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
    > 请你将两个数相加，并以相同形式返回一个表示和的链表。
    > 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

        🌰
            输入：l1 = [2,4,3], l2 = [5,6,4]
            输出：[7,0,8]
            解释：342 + 465 = 807.
        🌰
            输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
            输出：[8,9,9,9,0,0,0,1]

::: details 💡

【思路】遍历链表，进行加法运算，通过一个变量保存进位，如果最后还存在进位，需要连接到链表。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node1 = l1;
        ListNode node2 = l2;
        // 保存进位
        int carry = 0;
        // 结果链表
        ListNode dummy = new ListNode();
        ListNode result = dummy;
        // 遍历两个链表，进行加加法运算
        while (node1 != null && node2 != null) {
            int sum = node1.val + node2.val + carry;
            result.next = new ListNode(sum % 10);
            result = result.next;
            carry = sum / 10;
            node1 = node1.next;
            node2 = node2.next;
        }
        // 较长的链表，继续
        ListNode node = node1 != null ? node1 : node2;
        while (node != null) {
            int sum = node.val + carry;
            result.next = new ListNode(sum % 10);
            result = result.next;
            carry = sum / 10;
            node = node.next;
        }
        // 如果还有进位，连接到链表
        if (carry > 0) {
            result.next = new ListNode(carry);
        }
        return dummy.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        var left = l1
        var right = l2
        let head = ListNode(0)
        var result: ListNode? = head
        var carry = 0
        var sum = 0
        while ( left != nil && right != nil ) {
            sum = (left?.val ?? 0) + (right?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            left = left?.next
            right = right?.next
        }
        while ( left != nil ) {
            sum = (left?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            left = left?.next
        }
        while ( right != nil ) {
            sum = (right?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            right = right?.next
        }
        if (carry > 0) {
            result?.next = ListNode(carry)
        }
        return head.next
    }
}
```

:::

// #endregion 0002

## 0003 ✅

// #region 0003

- [🟠 3 - 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)
    > 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

        🌰
            输入: s = "abcabcbb"
            输出: 3 ("abc")
        🌰
            输入: s = "bbbbb"
            输出: 1
            
::: details 💡

【思路】滑动窗口，定义一个哈希集合，用来记录窗口中的字符。
  * 遍历字符串中的字符，如果该字符不存在集合中，加入集合，进行窗口扩大。
  * 如果该字符已经存在集合中，进行窗口缩小，直到该字符被移除窗口。
  * 遍历的过程中，进行最长字符子串的长度替换。

::: code-tabs

@tab java
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] chars = s.toCharArray();

        Set<Character> window = new HashSet();

        int left = 0;
        int right = 0;
        int maxLen = 0;
        while (right < chars.length) {
            // 扩大窗口
            char rc = chars[right];
            right += 1;
            // 重复，缩小窗口，直到不包含重复字符
            while (window.contains(rc)) {
                char lc = chars[left];
                left += 1;
                window.remove(lc);
            }
            // 添加不重复字符
            window.add(rc);
            // 保存最大值
            if (right - left > maxLen) {
                maxLen = right - left;
            }
        }
        return maxLen;
    }
}
```

@tab swift
```swift
class Solution {
    func lengthOfLongestSubstring(_ s: String) -> Int {
        let chars = [Character](s)
        var window = [Character: Int]()
        var left = 0
        var right = 0
        var res = 0
        while right < chars.count {
            let rightChar = chars[right]
            right += 1
            window[rightChar] = (window[rightChar] ?? 0) + 1
            while window[rightChar] ?? 0 > 1 {
                let leftChar = chars[left]
                left += 1
                window[leftChar] = (window[leftChar] ?? 0) - 1
            }
            res = max(res, right - left)
        }
        return res
    }
}
```

:::

// #endregion 0003

## 0004

// #region 0004

- [🔴 4 - 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays)
    > 给定两个正序数组，返回这两个正序数组的中位数。

::: details 💡

【思路1】暴力法，将两个数组合并，当合并到两个数组的一半时，就是中位数。

::: code-tabs

@tab java
```java

```

:::

// #endregion 0004

## 0005 ✅

// #region 0005

- [🟠 5 - 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
    > 给定一个字符串，返回该字符串中最长的回文串。

::: details 💡

【思路】需要查找最长的回文串，如果已一个字符为中心去查找最长的回文串，使用双指针朝两个方向去判断，存在两种情况。

  * 以该索引为中心的奇数回文串，则从该索引左右索引开始去匹配。
  * 以该索引为中心的偶数回文串，则将该索引作为左边索引，下一个索引为右边索引开启去进行匹配。
  
  匹配到该索引下的最长回文串，然后比较保留住最长的回文串。
  
  👉🏻 可以进一步优化，判断一下剩余索引是否少于当前保留的最长回文串的一半，就不需要继续判断了。

::: code-tabs

@tab java
```java
class Solution {
    public String longestPalindrome(String s) {
        String result = "";
        for (int i = 0; i < s.length(); i++) {
            String str = longestPalindrome(s, i);
            if ( str.length() > result.length() ) {
                result = str;
            }
            // 如果剩余索引长度不足保留的最长回文串长度的一半，不需要再做判断
            if ( result.length() > (s.length() - i - 1) * 2 ) {
                break;
            }
        }
        return result;
    }

    /// 指定索引为中心的最长回文串
    String longestPalindrome(String s, int i) {
        // 以 i 为中心的奇数回文串
        int left = i - 1;
        int right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str1 = s.substring(left + 1, right);
        // 以 i 为中心的偶数回文串
        left = i;
        right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str2 = s.substring(left + 1, right);
        return str1.length() > str2.length() ? str1 : str2;
    }
}
```

:::

// #endregion 0005

## 0006

// #region 0006

- [🟠 6 - N 字形变换](https://leetcode.cn/problems/zigzag-conversion)

::: details 💡

:::

// #endregion 0006

## 0007 ✅

// #region 0007

- [🟠 7 - 整数反转](https://leetcode.cn/problems/reverse-integer)
    > 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
    > 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
    > 假设环境不允许存储 64 位整数（有符号或无符号）。

        🌰
            输入：x = 123
            输出：321
        🌰
            输入：x = -123
            输出：-321
            
::: details 💡

【思路】通过除法每次取到数字最后的数字，再进行进位加法运算就等到最后结果。需要注意最后反转结果可能存在整数溢出的可能性，所以每次进行进位加法运算前，需要判断是否存在溢出的情况。

::: code-tabs

@tab java
```java
class Solution {
    public int reverse(int x) {
        // 如果等于最小值，反转越界，直接返回 0
        if (x == Integer.MIN_VALUE) return 0;

        int carrayMax = Integer.MAX_VALUE / 10;
        int digitMax = Integer.MAX_VALUE % 10;

        int sign = x < 0 ? -1 : 1; // 数字符号
        int num = Math.abs(x); // 保证了绝对值不越界
        int result = 0;
        while (num != 0) {
            int digit = num % 10;
            num = num / 10;

            // 如果当前结果值大于当前最大的进位，溢出，返回 0
            if (result > carrayMax) return 0;
            // 如果当前结果值等于最大的进位
            if (result == carrayMax) {
                // 正数时，如果大于最大值末尾数字，溢出，返回 0
                if (sign == 1 && digit > digitMax) return 0;
                // 负数是
                if (sign == -1) {
                    // 超过最小值某位数字，溢出，返回 0
                    if (digit > (digitMax + 1)) {
                        return 0;
                    } else if (digit == (digitMax + 1)) {
                        // 刚好等于最小值时，如果后面没有数字则最小值就是反转结果；如果后面还有数字则最溢出，返回 0
                        return num == 0 ? Integer.MIN_VALUE : 0;
                    }
                }
            }

            // 进行加法进位运算
            result = result * 10 + digit;
        }
        return sign * result;
    }
}
```

@tab swift
```swift
class Solution {
    let quotient_max = 214748364    // Int32.max / 10
    let quotient_min = -214748364   // Int32.min / 10
    let remainder_max = 7   // Int32.max % 10
    let remainder_min = -8  // Int32.min % 10

    func reverse(_ x: Int) -> Int {
        var num = x
        var result = 0
        while num != 0 {
            let remainder = num % 10
            guard result <= quotient_max, result >= quotient_min else { return 0 }
            if result == quotient_max && remainder > remainder_max { return 0 }
            if result == quotient_min && remainder < remainder_min { return 0 }
            result = result * 10 + remainder
            num = num / 10
        }
        return result
    }
}
```

:::

// #endregion 0007

## 0008 ✅

// #region 0008

- [🟠 8 - 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi)
    > 请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
    > 函数 `myAtoi(string s)` 的算法如下：
    > * 读入字符串并丢弃无用的前导空格
    > * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
    > * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
    > * 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
    > * 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
    > * 返回整数作为最终结果。

        🌰
            输入：s = "   -42"
            输出：-42
        🌰
            输入：s = "+-12"
            输出：0
        🌰
            输入：s = "+ 12"
            输出：0
        🌰
            输入：s = "-21474836482"
            输出：-2147483648
        
::: details 💡

【思路】读取字符，进位乘法运算，注意整数越界条件处理。

::: code-tabs 

@tab java
```java
class Solution {
    public int myAtoi(String s) {
        char[] chars = s.toCharArray();
        int i = 0;
        // 跳过所有空格
        while (i < chars.length && chars[i] == ' ') {
            i += 1;
        }
        // 读取符号
        int sign = 1;
        if (i < chars.length && (chars[i] == '+' || chars[i] == '-')) {
            sign = chars[i] == '+' ? 1 : -1;
            i += 1;
        }
        // 读取数字，进行结果进位运算
        int result = 0;
        while (i < chars.length && Character.isDigit(chars[i])) {
            int digit = chars[i] - '0';
            if (isOver(result, digit)) {
                // 如果超过范围，直接范围临界值
                return sign == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            // 是数字，进行运算
            result = result * 10 + digit;
            i += 1;
        }
        return sign * result;
    }

    // 最大值进位
    private int carryMax = Integer.MAX_VALUE / 10; // -2147483648 ~ 2147483647
    // 最大进位时，数字的范围
    private int digitMax = Integer.MAX_VALUE % 10; // 7
    /// 判断是否超过整形范围
    boolean isOver(int result, int digit) {
        // 超过最大进位，越界
        if (result > carryMax) return true;
        // 等于最大进位时，需要判断下一位数字范围
        // 整数范围：[−2^31,  2^31 − 1] 虽然负数的范围比正数多1
        // 由于越界时，也是返回边界值，所以可以将负数中的等于边界时也归为越界，简化判断
        if (result == carryMax && digit > digitMax) return true;
        return false;
    }
}
```

:::

// #endregion 0008

## 0009

// #region 0009

- [🟢 9 - 回文数](https://leetcode.cn/problems/palindrome-number)

::: details 💡

:::

// #endregion 0009

## 0010

// #region 0010

- [🔴 10 - 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)

::: details 💡

:::

// #endregion 0010

## 0011 ✅

// #region 0011

- [🟠 11 - 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water)
    > 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
    > 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
    > 返回容器可以储存的最大水量。
        
        🌰
            输入：[1,8,6,2,5,4,8,3,7]
            输出：49 
            解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
    
::: details 💡

【思路】双指针

::: code-tabs

@tab java
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int result = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                // 左边挡板低，调整左边索引
                result = Math.max(result, (right - left) * height[left]);
                left += 1;   
            } else {
                // 右边挡板低，调整右边索引
                result = Math.max(result, (right - left) * height[right]);
                right -= 1;
            }
        }
        return result;
    }
}
```

:::

// #endregion 0011

## 0012

// #region 0012

- [🟠 12 - 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman)

::: details 💡

:::

// #endregion 0012

## 0013

// #region 0013

- [🟢 13 - 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer)

::: details 💡

:::

// #endregion 0013

## 0014

// #region 0014

- [🟢 14 - 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix)

::: details 💡

:::

// #endregion 0014

## 0015 ✅

// #region 0015

- [🟠 15 - 三数之和](https://leetcode.cn/problems/3sum)
    > 给定整数数组 nums，返回数组中三个数(索引均不相同)之和等于0的三元组。

        🌰
            输入：nums = [-1,0,1,2,-1,-4]
            输出：[[-1,-1,2],[-1,0,1]]

::: details 💡

【思路】先将数组排序，遍历固定一个值，然后在这个值后面的数组进行两数求和。

::: code-tabs

@tab java
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // 排序数组
        List<List<Integer>> result = new LinkedList();
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> items = twoSum(nums, -nums[i], i + 1);
            for (List<Integer> item : items) {
                List<Integer> list = new LinkedList();
                list.add(nums[i]);
                list.addAll(item);
                result.add(list);
            }
            // 跳过相同值
            while (i < nums.length - 1 && nums[i] == nums[i + 1]) {
                i += 1;
            }
        }
        return result;
    }

    List<List<Integer>> twoSum(int[] nums, int target, int start) {
        int left = start;
        int right = nums.length - 1;
        List<List<Integer>> result = new LinkedList();
        while (left < right) {
            int lnum = nums[left];
            int rnum = nums[right];
            int sum = lnum + rnum;
            if (sum == target) {
                // 收集结果
                result.add(Arrays.asList(nums[left], nums[right]));
                // 跳过相同的值
                while (left < right && nums[left] == lnum) {
                    left += 1;
                }
                while (left < right && nums[right] == rnum) {
                    right -= 1;
                }
            } else if (sum < target) { // 和小于目标值，调整左边界
                while (left < right && nums[left] == lnum) {
                    left += 1;
                }
            } else { // 和大于目标值，调整右边界
                while (left < right && nums[right] == rnum) {
                    right -= 1;
                }
            }
        }
        return result;
    }
}
```

@tab swift
```swift
class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        // 先对数组进行排序
        let nums = nums.sorted()
        var result = [[Int]]()
        for i in 0..<nums.count - 1 {
            // 数据不足 3 个，不需要再进行判断，直接返回结果
            if nums.count - i < 3 {
                return result
            }
            // 过滤掉以判断的相同值
            if i > 0, nums[i] == nums[i - 1] {
                continue
            }
            // 固定第一个数，计算剩下两数之和的目标值
            let target = 0 - nums[i]
            var left = i + 1
            var right = nums.count - 1
            // 条状到下一个左边值
            func skipToNextLeft() {
                while left + 1 < right, nums[left + 1] == nums[left] {
                    left += 1
                }
                left += 1
            }
            // 跳转到下一个右边值
            func skipToNextRight() {
                while left < right - 1, nums[right - 1] == nums[right] {
                    right -= 1
                }
                right -= 1
            }
            while left < right {
                let sum = nums[left] + nums[right]
                if target == sum {
                    result.append([nums[i], nums[left], nums[right]])
                    // 左右方向跳过当前判断两个值
                    skipToNextLeft()
                    skipToNextRight()
                } else if sum < target {
                    // 和小于目标值，调整左边索引
                    skipToNextLeft()
                } else { // target > sum
                    // 和大于目标值，调整右边索引
                    skipToNextRight()
                }
            }
        }
        return result
    }
}
```

:::

// #endregion 0015

## 0016 ✅

// #region 0016

- [🟠 16 - 最接近的三数之和](https://leetcode.cn/problems/3sum-closest)
    > 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。
    
            🌰
                输入：nums = [-1,2,1,-4], target = 1
                输出：2 (说明：-1 + 2 + 1 = 2) 。
            🌰
                输入：nums = [0,0,0], target = 1
                输出：0

::: details 💡

【思路】同三数之和的思路，区别在于每次需要进行绝对比对，保存最接近目标值的三数之和

::: code-tabs

@tab java
```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        return closet(nums, target);
    }
    int closet(int[] nums, int target) {
        int result = Integer.MAX_VALUE;
        int i = 0;
        while (i < nums.length) {
            int num = nums[i];
            // 再进行两数之和
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                int lnum = nums[left];
                int rnum = nums[right];
                int sum = num + lnum + rnum;
                if (sum == target) { // 等于目标值
                    return target;
                } else if (sum < target) { // 小于目标值，调整左边界
                    // 跳过左边相同值
                    while (left < right && nums[left] == lnum) left += 1;
                } else { // 大于目标值，调整右边界
                    // 跳过右边相同值
                    while (left < right && nums[right] == rnum) right -= 1;
                }
                // 通过绝对值比对，替换更加接近的值
                if (Math.abs(sum - target) < Math.abs(result - target)) {
                    result = sum;
                }
            }
            // 跳过相同值
            while (i < nums.length && nums[i] == num) i += 1;
        }
        return result;
    }
}
```

:::

// #endregion 0016

## 0017

// #region 0017

- [🟠 17 - 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)

::: details 💡

:::

// #endregion 0017

## 0018 ✅

// #region 0018

- [🟠 18 - 四数之和](https://leetcode.cn/problems/4sum)
    > 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target，找出数组中所有的四个不同索引位置的值之和等于目标值。

        🌰
            输入：nums = [1,0,-1,0,-2,2], target = 0
            输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
        🌰
            输入：nums = [2,2,2,2,2], target = 8
            输出：[[2,2,2,2]]

::: details 💡

【思路】与三数之和思路相同，先需要对数组进行排序，为了方便跳过相同答案。循环遍历，固定一个值，然后进行三数求和。

::: code-tabs

@tab java
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        // 先对数组进行排序
        Arrays.sort(nums);
        return nSum(nums, target, 4, 0);
    }

    // target 值类型需要设置为 long，防止溢出
    List<List<Integer>> nSum(int[] nums, long target, int n, int start) {
        if (nums.length < n || n < 2) return new LinkedList();
        if (n == 2) { // 两数之和
            List<List<Integer>> result = new LinkedList();
            int left = start;
            int right = nums.length - 1;
            while (left < right) {
                int lnum = nums[left];
                int rnum = nums[right];
                int sum = lnum + rnum;
                if (sum == target) { // 等于目标值，收集答案
                    result.add(Arrays.asList(lnum, rnum));
                    // 跳过相同的值
                    while (left < right && nums[left] == lnum) left += 1;
                    while (left < right && nums[right] == rnum) right -= 1;
                } else if (sum < target) { // 小于目标值，调整左边界
                    while (left < right && nums[left] == lnum) left += 1;
                } else { // 大于目标值，调整右边界
                    while (left < right && nums[right] == rnum) right -= 1;
                }
            }
            return result;
        }
        List<List<Integer>> result = new LinkedList();
        int i = start;
        while (i < nums.length) {
            int num = nums[i];
            // 固定住一个数，继续递归进行下一个求和
            List<List<Integer>> items = nSum(nums, target - num, n - 1, i + 1);
            for (List<Integer> item : items) {
                List<Integer> list = new LinkedList();
                list.add(num);
                list.addAll(item);
                result.add(list);
            }
            // 跳过相同值
            while (i < nums.length && nums[i] == num) i += 1;
        }
        return result;
    }
}
```

:::

// #endregion 0018

## 0019 ✅

// #region 0019

- [🟢 19 - 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
    > 删除单链表的倒数第 N 个节点，并返回头结点。

::: details 💡

【思路1】遍历一次链表得到链表长度 len，第二次就能遍历到 len - n 的节点，进行删除操作即可。

【思路2】栈，先将所有链表节点入栈，出栈时进行计数，当到第 n 个元素时进行删除处理。

【思路3】快慢指针，快指针先走 n 步之后，快慢指针开始同时向前走，当快指针走到链表尾部，这慢指针刚好指向要删除的节点。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚头节点，解决删除后链表为空的特殊情况，减少判断逻辑
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode p = dummy;
        ListNode target = dummy;
        // p 指针先走 n 步
        for (int i = 0; i < n; i++) {
            p = p.next;
        }
        // p 指针和目标指针开始同时走
        while (p.next != null) {
            p = p.next;
            target = target.next;
        }
        // 删除目标节点后面节点
        target.next = target.next.next;
        return dummy.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {
        let dummy = ListNode(0, head)
        var p1: ListNode? = head
        var p2: ListNode? = dummy
        var count = 0
        while p1?.next != nil {
            p1 = p1?.next
            count += 1
            guard count >= n else { continue }
            p2 = p2?.next
        }
        p2?.next = p2?.next?.next
        return dummy.next
    }
}
```

:::

// #endregion 0019

## 0020 ✅

// #region 0020

- [🟢 20 - 有效的括号](https://leetcode.cn/problems/valid-parentheses)
    > 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

        🌰
            输入：s = "()[]{}"
            输出：true
        🌰
            输入：s = "(]"
            输出：false

::: details 💡

【思路】使用栈，利用栈先进后出的特性。如果遇到左边括号，进行入栈操作；如果于鏊右边括号，则从栈顶取出一个左边括号进行判断，如果不匹配则为无效，如果匹配则继续判断。最后栈中元素为空，则表明有效。

::: code-tabs

@tab java
```java
class Solution {
    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        List<Character> stack = new LinkedList();
        for (char c : chars) {
            if (isLeft(c)) {
                stack.add(c); // 是左边括号入栈
            } else {
                // 如果不是左边括号，从栈顶中取出字符进行判断
                // 如果栈已经为空，则为非法
                if (stack.isEmpty()) return false;
                // 如果不匹配，则也是非法
                if (!isMatch(stack.removeLast(), c)) return false;
            }
        }
        // 最后如果栈中元素为空，则表明有效
        return stack.isEmpty();
    }

    // 判断是否为左边括号
    private boolean isLeft(char c) {
        return c == '(' || c == '{' || c == '[';
    }
    // 两个字符括号是否匹配
    private boolean isMatch(char left, char right) {
        return (left == '(' && right == ')') 
            || (left == '{' && right == '}')
            || (left == '[' && right == ']');
    }
}
```

@tab swift
```swift
class Solution {
    func isValid(_ s: String) -> Bool {
        let map: [Character: Character] = [")": "(", "]": "[", "}": "{"]
        var lefts = [Character]()
        for char in s {
            if map.values.contains(char) {
                lefts.append(char)
            } else {
                guard !lefts.isEmpty, map[char] == lefts.removeLast() else { 
                    return false 
                }
            }
        }
        return lefts.isEmpty
    }
}
```

:::

// #endregion 0020

## 0021 ✅

// #region 0021

- [🟢 21 - 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)
    > 合并两个有序的链表。

::: details 💡

【思路】创建一个结果链表头，并用一个指针指向这个结果链表用于指向添加位置。然后分别使用两个指针指向两个链表，每次比较比较链表中的值，将较小的链表中的节点添加到结果链表中。直到其中一个链表中已为空，最后将剩下不为空的链表全部添加到结果链表中。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 头结点：指向结果链表头部
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = list1;
        ListNode p2 = list2;
        while ( p1 != null && p2 != null ) {
            // 比较两个链表中值小的添加到结果链表中
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        // 将不为空的链表添加到结果链表尾部
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        guard let l1 = l1, let l2 = l2 else {
            return l1 ?? l2
        }
        let head = ListNode(0)
        var p: ListNode? = head
        var op1: ListNode? = l1
        var op2: ListNode? = l2
        // 遍历两个链表，并将较小值节点添加到结果链表
        while let p1 = op1, let p2 = op2 {
            if p1.val <= p2.val {
                p?.next = p1
                op1 = op1?.next
            } else {
                p?.next = p2
                op2 = op2?.next
            }
            p = p?.next
        }
        // 将不为空的链表添加到结果链表后面
        p?.next = op1 ?? op2
        return head.next
    }
}
```

:::

// #endregion 0021

## 0022 

// #region 0022

- [🟠 22 - 括号生成](https://leetcode.cn/problems/generate-parentheses)

::: details 💡

:::

// #endregion 0022

## 0023 ✅

// #region 0023

- [🔴 23 - 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)
    > 给定一个升序链表数组，合并得到一个升序链表，并返回头结点。

::: details 💡

【思路1】合并两个升序链表比较容易解决。合并多个链表，可以先两个两个合并，最后就合并成一个了。

【思路2】分治思想，类似归并排序，两两合并，最后合并成为结果链表。

【思路3】优先级队列，每次将 K 个链表的头结点放入优先级队列中，那么可以每次从优先级队列中取出最小值节点放入结果链表，然后再将该节点的下一个节点放入优先级队列，直到合并完成。

::: code-tabs

@tab 解法1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if ( lists.length == 0 ) { return null; }
        if ( lists.length == 1 ) { return lists[0]; }
        // 遍历链表数组，每次取出一个链表，进行两条链表合并
        ListNode l1 = lists[0];
        for ( int i = 1; i < lists.length; i++ ) {
            ListNode l2 = lists[i];
            l1 = mergeTwoLists(l1, l2);
        }
        return l1;
    }

    // 合并两个升序链表
    ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = l1;
        ListNode p2 = l2;
        while ( p1 != null && p2 != null ) {
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

:::

// #endregion 0023

## 0024

// #region 0024

- [🟠 24 - 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs)

::: details 💡

:::

// #endregion 0024

## 0025 ✅

// #region 0025

- [🔴 - K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group)
    > 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
    > k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
    > 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

        🌰  1 -> 2 -> 3 -> 4 -> 5
            输入：head = [1,2,3,4,5], k = 2
            输出：[2,1,4,3,5]
        🌰
            输入：head = [1,2,3,4,5], k = 3
            输出：[3,2,1,4,5]

::: details 💡

【思路1】递归，遍历得到 K 个节点的分割节点，将该节点作为反转的结束值，进行 K 个节点的反转。之后递归进行剩下节点的反转，并将反转之后的尾结点(也就是之前头结点)与之后的递归返回的头结点相连。递归的结束条件就是节点数不足 K 个。

::: code-tabs

@tab java 解法1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个节点，不需要反转，直接返回头结点
            if (tail == null) return head;
            tail = tail.next;
        }
        ListNode result = reverse(head, tail);
        // 反转之后 head 变为最后节点，链接递归返回的头结点
        // 递归 K 个一组反转剩下链表
        head.next = reverseKGroup(tail, k);
        return result;
    }

    // 指定节点范围的链表，并返回反转后的新节点
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode result = null;
        ListNode node = head;
        while (node != tail) {
            ListNode temp = node.next;

            node.next = result;
            result = node;

            node = temp;
        }
        return result;
    }
}
```

:::

// #endregion 0025

## 0026 ✅

// #region 0026

- [🟢 26 - 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)
    > 给定一个有序数组，删除数组中的重复项，并返回数组新长度。

        🌰
            输入：nums = [1,1,2]
            输出：2, nums = [1,2]
        🌰
            输入：nums = [0,0,1,1,1,2,2,3,3,4]
            输出：5, nums = [0,1,2,3,4]

::: details 💡

【思路1】遍历数组，使用一个额外数组保存不重复的元素，使用了额外空间，空间复杂度 O(n)。
 
【思路2】双指针法，一个遍历索引指针遍历数组，另一个结果索引指针指向未重复的元素。遍历时，如果两个索引位置值相等，则仅移动遍历索引；如果值不等，则往前移动位置索引，将遍历索引指向的元素赋值给结果索引位置，之后再移动遍历索引。遍历结束，结果索引 + 1 就是数组的新长度。

::: code-tabs

@tab java 解法2
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        var i = 0; // 遍历索引
        var j = 0; // 结果索引
        while ( i < nums.length ) {
            if ( nums[i] != nums[j] ) {
                // 遍历值不等于结果值，结果索引往前移动，将遍历值赋值给结果索引位置
                j += 1;
                nums[j] = nums[i];
            } 
            // 遍历索引往前移动
            i += 1;
        }
        return j + 1;
    }
}
```

@tab swift 解法2 💯
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        var slow = 0 
        var fast = 0
        while ( fast < nums.count ) {
            if ( nums[fast] != nums[slow] ) {
                slow += 1
                nums[slow] = nums[fast] 
            }
            fast += 1
        }
        return slow + 1
    }
}
```

:::

// #endregion 0026

## 0027 ✅

// #region 0027

- [🟢 27 - 移除元素](https://leetcode.cn/problems/remove-element)
    > 给定一个数组和目标值，需要将数组中的与目标值相等的元素移除，返回数组新长度。

        🌰
            输入：nums = [0,1,2,2,3,0,4,2], val = 2
            输出：5, nums = [0,1,3,0,4]

::: details 💡

【思路】双指针法，遍历时将如果值不等于目标值，则将慢指针往前移动，将快指针值复制到慢指针对应索引位置。

::: code-tabs

@tab java
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( nums[fast] != val ) {
                // 遍历值不等于目标值，慢指针往前移动，将快指针位置值移动到慢指针位置
                slow += 1;
                nums[slow] = nums[fast];
            } 
            fast += 1;
        }
        return slow + 1;
    }
}
```

@tab swift
```swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        var count = -1
        for i in 0..<nums.count {
            if nums[i] != val {
                count += 1
                if count != i { // 优化，减少不必要的赋值
                    nums[count] = nums[i]
                }
            }
        }
        return count + 1
    }
}
```

:::

// #endregion 0027

## 0028

// #region 0028

- [🟢 28 - 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)

::: details 💡

:::

// #endregion 0028

## 0029

// #region 0029

- [🟠 29 - 两数相除](https://leetcode.cn/problems/divide-two-integers)

::: details 💡

:::

// #endregion 0029

## 0030

// #region 0030

- [🔴 30 - 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)

::: details 💡

:::

// #endregion 0030

## 0031

// #region 0031

- [🟠 31 - 下一个排列](https://leetcode.cn/problems/next-permutation)

::: details 💡

:::

// #endregion 0031

## 0032 ✅

// #region 0032

- [🔴 32 - 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses)
    > 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。
    
        🌰
            输入：s = "(()"
            输出：2    解释：最长有效括号子串是 "()"
        🌰
            输入：s = ")()())"
            输出：4    解释：最长有效括号子串是 "()()"
    
::: details 💡

【思路1】动态规划，

【思路2】栈，

【思路3】贪心算法，

::: code-tabs

@tab java 解法3 💯
```java
class Solution {
    public int longestValidParentheses(String s) {
        int left = 0; // 左括号计数
        int right = 0; // 有括号计数
        int maxLength = 0;
        // 正向判断
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left += 1;
            } else {
                right += 1;
            }
            if (left == right) {
                // 括号已匹配，更新最大值
                maxLength = Math.max(maxLength, right *2);
            }
            if (right > left) {
                // 右括号大于左括号，已经不匹配，重置
                left = 0;
                right = 0;
            }
        }
        // 反向判断：解决多个左括号的问题，类似 "(()"
        left = 0;
        right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left += 1;
            } else {
                right += 1;
            }
            if (left == right) {
                // 括号已匹配，更新最大值
                maxLength = Math.max(maxLength, right *2);
            }
            if (left > right) {
                // 左括号大于右括号已经不匹配，重置
                left = 0;
                right = 0;
            }
        }

        return maxLength;
    }
}
```

:::

// #endregion 0032

## 0033

// #region 0033

- [🟠 33 - 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array)

::: details 💡

:::

// #endregion 0033

## 0034 ✅

// #region 0034

- [🟢 34 - 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)
    > 给定一个非递减数组和一个目标值，查找该目标值在数组中的开始位置和结束位置，如果存在则返回 [start, end]，如果不存在返回 [-1, -1]。
    
::: details 💡

【思路1】二分搜索法，查询最左边目标值和最右边目标值

【思路2】双指针法，从前后分别查询目标值的索引位置

::: code-tabs

@tab java 解法1
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = searchLeft(nums, target);
        int right = searchRight(nums, target);
        return new int[] {left, right};
    }

    int searchLeft(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) { // 等于目标值，进一步缩小右边界
                right = mid - 1;
            } else if (nums[mid] > target) { // 目标值在左边，调整右边界
                right = mid - 1;
            } else { // 目标值在右边，调整左边界
                left = mid + 1;
            }
        }
        if (left < 0 || left >= nums.length) return -1;
        return nums[left] == target ? left : -1;
    }
    int searchRight(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) { // 等于目标值，进一步缩小左边界
                left = mid + 1;
            } else if (nums[mid] > target) { // 目标值在左边
                right = mid - 1;
            } else { // 目标值在右边
                left = mid + 1;
            }
        }
        if (right < 0 || right >= nums.length) return -1;
        return nums[right] == target ? right : -1;
    }
}
```

@tab dart 解法1
```dart
class Solution {
  List<int> searchRange(List<int> nums, int target) {
      int leftIndex = _searchLeftIndex(nums, target);
      int rightIndex = _searchRightIndex(nums, target);
      return [leftIndex, rightIndex];
  }

  // 搜索左边界索引
  int _searchLeftIndex(List<int> nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while ( left <= right ) {
          int mid = left + (right - left)~/2;
          if ( nums[mid] == target ) {
              // 定位到目标值，进一步缩小右边范围
              right = mid - 1;
          } else if ( nums[mid] < target ) {
              // 目标值到右边，缩小左边范围
              left = mid + 1;
          } else { // nums[mid] > target
              // 目标值在左边，缩小右边范围
              right = mid - 1;
          }
      }
      if ( left >= nums.length ) { return -1; }
      return nums[left] == target ? left : -1;
  }

  // 搜索右边界索引
  int _searchRightIndex(List<int> nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while( left <= right ) {
          int mid = left + (right - left)~/2;
          if ( nums[mid] == target ) {
              // 定位到目标值，进一步缩小左边范围
              left = mid + 1;
          } else if ( nums[mid] < target ) {
              // 目标值在右边，缩小左边范围
              left = mid + 1;
          } else { // nums[mid] > target
              // 目标值在左边，缩小右边范围
              right = mid - 1;
          }
      }
      if ( right < 0 ) { return -1; }
      return nums[right] == target ? right : -1;
  }
}
```

@tab swift 解法2
```swift
class Solution {
    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {
        var first = -1
        var last = -1
        var i = 0
        var j = nums.count - 1
        while i <= j {
            if first == -1 {
                if nums[i] == target {
                    first = i
                } else {
                    i += 1
                }
            }
            if last == -1 {
                if nums[j] == target {
                    last = j
                } else {
                    j -= 1
                }
            }
            if first != -1, last != -1 {
                break
            }
        }
        return [first, last]
    }
}
```

:::

// #endregion 0034

## 0035 ✅

// #region 0035

- [🟢 35 - 搜索插入位置](https://leetcode.cn/problems/search-insert-position)
    > 给定一个升序数组和一个目标值，如果目标值在数组中存在返回目标值索引，如果不存在返回插入位置索引。
    
::: details 💡

【思路】二分搜索

::: code-tabs

@tab java
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) {
                return mid; // 找到目标索引
            } else if (nums[mid] > target) { // 目标值在左边，调整右边边界
                right = mid - 1;
            } else { // 目标值在右边，调整左边界
                left = mid + 1;
            }
        }
        return left; // 未找到目标值，返回插入索引
    }
}
```

:::

// #endregion 0035

## 0036

// #region 0036

- [🟠 36 - 有效的数独](https://leetcode.cn/problems/valid-sudoku)

::: details 💡

:::

// #endregion 0036

## 0037

// #region 0037

- [🔴 37 - 解数独](https://leetcode.cn/problems/sudoku-solver)

::: details 💡

:::

// #endregion 0037

## 0038

// #region 0038

- [🟠 38 - 外观数列](https://leetcode.cn/problems/count-and-say)

::: details 💡

:::

// #endregion 0038

## 0039 ✅

// #region 0039

- [🟠 39 - 组合总和](https://leetcode.cn/problems/combination-sum)
    > 给定无重复元素的数组和一个目标值，找出和等于目标值的所有组合(数组中的元素可以重复使用)
    
        🌰
            输入：candidates = [2,3,6,7], target = 7
            输出：[[2,2,3],[7]]
    
::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    int trackSum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtrack(candidates, target, 0);
        return result;
    }

    void backtrack(int[] candidates, int target, int start) {
        if (trackSum > target) return; // 已大于目标值，跳过
        if (trackSum == target) { // 等于目标值，收集组合结果
            result.add(new LinkedList(track));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int candidate = candidates[i];
            track.add(candidate);
            trackSum += candidate;
            backtrack(candidates, target, i); // 可以重复使用
            track.removeLast();
            trackSum -= candidate;
        }
    }
}
```

@tab swift
```swift
class Solution {
    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
        backtrack(candidates, start: 0, target: target, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ candidates: [Int], start: Int, target: Int, track: [Int]) {
        let sum = track.reduce(0, +)
        guard sum < target else {
            guard sum == target else { return }
            res.append(track)
            return
        }
        var track = track
        for i in start..<candidates.count {
            track.append(candidates[i])
            backtrack(candidates, start: i, target: target, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0039

## 0040 ✅

// #region 0040

- [🟠 40 - 组合总和 II](https://leetcode.cn/problems/combination-sum-ii)
    > 给定包含重复元素的数组和一个目标值，找出和等于目标值的所有组合(数组中元素只能使用一次)
    
        🌰
            输入: candidates = [10,1,2,7,6,1,5], target = 8,
            输出:
            [
              [1,1,6],
              [1,2,5],
              [1,7],
              [2,6]
            ]
            
::: details 💡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    int trackSum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // 排序数组，便于进行相同元素剪枝处理
        Arrays.sort(candidates);
        backtrack(candidates, target, 0);
        return result;
    }

    void backtrack(int[] candidates, int target, int start) {
        if (trackSum > target) return;
        if (trackSum == target) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            // 剪枝处理，相同的值只处理一次
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            int candidate = candidates[i];
            track.add(candidate);
            trackSum += candidate;
            backtrack(candidates, target, i + 1);
            track.removeLast();
            trackSum -= candidate;
        }
    }
}
```

:::

// #endregion 0040

## 0041 ✅

// #region 0041

- [🔴 41 - 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive)
    > 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
      请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
        
        🌰
            输入：nums = [1,2,0]
            输出：3
        🌰
            输入：nums = [3,4,-1,1]
            输出：2
        🌰
            输入：nums = [7,8,9,11,12]
            输出：1

::: details 💡

【思路】

::: code-tabs

@tab swift
```swift
class Solution {
    func firstMissingPositive(_ nums: [Int]) -> Int {
        var iNums = nums
        let count = iNums.count
        // 第一次遍历数组，判断是否存在 1
        var hasOne = false 
        for i in 0..<count {
            guard iNums[i] == 1 else { continue }
            hasOne = true
            break
        }
        guard hasOne else { return 1 } // 如果不存在 1，那么最小正整数就是 1
        // 已经存在 1，那么数组中缺少的最小整数肯定是 2 ~ count
        // 第二次遍历数组，将数组中小于 0 的数和大于数组长度的数都置为 1
        for i in 0..<count {
            let num = iNums[i]
            guard num <= 0 || num > count else { continue }
            iNums[i] = 1
        }
        // 第三次遍历数组，对应数字 - 1，就对应[0, n) 数组中的索引，将该索引位置设为负数
        for i in 0..<count {
            let index = abs(iNums[i]) - 1
            if iNums[index] > 0 {
                iNums[index] = -iNums[index]
            }
        }
        // 第四次遍历数组，第一个正整数索引的位置 + 1 = 缺失的数字 (存在的数都在第三次遍历的时候被设为了负数)
        for i in 0..<count {
            guard iNums[i] > 0 else { continue }
            return i + 1
        }
        return count + 1
    }
}
```

:::

// #endregion 0041

## 0042

// #region 0042

- [🔴 42 - 接雨水](https://leetcode.cn/problems/trapping-rain-water)

::: details 💡

:::

// #endregion 0042

## 0043 ✅

// #region 0043

- [🟠 43 - 字符串相乘](https://leetcode.cn/problems/multiply-strings)
    > 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
    
        🌰
            输入: num1 = "2", num2 = "3"
            输出: "6"
        🌰
            输入: num1 = "123", num2 = "456"
            输出: "56088"

::: details 💡

【思路】竖式乘法公式

::: code-tabs

@tab java
```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        char[] chars1 = num1.toCharArray();
        char[] chars2 = num2.toCharArray();
        int[] result = new int[chars1.length + chars2.length];
        for (int i = chars1.length - 1; i >= 0; i--) {
            for (int j = chars2.length - 1; j >= 0; j--) {
                int p0 = i + j + 1; // 个位
                int p1 = i + j; // 十位
                // 计算两位乘积
                int value = (chars1[i] - '0') * (chars2[j] - '0');
                // 加上个位已有的数字
                value += result[p0];

                result[p0] = value % 10;
                result[p1] += value / 10; 
            }
        }

        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < result.length; i++) {
            if (result[i] == 0 && builder.length() == 0) continue;
            builder.append(result[i]); 
        }
        return builder.toString();
    }
}
```

:::

// #endregion 0043

## 0044

// #region 0044

- [🔴 44 - 通配符匹配](https://leetcode.cn/problems/wildcard-matching)

::: details 💡

:::

// #endregion 0044

## 0045

// #region 0045

- [🟠 45 - 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii)

::: details 💡

:::

// #endregion 0045

## 0046 ✅

// #region 0046

- [🟠 46 - 全排列](https://leetcode.cn/problems/permutations)
  > 给定一个没有重复数字的数组，返回其所有可能的全排列。

        🌰
            输入：nums = [1,2,3]
            输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList(); // 全排列结果
    List<Integer> track = new LinkedList(); // 一个排列收集

    public List<List<Integer>> permute(int[] nums) {
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used);
        return result;
    }

    void backtrack(int[] nums, boolean[] used) {
        if (track.size() == nums.length) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue; // 已使用过的数字，跳过
            track.add(nums[i]); // 回溯前，加入
            used[i] = true;
            backtrack(nums, used);
            track.removeLast(); // 回溯后，移除
            used[i] = false;
        }
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[Int]]()
    func permute(_ nums: [Int]) -> [[Int]] {
        backtrack(nums, track: [], used: [:])
        return res
    }
    private func backtrack(_ nums: [Int], track: [Int], used: [Int: Bool]) {
        guard track.count != nums.count else {
            res.append(track)
            return
        }
        var track = track
        var used = used
        for num in nums {
            guard !(used[num] ?? false) else { continue }
            used[num] = true
            track.append(num)
            backtrack(nums, track: track, used: used)
            track.removeLast()
            used[num] = false
        }
    } 
}
```

:::

// #endregion 0046

## 0047 ✅

// #region 0047

- [🟠 47 - 全排列 II](https://leetcode.cn/problems/permutations-ii)
  > 给定一个包含重复数字的数组，返回所有不重复的全排列。

        🌰
            输入：nums = [1,1,2]
            输出：
            [
              [1,1,2],
              [1,2,1],
              [2,1,1]
            ]

::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums); // 排序数组，便于剪枝处理
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used);
        return result;
    }

    void backtrack(int[] nums, boolean[] used) {
        if (track.size() == nums.length) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // 剪枝处理：已使用，跳过
            if (used[i]) continue;
            // 相同元素，需要保证前面元素已使用，如果未使用，跳过
            // 核心点在于保持相同元素的相对位置保持不变
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
            track.add(nums[i]);
            used[i] = true;
            backtrack(nums, used);
            track.removeLast();
            used[i] = false;
        }
    }
}
```

:::

// #endregion 0047

## 0048

// #region 0048

- [🟠 48 - 旋转图像](https://leetcode.cn/problems/rotate-image)

::: details 💡

:::

// #endregion 0048

## 0049

// #region 0049

- [🟠 49 - 字母异位词分组](https://leetcode.cn/problems/group-anagrams)

::: details 💡

:::

// #endregion 0049

## 0050 ✅

// #region 0050

- [🟠 50 - Pow(x, n)](https://leetcode.cn/problems/powx-n)
    > 实现一个浮点数 x 的整数 n 次幂函数
    
        🌰
            输入：x = 2.10000, n = 3
            输出：9.26100
        🌰
            输入：x = 2.00000, n = -2
            输出：0.25000

::: details 💡

【思路1】通过幂次是否为正数幂次，然后去幂次的绝对值进行幂次运算，最后根据幂次符号进行结果返回。

【思路2】二分法进行时间复杂度降级， `x^n` 的幂次求解
  - n 如果是奇数 `x^n = x * x^(n-1)`，`n-1` 就是偶数了
  - n 如果是偶数 `x^n = (x^(n/2))^2`

【思路3】进一步优化思路2，将递归改为迭代解法

::: code-tabs

@tab java 解法1 (超时)
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // 是否是正幂次
        int i = Math.abs(n);
        double result = 1;
        while (i >= 1) {
            result *= x;
            i -= 1;
        }
        return isPositive ? result : 1 / result;
    }
}
```

@tab java 解法2 (栈溢出)
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // 是否是正幂次
        double result = positivePow(x, Math.abs(n));
        return isPositive ? result : 1 / result;
    }

    /// 正数幂次
    double positivePow(double x, int n) {
        if (n == 0) return 1;
        if (n % 2 == 0) { // 偶数幂次
            double x2 = positivePow(x, n/2);
            return x2 * x2;
        } else { // 奇数幂次
            return x * positivePow(x, n - 1);
        }
    }
}
```

@tab java 解法3 💯
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // 是否是正幂次
        long i = Math.abs((long)n); // 需要将 n 转化为长整型，防止取绝对值溢出
        double result = 1;
        double square = x;
        while (i > 0) {
            if ((i % 2) != 0) { // 奇数时
                result *= square;
            }
            square *= square;
            i /= 2;
        }
        return isPositive ? result : 1 / result;
    }
}
```

@tab swift 解法3 💯
```swift
class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        guard x != 0 else { return 0 }
        var isPositive = n > 0 // 是否为正次幂
        var num = abs(n)
        var square = x
        var result: Double = 1
        while num > 0 {
            if num % 2 != 0 { // 奇数
                result *= square
            }
            square *= square
            num /= 2
        }
        return isPositive ? result : 1/result
    }
}
```

:::

// #endregion 0050

## 0051

// #region 0051

- [🔴 51 - N 皇后](https://leetcode.cn/problems/n-queens)
    > 将 n 个皇后棋子，放置在 nxn 的棋盘中。'Q'代表皇后，'.'代表空位，返回所有的不同的解决方案。
    > 国际象棋的规则 : 皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
    
        🌰
            输入：n = 4
            输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
            输入：n = 1
            输出：[["Q"]]
    
::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<String>> result = new LinkedList(); // 所有结果列表
    char[][] chessboard; // 记录棋盘棋子

    public List<List<String>> solveNQueens(int n) {
        // 创建棋盘，初始化都为空 '.'
        chessboard = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                chessboard[i][j] = '.';
            }
        }
        // 进行回溯求解
        backtrack(n, 0);
        return result;
    }

    void backtrack(int n, int row) {
        if (row == n) {
            // 棋盘已下完
            List<String> list = new LinkedList();
            for (int i = 0; i < n; i++) {
                list.add(new String(chessboard[i]));
            } 
            result.add(list);
            return;
        }
        // 遍历这行每一列
        for (int i = 0; i < n; i++) {
            if (!isValid(n, row, i)) continue; // 无效位置，跳过
            // 加入棋盘
            chessboard[row][i] = 'Q';
            // 进行下一行求解
            backtrack(n, row + 1);
            // 从棋盘中移除
            chessboard[row][i] = '.';
        }
    }
    
    /// 根据行列坐标判断该位置是否合法
    boolean isValid(int n, int row, int column) {
        // 判断行 - 是否存在 Q (row 行还未下，不需要判断)
        // 判断列 | 是否存在 Q (row 行以下还没下，只需要判断 row 以上行)
        for (int i = 0; i < row; i++) {
            if (chessboard[i][column] == 'Q')
                return false;
        }
        // 判断左斜方向 / 是否存在 Q (只需要判断 row 以上)
        int i = row - 1;
        int j = column + 1;
        while (i >= 0 && j < n) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j += 1;
        }
        // 判断右斜方向 \ 是否存在 Q (只需要判断 row 以上)
        i = row - 1;
        j = column - 1;
        while (i >= 0 && j >= 0) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j -= 1;
        }
        return true;
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[String]]()
    func solveNQueens(_ n: Int) -> [[String]] {
        var board = [[Character]].init(repeating: [Character].init(repeating: Character("."), count: n), count: n)
        backtrack(&board, row: 0)
        return res
    }
    
    private func backtrack(_ board: inout [[Character]], row: Int) {
        guard row < board.count else {
            res.append(board.map({ String($0) }))
            return
        }
        for col in 0..<board[row].count {
            guard isValid(board, row: row, col: col) else { continue }
            board[row][col] = Character("Q")
            backtrack(&board, row: row + 1)
            board[row][col] = Character(".")
        }
    }
    private func isValid(_ board: [[Character]], row: Int, col: Int) -> Bool {
        func chess(row: Int, col: Int) -> Character? {
            guard 0 <= row, row < board.count, 
                  0 <= col, col < board[row].count else { return nil }
            return board[row][col]
        }
        func isQ(row: Int, col: Int) -> Bool {
            guard let chess = chess(row: row, col: col) else { return false }
            return String(chess) == "Q"
        }
        // -
        for i in 0..<col {
            guard isQ(row: row, col: i) else { continue }
            return false
        }
        // |
        for i in 0..<row {
            guard isQ(row: i, col: col) else { continue }
            return false
        }
        // \
        var i = row
        var j = col
        while i >= 0, j >= 0 {
            i -= 1
            j -= 1
            guard isQ(row: i, col: j) else { continue }
            return false
        }
        // /
        var m = row
        var n = col
        while m >= 0, n < board.count {
            m -= 1
            n += 1
            guard isQ(row: m, col: n) else { continue }
            return false
        }

        return true
    }
}
```

:::

// #endregion 0051

## 0052

// #region 0052

- [🔴 52 - N 皇后 II](https://leetcode.cn/problems/n-queens-ii)
    > 返回 N 皇后问题的解决方案数量
    
::: details 💡

:::

// #endregion 0052

## 0053 ✅

// #region 0053

- [🟠 53 - 最大子数组和](https://leetcode.cn/problems/maximum-subarray)
    > 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    > 子数组是数组中的一个连续部分。

        🌰
            输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
            输出：6 (最大子数组：[4,-1,2,1])

        🌰
            输入：nums = [5,4,-1,7,8]
            输出：23

::: details 💡

【思路1】滑动窗口，遍历数组扩大窗口，当窗口和小于 0 时，进行窗口缩小，扩大窗口的时候进行最大和的替换。

【思路2】动态规划，每次通过中间变量保存目前遍历值之前的最大和，通过与当前值进行判断比较保留最终结果的最大和。

【思路3】前缀和，

::: code-tabs

@tab java 解法1
```java 
class Solution {
    public int maxSubArray(int[] nums) {
        int windowSum = 0;
        int maxSum = Integer.MIN_VALUE;
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            // 扩大窗口
            windowSum += nums[right];
            right += 1;

            // 保留最大和
            maxSum = maxSum > windowSum ? maxSum : windowSum;

            // 窗口和小于 0 时，缩小窗口
            while (windowSum < 0) {
                windowSum -= nums[left];
                left += 1;
            }
        }
        return maxSum;
    }
}
```

@tab java 解法2
```java
class Solution {
    public int maxSubArray(int[] nums) {
        // 保存最大和
        int maxSum = Integer.MIN_VALUE;
        // 遍历过程中的最大和
        int sum = 0; 
        for (int num : nums) {
            // 保留遍历过程的最大和
            sum = Math.max(num, sum + num); 
            // 替换结果最大和
            maxSum = Math.max(maxSum, sum);
        }
        return maxSum;
    }
}
```

@tab java 解法3
```java

```

:::

// #endregion 0053

## 0054 ✅

// #region 0054

- [🟠 54 - 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix)
    > 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
        
        🌰
            1 2 3
            4 5 6
            7 8 9
            输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
            输出：[1,2,3,6,9,8,7,4,5]

::: details 💡

【思路】通过上下左右四个边界控制遍历边界，通过二维数组的长宽计算总元素数量，按照规律进行上 -> 右 -> 下 -> 左 的螺旋规则进行遍历，并进一步缩小边界。最后当收集到的元素等与目标数量，则遍历完成。

::: code-tabs

@tab java
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int h = matrix.length;
        int w = matrix[0].length;
        int count = h * w;
        int top = 0;
        int bottom = h - 1;
        int left = 0;
        int right = w - 1;
        
        List<Integer> result = new LinkedList();
        while (result.size() < count) {
            // 1> 进行上遍历
            if (top <= bottom) {
                for (int i = left; i <= right; i++) {
                    result.add(matrix[top][i]);
                }
                top += 1;
            }
            
            // 2> 进行右边遍历
            if (left <= right) {
                for (int i = top; i <= bottom; i++) {
                    result.add(matrix[i][right]);
                }
                right -= 1;
            }
            // 3> 进行下遍历
            if (top <= bottom) {
                for (int i = right; i >= left; i--) {
                    result.add(matrix[bottom][i]);
                }
                bottom -= 1;
            }
            // 4> 进行左边遍历
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result.add(matrix[i][left]);
                }
                left += 1;
            }
        }
        return result;
    }
}
```

@tab swift
```swift
class Solution {
    func spiralOrder(_ matrix: [[Int]]) -> [Int] {
        var h = matrix.count
        var w = matrix[0].count
        var count = h * w

        var top = 0
        var bottom = h - 1
        var left = 0
        var right = w - 1

        var result = [Int]()
        while (result.count < count) {
            if top <= bottom, left <= right {
                for i in left...right {
                    result.append(matrix[top][i])
                }
                top += 1
            }
            if top <= bottom, left <= right {
                for i in top...bottom {
                    result.append(matrix[i][right])
                }
                right -= 1
            }
            if top <= bottom, left <= right {
                for i in (left...right).reversed() {
                    result.append(matrix[bottom][i])
                }
                bottom -= 1
            }
            if top <= bottom, left <= right {
                for i in (top...bottom).reversed() {
                    result.append(matrix[i][left])
                }
                left += 1
            }
        }
        return result
    }
}
```

:::

// #endregion 0054

## 0055

// #region 0055

- [🟠 55 - 跳跃游戏](https://leetcode.cn/problems/jump-game)

::: details 💡

:::

// #endregion 0055

## 0056

// #region 0056

- [🟠 56 - 合并区间](https://leetcode.cn/problems/merge-intervals)

::: details 💡

:::

// #endregion 0056

## 0057

// #region 0057

- [🟠 57 - 插入区间](https://leetcode.cn/problems/insert-interval)

::: details 💡

:::

// #endregion 0057

## 0058

// #region 0058

- [🟢 58 - 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word)

::: details 💡

:::

// #endregion 0058

## 0059

// #region 0059

- [🟠 59 - 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii)

::: details 💡

:::

// #endregion 0059

## 0060

// #region 0060

- [🔴 60 - 排列序列](https://leetcode.cn/problems/permutation-sequence)

::: details 💡

:::

// #endregion 0060

## 0061

// #region 0061

- [🟠 61 - 旋转链表](https://leetcode.cn/problems/rotate-list)

::: details 💡

:::

// #endregion 0061

## 0062

// #region 0062

- [🟠 62 - 不同路径](https://leetcode.cn/problems/unique-paths)

::: details 💡

:::

// #endregion 0062


## 0063

// #region 0063

- [🟠 63 - 不同路径 II](https://leetcode.cn/problems/unique-paths-ii)

::: details 💡

:::

// #endregion 0063

## 0064

// #region 0064

- [🟠 64 - 最小路径和](https://leetcode.cn/problems/minimum-path-sum)

::: details 💡

:::

// #endregion 0064

## 0065

// #region 0065

- [🔴 65 - 有效数字](https://leetcode.cn/problems/valid-number)

::: details 💡

:::

// #endregion 0065

## 0066

// #region 0066

- [🟢 66 - 加一](https://leetcode.cn/problems/plus-one)

::: details 💡

:::

// #endregion 0066

## 0067

// #region 0067

- [🟢 67 - 二进制求和](https://leetcode.cn/problems/add-binary)

::: details 💡

:::

// #endregion 0067

## 0068

// #region 0068

- [🔴 68 - 文本左右对齐](https://leetcode.cn/problems/text-justification)

::: details 💡

:::

// #endregion 0068

## 0069

// #region 0069

- [🟢 69 - x 的平方根](https://leetcode.cn/problems/sqrtx)

::: details 💡

:::

// #endregion 0069

## 0070 ✅

// #region 0070 

- [🟢 70 - 爬楼梯](https://leetcode.cn/problems/climbing-stairs)

::: details 💡

::: code-tabs

【思路1】动态规划，自顶向下，递归解法

【思路2】动态规划，自底向上，迭代解法

@tab java 解法1
```java
class Solution {
    Map<Integer, Integer> dp = new HashMap();
    public int climbStairs(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (dp.containsKey(n)) return dp.get(n);
        // 到达第 n 阶台阶方法 = 到达 n-1 阶台阶方法数(再爬1阶) + 到达 n-2 阶台阶方法数(再爬2阶)
        int fn = climbStairs(n - 1) + climbStairs(n - 2);
        dp.put(n, fn);
        return fn;
    }
}
```

@tab java 解法2
```java
class Solution {
    public int climbStairs(int n) {
        if (n < 3) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

@tab swift 解法2
```swift
class Solution {
    func climbStairs(_ n: Int) -> Int {
        guard n > 2 else { return n }
        var dp = [Int](repeating: 0, count: n+1)
        dp[1] = 1
        dp[2] = 2
        for i in 3...n {
            dp[i] = dp[i - 1] + dp[i - 2]
        }
        return dp[n]
    }
}
```

:::

// #endregion 0070

## 0071

// #region 0071

- [🟠 71 - 简化路径](https://leetcode.cn/problems/simplify-path)

::: details 💡

:::

// #endregion 0071

## 0072 ✅

// #region 0072

- [🔴 72 - 编辑距离](https://leetcode.cn/problems/edit-distance)
    > 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
    > 你可以对一个单词进行如下三种操作：
    >       插入一个字符
    >       删除一个字符
    >       替换一个字符

        🌰
            输入：word1 = "horse", word2 = "ros"
            输出：3
            解释：
            horse -> rorse (将 'h' 替换为 'r')
            rorse -> rose (删除 'r')
            rose -> ros (删除 'e')
        🌰
            输入：word1 = "intention", word2 = "execution"
            输出：5
            解释：
            intention -> inention (删除 't')
            inention -> enention (将 'i' 替换为 'e')
            enention -> exention (将 'n' 替换为 'x')
            exention -> exection (将 'n' 替换为 'c')
            exection -> execution (插入 'u')
            
::: details 💡

【思路1】动态规划，迭代(自顶向下)

【思路2】动态规划，递归(自顶向上)

::: code-tabs

@tab java 解法1
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        // 定义 dp 表，代表每位位置需要修改的步数
        int dp[][] = new int[m + 1][n + 1];
        // 初始化第一行的修改数就是字符的长度
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < n + 1; i++) {
            dp[0][i] = i;
        }
        // 遍历进行 dp 表的填充
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 该位置上一位置索引匹配，则不需要修改
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 不匹配，需要修改，选取其中最小值加上一步，就是该位置最小修改步数
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```

@tab swift 解法2
```swift
class Solution {
    func minDistance(_ word1: String, _ word2: String) -> Int {
        let char1s = [Character](word1)
        let char2s = [Character](word2)

        var cache = [[Int?]](repeating: [Int?](repeating: nil, count: char2s.count), count: char1s.count)

        func dp(i: Int, j: Int) -> Int {
            if i == -1 { return j + 1 }
            if j == -1 { return i + 1 }
            if let value = cache[i][j] { return value }
            
            let value = char1s[i] == char2s[j] ?
                dp(i: i - 1, j: j - 1)
                :
                min(
                    dp(i: i - 1, j: j) + 1,     // 删除一个字符
                    dp(i: i - 1, j: j - 1) + 1, // 替换一个字符 
                    dp(i: i, j: j - 1) + 1      // 增加一个字符
                )
            cache[i][j] = value
            return value
        }

        return dp(i: char1s.count - 1, j: char2s.count - 1)
    }
}
```

:::

// #endregion 0072

## 0073

// #region 0073

- [🟠 73 - 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes)

::: details 💡

:::

// #endregion 0073

## 0074

// #region 0074

- [🟠 74 - 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix)

::: details 💡

:::

// #endregion 0074

## 0075 ✅

// #region 0075

- [🟠 75 - 颜色分类](https://leetcode.cn/problems/sort-colors)
    > 给定一个包含红色、白色和蓝色的是数组，使用整数 0、 1 和 2 分别表示红色、白色和蓝色，按照红色、白色、蓝色顺序排列。
    
        🌰
            输入：nums = [2,0,2,1,1,0]
            输出：[0,0,1,1,2,2]

::: details 💡

> 荷兰国旗问题

【思路】统计法，先统计各种颜色的个数，再按照颜色个数给数组重新赋值。

::: code-tabs

@tab java
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        int white = 0;
        int blue = 0;
        /// 统计三种颜色个数
        for (int i = 0; i < nums.length; i++) {
            if ( nums[i] == 0 ) {
                red += 1;
            } else if ( nums[i] == 1 ) {
                white += 1;
            } else if ( nums[i] == 2 ) {
                blue += 1;
            }
        }
        // 按照个数重新给数组赋值
        for ( int i = 0; i < red; i++ ) {
            nums[i] = 0;
        }
        for ( int i = red; i < red + white; i++ ) {
            nums[i] = 1;
        }
        for ( int i = red + white; i < nums.length; i++ ) {
            nums[i] = 2;
        }
    }
}
```

:::

> 进阶：仅使用常数空间的一趟扫描算法吗？

::: details 💡

【思路1】双指针法，数组头指针用于指向 0，尾指针用于指向 2。一次遍历数组，如果值为 0 与头指针位置交换，如果值为 2 与尾指针位置交换。

【思路2】刷油漆法，其实这个方法类似统计法，将其优化为了一次遍历。遍历数组，先保留该值。

  - 先将该位置刷为 2。
  - 如果值 <2，将 1 索引下刷为 1，刷 1 的索引增加。(为什么不是 == 1？当值为 0 时，相等于将刷 1 的范围往后移动了一位，因为后面 <1 的判断，刷 0 的长度会加 1)
  - 如果值 <1，将 0 索引下刷为 0，刷 0 的索引需要增加。

::: code-tabs

@tab java 解法1
```java
class Solution {
    public void sortColors(int[] nums) {
        if ( nums.length <= 1 ) return;
        int head = 0;
        int tail = nums.length - 1;
        for ( int i = 0; i < nums.length; i++ ) {
            if ( nums[i] == 0 ) {
                // 如果索引位置值为 0，则先进行头部交换并将头部指针往前移动
                swap(nums, head, i);
                head += 1;
                // 交换之后，再进行尾部交换
                if ( nums[i] == 2 ) {
                    swap(nums, i, tail);
                    tail -= 1;
                }
            } else if ( nums[i] == 2 ) {
                // 如果索引位置值为 2，则先进行尾部交换并将尾部指针往后移动
                swap(nums, i, tail);
                tail -= 1;
                // 交换之后，再进行头部交换
                if ( nums[i] == 0 ) {
                    swap(nums, head, i);
                    head += 1;
                }
            }
            // 遍历索引已经尾部索引相遇，不需要再进行处理
            if ( i >= tail ) break;
        }
    }
    void swap(int[] nums, int i, int j) {
        if ( i == j ) return;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

@tab java 解法2
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0; // 刷红色的长度
        int white = 0;  // 刷白色的长度
        for ( int i = 0; i < nums.length; i++ ) {
            int num = nums[i]; 
            nums[i] = 2; // 先将全部刷为 blue = 2
            // 如果值为 0 或 1，则白色索引下刷为 white = 1，白色长度增加
            if ( num < 2 ) { 
                nums[white] = 1;
                white += 1;
            }
            // 如果值为 0，则红色索引下刷为 red = 0，红色长度增加
            if ( num < 1 ) {
                nums[red] = 0;
                red += 1;
            }
        }
    }
}
```

:::

// #endregion 0075

## 0076 ✅

// #region 0076

- [🔴 76 - 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)
    > 给定义一个字符串和一个目标值字符串，返回字符串中包含目标字符串的最小子串，如果不存在返回空串。
    
        🌰
            输入：s = "ADOBECODEBANC", t = "ABC"
            输出："BANC"

::: details 💡

【思路】滑动窗口

::: code-tabs

@tab java
```java
class Solution {
    public String minWindow(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        
        Map<Character, Integer> need = new HashMap(); // 需求的字符表
        int needCount = 0; // 需要字符有效性计数(等于 need 大小时，表明已符合要求)
        // 填入需要的字符
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> window = new HashMap(); // 窗口字符表
        int left = 0;
        int right = 0;
        // 保存最小窗口的开始结束索引
        int minStart = 0;
        int minStop = Integer.MAX_VALUE;
        // 调整窗口右边界，直到符合条件
        while(right < sChars.length) {
            char c = sChars[right];
            if (need.containsKey(c)) {
                // 是需要的字符，加入窗口
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    // 该字符已达到要求数量，有效性增加
                    needCount += 1;
                }
            }
            right += 1; // 扩大窗口
            
            // 字符窗口已符合要求，开始调整左边界缩小，直至不满足要求
            while (needCount == need.size()) {
                // 更新最小值
                if (minStop - minStart > (right - left)) {
                    minStart = left;
                    minStop = right;
                }
                char cc = sChars[left];
                if (window.containsKey(cc)) {
                    // 字符数量等于需求数时，由于即将 -1，所以有消息较少
                    if (window.get(cc).equals(need.get(cc))) {
                        needCount -= 1;
                    }
                    window.put(cc, window.getOrDefault(cc, 0) - 1);
                }
                left += 1; // 缩小窗口
            }
        }
        if (minStop == Integer.MAX_VALUE) return ""; // 未找到
        return s.substring(minStart, minStop);
    }
}
```

@tab swift
```swift
class Solution {
    func minWindow(_ s: String, _ t: String) -> String {
        let schars = [Character](s)
        let tchars = [Character](t)
        let scount = schars.count
        let tcount = tchars.count
        guard tcount <= scount else { return "" }
        
        var need = [Character: Int]()
        for char in tchars {
            need[char] = (need[char] ?? 0) + 1
        }

        func isValid() -> Bool {
            !need.values.contains(where: { $0 > 0 })
        }

        var start: Int = 0
        var count: Int = 0

        var i = 0
        var j = 0
        while i < scount {
            let ichar = schars[i]
            if need.keys.contains(ichar) {
                need[ichar] = (need[ichar] ?? 0) - 1
            }
            i += 1
            guard isValid() else { continue }
            while j < i {
                let jchar = schars[j]
                if need.keys.contains(jchar) {
                    need[jchar] = min(1, (need[jchar] ?? 0) + 1)
                }
                j += 1
                guard !isValid() else { continue }
                if count == 0 || count > (i - j) {
                    start = j - 1
                    count = i - j + 1
                }
                break
            }
        }
        guard count > 0 else { return "" }
        return String(schars[start..<(start + count)])
    }
}
```

:::

// #endregion 0076

## 0077 ✅

// #region 0077

- [🟠 77 - 组合](https://leetcode.cn/problems/combinations)
    > 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
    
        🌰
            输入：n = 4, k = 2
            输出：
            [
              [2,4],
              [3,4],
              [2,3],
              [1,2],
              [1,3],
              [1,4],
            ]
    
::: details 💡

【思路】回溯法

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> combine(int n, int k) {
        backtrack(n, k, 1);
        return result;
    }

    void backtrack(int n, int k, int start) {
        if (track.size() == k) { // 等于目标组合数时，收集组合
            result.add(new LinkedList(track));
            return;
        }
        // 未达到目标组合数，继续进行递归回溯
        for (int i = start; i <= n; i++) {
            track.add(i);
            backtrack(n, k, i+1);
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func combine(_ n: Int, _ k: Int) -> [[Int]] {
        backtrack(n, start: 1, k: k, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ n: Int, start: Int, k: Int, track: [Int]) {
        if track.count == k {
            res.append(track)
            return
        }

        var track = track
        for i in start..<(n + 1) {
            track.append(i)
            backtrack(n, start: i + 1, k: k, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0077

## 0078 ✅

// #region 0078

- [🟠 78 - 子集](https://leetcode.cn/problems/subsets)
    
        🌰
            输入：nums = [1,2,3]
            输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
    
::: details 💡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return result;
    }
    
    void backtrack(int[] nums, int start) {
        result.add(new LinkedList(track));
        for (int i = start; i < nums.length; i++) {
            track.add(nums[i]);
            backtrack(nums, i + 1); // 继续回溯当前索引的后一个元素，确保不会出现重复子集
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func subsets(_ nums: [Int]) -> [[Int]] {
        backtrack(nums, track: [], start: 0)
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ nums: [Int], track: [Int], start: Int) {
        res.append(track)

        var track = track
        for i in start..<nums.count {
            track.append(nums[i])
            backtrack(nums, track: track, start: i + 1)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0078

## 0079

// #region 0079

- [🟠 79 - 单词搜索](https://leetcode.cn/problems/word-search)

::: details 💡

:::

// #endregion 0079

## 0080 ✅

// #region 0080

- [🟠 80 - 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii)
    > 给定一个有序数组，删除数组中重复元素(保留两个)。
    
        🌰
            输入：nums = [1,1,1,2,2,3]
            输出：5, nums = [1,1,2,2,3]

::: details 💡

【思路1】双指针法，核心点在于如何将重复元素保留两个。快指针索引为遍历指针，

  - 当遍历值与下一个值是否相等，不相等时，需要移动慢指针，将快指针值赋值到慢指针为止
  - 相等时，先将快指针位置赋值到慢指针位置；跳过中间重复元素；然后将最后一个重复元素也赋值到慢指针位置。

【思路2】也是双指针，但是不是添加第一个和最后一个重复元素，而是保证间隔为 2 的元素不相等即可。

  - 判断数组长度是否大于 2，小于 2 不需要处理。
  - 大于 2 时，判断快指针索引位置元素，与慢指针索引 - 2 的位置元素是否相等。
    * 如果相等，则跳过该元素
    * 如果不相等，则将快指针元素赋值给慢指针位置，移动慢指针。

::: code-tabs

@tab java 解法1
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                // 是重复元素
                //  1> 添加第一个重复元素
                slow += 1;
                nums[slow] = nums[fast];
                //  2> 跳过中间的重复元素
                while ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                    fast += 1;
                }
                //  3> 添加最后一个重复元素
                slow += 1;
                nums[slow] = nums[fast];
                //  4> 跳过最后一个重复元素
                fast += 1;
            } else {
                // 不是重复元素，移动慢指针，将快指针元素赋值到慢指针索引位置
                slow += 1;
                nums[slow] = nums[fast];
                fast += 1;
            }
        }
        return slow + 1;
    }
}
```

@tab swift 解法2 💯
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        let count = nums.count
        // 输出大于 2 时才需要处理
        guard count > 2 else { return count }
        var slow = 2
        var fast = 2
        while ( fast < count ) {
            
            if ( nums[slow - 2] != nums[fast] ) {
                nums[slow] = nums[fast] 
                slow += 1
            }
            fast += 1
        }
        return slow
    }
}
```

:::

// #endregion 0080

## 0081

// #region 0081

- [🟠 81 - 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii)

::: details 💡

:::

// #endregion 0081

## 0082 ✅

// #region 0082

- [🟠 82 - 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)
    > 给定一个已排序的链表，删除链表中的重复元素(重复元素全部删除)。

        🌰
            输入：1 -> 1 -> 1 -> 2 -> 3
            输出：2 -> 3

::: details 💡

【思路】双指针法，创建已伪头结点，用于解决链表为空或全部为重复元素的情况；然后慢指针指向伪头结点，快指针从头结点开始遍历。

  - 如果快指针节点与后面节点值相等，则跳过全部重复节点。特殊情况处理，跳过之后如果链表已经结束，则需要将慢指针指向 null。
  - 如果快指针节点与后面节点不相等，则表明不是重复节点。则将慢指针的后继节点指向快指针节点，然后将快慢指针都往前移动一步。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy.next;
        while ( fast != null ) {
            // 快指针去探测不重复的节点
            if ( fast.next != null && fast.val == fast.next.val ) {
                // 探测到重复节点，跳过重复元素
                while ( fast.next != null && fast.val == fast.next.val ) {
                    fast = fast.next;
                }
                // 指向了最后一个重复节点，往前移动一步
                fast = fast.next;
                // 后面为空，则将慢指针指向 null
                if ( fast == null ) {
                    slow.next = null;
                }
            } else {
                // 探测到不重复节点，将慢指针指向节点，并往前移动
                slow.next = fast;
                slow = slow.next;
                fast = fast.next;
            }
        }
        return dummy.next;
    }
}
```

:::

// #endregion 0082

## 0083 ✅

// #region 0083

- [🟢 83 - 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)
  > 给定一个已排序的链表，删除链表中的重复元素(重复元素保留一个)。

        🌰
            输入：1 -> 1 -> 1 -> 2 -> 3
            输出：1 -> 2 -> 3

::: details 💡

【思路1】双指针法，取巧方案，类似排序数组中的删除重复元素方案，每次判断值不一样时，将慢指针往前移动，将快指针中的值赋值到慢指针位置。

【思路2】思路 1 虽然得到结果是正确，但是却改变了节点。 优化思路 1 方案，每次判断值不一样时，不进行赋值，直接将慢指针指向快指针节点。

::: code-tabs

@tab java 思路1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // 快指针值与慢指针指不一样时，将慢指针往前移动，
            if ( fast.val != slow.val ) {
                slow = slow.next;
                slow.val = fast.val;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

@tab java 思路2
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // 值不相等时，将慢指针指向快指针节点，并将慢指针往前移动
            if ( fast.val != slow.val ) {
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

:::

// #endregion 0083

## 0084

// #region 0084

- [🔴 84 - 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram)

::: details 💡

:::

// #endregion 0084

## 0085

// #region 0085

- [🔴 85 - 最大矩形](https://leetcode.cn/problems/maximal-rectangle)

::: details 💡

:::

// #endregion 0085

## 0086 ✅

// #region 0086

- [🟠 86 - 分隔链表](https://leetcode.cn/problems/partition-list)
  > 根据给定值将链表元素分割为小于和大于等于该值的两部分。并保持节点元素相对位置。

        🌰
            
            输入：head = [1,4,3,2,5,2], x = 3
            输出：[1,2,2,4,3,5]

::: details 💡

【思路】将原链表按照值大小分隔成两条链表，最后合并成结果链表。

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode l1 = new ListNode(); // 小于 x 链表
        ListNode l2 = new ListNode(); // 大于 x 链表
        ListNode p1 = l1;
        ListNode p2 = l2;
        // 遍历链表，按照大小将原链表分成两条链表，分解时需要注意分解节点与原链表的断开问题。
        ListNode p = head;
        while ( p != null ) {
            if ( p.val < x ) {
                p1.next = p;    // 将节点添加到小于 x 链表
                p = p.next;     // 链表指针前进
                p1 = p1.next;   // 小于 x 链表指针前进
                p1.next = null; // 并将小于 x 链表与原链表断开
            } else {
                p2.next = p;    
                p = p.next;
                p2 = p2.next;
                p2.next = null;
            }
        }
        // 合并成一条
        p1.next = l2.next;
        return l1.next; 
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {
        let minHead = ListNode(0)
        var min: ListNode? = minHead
        let maxHead = ListNode(0)
        var max: ListNode? = maxHead
        var node = head
        // 根据值大小创建了两条新链表，最后合并。这样不需要处理链表断开的问题。
        while node != nil {
            guard let n = node  else { break }
            if n.val < x {
                min?.next = ListNode(n.val)
                min = min?.next
            } else {
                max?.next = ListNode(n.val)
                max = max?.next
            }
            node = n.next
        }
        min?.next = maxHead.next
        return minHead.next
    }
}
```

:::

// #endregion 0086

## 0087

// #region 0087

- [🔴 87 - 扰乱字符串](https://leetcode.cn/problems/scramble-string)

::: details 💡

:::

// #endregion 0087

## 0088

// #region 0088

- [🟢 88 - 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array)
    > 给你两个按 “非递减顺序” 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请合并 nums2 到 nums1 (nums1 数组长度为 m+n) 中，使合并后的数组同样按 “非递减顺序” 排列。

        🌰
            输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
            输出：[1,2,2,3,5,6]

::: details 💡

【思路】使用双指针，指向两个数组的有元素的尾部，使用一个指针指向总长度的位置索引。倒序遍历两个数组，比较大小，将大的元素，加入结果数组 nums1 尾部指针的地方。结束之后，如果 nums2 数组中还有元素，则直接倒序加入结果 nums1 数组中即可。

::: code-tabs

@tab java
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            int num1 = nums1[i];
            int num2 = nums2[j];
            // 比较数据大小，将数据加入结果数组中
            if (num2 >= num1) { 
                nums1[k] = num2;
                j -= 1;
            } else {
                nums1[k] = num1;
                i -= 1;
            }
            k -= 1;
        }   
        // 如果 nums2 还有元素，直接加入到结果数组中
        while (j >= 0) {
            nums1[k] = nums2[j];
            j -= 1;
            k -= 1;
        }
    }
}
```

@tab swift
```swift
class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        var i = m - 1;
        var j = n - 1;
        var k = m + n - 1;
        while ( i >= 0 && j >= 0 ) {
            if ( nums1[i] >= nums2[j] ) {
                nums1[k] = nums1[i]
                i -= 1
            } else {
                nums1[k] = nums2[j]
                j -= 1
            }
            k -= 1
        }
        while ( j >= 0 ) {
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
        } 
    }
}
```

:::

// #endregion 0088

## 0089

// #region 0089

- [🟠 89 - 格雷编码](https://leetcode.cn/problems/gray-code)

::: details 💡

:::

// #endregion 0089

## 0090 ✅

// #region 0090

- [🟠 90 - 子集 II](https://leetcode.cn/problems/subsets-ii)
    
        🌰
            输入：nums = [1,2,2]
            输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
    
::: details 💡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 核心点在于保证相同元素的相同位置保持不变
        Arrays.sort(nums);
        backtrack(nums, 0);
        return result;
    }

    void backtrack(int[] nums, int start) {
        result.add(new LinkedList(track));
        for (int i = start; i < nums.length; i++) {
            // 剪枝逻辑：避免回溯之相同的元素
            if (i > start && nums[i] == nums[i - 1]) continue;
            track.add(nums[i]);
            backtrack(nums, i + 1);
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {
        backtrack(nums.sorted(), start: 0, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ nums: [Int], start: Int, track: [Int]) {
        res.append(track)

        var track = track
        for i in start..<nums.count {
            if i > start, nums[i] == nums[i - 1] { continue }
            track.append(nums[i])
            backtrack(nums, start: i + 1, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0090

## 0091

// #region 0091

- [🟠 91 - 解码方法](https://leetcode.cn/problems/decode-ways)

::: details 💡

:::

// #endregion 0091

## 0092 ✅

// #region 0092

- [🟠 92 - 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)
  > 通过单链表的头结点 head 和两个整数 left 和 right (left <= right)，反转链表从 left 到 right 位置的链表节点，返回反转后的链表。

        🌰 1 -> 2 -> 3 -> 4 -> 5
            输入：head = [1,2,3,4,5], left = 2, right = 4
            输出：[1,4,3,2,5]
            
::: details 💡

【思路】先通过遍历，得到反转区域的左右节点，通过这两个节点，可以进行该区域的链表的反转，反转之后通过这两个节点将反转后的链表连接起来。

::: code-tabs

@tab java 
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left >= right) return head;
        // 给链表加头，解决头结点也参与反转的问题
        ListNode dummy = new ListNode();
        dummy.next = head;
        // 遍历得到左右节点
        ListNode leftNode = dummy; // 左节点：反转的前一个节点
        ListNode rightNode = dummy; // 右节点：反转的后一个节点
        for (int i = 0; i < right + 1; i++) {
            if (i < left - 1) {
                leftNode = leftNode.next;
            }
            rightNode = rightNode.next;
        }
        // 反转的头结点
        ListNode reverseHead = leftNode.next;
        // 将左节点下一个节点指向反转后的头结点
        leftNode.next = reverse(reverseHead, rightNode);
        // 反转的头结点，反转后变为了尾结点，指向有右节点
        reverseHead.next = rightNode;
        return dummy.next;
    }

    // 反转指定范围节点，到 tail 为止(tail 不参与反转)
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode result = null;
        ListNode node = head;
        while (node != tail) {
            ListNode temp = node.next;

            node.next = result;
            result = node;

            node = temp;
        }
        return result;
    }
}
```

  > 如果使用迭代，应该怎么处理？
  
  > 使用一趟扫描完成反转吗？

:::

// #endregion 0092

## 0093

// #region 0093

- [🟠 93 - 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses)

::: details 💡

:::

// #endregion 0093

## 0094 ✅

// #region 0094

- [🟢 94 - 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

::: details 💡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);
        return list;
    }

    void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        list.add(root.val); // 中序位置，添加值
        traversal(root.right);
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func inorderTraversal(_ root: TreeNode?) -> [Int] {
        guard let root = root else { return [] }
        var result = [Int]()
        result.append(contentsOf: inorderTraversal(root.left))
        result.append(root.val)
        result.append(contentsOf: inorderTraversal(root.right))
        return result
    }
}
```

:::

// #endregion 0094

## 0095

// #region 0095

- [🟠 95 - 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii)

::: details 💡

:::

// #endregion 0095

## 0096

// #region 0096

- [🟠 96 - 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees)

::: details 💡

:::

// #endregion 0096

## 0097

// #region 0097

- [🟠 97 - 交错字符串](https://leetcode.cn/problems/interleaving-string)

::: details 💡

:::

// #endregion 0097

## 0098 ✅

// #region 0098

- [🟠 98 - 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree)
    > 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
    > 有效二叉搜索树定义如下：
    >   节点的左子树只包含 小于 当前节点的数。
    >   节点的右子树只包含 大于 当前节点的数。
    >   所有左子树和右子树自身必须也是二叉搜索树。

        🌰
            输入：root = [2,1,3]
            输出：true
        🌰
            输入：root = [5,1,4,null,null,3,6]
            输出：false
            解释：根节点的值是 5 ，但是右子节点的值是 4 。
            
::: details 💡

【思路1】递归，

【思路2】中序遍历，

::: code-tabs

@tab swift 解法1
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func isValidBST(_ root: TreeNode?) -> Bool {
        isValidBST(root, min: nil, max: nil)
    }
    private func isValidBST(_ root: TreeNode?, min: TreeNode?, max: TreeNode?) -> Bool {
        guard let root = root else { return true }
        if let min = min, root.val <= min.val { return false }
        if let max = max, root.val >= max.val { return false }
        
        return isValidBST(root.left, min: min, max: root) && isValidBST(root.right, min: root, max: max)
    }
}
```

@tab java 解法2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean isValid(TreeNode root, long min, long max) {
        if (root == null) return true;
        if (root.val <= min || root.val >= max) return false;
        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);
    }
}
```

:::

// #endregion 0098

## 0099

// #region 0099

- [🟠 99 - 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree)

::: details 💡

:::

// #endregion 0099
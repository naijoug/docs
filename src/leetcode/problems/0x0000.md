---
title: 0000 ~ 0099
icon: hashtag

index: true

---

<!-- more -->

## 0000

// #region 0000

- [ğŸŸ¢ğŸŸ ğŸ”´ - ]()

::: details ğŸ’¡

::: code-tabs

@tab java
```java

```

:::

// #endregion 0000

## 0001 âœ…

// #region 0001

- [ğŸŸ¢ 1 - ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum)
    > ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ï¼Œè¯·æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [2,7,11,15], target = 9
            è¾“å‡ºï¼š[0,1]
        ğŸŒ°
            è¾“å…¥ï¼šnums = [3,2,4], target = 6
            è¾“å‡ºï¼š[1,2]

::: details ğŸ’¡

ã€æ€è·¯1ã€‘æš´åŠ›æ³•ï¼Œä¸¤æ¬¡éå†ï¼Œå¤–å±‚å¾ªç¯å›ºå®šå…¶ä¸­ä¸€ä¸ªå€¼ï¼Œå†…å±‚å¾ªç¯éå†å…ƒç´ è¿›è¡Œæ±‚å’Œæ¯”è¾ƒ

ã€æ€è·¯2ã€‘å“ˆå¸Œè¡¨ï¼Œéå†å…ƒç´  num æ—¶ï¼Œå°† target - num ä½œä¸ºé”®ï¼Œå€¼ä¸ºç´¢å¼•ï¼Œå­˜å…¥å“ˆå¸Œè¡¨ï¼›ç»§ç»­éå†ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåˆ¤æ–­å“ˆå¸Œè¡¨ä¸­æ˜¯å¦å­˜åœ¨ä¸è¯¥å…ƒç´ é”®ç›¸ç­‰çš„æ•°æ®å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›ç»“æœ

ã€æ€è·¯3ã€‘åŒæŒ‡é’ˆï¼Œè¿™ç§æ–¹æ¡ˆéœ€è¦å…ˆæ’åºï¼Œç„¶åé¦–å°¾æŒ‡é’ˆè¿›è¡Œå¤§å°è°ƒæ•´ä¸ target å€¼è¿›è¡Œæ¯”å¯¹ï¼Œä¸è¿‡æœ€åè¿˜éœ€è¦é€šè¿‡ç»“æœå€¼å»åŸæ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡ç´¢å¼•ã€‚è¿™ç§æ–¹æ³•æ¯”è¾ƒé€‚ç”¨äºç›´æ¥æ±‚è§£ç›®æ ‡å€¼ã€‚

::: code-tabs

@tab swift è§£æ³•1
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        for i in 0..<nums.count {
            for j in i+1..<nums.count {
                if (nums[i] + nums[j] == target) {
                    return [i, j]
                }
            }
        }
        return []
    }
}
```

@tab swift è§£æ³•2
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        let nums = nums
        var map = [Int: Int]()
        for i in 0..<nums.count {
            let num = nums[i]
            guard let index = map[num] else {
                map[target - num] = i
                continue
            } 
            return [index, i]
        }
        return []
    }
}
```

@tab java è§£æ³•2
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap();
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[] { map.get(num), i };
            } else {
                map.put(target - num, i);
            }
        }
        return new int[] {};
    }
}
```

@tab swift è§£æ³•3
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        // å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åº
        let sortedNums = nums.sorted()
        var left = 0
        var right = sortedNums.count - 1
        // åŒæŒ‡é’ˆå®šä½å‰åå€¼
        while left < right {
            let sum = sortedNums[left] + sortedNums[right]
            if sum == target {
                break
            } else if sum < target {
                // å’Œå°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹èŒƒå›´
                left += 1
            } else { // sum > target
                // å’Œå¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹èŒƒå›´
                right -= 1
            }
        }
        // è·å–å€¼ç´¢å¼•
        var leftIndex: Int?
        var rightIndex: Int?
        for i in 0..<nums.count {
            if leftIndex == nil, sortedNums[left] == nums[i] {
                leftIndex = i
            } else if sortedNums[right] == nums[i] {
                rightIndex = i
            }
            guard let leftIndex = leftIndex, let rightIndex = rightIndex else {
                continue
            }
            return [leftIndex, rightIndex]
        }

        return [left, right]
    }
}
```

:::

// #endregion 0001

## 0002 âœ…

// #region 0002

- [ğŸŸ  2 - ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers)
    > ç»™ä½ ä¸¤ä¸ª éç©º çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚
    > è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚
    > ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šl1 = [2,4,3], l2 = [5,6,4]
            è¾“å‡ºï¼š[7,0,8]
            è§£é‡Šï¼š342 + 465 = 807.
        ğŸŒ°
            è¾“å…¥ï¼šl1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
            è¾“å‡ºï¼š[8,9,9,9,0,0,0,1]

::: details ğŸ’¡

ã€æ€è·¯ã€‘éå†é“¾è¡¨ï¼Œè¿›è¡ŒåŠ æ³•è¿ç®—ï¼Œé€šè¿‡ä¸€ä¸ªå˜é‡ä¿å­˜è¿›ä½ï¼Œå¦‚æœæœ€åè¿˜å­˜åœ¨è¿›ä½ï¼Œéœ€è¦è¿æ¥åˆ°é“¾è¡¨ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node1 = l1;
        ListNode node2 = l2;
        // ä¿å­˜è¿›ä½
        int carry = 0;
        // ç»“æœé“¾è¡¨
        ListNode dummy = new ListNode();
        ListNode result = dummy;
        // éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œè¿›è¡ŒåŠ åŠ æ³•è¿ç®—
        while (node1 != null && node2 != null) {
            int sum = node1.val + node2.val + carry;
            result.next = new ListNode(sum % 10);
            result = result.next;
            carry = sum / 10;
            node1 = node1.next;
            node2 = node2.next;
        }
        // è¾ƒé•¿çš„é“¾è¡¨ï¼Œç»§ç»­
        ListNode node = node1 != null ? node1 : node2;
        while (node != null) {
            int sum = node.val + carry;
            result.next = new ListNode(sum % 10);
            result = result.next;
            carry = sum / 10;
            node = node.next;
        }
        // å¦‚æœè¿˜æœ‰è¿›ä½ï¼Œè¿æ¥åˆ°é“¾è¡¨
        if (carry > 0) {
            result.next = new ListNode(carry);
        }
        return dummy.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        var left = l1
        var right = l2
        let head = ListNode(0)
        var result: ListNode? = head
        var carry = 0
        var sum = 0
        while ( left != nil && right != nil ) {
            sum = (left?.val ?? 0) + (right?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            left = left?.next
            right = right?.next
        }
        while ( left != nil ) {
            sum = (left?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            left = left?.next
        }
        while ( right != nil ) {
            sum = (right?.val ?? 0) + carry
            result?.next = ListNode(sum % 10)
            result = result?.next
            carry = sum / 10
            right = right?.next
        }
        if (carry > 0) {
            result?.next = ListNode(carry)
        }
        return head.next
    }
}
```

:::

// #endregion 0002

## 0003 âœ…

// #region 0003

- [ğŸŸ  3 - æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters)
    > ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚

        ğŸŒ°
            è¾“å…¥: s = "abcabcbb"
            è¾“å‡º: 3 ("abc")
        ğŸŒ°
            è¾“å…¥: s = "bbbbb"
            è¾“å‡º: 1
            
::: details ğŸ’¡

ã€æ€è·¯ã€‘æ»‘åŠ¨çª—å£ï¼Œå®šä¹‰ä¸€ä¸ªå“ˆå¸Œé›†åˆï¼Œç”¨æ¥è®°å½•çª—å£ä¸­çš„å­—ç¬¦ã€‚
  * éå†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼Œå¦‚æœè¯¥å­—ç¬¦ä¸å­˜åœ¨é›†åˆä¸­ï¼ŒåŠ å…¥é›†åˆï¼Œè¿›è¡Œçª—å£æ‰©å¤§ã€‚
  * å¦‚æœè¯¥å­—ç¬¦å·²ç»å­˜åœ¨é›†åˆä¸­ï¼Œè¿›è¡Œçª—å£ç¼©å°ï¼Œç›´åˆ°è¯¥å­—ç¬¦è¢«ç§»é™¤çª—å£ã€‚
  * éå†çš„è¿‡ç¨‹ä¸­ï¼Œè¿›è¡Œæœ€é•¿å­—ç¬¦å­ä¸²çš„é•¿åº¦æ›¿æ¢ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] chars = s.toCharArray();

        Set<Character> window = new HashSet();

        int left = 0;
        int right = 0;
        int maxLen = 0;
        while (right < chars.length) {
            // æ‰©å¤§çª—å£
            char rc = chars[right];
            right += 1;
            // é‡å¤ï¼Œç¼©å°çª—å£ï¼Œç›´åˆ°ä¸åŒ…å«é‡å¤å­—ç¬¦
            while (window.contains(rc)) {
                char lc = chars[left];
                left += 1;
                window.remove(lc);
            }
            // æ·»åŠ ä¸é‡å¤å­—ç¬¦
            window.add(rc);
            // ä¿å­˜æœ€å¤§å€¼
            if (right - left > maxLen) {
                maxLen = right - left;
            }
        }
        return maxLen;
    }
}
```

@tab swift
```swift
class Solution {
    func lengthOfLongestSubstring(_ s: String) -> Int {
        let chars = [Character](s)
        var window = [Character: Int]()
        var left = 0
        var right = 0
        var res = 0
        while right < chars.count {
            let rightChar = chars[right]
            right += 1
            window[rightChar] = (window[rightChar] ?? 0) + 1
            while window[rightChar] ?? 0 > 1 {
                let leftChar = chars[left]
                left += 1
                window[leftChar] = (window[leftChar] ?? 0) - 1
            }
            res = max(res, right - left)
        }
        return res
    }
}
```

:::

// #endregion 0003

## 0004

// #region 0004

- [ğŸ”´ 4 - å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode.cn/problems/median-of-two-sorted-arrays)
    > ç»™å®šä¸¤ä¸ªæ­£åºæ•°ç»„ï¼Œè¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°ã€‚

::: details ğŸ’¡

ã€æ€è·¯1ã€‘æš´åŠ›æ³•ï¼Œå°†ä¸¤ä¸ªæ•°ç»„åˆå¹¶ï¼Œå½“åˆå¹¶åˆ°ä¸¤ä¸ªæ•°ç»„çš„ä¸€åŠæ—¶ï¼Œå°±æ˜¯ä¸­ä½æ•°ã€‚

::: code-tabs

@tab java
```java

```

:::

// #endregion 0004

## 0005 âœ…

// #region 0005

- [ğŸŸ  5 - æœ€é•¿å›æ–‡å­ä¸²](https://leetcode.cn/problems/longest-palindromic-substring/)
    > ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿”å›è¯¥å­—ç¬¦ä¸²ä¸­æœ€é•¿çš„å›æ–‡ä¸²ã€‚

::: details ğŸ’¡

ã€æ€è·¯ã€‘éœ€è¦æŸ¥æ‰¾æœ€é•¿çš„å›æ–‡ä¸²ï¼Œå¦‚æœå·²ä¸€ä¸ªå­—ç¬¦ä¸ºä¸­å¿ƒå»æŸ¥æ‰¾æœ€é•¿çš„å›æ–‡ä¸²ï¼Œä½¿ç”¨åŒæŒ‡é’ˆæœä¸¤ä¸ªæ–¹å‘å»åˆ¤æ–­ï¼Œå­˜åœ¨ä¸¤ç§æƒ…å†µã€‚

  * ä»¥è¯¥ç´¢å¼•ä¸ºä¸­å¿ƒçš„å¥‡æ•°å›æ–‡ä¸²ï¼Œåˆ™ä»è¯¥ç´¢å¼•å·¦å³ç´¢å¼•å¼€å§‹å»åŒ¹é…ã€‚
  * ä»¥è¯¥ç´¢å¼•ä¸ºä¸­å¿ƒçš„å¶æ•°å›æ–‡ä¸²ï¼Œåˆ™å°†è¯¥ç´¢å¼•ä½œä¸ºå·¦è¾¹ç´¢å¼•ï¼Œä¸‹ä¸€ä¸ªç´¢å¼•ä¸ºå³è¾¹ç´¢å¼•å¼€å¯å»è¿›è¡ŒåŒ¹é…ã€‚
  
  åŒ¹é…åˆ°è¯¥ç´¢å¼•ä¸‹çš„æœ€é•¿å›æ–‡ä¸²ï¼Œç„¶åæ¯”è¾ƒä¿ç•™ä½æœ€é•¿çš„å›æ–‡ä¸²ã€‚
  
  ğŸ‘‰ğŸ» å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œåˆ¤æ–­ä¸€ä¸‹å‰©ä½™ç´¢å¼•æ˜¯å¦å°‘äºå½“å‰ä¿ç•™çš„æœ€é•¿å›æ–‡ä¸²çš„ä¸€åŠï¼Œå°±ä¸éœ€è¦ç»§ç»­åˆ¤æ–­äº†ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public String longestPalindrome(String s) {
        String result = "";
        for (int i = 0; i < s.length(); i++) {
            String str = longestPalindrome(s, i);
            if ( str.length() > result.length() ) {
                result = str;
            }
            // å¦‚æœå‰©ä½™ç´¢å¼•é•¿åº¦ä¸è¶³ä¿ç•™çš„æœ€é•¿å›æ–‡ä¸²é•¿åº¦çš„ä¸€åŠï¼Œä¸éœ€è¦å†åšåˆ¤æ–­
            if ( result.length() > (s.length() - i - 1) * 2 ) {
                break;
            }
        }
        return result;
    }

    /// æŒ‡å®šç´¢å¼•ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
    String longestPalindrome(String s, int i) {
        // ä»¥ i ä¸ºä¸­å¿ƒçš„å¥‡æ•°å›æ–‡ä¸²
        int left = i - 1;
        int right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str1 = s.substring(left + 1, right);
        // ä»¥ i ä¸ºä¸­å¿ƒçš„å¶æ•°å›æ–‡ä¸²
        left = i;
        right = i + 1;
        while ( left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right) ) {
            left -= 1;
            right += 1;
        }
        String str2 = s.substring(left + 1, right);
        return str1.length() > str2.length() ? str1 : str2;
    }
}
```

:::

// #endregion 0005

## 0006

// #region 0006

- [ğŸŸ  6 - N å­—å½¢å˜æ¢](https://leetcode.cn/problems/zigzag-conversion)

::: details ğŸ’¡

:::

// #endregion 0006

## 0007 âœ…

// #region 0007

- [ğŸŸ  7 - æ•´æ•°åè½¬](https://leetcode.cn/problems/reverse-integer)
    > ç»™ä½ ä¸€ä¸ª 32 ä½çš„æœ‰ç¬¦å·æ•´æ•° x ï¼Œè¿”å›å°† x ä¸­çš„æ•°å­—éƒ¨åˆ†åè½¬åçš„ç»“æœã€‚
    > å¦‚æœåè½¬åæ•´æ•°è¶…è¿‡ 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°çš„èŒƒå›´ [âˆ’231,  231 âˆ’ 1] ï¼Œå°±è¿”å› 0ã€‚
    > å‡è®¾ç¯å¢ƒä¸å…è®¸å­˜å‚¨ 64 ä½æ•´æ•°ï¼ˆæœ‰ç¬¦å·æˆ–æ— ç¬¦å·ï¼‰ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šx = 123
            è¾“å‡ºï¼š321
        ğŸŒ°
            è¾“å…¥ï¼šx = -123
            è¾“å‡ºï¼š-321
            
::: details ğŸ’¡

ã€æ€è·¯ã€‘é€šè¿‡é™¤æ³•æ¯æ¬¡å–åˆ°æ•°å­—æœ€åçš„æ•°å­—ï¼Œå†è¿›è¡Œè¿›ä½åŠ æ³•è¿ç®—å°±ç­‰åˆ°æœ€åç»“æœã€‚éœ€è¦æ³¨æ„æœ€ååè½¬ç»“æœå¯èƒ½å­˜åœ¨æ•´æ•°æº¢å‡ºçš„å¯èƒ½æ€§ï¼Œæ‰€ä»¥æ¯æ¬¡è¿›è¡Œè¿›ä½åŠ æ³•è¿ç®—å‰ï¼Œéœ€è¦åˆ¤æ–­æ˜¯å¦å­˜åœ¨æº¢å‡ºçš„æƒ…å†µã€‚

::: code-tabs

@tab java
```java
class Solution {
    public int reverse(int x) {
        // å¦‚æœç­‰äºæœ€å°å€¼ï¼Œåè½¬è¶Šç•Œï¼Œç›´æ¥è¿”å› 0
        if (x == Integer.MIN_VALUE) return 0;

        int carrayMax = Integer.MAX_VALUE / 10;
        int digitMax = Integer.MAX_VALUE % 10;

        int sign = x < 0 ? -1 : 1; // æ•°å­—ç¬¦å·
        int num = Math.abs(x); // ä¿è¯äº†ç»å¯¹å€¼ä¸è¶Šç•Œ
        int result = 0;
        while (num != 0) {
            int digit = num % 10;
            num = num / 10;

            // å¦‚æœå½“å‰ç»“æœå€¼å¤§äºå½“å‰æœ€å¤§çš„è¿›ä½ï¼Œæº¢å‡ºï¼Œè¿”å› 0
            if (result > carrayMax) return 0;
            // å¦‚æœå½“å‰ç»“æœå€¼ç­‰äºæœ€å¤§çš„è¿›ä½
            if (result == carrayMax) {
                // æ­£æ•°æ—¶ï¼Œå¦‚æœå¤§äºæœ€å¤§å€¼æœ«å°¾æ•°å­—ï¼Œæº¢å‡ºï¼Œè¿”å› 0
                if (sign == 1 && digit > digitMax) return 0;
                // è´Ÿæ•°æ˜¯
                if (sign == -1) {
                    // è¶…è¿‡æœ€å°å€¼æŸä½æ•°å­—ï¼Œæº¢å‡ºï¼Œè¿”å› 0
                    if (digit > (digitMax + 1)) {
                        return 0;
                    } else if (digit == (digitMax + 1)) {
                        // åˆšå¥½ç­‰äºæœ€å°å€¼æ—¶ï¼Œå¦‚æœåé¢æ²¡æœ‰æ•°å­—åˆ™æœ€å°å€¼å°±æ˜¯åè½¬ç»“æœï¼›å¦‚æœåé¢è¿˜æœ‰æ•°å­—åˆ™æœ€æº¢å‡ºï¼Œè¿”å› 0
                        return num == 0 ? Integer.MIN_VALUE : 0;
                    }
                }
            }

            // è¿›è¡ŒåŠ æ³•è¿›ä½è¿ç®—
            result = result * 10 + digit;
        }
        return sign * result;
    }
}
```

@tab swift
```swift
class Solution {
    let quotient_max = 214748364    // Int32.max / 10
    let quotient_min = -214748364   // Int32.min / 10
    let remainder_max = 7   // Int32.max % 10
    let remainder_min = -8  // Int32.min % 10

    func reverse(_ x: Int) -> Int {
        var num = x
        var result = 0
        while num != 0 {
            let remainder = num % 10
            guard result <= quotient_max, result >= quotient_min else { return 0 }
            if result == quotient_max && remainder > remainder_max { return 0 }
            if result == quotient_min && remainder < remainder_min { return 0 }
            result = result * 10 + remainder
            num = num / 10
        }
        return result
    }
}
```

:::

// #endregion 0007

## 0008 âœ…

// #region 0008

- [ğŸŸ  8 - å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)](https://leetcode.cn/problems/string-to-integer-atoi)
    > è¯·ä½ æ¥å®ç°ä¸€ä¸ª `myAtoi(string s)` å‡½æ•°ï¼Œä½¿å…¶èƒ½å°†å­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ª 32 ä½æœ‰ç¬¦å·æ•´æ•°ï¼ˆç±»ä¼¼ C/C++ ä¸­çš„ atoi å‡½æ•°ï¼‰ã€‚
    > å‡½æ•° `myAtoi(string s)` çš„ç®—æ³•å¦‚ä¸‹ï¼š
    > * è¯»å…¥å­—ç¬¦ä¸²å¹¶ä¸¢å¼ƒæ— ç”¨çš„å‰å¯¼ç©ºæ ¼
    > * æ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ˆå‡è®¾è¿˜æœªåˆ°å­—ç¬¦æœ«å°¾ï¼‰ä¸ºæ­£è¿˜æ˜¯è´Ÿå·ï¼Œè¯»å–è¯¥å­—ç¬¦ï¼ˆå¦‚æœæœ‰ï¼‰ã€‚ ç¡®å®šæœ€ç»ˆç»“æœæ˜¯è´Ÿæ•°è¿˜æ˜¯æ­£æ•°ã€‚ å¦‚æœä¸¤è€…éƒ½ä¸å­˜åœ¨ï¼Œåˆ™å‡å®šç»“æœä¸ºæ­£ã€‚
    > * è¯»å…¥ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œç›´åˆ°åˆ°è¾¾ä¸‹ä¸€ä¸ªéæ•°å­—å­—ç¬¦æˆ–åˆ°è¾¾è¾“å…¥çš„ç»“å°¾ã€‚å­—ç¬¦ä¸²çš„å…¶ä½™éƒ¨åˆ†å°†è¢«å¿½ç•¥ã€‚
    > * å°†å‰é¢æ­¥éª¤è¯»å…¥çš„è¿™äº›æ•°å­—è½¬æ¢ä¸ºæ•´æ•°ï¼ˆå³ï¼Œ"123" -> 123ï¼Œ "0032" -> 32ï¼‰ã€‚å¦‚æœæ²¡æœ‰è¯»å…¥æ•°å­—ï¼Œåˆ™æ•´æ•°ä¸º 0 ã€‚å¿…è¦æ—¶æ›´æ”¹ç¬¦å·ï¼ˆä»æ­¥éª¤ 2 å¼€å§‹ï¼‰ã€‚
    > * å¦‚æœæ•´æ•°æ•°è¶…è¿‡ 32 ä½æœ‰ç¬¦å·æ•´æ•°èŒƒå›´ [âˆ’231,  231 âˆ’ 1] ï¼Œéœ€è¦æˆªæ–­è¿™ä¸ªæ•´æ•°ï¼Œä½¿å…¶ä¿æŒåœ¨è¿™ä¸ªèŒƒå›´å†…ã€‚å…·ä½“æ¥è¯´ï¼Œå°äº âˆ’231 çš„æ•´æ•°åº”è¯¥è¢«å›ºå®šä¸º âˆ’231 ï¼Œå¤§äº 231 âˆ’ 1 çš„æ•´æ•°åº”è¯¥è¢«å›ºå®šä¸º 231 âˆ’ 1 ã€‚
    > * è¿”å›æ•´æ•°ä½œä¸ºæœ€ç»ˆç»“æœã€‚

        ğŸŒ°
            è¾“å…¥ï¼šs = "   -42"
            è¾“å‡ºï¼š-42
        ğŸŒ°
            è¾“å…¥ï¼šs = "+-12"
            è¾“å‡ºï¼š0
        ğŸŒ°
            è¾“å…¥ï¼šs = "+ 12"
            è¾“å‡ºï¼š0
        ğŸŒ°
            è¾“å…¥ï¼šs = "-21474836482"
            è¾“å‡ºï¼š-2147483648
        
::: details ğŸ’¡

ã€æ€è·¯ã€‘è¯»å–å­—ç¬¦ï¼Œè¿›ä½ä¹˜æ³•è¿ç®—ï¼Œæ³¨æ„æ•´æ•°è¶Šç•Œæ¡ä»¶å¤„ç†ã€‚

::: code-tabs 

@tab java
```java
class Solution {
    public int myAtoi(String s) {
        char[] chars = s.toCharArray();
        int i = 0;
        // è·³è¿‡æ‰€æœ‰ç©ºæ ¼
        while (i < chars.length && chars[i] == ' ') {
            i += 1;
        }
        // è¯»å–ç¬¦å·
        int sign = 1;
        if (i < chars.length && (chars[i] == '+' || chars[i] == '-')) {
            sign = chars[i] == '+' ? 1 : -1;
            i += 1;
        }
        // è¯»å–æ•°å­—ï¼Œè¿›è¡Œç»“æœè¿›ä½è¿ç®—
        int result = 0;
        while (i < chars.length && Character.isDigit(chars[i])) {
            int digit = chars[i] - '0';
            if (isOver(result, digit)) {
                // å¦‚æœè¶…è¿‡èŒƒå›´ï¼Œç›´æ¥èŒƒå›´ä¸´ç•Œå€¼
                return sign == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            // æ˜¯æ•°å­—ï¼Œè¿›è¡Œè¿ç®—
            result = result * 10 + digit;
            i += 1;
        }
        return sign * result;
    }

    // æœ€å¤§å€¼è¿›ä½
    private int carryMax = Integer.MAX_VALUE / 10; // -2147483648 ~ 2147483647
    // æœ€å¤§è¿›ä½æ—¶ï¼Œæ•°å­—çš„èŒƒå›´
    private int digitMax = Integer.MAX_VALUE % 10; // 7
    /// åˆ¤æ–­æ˜¯å¦è¶…è¿‡æ•´å½¢èŒƒå›´
    boolean isOver(int result, int digit) {
        // è¶…è¿‡æœ€å¤§è¿›ä½ï¼Œè¶Šç•Œ
        if (result > carryMax) return true;
        // ç­‰äºæœ€å¤§è¿›ä½æ—¶ï¼Œéœ€è¦åˆ¤æ–­ä¸‹ä¸€ä½æ•°å­—èŒƒå›´
        // æ•´æ•°èŒƒå›´ï¼š[âˆ’2^31,  2^31 âˆ’ 1] è™½ç„¶è´Ÿæ•°çš„èŒƒå›´æ¯”æ­£æ•°å¤š1
        // ç”±äºè¶Šç•Œæ—¶ï¼Œä¹Ÿæ˜¯è¿”å›è¾¹ç•Œå€¼ï¼Œæ‰€ä»¥å¯ä»¥å°†è´Ÿæ•°ä¸­çš„ç­‰äºè¾¹ç•Œæ—¶ä¹Ÿå½’ä¸ºè¶Šç•Œï¼Œç®€åŒ–åˆ¤æ–­
        if (result == carryMax && digit > digitMax) return true;
        return false;
    }
}
```

:::

// #endregion 0008

## 0009

// #region 0009

- [ğŸŸ¢ 9 - å›æ–‡æ•°](https://leetcode.cn/problems/palindrome-number)

::: details ğŸ’¡

:::

// #endregion 0009

## 0010

// #region 0010

- [ğŸ”´ 10 - æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…](https://leetcode.cn/problems/regular-expression-matching)

::: details ğŸ’¡

:::

// #endregion 0010

## 0011 âœ…

// #region 0011

- [ğŸŸ  11 - ç››æœ€å¤šæ°´çš„å®¹å™¨](https://leetcode.cn/problems/container-with-most-water)
    > ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ height ã€‚æœ‰ n æ¡å‚çº¿ï¼Œç¬¬ i æ¡çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯ (i, 0) å’Œ (i, height[i]) ã€‚
    > æ‰¾å‡ºå…¶ä¸­çš„ä¸¤æ¡çº¿ï¼Œä½¿å¾—å®ƒä»¬ä¸ x è½´å…±åŒæ„æˆçš„å®¹å™¨å¯ä»¥å®¹çº³æœ€å¤šçš„æ°´ã€‚
    > è¿”å›å®¹å™¨å¯ä»¥å‚¨å­˜çš„æœ€å¤§æ°´é‡ã€‚
        
        ğŸŒ°
            è¾“å…¥ï¼š[1,8,6,2,5,4,8,3,7]
            è¾“å‡ºï¼š49 
            è§£é‡Šï¼šå›¾ä¸­å‚ç›´çº¿ä»£è¡¨è¾“å…¥æ•°ç»„ [1,8,6,2,5,4,8,3,7]ã€‚åœ¨æ­¤æƒ…å†µä¸‹ï¼Œå®¹å™¨èƒ½å¤Ÿå®¹çº³æ°´ï¼ˆè¡¨ç¤ºä¸ºè“è‰²éƒ¨åˆ†ï¼‰çš„æœ€å¤§å€¼ä¸º 49ã€‚
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘åŒæŒ‡é’ˆ

::: code-tabs

@tab java
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int result = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                // å·¦è¾¹æŒ¡æ¿ä½ï¼Œè°ƒæ•´å·¦è¾¹ç´¢å¼•
                result = Math.max(result, (right - left) * height[left]);
                left += 1;   
            } else {
                // å³è¾¹æŒ¡æ¿ä½ï¼Œè°ƒæ•´å³è¾¹ç´¢å¼•
                result = Math.max(result, (right - left) * height[right]);
                right -= 1;
            }
        }
        return result;
    }
}
```

:::

// #endregion 0011

## 0012

// #region 0012

- [ğŸŸ  12 - æ•´æ•°è½¬ç½—é©¬æ•°å­—](https://leetcode.cn/problems/integer-to-roman)

::: details ğŸ’¡

:::

// #endregion 0012

## 0013

// #region 0013

- [ğŸŸ¢ 13 - ç½—é©¬æ•°å­—è½¬æ•´æ•°](https://leetcode.cn/problems/roman-to-integer)

::: details ğŸ’¡

:::

// #endregion 0013

## 0014

// #region 0014

- [ğŸŸ¢ 14 - æœ€é•¿å…¬å…±å‰ç¼€](https://leetcode.cn/problems/longest-common-prefix)

::: details ğŸ’¡

:::

// #endregion 0014

## 0015 âœ…

// #region 0015

- [ğŸŸ  15 - ä¸‰æ•°ä¹‹å’Œ](https://leetcode.cn/problems/3sum)
    > ç»™å®šæ•´æ•°æ•°ç»„ numsï¼Œè¿”å›æ•°ç»„ä¸­ä¸‰ä¸ªæ•°(ç´¢å¼•å‡ä¸ç›¸åŒ)ä¹‹å’Œç­‰äº0çš„ä¸‰å…ƒç»„ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [-1,0,1,2,-1,-4]
            è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]]

::: details ğŸ’¡

ã€æ€è·¯ã€‘å…ˆå°†æ•°ç»„æ’åºï¼Œéå†å›ºå®šä¸€ä¸ªå€¼ï¼Œç„¶ååœ¨è¿™ä¸ªå€¼åé¢çš„æ•°ç»„è¿›è¡Œä¸¤æ•°æ±‚å’Œã€‚

::: code-tabs

@tab java
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // æ’åºæ•°ç»„
        List<List<Integer>> result = new LinkedList();
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> items = twoSum(nums, -nums[i], i + 1);
            for (List<Integer> item : items) {
                List<Integer> list = new LinkedList();
                list.add(nums[i]);
                list.addAll(item);
                result.add(list);
            }
            // è·³è¿‡ç›¸åŒå€¼
            while (i < nums.length - 1 && nums[i] == nums[i + 1]) {
                i += 1;
            }
        }
        return result;
    }

    List<List<Integer>> twoSum(int[] nums, int target, int start) {
        int left = start;
        int right = nums.length - 1;
        List<List<Integer>> result = new LinkedList();
        while (left < right) {
            int lnum = nums[left];
            int rnum = nums[right];
            int sum = lnum + rnum;
            if (sum == target) {
                // æ”¶é›†ç»“æœ
                result.add(Arrays.asList(nums[left], nums[right]));
                // è·³è¿‡ç›¸åŒçš„å€¼
                while (left < right && nums[left] == lnum) {
                    left += 1;
                }
                while (left < right && nums[right] == rnum) {
                    right -= 1;
                }
            } else if (sum < target) { // å’Œå°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹ç•Œ
                while (left < right && nums[left] == lnum) {
                    left += 1;
                }
            } else { // å’Œå¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹ç•Œ
                while (left < right && nums[right] == rnum) {
                    right -= 1;
                }
            }
        }
        return result;
    }
}
```

@tab swift
```swift
class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        // å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åº
        let nums = nums.sorted()
        var result = [[Int]]()
        for i in 0..<nums.count - 1 {
            // æ•°æ®ä¸è¶³ 3 ä¸ªï¼Œä¸éœ€è¦å†è¿›è¡Œåˆ¤æ–­ï¼Œç›´æ¥è¿”å›ç»“æœ
            if nums.count - i < 3 {
                return result
            }
            // è¿‡æ»¤æ‰ä»¥åˆ¤æ–­çš„ç›¸åŒå€¼
            if i > 0, nums[i] == nums[i - 1] {
                continue
            }
            // å›ºå®šç¬¬ä¸€ä¸ªæ•°ï¼Œè®¡ç®—å‰©ä¸‹ä¸¤æ•°ä¹‹å’Œçš„ç›®æ ‡å€¼
            let target = 0 - nums[i]
            var left = i + 1
            var right = nums.count - 1
            // æ¡çŠ¶åˆ°ä¸‹ä¸€ä¸ªå·¦è¾¹å€¼
            func skipToNextLeft() {
                while left + 1 < right, nums[left + 1] == nums[left] {
                    left += 1
                }
                left += 1
            }
            // è·³è½¬åˆ°ä¸‹ä¸€ä¸ªå³è¾¹å€¼
            func skipToNextRight() {
                while left < right - 1, nums[right - 1] == nums[right] {
                    right -= 1
                }
                right -= 1
            }
            while left < right {
                let sum = nums[left] + nums[right]
                if target == sum {
                    result.append([nums[i], nums[left], nums[right]])
                    // å·¦å³æ–¹å‘è·³è¿‡å½“å‰åˆ¤æ–­ä¸¤ä¸ªå€¼
                    skipToNextLeft()
                    skipToNextRight()
                } else if sum < target {
                    // å’Œå°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹ç´¢å¼•
                    skipToNextLeft()
                } else { // target > sum
                    // å’Œå¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹ç´¢å¼•
                    skipToNextRight()
                }
            }
        }
        return result
    }
}
```

:::

// #endregion 0015

## 0016 âœ…

// #region 0016

- [ğŸŸ  16 - æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ](https://leetcode.cn/problems/3sum-closest)
    > ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ nums å’Œ ä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯·ä½ ä» nums ä¸­é€‰å‡ºä¸‰ä¸ªæ•´æ•°ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ target æœ€æ¥è¿‘ã€‚è¿”å›è¿™ä¸‰ä¸ªæ•°çš„å’Œã€‚
    
            ğŸŒ°
                è¾“å…¥ï¼šnums = [-1,2,1,-4], target = 1
                è¾“å‡ºï¼š2 (è¯´æ˜ï¼š-1 + 2 + 1 = 2) ã€‚
            ğŸŒ°
                è¾“å…¥ï¼šnums = [0,0,0], target = 1
                è¾“å‡ºï¼š0

::: details ğŸ’¡

ã€æ€è·¯ã€‘åŒä¸‰æ•°ä¹‹å’Œçš„æ€è·¯ï¼ŒåŒºåˆ«åœ¨äºæ¯æ¬¡éœ€è¦è¿›è¡Œç»å¯¹æ¯”å¯¹ï¼Œä¿å­˜æœ€æ¥è¿‘ç›®æ ‡å€¼çš„ä¸‰æ•°ä¹‹å’Œ

::: code-tabs

@tab java
```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        return closet(nums, target);
    }
    int closet(int[] nums, int target) {
        int result = Integer.MAX_VALUE;
        int i = 0;
        while (i < nums.length) {
            int num = nums[i];
            // å†è¿›è¡Œä¸¤æ•°ä¹‹å’Œ
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                int lnum = nums[left];
                int rnum = nums[right];
                int sum = num + lnum + rnum;
                if (sum == target) { // ç­‰äºç›®æ ‡å€¼
                    return target;
                } else if (sum < target) { // å°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹ç•Œ
                    // è·³è¿‡å·¦è¾¹ç›¸åŒå€¼
                    while (left < right && nums[left] == lnum) left += 1;
                } else { // å¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹ç•Œ
                    // è·³è¿‡å³è¾¹ç›¸åŒå€¼
                    while (left < right && nums[right] == rnum) right -= 1;
                }
                // é€šè¿‡ç»å¯¹å€¼æ¯”å¯¹ï¼Œæ›¿æ¢æ›´åŠ æ¥è¿‘çš„å€¼
                if (Math.abs(sum - target) < Math.abs(result - target)) {
                    result = sum;
                }
            }
            // è·³è¿‡ç›¸åŒå€¼
            while (i < nums.length && nums[i] == num) i += 1;
        }
        return result;
    }
}
```

:::

// #endregion 0016

## 0017

// #region 0017

- [ğŸŸ  17 - ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)

::: details ğŸ’¡

:::

// #endregion 0017

## 0018 âœ…

// #region 0018

- [ğŸŸ  18 - å››æ•°ä¹‹å’Œ](https://leetcode.cn/problems/4sum)
    > ç»™ä½ ä¸€ä¸ªç”± n ä¸ªæ•´æ•°ç»„æˆçš„æ•°ç»„ nums ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œæ‰¾å‡ºæ•°ç»„ä¸­æ‰€æœ‰çš„å››ä¸ªä¸åŒç´¢å¼•ä½ç½®çš„å€¼ä¹‹å’Œç­‰äºç›®æ ‡å€¼ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,0,-1,0,-2,2], target = 0
            è¾“å‡ºï¼š[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
        ğŸŒ°
            è¾“å…¥ï¼šnums = [2,2,2,2,2], target = 8
            è¾“å‡ºï¼š[[2,2,2,2]]

::: details ğŸ’¡

ã€æ€è·¯ã€‘ä¸ä¸‰æ•°ä¹‹å’Œæ€è·¯ç›¸åŒï¼Œå…ˆéœ€è¦å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œä¸ºäº†æ–¹ä¾¿è·³è¿‡ç›¸åŒç­”æ¡ˆã€‚å¾ªç¯éå†ï¼Œå›ºå®šä¸€ä¸ªå€¼ï¼Œç„¶åè¿›è¡Œä¸‰æ•°æ±‚å’Œã€‚

::: code-tabs

@tab java
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        // å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åº
        Arrays.sort(nums);
        return nSum(nums, target, 4, 0);
    }

    // target å€¼ç±»å‹éœ€è¦è®¾ç½®ä¸º longï¼Œé˜²æ­¢æº¢å‡º
    List<List<Integer>> nSum(int[] nums, long target, int n, int start) {
        if (nums.length < n || n < 2) return new LinkedList();
        if (n == 2) { // ä¸¤æ•°ä¹‹å’Œ
            List<List<Integer>> result = new LinkedList();
            int left = start;
            int right = nums.length - 1;
            while (left < right) {
                int lnum = nums[left];
                int rnum = nums[right];
                int sum = lnum + rnum;
                if (sum == target) { // ç­‰äºç›®æ ‡å€¼ï¼Œæ”¶é›†ç­”æ¡ˆ
                    result.add(Arrays.asList(lnum, rnum));
                    // è·³è¿‡ç›¸åŒçš„å€¼
                    while (left < right && nums[left] == lnum) left += 1;
                    while (left < right && nums[right] == rnum) right -= 1;
                } else if (sum < target) { // å°äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å·¦è¾¹ç•Œ
                    while (left < right && nums[left] == lnum) left += 1;
                } else { // å¤§äºç›®æ ‡å€¼ï¼Œè°ƒæ•´å³è¾¹ç•Œ
                    while (left < right && nums[right] == rnum) right -= 1;
                }
            }
            return result;
        }
        List<List<Integer>> result = new LinkedList();
        int i = start;
        while (i < nums.length) {
            int num = nums[i];
            // å›ºå®šä½ä¸€ä¸ªæ•°ï¼Œç»§ç»­é€’å½’è¿›è¡Œä¸‹ä¸€ä¸ªæ±‚å’Œ
            List<List<Integer>> items = nSum(nums, target - num, n - 1, i + 1);
            for (List<Integer> item : items) {
                List<Integer> list = new LinkedList();
                list.add(num);
                list.addAll(item);
                result.add(list);
            }
            // è·³è¿‡ç›¸åŒå€¼
            while (i < nums.length && nums[i] == num) i += 1;
        }
        return result;
    }
}
```

:::

// #endregion 0018

## 0019 âœ…

// #region 0019

- [ğŸŸ¢ 19 - åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
    > åˆ é™¤å•é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›å¤´ç»“ç‚¹ã€‚

::: details ğŸ’¡

ã€æ€è·¯1ã€‘éå†ä¸€æ¬¡é“¾è¡¨å¾—åˆ°é“¾è¡¨é•¿åº¦ lenï¼Œç¬¬äºŒæ¬¡å°±èƒ½éå†åˆ° len - n çš„èŠ‚ç‚¹ï¼Œè¿›è¡Œåˆ é™¤æ“ä½œå³å¯ã€‚

ã€æ€è·¯2ã€‘æ ˆï¼Œå…ˆå°†æ‰€æœ‰é“¾è¡¨èŠ‚ç‚¹å…¥æ ˆï¼Œå‡ºæ ˆæ—¶è¿›è¡Œè®¡æ•°ï¼Œå½“åˆ°ç¬¬ n ä¸ªå…ƒç´ æ—¶è¿›è¡Œåˆ é™¤å¤„ç†ã€‚

ã€æ€è·¯3ã€‘å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆå…ˆèµ° n æ­¥ä¹‹åï¼Œå¿«æ…¢æŒ‡é’ˆå¼€å§‹åŒæ—¶å‘å‰èµ°ï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°é“¾è¡¨å°¾éƒ¨ï¼Œè¿™æ…¢æŒ‡é’ˆåˆšå¥½æŒ‡å‘è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // åˆ›å»ºè™šå¤´èŠ‚ç‚¹ï¼Œè§£å†³åˆ é™¤åé“¾è¡¨ä¸ºç©ºçš„ç‰¹æ®Šæƒ…å†µï¼Œå‡å°‘åˆ¤æ–­é€»è¾‘
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode p = dummy;
        ListNode target = dummy;
        // p æŒ‡é’ˆå…ˆèµ° n æ­¥
        for (int i = 0; i < n; i++) {
            p = p.next;
        }
        // p æŒ‡é’ˆå’Œç›®æ ‡æŒ‡é’ˆå¼€å§‹åŒæ—¶èµ°
        while (p.next != null) {
            p = p.next;
            target = target.next;
        }
        // åˆ é™¤ç›®æ ‡èŠ‚ç‚¹åé¢èŠ‚ç‚¹
        target.next = target.next.next;
        return dummy.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {
        let dummy = ListNode(0, head)
        var p1: ListNode? = head
        var p2: ListNode? = dummy
        var count = 0
        while p1?.next != nil {
            p1 = p1?.next
            count += 1
            guard count >= n else { continue }
            p2 = p2?.next
        }
        p2?.next = p2?.next?.next
        return dummy.next
    }
}
```

:::

// #endregion 0019

## 0020 âœ…

// #region 0020

- [ğŸŸ¢ 20 - æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses)
    > ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']' çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚

        ğŸŒ°
            è¾“å…¥ï¼šs = "()[]{}"
            è¾“å‡ºï¼štrue
        ğŸŒ°
            è¾“å…¥ï¼šs = "(]"
            è¾“å‡ºï¼šfalse

::: details ğŸ’¡

ã€æ€è·¯ã€‘ä½¿ç”¨æ ˆï¼Œåˆ©ç”¨æ ˆå…ˆè¿›åå‡ºçš„ç‰¹æ€§ã€‚å¦‚æœé‡åˆ°å·¦è¾¹æ‹¬å·ï¼Œè¿›è¡Œå…¥æ ˆæ“ä½œï¼›å¦‚æœäºéŠå³è¾¹æ‹¬å·ï¼Œåˆ™ä»æ ˆé¡¶å–å‡ºä¸€ä¸ªå·¦è¾¹æ‹¬å·è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸åŒ¹é…åˆ™ä¸ºæ— æ•ˆï¼Œå¦‚æœåŒ¹é…åˆ™ç»§ç»­åˆ¤æ–­ã€‚æœ€åæ ˆä¸­å…ƒç´ ä¸ºç©ºï¼Œåˆ™è¡¨æ˜æœ‰æ•ˆã€‚

::: code-tabs

@tab java
```java
class Solution {
    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        List<Character> stack = new LinkedList();
        for (char c : chars) {
            if (isLeft(c)) {
                stack.add(c); // æ˜¯å·¦è¾¹æ‹¬å·å…¥æ ˆ
            } else {
                // å¦‚æœä¸æ˜¯å·¦è¾¹æ‹¬å·ï¼Œä»æ ˆé¡¶ä¸­å–å‡ºå­—ç¬¦è¿›è¡Œåˆ¤æ–­
                // å¦‚æœæ ˆå·²ç»ä¸ºç©ºï¼Œåˆ™ä¸ºéæ³•
                if (stack.isEmpty()) return false;
                // å¦‚æœä¸åŒ¹é…ï¼Œåˆ™ä¹Ÿæ˜¯éæ³•
                if (!isMatch(stack.removeLast(), c)) return false;
            }
        }
        // æœ€åå¦‚æœæ ˆä¸­å…ƒç´ ä¸ºç©ºï¼Œåˆ™è¡¨æ˜æœ‰æ•ˆ
        return stack.isEmpty();
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºå·¦è¾¹æ‹¬å·
    private boolean isLeft(char c) {
        return c == '(' || c == '{' || c == '[';
    }
    // ä¸¤ä¸ªå­—ç¬¦æ‹¬å·æ˜¯å¦åŒ¹é…
    private boolean isMatch(char left, char right) {
        return (left == '(' && right == ')') 
            || (left == '{' && right == '}')
            || (left == '[' && right == ']');
    }
}
```

@tab swift
```swift
class Solution {
    func isValid(_ s: String) -> Bool {
        let map: [Character: Character] = [")": "(", "]": "[", "}": "{"]
        var lefts = [Character]()
        for char in s {
            if map.values.contains(char) {
                lefts.append(char)
            } else {
                guard !lefts.isEmpty, map[char] == lefts.removeLast() else { 
                    return false 
                }
            }
        }
        return lefts.isEmpty
    }
}
```

:::

// #endregion 0020

## 0021 âœ…

// #region 0021

- [ğŸŸ¢ 21 - åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists)
    > åˆå¹¶ä¸¤ä¸ªæœ‰åºçš„é“¾è¡¨ã€‚

::: details ğŸ’¡

ã€æ€è·¯ã€‘åˆ›å»ºä¸€ä¸ªç»“æœé“¾è¡¨å¤´ï¼Œå¹¶ç”¨ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¿™ä¸ªç»“æœé“¾è¡¨ç”¨äºæŒ‡å‘æ·»åŠ ä½ç½®ã€‚ç„¶ååˆ†åˆ«ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸¤ä¸ªé“¾è¡¨ï¼Œæ¯æ¬¡æ¯”è¾ƒæ¯”è¾ƒé“¾è¡¨ä¸­çš„å€¼ï¼Œå°†è¾ƒå°çš„é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ·»åŠ åˆ°ç»“æœé“¾è¡¨ä¸­ã€‚ç›´åˆ°å…¶ä¸­ä¸€ä¸ªé“¾è¡¨ä¸­å·²ä¸ºç©ºï¼Œæœ€åå°†å‰©ä¸‹ä¸ä¸ºç©ºçš„é“¾è¡¨å…¨éƒ¨æ·»åŠ åˆ°ç»“æœé“¾è¡¨ä¸­ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // å¤´ç»“ç‚¹ï¼šæŒ‡å‘ç»“æœé“¾è¡¨å¤´éƒ¨
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = list1;
        ListNode p2 = list2;
        while ( p1 != null && p2 != null ) {
            // æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨ä¸­å€¼å°çš„æ·»åŠ åˆ°ç»“æœé“¾è¡¨ä¸­
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        // å°†ä¸ä¸ºç©ºçš„é“¾è¡¨æ·»åŠ åˆ°ç»“æœé“¾è¡¨å°¾éƒ¨
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        guard let l1 = l1, let l2 = l2 else {
            return l1 ?? l2
        }
        let head = ListNode(0)
        var p: ListNode? = head
        var op1: ListNode? = l1
        var op2: ListNode? = l2
        // éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œå¹¶å°†è¾ƒå°å€¼èŠ‚ç‚¹æ·»åŠ åˆ°ç»“æœé“¾è¡¨
        while let p1 = op1, let p2 = op2 {
            if p1.val <= p2.val {
                p?.next = p1
                op1 = op1?.next
            } else {
                p?.next = p2
                op2 = op2?.next
            }
            p = p?.next
        }
        // å°†ä¸ä¸ºç©ºçš„é“¾è¡¨æ·»åŠ åˆ°ç»“æœé“¾è¡¨åé¢
        p?.next = op1 ?? op2
        return head.next
    }
}
```

:::

// #endregion 0021

## 0022 

// #region 0022

- [ğŸŸ  22 - æ‹¬å·ç”Ÿæˆ](https://leetcode.cn/problems/generate-parentheses)

::: details ğŸ’¡

:::

// #endregion 0022

## 0023 âœ…

// #region 0023

- [ğŸ”´ 23 - åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists)
    > ç»™å®šä¸€ä¸ªå‡åºé“¾è¡¨æ•°ç»„ï¼Œåˆå¹¶å¾—åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ï¼Œå¹¶è¿”å›å¤´ç»“ç‚¹ã€‚

::: details ğŸ’¡

ã€æ€è·¯1ã€‘åˆå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨æ¯”è¾ƒå®¹æ˜“è§£å†³ã€‚åˆå¹¶å¤šä¸ªé“¾è¡¨ï¼Œå¯ä»¥å…ˆä¸¤ä¸ªä¸¤ä¸ªåˆå¹¶ï¼Œæœ€åå°±åˆå¹¶æˆä¸€ä¸ªäº†ã€‚

ã€æ€è·¯2ã€‘åˆ†æ²»æ€æƒ³ï¼Œç±»ä¼¼å½’å¹¶æ’åºï¼Œä¸¤ä¸¤åˆå¹¶ï¼Œæœ€ååˆå¹¶æˆä¸ºç»“æœé“¾è¡¨ã€‚

ã€æ€è·¯3ã€‘ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæ¯æ¬¡å°† K ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹æ”¾å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—ä¸­ï¼Œé‚£ä¹ˆå¯ä»¥æ¯æ¬¡ä»ä¼˜å…ˆçº§é˜Ÿåˆ—ä¸­å–å‡ºæœ€å°å€¼èŠ‚ç‚¹æ”¾å…¥ç»“æœé“¾è¡¨ï¼Œç„¶åå†å°†è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œç›´åˆ°åˆå¹¶å®Œæˆã€‚

::: code-tabs

@tab è§£æ³•1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if ( lists.length == 0 ) { return null; }
        if ( lists.length == 1 ) { return lists[0]; }
        // éå†é“¾è¡¨æ•°ç»„ï¼Œæ¯æ¬¡å–å‡ºä¸€ä¸ªé“¾è¡¨ï¼Œè¿›è¡Œä¸¤æ¡é“¾è¡¨åˆå¹¶
        ListNode l1 = lists[0];
        for ( int i = 1; i < lists.length; i++ ) {
            ListNode l2 = lists[i];
            l1 = mergeTwoLists(l1, l2);
        }
        return l1;
    }

    // åˆå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨
    ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = l1;
        ListNode p2 = l2;
        while ( p1 != null && p2 != null ) {
            if ( p1.val <= p2.val ) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if ( p1 != null ) {
            p.next = p1;
        }
        if ( p2 != null ) {
            p.next = p2;
        }
        return head.next;
    }
}
```

:::

// #endregion 0023

## 0024

// #region 0024

- [ğŸŸ  24 - ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs)

::: details ğŸ’¡

:::

// #endregion 0024

## 0025 âœ…

// #region 0025

- [ğŸ”´ - K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group)
    > ç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨ã€‚
    > k æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ k çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚
    > ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚

        ğŸŒ°  1 -> 2 -> 3 -> 4 -> 5
            è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
            è¾“å‡ºï¼š[2,1,4,3,5]
        ğŸŒ°
            è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 3
            è¾“å‡ºï¼š[3,2,1,4,5]

::: details ğŸ’¡

ã€æ€è·¯1ã€‘é€’å½’ï¼Œéå†å¾—åˆ° K ä¸ªèŠ‚ç‚¹çš„åˆ†å‰²èŠ‚ç‚¹ï¼Œå°†è¯¥èŠ‚ç‚¹ä½œä¸ºåè½¬çš„ç»“æŸå€¼ï¼Œè¿›è¡Œ K ä¸ªèŠ‚ç‚¹çš„åè½¬ã€‚ä¹‹åé€’å½’è¿›è¡Œå‰©ä¸‹èŠ‚ç‚¹çš„åè½¬ï¼Œå¹¶å°†åè½¬ä¹‹åçš„å°¾ç»“ç‚¹(ä¹Ÿå°±æ˜¯ä¹‹å‰å¤´ç»“ç‚¹)ä¸ä¹‹åçš„é€’å½’è¿”å›çš„å¤´ç»“ç‚¹ç›¸è¿ã€‚é€’å½’çš„ç»“æŸæ¡ä»¶å°±æ˜¯èŠ‚ç‚¹æ•°ä¸è¶³ K ä¸ªã€‚

::: code-tabs

@tab java è§£æ³•1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            // ä¸è¶³ k ä¸ªèŠ‚ç‚¹ï¼Œä¸éœ€è¦åè½¬ï¼Œç›´æ¥è¿”å›å¤´ç»“ç‚¹
            if (tail == null) return head;
            tail = tail.next;
        }
        ListNode result = reverse(head, tail);
        // åè½¬ä¹‹å head å˜ä¸ºæœ€åèŠ‚ç‚¹ï¼Œé“¾æ¥é€’å½’è¿”å›çš„å¤´ç»“ç‚¹
        // é€’å½’ K ä¸ªä¸€ç»„åè½¬å‰©ä¸‹é“¾è¡¨
        head.next = reverseKGroup(tail, k);
        return result;
    }

    // æŒ‡å®šèŠ‚ç‚¹èŒƒå›´çš„é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„æ–°èŠ‚ç‚¹
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode result = null;
        ListNode node = head;
        while (node != tail) {
            ListNode temp = node.next;

            node.next = result;
            result = node;

            node = temp;
        }
        return result;
    }
}
```

:::

// #endregion 0025

## 0026 âœ…

// #region 0026

- [ğŸŸ¢ 26 - åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)
    > ç»™å®šä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œåˆ é™¤æ•°ç»„ä¸­çš„é‡å¤é¡¹ï¼Œå¹¶è¿”å›æ•°ç»„æ–°é•¿åº¦ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,1,2]
            è¾“å‡ºï¼š2, nums = [1,2]
        ğŸŒ°
            è¾“å…¥ï¼šnums = [0,0,1,1,1,2,2,3,3,4]
            è¾“å‡ºï¼š5, nums = [0,1,2,3,4]

::: details ğŸ’¡

ã€æ€è·¯1ã€‘éå†æ•°ç»„ï¼Œä½¿ç”¨ä¸€ä¸ªé¢å¤–æ•°ç»„ä¿å­˜ä¸é‡å¤çš„å…ƒç´ ï¼Œä½¿ç”¨äº†é¢å¤–ç©ºé—´ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
 
ã€æ€è·¯2ã€‘åŒæŒ‡é’ˆæ³•ï¼Œä¸€ä¸ªéå†ç´¢å¼•æŒ‡é’ˆéå†æ•°ç»„ï¼Œå¦ä¸€ä¸ªç»“æœç´¢å¼•æŒ‡é’ˆæŒ‡å‘æœªé‡å¤çš„å…ƒç´ ã€‚éå†æ—¶ï¼Œå¦‚æœä¸¤ä¸ªç´¢å¼•ä½ç½®å€¼ç›¸ç­‰ï¼Œåˆ™ä»…ç§»åŠ¨éå†ç´¢å¼•ï¼›å¦‚æœå€¼ä¸ç­‰ï¼Œåˆ™å¾€å‰ç§»åŠ¨ä½ç½®ç´¢å¼•ï¼Œå°†éå†ç´¢å¼•æŒ‡å‘çš„å…ƒç´ èµ‹å€¼ç»™ç»“æœç´¢å¼•ä½ç½®ï¼Œä¹‹åå†ç§»åŠ¨éå†ç´¢å¼•ã€‚éå†ç»“æŸï¼Œç»“æœç´¢å¼• + 1 å°±æ˜¯æ•°ç»„çš„æ–°é•¿åº¦ã€‚

::: code-tabs

@tab java è§£æ³•2
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        var i = 0; // éå†ç´¢å¼•
        var j = 0; // ç»“æœç´¢å¼•
        while ( i < nums.length ) {
            if ( nums[i] != nums[j] ) {
                // éå†å€¼ä¸ç­‰äºç»“æœå€¼ï¼Œç»“æœç´¢å¼•å¾€å‰ç§»åŠ¨ï¼Œå°†éå†å€¼èµ‹å€¼ç»™ç»“æœç´¢å¼•ä½ç½®
                j += 1;
                nums[j] = nums[i];
            } 
            // éå†ç´¢å¼•å¾€å‰ç§»åŠ¨
            i += 1;
        }
        return j + 1;
    }
}
```

@tab swift è§£æ³•2 ğŸ’¯
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        var slow = 0 
        var fast = 0
        while ( fast < nums.count ) {
            if ( nums[fast] != nums[slow] ) {
                slow += 1
                nums[slow] = nums[fast] 
            }
            fast += 1
        }
        return slow + 1
    }
}
```

:::

// #endregion 0026

## 0027 âœ…

// #region 0027

- [ğŸŸ¢ 27 - ç§»é™¤å…ƒç´ ](https://leetcode.cn/problems/remove-element)
    > ç»™å®šä¸€ä¸ªæ•°ç»„å’Œç›®æ ‡å€¼ï¼Œéœ€è¦å°†æ•°ç»„ä¸­çš„ä¸ç›®æ ‡å€¼ç›¸ç­‰çš„å…ƒç´ ç§»é™¤ï¼Œè¿”å›æ•°ç»„æ–°é•¿åº¦ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [0,1,2,2,3,0,4,2], val = 2
            è¾“å‡ºï¼š5, nums = [0,1,3,0,4]

::: details ğŸ’¡

ã€æ€è·¯ã€‘åŒæŒ‡é’ˆæ³•ï¼Œéå†æ—¶å°†å¦‚æœå€¼ä¸ç­‰äºç›®æ ‡å€¼ï¼Œåˆ™å°†æ…¢æŒ‡é’ˆå¾€å‰ç§»åŠ¨ï¼Œå°†å¿«æŒ‡é’ˆå€¼å¤åˆ¶åˆ°æ…¢æŒ‡é’ˆå¯¹åº”ç´¢å¼•ä½ç½®ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( nums[fast] != val ) {
                // éå†å€¼ä¸ç­‰äºç›®æ ‡å€¼ï¼Œæ…¢æŒ‡é’ˆå¾€å‰ç§»åŠ¨ï¼Œå°†å¿«æŒ‡é’ˆä½ç½®å€¼ç§»åŠ¨åˆ°æ…¢æŒ‡é’ˆä½ç½®
                slow += 1;
                nums[slow] = nums[fast];
            } 
            fast += 1;
        }
        return slow + 1;
    }
}
```

@tab swift
```swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        var count = -1
        for i in 0..<nums.count {
            if nums[i] != val {
                count += 1
                if count != i { // ä¼˜åŒ–ï¼Œå‡å°‘ä¸å¿…è¦çš„èµ‹å€¼
                    nums[count] = nums[i]
                }
            }
        }
        return count + 1
    }
}
```

:::

// #endregion 0027

## 0028

// #region 0028

- [ğŸŸ¢ 28 - æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)

::: details ğŸ’¡

:::

// #endregion 0028

## 0029

// #region 0029

- [ğŸŸ  29 - ä¸¤æ•°ç›¸é™¤](https://leetcode.cn/problems/divide-two-integers)

::: details ğŸ’¡

:::

// #endregion 0029

## 0030

// #region 0030

- [ğŸ”´ 30 - ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)

::: details ğŸ’¡

:::

// #endregion 0030

## 0031

// #region 0031

- [ğŸŸ  31 - ä¸‹ä¸€ä¸ªæ’åˆ—](https://leetcode.cn/problems/next-permutation)

::: details ğŸ’¡

:::

// #endregion 0031

## 0032 âœ…

// #region 0032

- [ğŸ”´ 32 - æœ€é•¿æœ‰æ•ˆæ‹¬å·](https://leetcode.cn/problems/longest-valid-parentheses)
    > ç»™ä½ ä¸€ä¸ªåªåŒ…å« '(' å’Œ ')' çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿æœ‰æ•ˆï¼ˆæ ¼å¼æ­£ç¡®ä¸”è¿ç»­ï¼‰æ‹¬å· å­ä¸² çš„é•¿åº¦ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šs = "(()"
            è¾“å‡ºï¼š2    è§£é‡Šï¼šæœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²æ˜¯ "()"
        ğŸŒ°
            è¾“å…¥ï¼šs = ")()())"
            è¾“å‡ºï¼š4    è§£é‡Šï¼šæœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²æ˜¯ "()()"
    
::: details ğŸ’¡

ã€æ€è·¯1ã€‘åŠ¨æ€è§„åˆ’ï¼Œ

ã€æ€è·¯2ã€‘æ ˆï¼Œ

ã€æ€è·¯3ã€‘è´ªå¿ƒç®—æ³•ï¼Œ

::: code-tabs

@tab java è§£æ³•3 ğŸ’¯
```java
class Solution {
    public int longestValidParentheses(String s) {
        int left = 0; // å·¦æ‹¬å·è®¡æ•°
        int right = 0; // æœ‰æ‹¬å·è®¡æ•°
        int maxLength = 0;
        // æ­£å‘åˆ¤æ–­
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left += 1;
            } else {
                right += 1;
            }
            if (left == right) {
                // æ‹¬å·å·²åŒ¹é…ï¼Œæ›´æ–°æœ€å¤§å€¼
                maxLength = Math.max(maxLength, right *2);
            }
            if (right > left) {
                // å³æ‹¬å·å¤§äºå·¦æ‹¬å·ï¼Œå·²ç»ä¸åŒ¹é…ï¼Œé‡ç½®
                left = 0;
                right = 0;
            }
        }
        // åå‘åˆ¤æ–­ï¼šè§£å†³å¤šä¸ªå·¦æ‹¬å·çš„é—®é¢˜ï¼Œç±»ä¼¼ "(()"
        left = 0;
        right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left += 1;
            } else {
                right += 1;
            }
            if (left == right) {
                // æ‹¬å·å·²åŒ¹é…ï¼Œæ›´æ–°æœ€å¤§å€¼
                maxLength = Math.max(maxLength, right *2);
            }
            if (left > right) {
                // å·¦æ‹¬å·å¤§äºå³æ‹¬å·å·²ç»ä¸åŒ¹é…ï¼Œé‡ç½®
                left = 0;
                right = 0;
            }
        }

        return maxLength;
    }
}
```

:::

// #endregion 0032

## 0033

// #region 0033

- [ğŸŸ  33 - æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode.cn/problems/search-in-rotated-sorted-array)

::: details ğŸ’¡

:::

// #endregion 0033

## 0034 âœ…

// #region 0034

- [ğŸŸ¢ 34 - åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)
    > ç»™å®šä¸€ä¸ªéé€’å‡æ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼ŒæŸ¥æ‰¾è¯¥ç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å› [start, end]ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å› [-1, -1]ã€‚
    
::: details ğŸ’¡

ã€æ€è·¯1ã€‘äºŒåˆ†æœç´¢æ³•ï¼ŒæŸ¥è¯¢æœ€å·¦è¾¹ç›®æ ‡å€¼å’Œæœ€å³è¾¹ç›®æ ‡å€¼

ã€æ€è·¯2ã€‘åŒæŒ‡é’ˆæ³•ï¼Œä»å‰ååˆ†åˆ«æŸ¥è¯¢ç›®æ ‡å€¼çš„ç´¢å¼•ä½ç½®

::: code-tabs

@tab java è§£æ³•1
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = searchLeft(nums, target);
        int right = searchRight(nums, target);
        return new int[] {left, right};
    }

    int searchLeft(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) { // ç­‰äºç›®æ ‡å€¼ï¼Œè¿›ä¸€æ­¥ç¼©å°å³è¾¹ç•Œ
                right = mid - 1;
            } else if (nums[mid] > target) { // ç›®æ ‡å€¼åœ¨å·¦è¾¹ï¼Œè°ƒæ•´å³è¾¹ç•Œ
                right = mid - 1;
            } else { // ç›®æ ‡å€¼åœ¨å³è¾¹ï¼Œè°ƒæ•´å·¦è¾¹ç•Œ
                left = mid + 1;
            }
        }
        if (left < 0 || left >= nums.length) return -1;
        return nums[left] == target ? left : -1;
    }
    int searchRight(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) { // ç­‰äºç›®æ ‡å€¼ï¼Œè¿›ä¸€æ­¥ç¼©å°å·¦è¾¹ç•Œ
                left = mid + 1;
            } else if (nums[mid] > target) { // ç›®æ ‡å€¼åœ¨å·¦è¾¹
                right = mid - 1;
            } else { // ç›®æ ‡å€¼åœ¨å³è¾¹
                left = mid + 1;
            }
        }
        if (right < 0 || right >= nums.length) return -1;
        return nums[right] == target ? right : -1;
    }
}
```

@tab dart è§£æ³•1
```dart
class Solution {
  List<int> searchRange(List<int> nums, int target) {
      int leftIndex = _searchLeftIndex(nums, target);
      int rightIndex = _searchRightIndex(nums, target);
      return [leftIndex, rightIndex];
  }

  // æœç´¢å·¦è¾¹ç•Œç´¢å¼•
  int _searchLeftIndex(List<int> nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while ( left <= right ) {
          int mid = left + (right - left)~/2;
          if ( nums[mid] == target ) {
              // å®šä½åˆ°ç›®æ ‡å€¼ï¼Œè¿›ä¸€æ­¥ç¼©å°å³è¾¹èŒƒå›´
              right = mid - 1;
          } else if ( nums[mid] < target ) {
              // ç›®æ ‡å€¼åˆ°å³è¾¹ï¼Œç¼©å°å·¦è¾¹èŒƒå›´
              left = mid + 1;
          } else { // nums[mid] > target
              // ç›®æ ‡å€¼åœ¨å·¦è¾¹ï¼Œç¼©å°å³è¾¹èŒƒå›´
              right = mid - 1;
          }
      }
      if ( left >= nums.length ) { return -1; }
      return nums[left] == target ? left : -1;
  }

  // æœç´¢å³è¾¹ç•Œç´¢å¼•
  int _searchRightIndex(List<int> nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while( left <= right ) {
          int mid = left + (right - left)~/2;
          if ( nums[mid] == target ) {
              // å®šä½åˆ°ç›®æ ‡å€¼ï¼Œè¿›ä¸€æ­¥ç¼©å°å·¦è¾¹èŒƒå›´
              left = mid + 1;
          } else if ( nums[mid] < target ) {
              // ç›®æ ‡å€¼åœ¨å³è¾¹ï¼Œç¼©å°å·¦è¾¹èŒƒå›´
              left = mid + 1;
          } else { // nums[mid] > target
              // ç›®æ ‡å€¼åœ¨å·¦è¾¹ï¼Œç¼©å°å³è¾¹èŒƒå›´
              right = mid - 1;
          }
      }
      if ( right < 0 ) { return -1; }
      return nums[right] == target ? right : -1;
  }
}
```

@tab swift è§£æ³•2
```swift
class Solution {
    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {
        var first = -1
        var last = -1
        var i = 0
        var j = nums.count - 1
        while i <= j {
            if first == -1 {
                if nums[i] == target {
                    first = i
                } else {
                    i += 1
                }
            }
            if last == -1 {
                if nums[j] == target {
                    last = j
                } else {
                    j -= 1
                }
            }
            if first != -1, last != -1 {
                break
            }
        }
        return [first, last]
    }
}
```

:::

// #endregion 0034

## 0035 âœ…

// #region 0035

- [ğŸŸ¢ 35 - æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position)
    > ç»™å®šä¸€ä¸ªå‡åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œå¦‚æœç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­å­˜åœ¨è¿”å›ç›®æ ‡å€¼ç´¢å¼•ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›æ’å…¥ä½ç½®ç´¢å¼•ã€‚
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘äºŒåˆ†æœç´¢

::: code-tabs

@tab java
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) {
                return mid; // æ‰¾åˆ°ç›®æ ‡ç´¢å¼•
            } else if (nums[mid] > target) { // ç›®æ ‡å€¼åœ¨å·¦è¾¹ï¼Œè°ƒæ•´å³è¾¹è¾¹ç•Œ
                right = mid - 1;
            } else { // ç›®æ ‡å€¼åœ¨å³è¾¹ï¼Œè°ƒæ•´å·¦è¾¹ç•Œ
                left = mid + 1;
            }
        }
        return left; // æœªæ‰¾åˆ°ç›®æ ‡å€¼ï¼Œè¿”å›æ’å…¥ç´¢å¼•
    }
}
```

:::

// #endregion 0035

## 0036

// #region 0036

- [ğŸŸ  36 - æœ‰æ•ˆçš„æ•°ç‹¬](https://leetcode.cn/problems/valid-sudoku)

::: details ğŸ’¡

:::

// #endregion 0036

## 0037

// #region 0037

- [ğŸ”´ 37 - è§£æ•°ç‹¬](https://leetcode.cn/problems/sudoku-solver)

::: details ğŸ’¡

:::

// #endregion 0037

## 0038

// #region 0038

- [ğŸŸ  38 - å¤–è§‚æ•°åˆ—](https://leetcode.cn/problems/count-and-say)

::: details ğŸ’¡

:::

// #endregion 0038

## 0039 âœ…

// #region 0039

- [ğŸŸ  39 - ç»„åˆæ€»å’Œ](https://leetcode.cn/problems/combination-sum)
    > ç»™å®šæ— é‡å¤å…ƒç´ çš„æ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œæ‰¾å‡ºå’Œç­‰äºç›®æ ‡å€¼çš„æ‰€æœ‰ç»„åˆ(æ•°ç»„ä¸­çš„å…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨)
    
        ğŸŒ°
            è¾“å…¥ï¼šcandidates = [2,3,6,7], target = 7
            è¾“å‡ºï¼š[[2,2,3],[7]]
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘å›æº¯æ³•

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    int trackSum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtrack(candidates, target, 0);
        return result;
    }

    void backtrack(int[] candidates, int target, int start) {
        if (trackSum > target) return; // å·²å¤§äºç›®æ ‡å€¼ï¼Œè·³è¿‡
        if (trackSum == target) { // ç­‰äºç›®æ ‡å€¼ï¼Œæ”¶é›†ç»„åˆç»“æœ
            result.add(new LinkedList(track));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int candidate = candidates[i];
            track.add(candidate);
            trackSum += candidate;
            backtrack(candidates, target, i); // å¯ä»¥é‡å¤ä½¿ç”¨
            track.removeLast();
            trackSum -= candidate;
        }
    }
}
```

@tab swift
```swift
class Solution {
    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
        backtrack(candidates, start: 0, target: target, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ candidates: [Int], start: Int, target: Int, track: [Int]) {
        let sum = track.reduce(0, +)
        guard sum < target else {
            guard sum == target else { return }
            res.append(track)
            return
        }
        var track = track
        for i in start..<candidates.count {
            track.append(candidates[i])
            backtrack(candidates, start: i, target: target, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0039

## 0040 âœ…

// #region 0040

- [ğŸŸ  40 - ç»„åˆæ€»å’Œ II](https://leetcode.cn/problems/combination-sum-ii)
    > ç»™å®šåŒ…å«é‡å¤å…ƒç´ çš„æ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œæ‰¾å‡ºå’Œç­‰äºç›®æ ‡å€¼çš„æ‰€æœ‰ç»„åˆ(æ•°ç»„ä¸­å…ƒç´ åªèƒ½ä½¿ç”¨ä¸€æ¬¡)
    
        ğŸŒ°
            è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8,
            è¾“å‡º:
            [
              [1,1,6],
              [1,2,5],
              [1,7],
              [2,6]
            ]
            
::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    int trackSum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // æ’åºæ•°ç»„ï¼Œä¾¿äºè¿›è¡Œç›¸åŒå…ƒç´ å‰ªæå¤„ç†
        Arrays.sort(candidates);
        backtrack(candidates, target, 0);
        return result;
    }

    void backtrack(int[] candidates, int target, int start) {
        if (trackSum > target) return;
        if (trackSum == target) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            // å‰ªæå¤„ç†ï¼Œç›¸åŒçš„å€¼åªå¤„ç†ä¸€æ¬¡
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            int candidate = candidates[i];
            track.add(candidate);
            trackSum += candidate;
            backtrack(candidates, target, i + 1);
            track.removeLast();
            trackSum -= candidate;
        }
    }
}
```

:::

// #endregion 0040

## 0041 âœ…

// #region 0041

- [ğŸ”´ 41 - ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°](https://leetcode.cn/problems/first-missing-positive)
    > ç»™ä½ ä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­æ²¡æœ‰å‡ºç°çš„æœ€å°çš„æ­£æ•´æ•°ã€‚
      è¯·ä½ å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(n) å¹¶ä¸”åªä½¿ç”¨å¸¸æ•°çº§åˆ«é¢å¤–ç©ºé—´çš„è§£å†³æ–¹æ¡ˆã€‚
        
        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,2,0]
            è¾“å‡ºï¼š3
        ğŸŒ°
            è¾“å…¥ï¼šnums = [3,4,-1,1]
            è¾“å‡ºï¼š2
        ğŸŒ°
            è¾“å…¥ï¼šnums = [7,8,9,11,12]
            è¾“å‡ºï¼š1

::: details ğŸ’¡

ã€æ€è·¯ã€‘

::: code-tabs

@tab swift
```swift
class Solution {
    func firstMissingPositive(_ nums: [Int]) -> Int {
        var iNums = nums
        let count = iNums.count
        // ç¬¬ä¸€æ¬¡éå†æ•°ç»„ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ 1
        var hasOne = false 
        for i in 0..<count {
            guard iNums[i] == 1 else { continue }
            hasOne = true
            break
        }
        guard hasOne else { return 1 } // å¦‚æœä¸å­˜åœ¨ 1ï¼Œé‚£ä¹ˆæœ€å°æ­£æ•´æ•°å°±æ˜¯ 1
        // å·²ç»å­˜åœ¨ 1ï¼Œé‚£ä¹ˆæ•°ç»„ä¸­ç¼ºå°‘çš„æœ€å°æ•´æ•°è‚¯å®šæ˜¯ 2 ~ count
        // ç¬¬äºŒæ¬¡éå†æ•°ç»„ï¼Œå°†æ•°ç»„ä¸­å°äº 0 çš„æ•°å’Œå¤§äºæ•°ç»„é•¿åº¦çš„æ•°éƒ½ç½®ä¸º 1
        for i in 0..<count {
            let num = iNums[i]
            guard num <= 0 || num > count else { continue }
            iNums[i] = 1
        }
        // ç¬¬ä¸‰æ¬¡éå†æ•°ç»„ï¼Œå¯¹åº”æ•°å­— - 1ï¼Œå°±å¯¹åº”[0, n) æ•°ç»„ä¸­çš„ç´¢å¼•ï¼Œå°†è¯¥ç´¢å¼•ä½ç½®è®¾ä¸ºè´Ÿæ•°
        for i in 0..<count {
            let index = abs(iNums[i]) - 1
            if iNums[index] > 0 {
                iNums[index] = -iNums[index]
            }
        }
        // ç¬¬å››æ¬¡éå†æ•°ç»„ï¼Œç¬¬ä¸€ä¸ªæ­£æ•´æ•°ç´¢å¼•çš„ä½ç½® + 1 = ç¼ºå¤±çš„æ•°å­— (å­˜åœ¨çš„æ•°éƒ½åœ¨ç¬¬ä¸‰æ¬¡éå†çš„æ—¶å€™è¢«è®¾ä¸ºäº†è´Ÿæ•°)
        for i in 0..<count {
            guard iNums[i] > 0 else { continue }
            return i + 1
        }
        return count + 1
    }
}
```

:::

// #endregion 0041

## 0042

// #region 0042

- [ğŸ”´ 42 - æ¥é›¨æ°´](https://leetcode.cn/problems/trapping-rain-water)

::: details ğŸ’¡

:::

// #endregion 0042

## 0043 âœ…

// #region 0043

- [ğŸŸ  43 - å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode.cn/problems/multiply-strings)
    > ç»™å®šä¸¤ä¸ªä»¥å­—ç¬¦ä¸²å½¢å¼è¡¨ç¤ºçš„éè´Ÿæ•´æ•° num1 å’Œ num2ï¼Œè¿”å› num1 å’Œ num2 çš„ä¹˜ç§¯ï¼Œå®ƒä»¬çš„ä¹˜ç§¯ä¹Ÿè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²å½¢å¼ã€‚
    
        ğŸŒ°
            è¾“å…¥: num1 = "2", num2 = "3"
            è¾“å‡º: "6"
        ğŸŒ°
            è¾“å…¥: num1 = "123", num2 = "456"
            è¾“å‡º: "56088"

::: details ğŸ’¡

ã€æ€è·¯ã€‘ç«–å¼ä¹˜æ³•å…¬å¼

::: code-tabs

@tab java
```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        char[] chars1 = num1.toCharArray();
        char[] chars2 = num2.toCharArray();
        int[] result = new int[chars1.length + chars2.length];
        for (int i = chars1.length - 1; i >= 0; i--) {
            for (int j = chars2.length - 1; j >= 0; j--) {
                int p0 = i + j + 1; // ä¸ªä½
                int p1 = i + j; // åä½
                // è®¡ç®—ä¸¤ä½ä¹˜ç§¯
                int value = (chars1[i] - '0') * (chars2[j] - '0');
                // åŠ ä¸Šä¸ªä½å·²æœ‰çš„æ•°å­—
                value += result[p0];

                result[p0] = value % 10;
                result[p1] += value / 10; 
            }
        }

        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < result.length; i++) {
            if (result[i] == 0 && builder.length() == 0) continue;
            builder.append(result[i]); 
        }
        return builder.toString();
    }
}
```

:::

// #endregion 0043

## 0044

// #region 0044

- [ğŸ”´ 44 - é€šé…ç¬¦åŒ¹é…](https://leetcode.cn/problems/wildcard-matching)

::: details ğŸ’¡

:::

// #endregion 0044

## 0045

// #region 0045

- [ğŸŸ  45 - è·³è·ƒæ¸¸æˆ II](https://leetcode.cn/problems/jump-game-ii)

::: details ğŸ’¡

:::

// #endregion 0045

## 0046 âœ…

// #region 0046

- [ğŸŸ  46 - å…¨æ’åˆ—](https://leetcode.cn/problems/permutations)
  > ç»™å®šä¸€ä¸ªæ²¡æœ‰é‡å¤æ•°å­—çš„æ•°ç»„ï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,2,3]
            è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

::: details ğŸ’¡

ã€æ€è·¯ã€‘å›æº¯æ³•

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList(); // å…¨æ’åˆ—ç»“æœ
    List<Integer> track = new LinkedList(); // ä¸€ä¸ªæ’åˆ—æ”¶é›†

    public List<List<Integer>> permute(int[] nums) {
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used);
        return result;
    }

    void backtrack(int[] nums, boolean[] used) {
        if (track.size() == nums.length) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue; // å·²ä½¿ç”¨è¿‡çš„æ•°å­—ï¼Œè·³è¿‡
            track.add(nums[i]); // å›æº¯å‰ï¼ŒåŠ å…¥
            used[i] = true;
            backtrack(nums, used);
            track.removeLast(); // å›æº¯åï¼Œç§»é™¤
            used[i] = false;
        }
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[Int]]()
    func permute(_ nums: [Int]) -> [[Int]] {
        backtrack(nums, track: [], used: [:])
        return res
    }
    private func backtrack(_ nums: [Int], track: [Int], used: [Int: Bool]) {
        guard track.count != nums.count else {
            res.append(track)
            return
        }
        var track = track
        var used = used
        for num in nums {
            guard !(used[num] ?? false) else { continue }
            used[num] = true
            track.append(num)
            backtrack(nums, track: track, used: used)
            track.removeLast()
            used[num] = false
        }
    } 
}
```

:::

// #endregion 0046

## 0047 âœ…

// #region 0047

- [ğŸŸ  47 - å…¨æ’åˆ— II](https://leetcode.cn/problems/permutations-ii)
  > ç»™å®šä¸€ä¸ªåŒ…å«é‡å¤æ•°å­—çš„æ•°ç»„ï¼Œè¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,1,2]
            è¾“å‡ºï¼š
            [
              [1,1,2],
              [1,2,1],
              [2,1,1]
            ]

::: details ğŸ’¡

ã€æ€è·¯ã€‘å›æº¯æ³•

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums); // æ’åºæ•°ç»„ï¼Œä¾¿äºå‰ªæå¤„ç†
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used);
        return result;
    }

    void backtrack(int[] nums, boolean[] used) {
        if (track.size() == nums.length) {
            result.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // å‰ªæå¤„ç†ï¼šå·²ä½¿ç”¨ï¼Œè·³è¿‡
            if (used[i]) continue;
            // ç›¸åŒå…ƒç´ ï¼Œéœ€è¦ä¿è¯å‰é¢å…ƒç´ å·²ä½¿ç”¨ï¼Œå¦‚æœæœªä½¿ç”¨ï¼Œè·³è¿‡
            // æ ¸å¿ƒç‚¹åœ¨äºä¿æŒç›¸åŒå…ƒç´ çš„ç›¸å¯¹ä½ç½®ä¿æŒä¸å˜
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
            track.add(nums[i]);
            used[i] = true;
            backtrack(nums, used);
            track.removeLast();
            used[i] = false;
        }
    }
}
```

:::

// #endregion 0047

## 0048

// #region 0048

- [ğŸŸ  48 - æ—‹è½¬å›¾åƒ](https://leetcode.cn/problems/rotate-image)

::: details ğŸ’¡

:::

// #endregion 0048

## 0049

// #region 0049

- [ğŸŸ  49 - å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode.cn/problems/group-anagrams)

::: details ğŸ’¡

:::

// #endregion 0049

## 0050 âœ…

// #region 0050

- [ğŸŸ  50 - Pow(x, n)](https://leetcode.cn/problems/powx-n)
    > å®ç°ä¸€ä¸ªæµ®ç‚¹æ•° x çš„æ•´æ•° n æ¬¡å¹‚å‡½æ•°
    
        ğŸŒ°
            è¾“å…¥ï¼šx = 2.10000, n = 3
            è¾“å‡ºï¼š9.26100
        ğŸŒ°
            è¾“å…¥ï¼šx = 2.00000, n = -2
            è¾“å‡ºï¼š0.25000

::: details ğŸ’¡

ã€æ€è·¯1ã€‘é€šè¿‡å¹‚æ¬¡æ˜¯å¦ä¸ºæ­£æ•°å¹‚æ¬¡ï¼Œç„¶åå»å¹‚æ¬¡çš„ç»å¯¹å€¼è¿›è¡Œå¹‚æ¬¡è¿ç®—ï¼Œæœ€åæ ¹æ®å¹‚æ¬¡ç¬¦å·è¿›è¡Œç»“æœè¿”å›ã€‚

ã€æ€è·¯2ã€‘äºŒåˆ†æ³•è¿›è¡Œæ—¶é—´å¤æ‚åº¦é™çº§ï¼Œ `x^n` çš„å¹‚æ¬¡æ±‚è§£
  - n å¦‚æœæ˜¯å¥‡æ•° `x^n = x * x^(n-1)`ï¼Œ`n-1` å°±æ˜¯å¶æ•°äº†
  - n å¦‚æœæ˜¯å¶æ•° `x^n = (x^(n/2))^2`

ã€æ€è·¯3ã€‘è¿›ä¸€æ­¥ä¼˜åŒ–æ€è·¯2ï¼Œå°†é€’å½’æ”¹ä¸ºè¿­ä»£è§£æ³•

::: code-tabs

@tab java è§£æ³•1 (è¶…æ—¶)
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // æ˜¯å¦æ˜¯æ­£å¹‚æ¬¡
        int i = Math.abs(n);
        double result = 1;
        while (i >= 1) {
            result *= x;
            i -= 1;
        }
        return isPositive ? result : 1 / result;
    }
}
```

@tab java è§£æ³•2 (æ ˆæº¢å‡º)
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // æ˜¯å¦æ˜¯æ­£å¹‚æ¬¡
        double result = positivePow(x, Math.abs(n));
        return isPositive ? result : 1 / result;
    }

    /// æ­£æ•°å¹‚æ¬¡
    double positivePow(double x, int n) {
        if (n == 0) return 1;
        if (n % 2 == 0) { // å¶æ•°å¹‚æ¬¡
            double x2 = positivePow(x, n/2);
            return x2 * x2;
        } else { // å¥‡æ•°å¹‚æ¬¡
            return x * positivePow(x, n - 1);
        }
    }
}
```

@tab java è§£æ³•3 ğŸ’¯
```java
class Solution {
    public double myPow(double x, int n) {
        if ( x == 0 ) return 0;
        boolean isPositive = n > 0; // æ˜¯å¦æ˜¯æ­£å¹‚æ¬¡
        long i = Math.abs((long)n); // éœ€è¦å°† n è½¬åŒ–ä¸ºé•¿æ•´å‹ï¼Œé˜²æ­¢å–ç»å¯¹å€¼æº¢å‡º
        double result = 1;
        double square = x;
        while (i > 0) {
            if ((i % 2) != 0) { // å¥‡æ•°æ—¶
                result *= square;
            }
            square *= square;
            i /= 2;
        }
        return isPositive ? result : 1 / result;
    }
}
```

@tab swift è§£æ³•3 ğŸ’¯
```swift
class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        guard x != 0 else { return 0 }
        var isPositive = n > 0 // æ˜¯å¦ä¸ºæ­£æ¬¡å¹‚
        var num = abs(n)
        var square = x
        var result: Double = 1
        while num > 0 {
            if num % 2 != 0 { // å¥‡æ•°
                result *= square
            }
            square *= square
            num /= 2
        }
        return isPositive ? result : 1/result
    }
}
```

:::

// #endregion 0050

## 0051

// #region 0051

- [ğŸ”´ 51 - N çš‡å](https://leetcode.cn/problems/n-queens)
    > å°† n ä¸ªçš‡åæ£‹å­ï¼Œæ”¾ç½®åœ¨ nxn çš„æ£‹ç›˜ä¸­ã€‚'Q'ä»£è¡¨çš‡åï¼Œ'.'ä»£è¡¨ç©ºä½ï¼Œè¿”å›æ‰€æœ‰çš„ä¸åŒçš„è§£å†³æ–¹æ¡ˆã€‚
    > å›½é™…è±¡æ£‹çš„è§„åˆ™ : çš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šn = 4
            è¾“å‡ºï¼š[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
            è¾“å…¥ï¼šn = 1
            è¾“å‡ºï¼š[["Q"]]
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘å›æº¯æ³•

::: code-tabs

@tab java
```java
class Solution {
    List<List<String>> result = new LinkedList(); // æ‰€æœ‰ç»“æœåˆ—è¡¨
    char[][] chessboard; // è®°å½•æ£‹ç›˜æ£‹å­

    public List<List<String>> solveNQueens(int n) {
        // åˆ›å»ºæ£‹ç›˜ï¼Œåˆå§‹åŒ–éƒ½ä¸ºç©º '.'
        chessboard = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                chessboard[i][j] = '.';
            }
        }
        // è¿›è¡Œå›æº¯æ±‚è§£
        backtrack(n, 0);
        return result;
    }

    void backtrack(int n, int row) {
        if (row == n) {
            // æ£‹ç›˜å·²ä¸‹å®Œ
            List<String> list = new LinkedList();
            for (int i = 0; i < n; i++) {
                list.add(new String(chessboard[i]));
            } 
            result.add(list);
            return;
        }
        // éå†è¿™è¡Œæ¯ä¸€åˆ—
        for (int i = 0; i < n; i++) {
            if (!isValid(n, row, i)) continue; // æ— æ•ˆä½ç½®ï¼Œè·³è¿‡
            // åŠ å…¥æ£‹ç›˜
            chessboard[row][i] = 'Q';
            // è¿›è¡Œä¸‹ä¸€è¡Œæ±‚è§£
            backtrack(n, row + 1);
            // ä»æ£‹ç›˜ä¸­ç§»é™¤
            chessboard[row][i] = '.';
        }
    }
    
    /// æ ¹æ®è¡Œåˆ—åæ ‡åˆ¤æ–­è¯¥ä½ç½®æ˜¯å¦åˆæ³•
    boolean isValid(int n, int row, int column) {
        // åˆ¤æ–­è¡Œ - æ˜¯å¦å­˜åœ¨ Q (row è¡Œè¿˜æœªä¸‹ï¼Œä¸éœ€è¦åˆ¤æ–­)
        // åˆ¤æ–­åˆ— | æ˜¯å¦å­˜åœ¨ Q (row è¡Œä»¥ä¸‹è¿˜æ²¡ä¸‹ï¼Œåªéœ€è¦åˆ¤æ–­ row ä»¥ä¸Šè¡Œ)
        for (int i = 0; i < row; i++) {
            if (chessboard[i][column] == 'Q')
                return false;
        }
        // åˆ¤æ–­å·¦æ–œæ–¹å‘ / æ˜¯å¦å­˜åœ¨ Q (åªéœ€è¦åˆ¤æ–­ row ä»¥ä¸Š)
        int i = row - 1;
        int j = column + 1;
        while (i >= 0 && j < n) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j += 1;
        }
        // åˆ¤æ–­å³æ–œæ–¹å‘ \ æ˜¯å¦å­˜åœ¨ Q (åªéœ€è¦åˆ¤æ–­ row ä»¥ä¸Š)
        i = row - 1;
        j = column - 1;
        while (i >= 0 && j >= 0) {
            if (chessboard[i][j] == 'Q')
                return false;
            i -= 1;
            j -= 1;
        }
        return true;
    }
}
```

@tab swift
```swift
class Solution {
    private var res = [[String]]()
    func solveNQueens(_ n: Int) -> [[String]] {
        var board = [[Character]].init(repeating: [Character].init(repeating: Character("."), count: n), count: n)
        backtrack(&board, row: 0)
        return res
    }
    
    private func backtrack(_ board: inout [[Character]], row: Int) {
        guard row < board.count else {
            res.append(board.map({ String($0) }))
            return
        }
        for col in 0..<board[row].count {
            guard isValid(board, row: row, col: col) else { continue }
            board[row][col] = Character("Q")
            backtrack(&board, row: row + 1)
            board[row][col] = Character(".")
        }
    }
    private func isValid(_ board: [[Character]], row: Int, col: Int) -> Bool {
        func chess(row: Int, col: Int) -> Character? {
            guard 0 <= row, row < board.count, 
                  0 <= col, col < board[row].count else { return nil }
            return board[row][col]
        }
        func isQ(row: Int, col: Int) -> Bool {
            guard let chess = chess(row: row, col: col) else { return false }
            return String(chess) == "Q"
        }
        // -
        for i in 0..<col {
            guard isQ(row: row, col: i) else { continue }
            return false
        }
        // |
        for i in 0..<row {
            guard isQ(row: i, col: col) else { continue }
            return false
        }
        // \
        var i = row
        var j = col
        while i >= 0, j >= 0 {
            i -= 1
            j -= 1
            guard isQ(row: i, col: j) else { continue }
            return false
        }
        // /
        var m = row
        var n = col
        while m >= 0, n < board.count {
            m -= 1
            n += 1
            guard isQ(row: m, col: n) else { continue }
            return false
        }

        return true
    }
}
```

:::

// #endregion 0051

## 0052

// #region 0052

- [ğŸ”´ 52 - N çš‡å II](https://leetcode.cn/problems/n-queens-ii)
    > è¿”å› N çš‡åé—®é¢˜çš„è§£å†³æ–¹æ¡ˆæ•°é‡
    
::: details ğŸ’¡

:::

// #endregion 0052

## 0053 âœ…

// #region 0053

- [ğŸŸ  53 - æœ€å¤§å­æ•°ç»„å’Œ](https://leetcode.cn/problems/maximum-subarray)
    > ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
    > å­æ•°ç»„æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums = [-2,1,-3,4,-1,2,1,-5,4]
            è¾“å‡ºï¼š6 (æœ€å¤§å­æ•°ç»„ï¼š[4,-1,2,1])

        ğŸŒ°
            è¾“å…¥ï¼šnums = [5,4,-1,7,8]
            è¾“å‡ºï¼š23

::: details ğŸ’¡

ã€æ€è·¯1ã€‘æ»‘åŠ¨çª—å£ï¼Œéå†æ•°ç»„æ‰©å¤§çª—å£ï¼Œå½“çª—å£å’Œå°äº 0 æ—¶ï¼Œè¿›è¡Œçª—å£ç¼©å°ï¼Œæ‰©å¤§çª—å£çš„æ—¶å€™è¿›è¡Œæœ€å¤§å’Œçš„æ›¿æ¢ã€‚

ã€æ€è·¯2ã€‘åŠ¨æ€è§„åˆ’ï¼Œæ¯æ¬¡é€šè¿‡ä¸­é—´å˜é‡ä¿å­˜ç›®å‰éå†å€¼ä¹‹å‰çš„æœ€å¤§å’Œï¼Œé€šè¿‡ä¸å½“å‰å€¼è¿›è¡Œåˆ¤æ–­æ¯”è¾ƒä¿ç•™æœ€ç»ˆç»“æœçš„æœ€å¤§å’Œã€‚

ã€æ€è·¯3ã€‘å‰ç¼€å’Œï¼Œ

::: code-tabs

@tab java è§£æ³•1
```java 
class Solution {
    public int maxSubArray(int[] nums) {
        int windowSum = 0;
        int maxSum = Integer.MIN_VALUE;
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            // æ‰©å¤§çª—å£
            windowSum += nums[right];
            right += 1;

            // ä¿ç•™æœ€å¤§å’Œ
            maxSum = maxSum > windowSum ? maxSum : windowSum;

            // çª—å£å’Œå°äº 0 æ—¶ï¼Œç¼©å°çª—å£
            while (windowSum < 0) {
                windowSum -= nums[left];
                left += 1;
            }
        }
        return maxSum;
    }
}
```

@tab java è§£æ³•2
```java
class Solution {
    public int maxSubArray(int[] nums) {
        // ä¿å­˜æœ€å¤§å’Œ
        int maxSum = Integer.MIN_VALUE;
        // éå†è¿‡ç¨‹ä¸­çš„æœ€å¤§å’Œ
        int sum = 0; 
        for (int num : nums) {
            // ä¿ç•™éå†è¿‡ç¨‹çš„æœ€å¤§å’Œ
            sum = Math.max(num, sum + num); 
            // æ›¿æ¢ç»“æœæœ€å¤§å’Œ
            maxSum = Math.max(maxSum, sum);
        }
        return maxSum;
    }
}
```

@tab java è§£æ³•3
```java

```

:::

// #endregion 0053

## 0054 âœ…

// #region 0054

- [ğŸŸ  54 - èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix)
    > ç»™ä½ ä¸€ä¸ª m è¡Œ n åˆ—çš„çŸ©é˜µ matrix ï¼Œè¯·æŒ‰ç…§ é¡ºæ—¶é’ˆèºæ—‹é¡ºåº ï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
        
        ğŸŒ°
            1 2 3
            4 5 6
            7 8 9
            è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]]
            è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5]

::: details ğŸ’¡

ã€æ€è·¯ã€‘é€šè¿‡ä¸Šä¸‹å·¦å³å››ä¸ªè¾¹ç•Œæ§åˆ¶éå†è¾¹ç•Œï¼Œé€šè¿‡äºŒç»´æ•°ç»„çš„é•¿å®½è®¡ç®—æ€»å…ƒç´ æ•°é‡ï¼ŒæŒ‰ç…§è§„å¾‹è¿›è¡Œä¸Š -> å³ -> ä¸‹ -> å·¦ çš„èºæ—‹è§„åˆ™è¿›è¡Œéå†ï¼Œå¹¶è¿›ä¸€æ­¥ç¼©å°è¾¹ç•Œã€‚æœ€åå½“æ”¶é›†åˆ°çš„å…ƒç´ ç­‰ä¸ç›®æ ‡æ•°é‡ï¼Œåˆ™éå†å®Œæˆã€‚

::: code-tabs

@tab java
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int h = matrix.length;
        int w = matrix[0].length;
        int count = h * w;
        int top = 0;
        int bottom = h - 1;
        int left = 0;
        int right = w - 1;
        
        List<Integer> result = new LinkedList();
        while (result.size() < count) {
            // 1> è¿›è¡Œä¸Šéå†
            if (top <= bottom) {
                for (int i = left; i <= right; i++) {
                    result.add(matrix[top][i]);
                }
                top += 1;
            }
            
            // 2> è¿›è¡Œå³è¾¹éå†
            if (left <= right) {
                for (int i = top; i <= bottom; i++) {
                    result.add(matrix[i][right]);
                }
                right -= 1;
            }
            // 3> è¿›è¡Œä¸‹éå†
            if (top <= bottom) {
                for (int i = right; i >= left; i--) {
                    result.add(matrix[bottom][i]);
                }
                bottom -= 1;
            }
            // 4> è¿›è¡Œå·¦è¾¹éå†
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result.add(matrix[i][left]);
                }
                left += 1;
            }
        }
        return result;
    }
}
```

@tab swift
```swift
class Solution {
    func spiralOrder(_ matrix: [[Int]]) -> [Int] {
        var h = matrix.count
        var w = matrix[0].count
        var count = h * w

        var top = 0
        var bottom = h - 1
        var left = 0
        var right = w - 1

        var result = [Int]()
        while (result.count < count) {
            if top <= bottom, left <= right {
                for i in left...right {
                    result.append(matrix[top][i])
                }
                top += 1
            }
            if top <= bottom, left <= right {
                for i in top...bottom {
                    result.append(matrix[i][right])
                }
                right -= 1
            }
            if top <= bottom, left <= right {
                for i in (left...right).reversed() {
                    result.append(matrix[bottom][i])
                }
                bottom -= 1
            }
            if top <= bottom, left <= right {
                for i in (top...bottom).reversed() {
                    result.append(matrix[i][left])
                }
                left += 1
            }
        }
        return result
    }
}
```

:::

// #endregion 0054

## 0055

// #region 0055

- [ğŸŸ  55 - è·³è·ƒæ¸¸æˆ](https://leetcode.cn/problems/jump-game)

::: details ğŸ’¡

:::

// #endregion 0055

## 0056

// #region 0056

- [ğŸŸ  56 - åˆå¹¶åŒºé—´](https://leetcode.cn/problems/merge-intervals)

::: details ğŸ’¡

:::

// #endregion 0056

## 0057

// #region 0057

- [ğŸŸ  57 - æ’å…¥åŒºé—´](https://leetcode.cn/problems/insert-interval)

::: details ğŸ’¡

:::

// #endregion 0057

## 0058

// #region 0058

- [ğŸŸ¢ 58 - æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦](https://leetcode.cn/problems/length-of-last-word)

::: details ğŸ’¡

:::

// #endregion 0058

## 0059

// #region 0059

- [ğŸŸ  59 - èºæ—‹çŸ©é˜µ II](https://leetcode.cn/problems/spiral-matrix-ii)

::: details ğŸ’¡

:::

// #endregion 0059

## 0060

// #region 0060

- [ğŸ”´ 60 - æ’åˆ—åºåˆ—](https://leetcode.cn/problems/permutation-sequence)

::: details ğŸ’¡

:::

// #endregion 0060

## 0061

// #region 0061

- [ğŸŸ  61 - æ—‹è½¬é“¾è¡¨](https://leetcode.cn/problems/rotate-list)

::: details ğŸ’¡

:::

// #endregion 0061

## 0062

// #region 0062

- [ğŸŸ  62 - ä¸åŒè·¯å¾„](https://leetcode.cn/problems/unique-paths)

::: details ğŸ’¡

:::

// #endregion 0062


## 0063

// #region 0063

- [ğŸŸ  63 - ä¸åŒè·¯å¾„ II](https://leetcode.cn/problems/unique-paths-ii)

::: details ğŸ’¡

:::

// #endregion 0063

## 0064

// #region 0064

- [ğŸŸ  64 - æœ€å°è·¯å¾„å’Œ](https://leetcode.cn/problems/minimum-path-sum)

::: details ğŸ’¡

:::

// #endregion 0064

## 0065

// #region 0065

- [ğŸ”´ 65 - æœ‰æ•ˆæ•°å­—](https://leetcode.cn/problems/valid-number)

::: details ğŸ’¡

:::

// #endregion 0065

## 0066

// #region 0066

- [ğŸŸ¢ 66 - åŠ ä¸€](https://leetcode.cn/problems/plus-one)

::: details ğŸ’¡

:::

// #endregion 0066

## 0067

// #region 0067

- [ğŸŸ¢ 67 - äºŒè¿›åˆ¶æ±‚å’Œ](https://leetcode.cn/problems/add-binary)

::: details ğŸ’¡

:::

// #endregion 0067

## 0068

// #region 0068

- [ğŸ”´ 68 - æ–‡æœ¬å·¦å³å¯¹é½](https://leetcode.cn/problems/text-justification)

::: details ğŸ’¡

:::

// #endregion 0068

## 0069

// #region 0069

- [ğŸŸ¢ 69 - x çš„å¹³æ–¹æ ¹](https://leetcode.cn/problems/sqrtx)

::: details ğŸ’¡

:::

// #endregion 0069

## 0070 âœ…

// #region 0070 

- [ğŸŸ¢ 70 - çˆ¬æ¥¼æ¢¯](https://leetcode.cn/problems/climbing-stairs)

::: details ğŸ’¡

::: code-tabs

ã€æ€è·¯1ã€‘åŠ¨æ€è§„åˆ’ï¼Œè‡ªé¡¶å‘ä¸‹ï¼Œé€’å½’è§£æ³•

ã€æ€è·¯2ã€‘åŠ¨æ€è§„åˆ’ï¼Œè‡ªåº•å‘ä¸Šï¼Œè¿­ä»£è§£æ³•

@tab java è§£æ³•1
```java
class Solution {
    Map<Integer, Integer> dp = new HashMap();
    public int climbStairs(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (dp.containsKey(n)) return dp.get(n);
        // åˆ°è¾¾ç¬¬ n é˜¶å°é˜¶æ–¹æ³• = åˆ°è¾¾ n-1 é˜¶å°é˜¶æ–¹æ³•æ•°(å†çˆ¬1é˜¶) + åˆ°è¾¾ n-2 é˜¶å°é˜¶æ–¹æ³•æ•°(å†çˆ¬2é˜¶)
        int fn = climbStairs(n - 1) + climbStairs(n - 2);
        dp.put(n, fn);
        return fn;
    }
}
```

@tab java è§£æ³•2
```java
class Solution {
    public int climbStairs(int n) {
        if (n < 3) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

@tab swift è§£æ³•2
```swift
class Solution {
    func climbStairs(_ n: Int) -> Int {
        guard n > 2 else { return n }
        var dp = [Int](repeating: 0, count: n+1)
        dp[1] = 1
        dp[2] = 2
        for i in 3...n {
            dp[i] = dp[i - 1] + dp[i - 2]
        }
        return dp[n]
    }
}
```

:::

// #endregion 0070

## 0071

// #region 0071

- [ğŸŸ  71 - ç®€åŒ–è·¯å¾„](https://leetcode.cn/problems/simplify-path)

::: details ğŸ’¡

:::

// #endregion 0071

## 0072 âœ…

// #region 0072

- [ğŸ”´ 72 - ç¼–è¾‘è·ç¦»](https://leetcode.cn/problems/edit-distance)
    > ç»™ä½ ä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œ è¯·è¿”å›å°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•°  ã€‚
    > ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š
    >       æ’å…¥ä¸€ä¸ªå­—ç¬¦
    >       åˆ é™¤ä¸€ä¸ªå­—ç¬¦
    >       æ›¿æ¢ä¸€ä¸ªå­—ç¬¦

        ğŸŒ°
            è¾“å…¥ï¼šword1 = "horse", word2 = "ros"
            è¾“å‡ºï¼š3
            è§£é‡Šï¼š
            horse -> rorse (å°† 'h' æ›¿æ¢ä¸º 'r')
            rorse -> rose (åˆ é™¤ 'r')
            rose -> ros (åˆ é™¤ 'e')
        ğŸŒ°
            è¾“å…¥ï¼šword1 = "intention", word2 = "execution"
            è¾“å‡ºï¼š5
            è§£é‡Šï¼š
            intention -> inention (åˆ é™¤ 't')
            inention -> enention (å°† 'i' æ›¿æ¢ä¸º 'e')
            enention -> exention (å°† 'n' æ›¿æ¢ä¸º 'x')
            exention -> exection (å°† 'n' æ›¿æ¢ä¸º 'c')
            exection -> execution (æ’å…¥ 'u')
            
::: details ğŸ’¡

ã€æ€è·¯1ã€‘åŠ¨æ€è§„åˆ’ï¼Œè¿­ä»£(è‡ªé¡¶å‘ä¸‹)

ã€æ€è·¯2ã€‘åŠ¨æ€è§„åˆ’ï¼Œé€’å½’(è‡ªé¡¶å‘ä¸Š)

::: code-tabs

@tab java è§£æ³•1
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        // å®šä¹‰ dp è¡¨ï¼Œä»£è¡¨æ¯ä½ä½ç½®éœ€è¦ä¿®æ”¹çš„æ­¥æ•°
        int dp[][] = new int[m + 1][n + 1];
        // åˆå§‹åŒ–ç¬¬ä¸€è¡Œçš„ä¿®æ”¹æ•°å°±æ˜¯å­—ç¬¦çš„é•¿åº¦
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < n + 1; i++) {
            dp[0][i] = i;
        }
        // éå†è¿›è¡Œ dp è¡¨çš„å¡«å……
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // è¯¥ä½ç½®ä¸Šä¸€ä½ç½®ç´¢å¼•åŒ¹é…ï¼Œåˆ™ä¸éœ€è¦ä¿®æ”¹
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // ä¸åŒ¹é…ï¼Œéœ€è¦ä¿®æ”¹ï¼Œé€‰å–å…¶ä¸­æœ€å°å€¼åŠ ä¸Šä¸€æ­¥ï¼Œå°±æ˜¯è¯¥ä½ç½®æœ€å°ä¿®æ”¹æ­¥æ•°
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```

@tab swift è§£æ³•2
```swift
class Solution {
    func minDistance(_ word1: String, _ word2: String) -> Int {
        let char1s = [Character](word1)
        let char2s = [Character](word2)

        var cache = [[Int?]](repeating: [Int?](repeating: nil, count: char2s.count), count: char1s.count)

        func dp(i: Int, j: Int) -> Int {
            if i == -1 { return j + 1 }
            if j == -1 { return i + 1 }
            if let value = cache[i][j] { return value }
            
            let value = char1s[i] == char2s[j] ?
                dp(i: i - 1, j: j - 1)
                :
                min(
                    dp(i: i - 1, j: j) + 1,     // åˆ é™¤ä¸€ä¸ªå­—ç¬¦
                    dp(i: i - 1, j: j - 1) + 1, // æ›¿æ¢ä¸€ä¸ªå­—ç¬¦ 
                    dp(i: i, j: j - 1) + 1      // å¢åŠ ä¸€ä¸ªå­—ç¬¦
                )
            cache[i][j] = value
            return value
        }

        return dp(i: char1s.count - 1, j: char2s.count - 1)
    }
}
```

:::

// #endregion 0072

## 0073

// #region 0073

- [ğŸŸ  73 - çŸ©é˜µç½®é›¶](https://leetcode.cn/problems/set-matrix-zeroes)

::: details ğŸ’¡

:::

// #endregion 0073

## 0074

// #region 0074

- [ğŸŸ  74 - æœç´¢äºŒç»´çŸ©é˜µ](https://leetcode.cn/problems/search-a-2d-matrix)

::: details ğŸ’¡

:::

// #endregion 0074

## 0075 âœ…

// #region 0075

- [ğŸŸ  75 - é¢œè‰²åˆ†ç±»](https://leetcode.cn/problems/sort-colors)
    > ç»™å®šä¸€ä¸ªåŒ…å«çº¢è‰²ã€ç™½è‰²å’Œè“è‰²çš„æ˜¯æ•°ç»„ï¼Œä½¿ç”¨æ•´æ•° 0ã€ 1 å’Œ 2 åˆ†åˆ«è¡¨ç¤ºçº¢è‰²ã€ç™½è‰²å’Œè“è‰²ï¼ŒæŒ‰ç…§çº¢è‰²ã€ç™½è‰²ã€è“è‰²é¡ºåºæ’åˆ—ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šnums = [2,0,2,1,1,0]
            è¾“å‡ºï¼š[0,0,1,1,2,2]

::: details ğŸ’¡

> è·å…°å›½æ——é—®é¢˜

ã€æ€è·¯ã€‘ç»Ÿè®¡æ³•ï¼Œå…ˆç»Ÿè®¡å„ç§é¢œè‰²çš„ä¸ªæ•°ï¼Œå†æŒ‰ç…§é¢œè‰²ä¸ªæ•°ç»™æ•°ç»„é‡æ–°èµ‹å€¼ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        int white = 0;
        int blue = 0;
        /// ç»Ÿè®¡ä¸‰ç§é¢œè‰²ä¸ªæ•°
        for (int i = 0; i < nums.length; i++) {
            if ( nums[i] == 0 ) {
                red += 1;
            } else if ( nums[i] == 1 ) {
                white += 1;
            } else if ( nums[i] == 2 ) {
                blue += 1;
            }
        }
        // æŒ‰ç…§ä¸ªæ•°é‡æ–°ç»™æ•°ç»„èµ‹å€¼
        for ( int i = 0; i < red; i++ ) {
            nums[i] = 0;
        }
        for ( int i = red; i < red + white; i++ ) {
            nums[i] = 1;
        }
        for ( int i = red + white; i < nums.length; i++ ) {
            nums[i] = 2;
        }
    }
}
```

:::

> è¿›é˜¶ï¼šä»…ä½¿ç”¨å¸¸æ•°ç©ºé—´çš„ä¸€è¶Ÿæ‰«æç®—æ³•å—ï¼Ÿ

::: details ğŸ’¡

ã€æ€è·¯1ã€‘åŒæŒ‡é’ˆæ³•ï¼Œæ•°ç»„å¤´æŒ‡é’ˆç”¨äºæŒ‡å‘ 0ï¼Œå°¾æŒ‡é’ˆç”¨äºæŒ‡å‘ 2ã€‚ä¸€æ¬¡éå†æ•°ç»„ï¼Œå¦‚æœå€¼ä¸º 0 ä¸å¤´æŒ‡é’ˆä½ç½®äº¤æ¢ï¼Œå¦‚æœå€¼ä¸º 2 ä¸å°¾æŒ‡é’ˆä½ç½®äº¤æ¢ã€‚

ã€æ€è·¯2ã€‘åˆ·æ²¹æ¼†æ³•ï¼Œå…¶å®è¿™ä¸ªæ–¹æ³•ç±»ä¼¼ç»Ÿè®¡æ³•ï¼Œå°†å…¶ä¼˜åŒ–ä¸ºäº†ä¸€æ¬¡éå†ã€‚éå†æ•°ç»„ï¼Œå…ˆä¿ç•™è¯¥å€¼ã€‚

  - å…ˆå°†è¯¥ä½ç½®åˆ·ä¸º 2ã€‚
  - å¦‚æœå€¼ <2ï¼Œå°† 1 ç´¢å¼•ä¸‹åˆ·ä¸º 1ï¼Œåˆ· 1 çš„ç´¢å¼•å¢åŠ ã€‚(ä¸ºä»€ä¹ˆä¸æ˜¯ == 1ï¼Ÿå½“å€¼ä¸º 0 æ—¶ï¼Œç›¸ç­‰äºå°†åˆ· 1 çš„èŒƒå›´å¾€åç§»åŠ¨äº†ä¸€ä½ï¼Œå› ä¸ºåé¢ <1 çš„åˆ¤æ–­ï¼Œåˆ· 0 çš„é•¿åº¦ä¼šåŠ  1)
  - å¦‚æœå€¼ <1ï¼Œå°† 0 ç´¢å¼•ä¸‹åˆ·ä¸º 0ï¼Œåˆ· 0 çš„ç´¢å¼•éœ€è¦å¢åŠ ã€‚

::: code-tabs

@tab java è§£æ³•1
```java
class Solution {
    public void sortColors(int[] nums) {
        if ( nums.length <= 1 ) return;
        int head = 0;
        int tail = nums.length - 1;
        for ( int i = 0; i < nums.length; i++ ) {
            if ( nums[i] == 0 ) {
                // å¦‚æœç´¢å¼•ä½ç½®å€¼ä¸º 0ï¼Œåˆ™å…ˆè¿›è¡Œå¤´éƒ¨äº¤æ¢å¹¶å°†å¤´éƒ¨æŒ‡é’ˆå¾€å‰ç§»åŠ¨
                swap(nums, head, i);
                head += 1;
                // äº¤æ¢ä¹‹åï¼Œå†è¿›è¡Œå°¾éƒ¨äº¤æ¢
                if ( nums[i] == 2 ) {
                    swap(nums, i, tail);
                    tail -= 1;
                }
            } else if ( nums[i] == 2 ) {
                // å¦‚æœç´¢å¼•ä½ç½®å€¼ä¸º 2ï¼Œåˆ™å…ˆè¿›è¡Œå°¾éƒ¨äº¤æ¢å¹¶å°†å°¾éƒ¨æŒ‡é’ˆå¾€åç§»åŠ¨
                swap(nums, i, tail);
                tail -= 1;
                // äº¤æ¢ä¹‹åï¼Œå†è¿›è¡Œå¤´éƒ¨äº¤æ¢
                if ( nums[i] == 0 ) {
                    swap(nums, head, i);
                    head += 1;
                }
            }
            // éå†ç´¢å¼•å·²ç»å°¾éƒ¨ç´¢å¼•ç›¸é‡ï¼Œä¸éœ€è¦å†è¿›è¡Œå¤„ç†
            if ( i >= tail ) break;
        }
    }
    void swap(int[] nums, int i, int j) {
        if ( i == j ) return;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

@tab java è§£æ³•2
```java
class Solution {
    public void sortColors(int[] nums) {
        int red = 0; // åˆ·çº¢è‰²çš„é•¿åº¦
        int white = 0;  // åˆ·ç™½è‰²çš„é•¿åº¦
        for ( int i = 0; i < nums.length; i++ ) {
            int num = nums[i]; 
            nums[i] = 2; // å…ˆå°†å…¨éƒ¨åˆ·ä¸º blue = 2
            // å¦‚æœå€¼ä¸º 0 æˆ– 1ï¼Œåˆ™ç™½è‰²ç´¢å¼•ä¸‹åˆ·ä¸º white = 1ï¼Œç™½è‰²é•¿åº¦å¢åŠ 
            if ( num < 2 ) { 
                nums[white] = 1;
                white += 1;
            }
            // å¦‚æœå€¼ä¸º 0ï¼Œåˆ™çº¢è‰²ç´¢å¼•ä¸‹åˆ·ä¸º red = 0ï¼Œçº¢è‰²é•¿åº¦å¢åŠ 
            if ( num < 1 ) {
                nums[red] = 0;
                red += 1;
            }
        }
    }
}
```

:::

// #endregion 0075

## 0076 âœ…

// #region 0076

- [ğŸ”´ 76 - æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring)
    > ç»™å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ä¸ªç›®æ ‡å€¼å­—ç¬¦ä¸²ï¼Œè¿”å›å­—ç¬¦ä¸²ä¸­åŒ…å«ç›®æ ‡å­—ç¬¦ä¸²çš„æœ€å°å­ä¸²ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›ç©ºä¸²ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šs = "ADOBECODEBANC", t = "ABC"
            è¾“å‡ºï¼š"BANC"

::: details ğŸ’¡

ã€æ€è·¯ã€‘æ»‘åŠ¨çª—å£

::: code-tabs

@tab java
```java
class Solution {
    public String minWindow(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        
        Map<Character, Integer> need = new HashMap(); // éœ€æ±‚çš„å­—ç¬¦è¡¨
        int needCount = 0; // éœ€è¦å­—ç¬¦æœ‰æ•ˆæ€§è®¡æ•°(ç­‰äº need å¤§å°æ—¶ï¼Œè¡¨æ˜å·²ç¬¦åˆè¦æ±‚)
        // å¡«å…¥éœ€è¦çš„å­—ç¬¦
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> window = new HashMap(); // çª—å£å­—ç¬¦è¡¨
        int left = 0;
        int right = 0;
        // ä¿å­˜æœ€å°çª—å£çš„å¼€å§‹ç»“æŸç´¢å¼•
        int minStart = 0;
        int minStop = Integer.MAX_VALUE;
        // è°ƒæ•´çª—å£å³è¾¹ç•Œï¼Œç›´åˆ°ç¬¦åˆæ¡ä»¶
        while(right < sChars.length) {
            char c = sChars[right];
            if (need.containsKey(c)) {
                // æ˜¯éœ€è¦çš„å­—ç¬¦ï¼ŒåŠ å…¥çª—å£
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    // è¯¥å­—ç¬¦å·²è¾¾åˆ°è¦æ±‚æ•°é‡ï¼Œæœ‰æ•ˆæ€§å¢åŠ 
                    needCount += 1;
                }
            }
            right += 1; // æ‰©å¤§çª—å£
            
            // å­—ç¬¦çª—å£å·²ç¬¦åˆè¦æ±‚ï¼Œå¼€å§‹è°ƒæ•´å·¦è¾¹ç•Œç¼©å°ï¼Œç›´è‡³ä¸æ»¡è¶³è¦æ±‚
            while (needCount == need.size()) {
                // æ›´æ–°æœ€å°å€¼
                if (minStop - minStart > (right - left)) {
                    minStart = left;
                    minStop = right;
                }
                char cc = sChars[left];
                if (window.containsKey(cc)) {
                    // å­—ç¬¦æ•°é‡ç­‰äºéœ€æ±‚æ•°æ—¶ï¼Œç”±äºå³å°† -1ï¼Œæ‰€ä»¥æœ‰æ¶ˆæ¯è¾ƒå°‘
                    if (window.get(cc).equals(need.get(cc))) {
                        needCount -= 1;
                    }
                    window.put(cc, window.getOrDefault(cc, 0) - 1);
                }
                left += 1; // ç¼©å°çª—å£
            }
        }
        if (minStop == Integer.MAX_VALUE) return ""; // æœªæ‰¾åˆ°
        return s.substring(minStart, minStop);
    }
}
```

@tab swift
```swift
class Solution {
    func minWindow(_ s: String, _ t: String) -> String {
        let schars = [Character](s)
        let tchars = [Character](t)
        let scount = schars.count
        let tcount = tchars.count
        guard tcount <= scount else { return "" }
        
        var need = [Character: Int]()
        for char in tchars {
            need[char] = (need[char] ?? 0) + 1
        }

        func isValid() -> Bool {
            !need.values.contains(where: { $0 > 0 })
        }

        var start: Int = 0
        var count: Int = 0

        var i = 0
        var j = 0
        while i < scount {
            let ichar = schars[i]
            if need.keys.contains(ichar) {
                need[ichar] = (need[ichar] ?? 0) - 1
            }
            i += 1
            guard isValid() else { continue }
            while j < i {
                let jchar = schars[j]
                if need.keys.contains(jchar) {
                    need[jchar] = min(1, (need[jchar] ?? 0) + 1)
                }
                j += 1
                guard !isValid() else { continue }
                if count == 0 || count > (i - j) {
                    start = j - 1
                    count = i - j + 1
                }
                break
            }
        }
        guard count > 0 else { return "" }
        return String(schars[start..<(start + count)])
    }
}
```

:::

// #endregion 0076

## 0077 âœ…

// #region 0077

- [ğŸŸ  77 - ç»„åˆ](https://leetcode.cn/problems/combinations)
    > ç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å›èŒƒå›´ [1, n] ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šn = 4, k = 2
            è¾“å‡ºï¼š
            [
              [2,4],
              [3,4],
              [2,3],
              [1,2],
              [1,3],
              [1,4],
            ]
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘å›æº¯æ³•

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> combine(int n, int k) {
        backtrack(n, k, 1);
        return result;
    }

    void backtrack(int n, int k, int start) {
        if (track.size() == k) { // ç­‰äºç›®æ ‡ç»„åˆæ•°æ—¶ï¼Œæ”¶é›†ç»„åˆ
            result.add(new LinkedList(track));
            return;
        }
        // æœªè¾¾åˆ°ç›®æ ‡ç»„åˆæ•°ï¼Œç»§ç»­è¿›è¡Œé€’å½’å›æº¯
        for (int i = start; i <= n; i++) {
            track.add(i);
            backtrack(n, k, i+1);
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func combine(_ n: Int, _ k: Int) -> [[Int]] {
        backtrack(n, start: 1, k: k, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ n: Int, start: Int, k: Int, track: [Int]) {
        if track.count == k {
            res.append(track)
            return
        }

        var track = track
        for i in start..<(n + 1) {
            track.append(i)
            backtrack(n, start: i + 1, k: k, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0077

## 0078 âœ…

// #region 0078

- [ğŸŸ  78 - å­é›†](https://leetcode.cn/problems/subsets)
    
        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,2,3]
            è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
    
::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();
    
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return result;
    }
    
    void backtrack(int[] nums, int start) {
        result.add(new LinkedList(track));
        for (int i = start; i < nums.length; i++) {
            track.add(nums[i]);
            backtrack(nums, i + 1); // ç»§ç»­å›æº¯å½“å‰ç´¢å¼•çš„åä¸€ä¸ªå…ƒç´ ï¼Œç¡®ä¿ä¸ä¼šå‡ºç°é‡å¤å­é›†
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func subsets(_ nums: [Int]) -> [[Int]] {
        backtrack(nums, track: [], start: 0)
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ nums: [Int], track: [Int], start: Int) {
        res.append(track)

        var track = track
        for i in start..<nums.count {
            track.append(nums[i])
            backtrack(nums, track: track, start: i + 1)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0078

## 0079

// #region 0079

- [ğŸŸ  79 - å•è¯æœç´¢](https://leetcode.cn/problems/word-search)

::: details ğŸ’¡

:::

// #endregion 0079

## 0080 âœ…

// #region 0080

- [ğŸŸ  80 - åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii)
    > ç»™å®šä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œåˆ é™¤æ•°ç»„ä¸­é‡å¤å…ƒç´ (ä¿ç•™ä¸¤ä¸ª)ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,1,1,2,2,3]
            è¾“å‡ºï¼š5, nums = [1,1,2,2,3]

::: details ğŸ’¡

ã€æ€è·¯1ã€‘åŒæŒ‡é’ˆæ³•ï¼Œæ ¸å¿ƒç‚¹åœ¨äºå¦‚ä½•å°†é‡å¤å…ƒç´ ä¿ç•™ä¸¤ä¸ªã€‚å¿«æŒ‡é’ˆç´¢å¼•ä¸ºéå†æŒ‡é’ˆï¼Œ

  - å½“éå†å€¼ä¸ä¸‹ä¸€ä¸ªå€¼æ˜¯å¦ç›¸ç­‰ï¼Œä¸ç›¸ç­‰æ—¶ï¼Œéœ€è¦ç§»åŠ¨æ…¢æŒ‡é’ˆï¼Œå°†å¿«æŒ‡é’ˆå€¼èµ‹å€¼åˆ°æ…¢æŒ‡é’ˆä¸ºæ­¢
  - ç›¸ç­‰æ—¶ï¼Œå…ˆå°†å¿«æŒ‡é’ˆä½ç½®èµ‹å€¼åˆ°æ…¢æŒ‡é’ˆä½ç½®ï¼›è·³è¿‡ä¸­é—´é‡å¤å…ƒç´ ï¼›ç„¶åå°†æœ€åä¸€ä¸ªé‡å¤å…ƒç´ ä¹Ÿèµ‹å€¼åˆ°æ…¢æŒ‡é’ˆä½ç½®ã€‚

ã€æ€è·¯2ã€‘ä¹Ÿæ˜¯åŒæŒ‡é’ˆï¼Œä½†æ˜¯ä¸æ˜¯æ·»åŠ ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªé‡å¤å…ƒç´ ï¼Œè€Œæ˜¯ä¿è¯é—´éš”ä¸º 2 çš„å…ƒç´ ä¸ç›¸ç­‰å³å¯ã€‚

  - åˆ¤æ–­æ•°ç»„é•¿åº¦æ˜¯å¦å¤§äº 2ï¼Œå°äº 2 ä¸éœ€è¦å¤„ç†ã€‚
  - å¤§äº 2 æ—¶ï¼Œåˆ¤æ–­å¿«æŒ‡é’ˆç´¢å¼•ä½ç½®å…ƒç´ ï¼Œä¸æ…¢æŒ‡é’ˆç´¢å¼• - 2 çš„ä½ç½®å…ƒç´ æ˜¯å¦ç›¸ç­‰ã€‚
    * å¦‚æœç›¸ç­‰ï¼Œåˆ™è·³è¿‡è¯¥å…ƒç´ 
    * å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™å°†å¿«æŒ‡é’ˆå…ƒç´ èµ‹å€¼ç»™æ…¢æŒ‡é’ˆä½ç½®ï¼Œç§»åŠ¨æ…¢æŒ‡é’ˆã€‚

::: code-tabs

@tab java è§£æ³•1
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0;
        int slow = -1;
        while ( fast < nums.length ) {
            if ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                // æ˜¯é‡å¤å…ƒç´ 
                //  1> æ·»åŠ ç¬¬ä¸€ä¸ªé‡å¤å…ƒç´ 
                slow += 1;
                nums[slow] = nums[fast];
                //  2> è·³è¿‡ä¸­é—´çš„é‡å¤å…ƒç´ 
                while ( (fast + 1) < nums.length && nums[fast] == nums[fast + 1] ) {
                    fast += 1;
                }
                //  3> æ·»åŠ æœ€åä¸€ä¸ªé‡å¤å…ƒç´ 
                slow += 1;
                nums[slow] = nums[fast];
                //  4> è·³è¿‡æœ€åä¸€ä¸ªé‡å¤å…ƒç´ 
                fast += 1;
            } else {
                // ä¸æ˜¯é‡å¤å…ƒç´ ï¼Œç§»åŠ¨æ…¢æŒ‡é’ˆï¼Œå°†å¿«æŒ‡é’ˆå…ƒç´ èµ‹å€¼åˆ°æ…¢æŒ‡é’ˆç´¢å¼•ä½ç½®
                slow += 1;
                nums[slow] = nums[fast];
                fast += 1;
            }
        }
        return slow + 1;
    }
}
```

@tab swift è§£æ³•2 ğŸ’¯
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        let count = nums.count
        // è¾“å‡ºå¤§äº 2 æ—¶æ‰éœ€è¦å¤„ç†
        guard count > 2 else { return count }
        var slow = 2
        var fast = 2
        while ( fast < count ) {
            
            if ( nums[slow - 2] != nums[fast] ) {
                nums[slow] = nums[fast] 
                slow += 1
            }
            fast += 1
        }
        return slow
    }
}
```

:::

// #endregion 0080

## 0081

// #region 0081

- [ğŸŸ  81 - æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii)

::: details ğŸ’¡

:::

// #endregion 0081

## 0082 âœ…

// #region 0082

- [ğŸŸ  82 - åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)
    > ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ (é‡å¤å…ƒç´ å…¨éƒ¨åˆ é™¤)ã€‚

        ğŸŒ°
            è¾“å…¥ï¼š1 -> 1 -> 1 -> 2 -> 3
            è¾“å‡ºï¼š2 -> 3

::: details ğŸ’¡

ã€æ€è·¯ã€‘åŒæŒ‡é’ˆæ³•ï¼Œåˆ›å»ºå·²ä¼ªå¤´ç»“ç‚¹ï¼Œç”¨äºè§£å†³é“¾è¡¨ä¸ºç©ºæˆ–å…¨éƒ¨ä¸ºé‡å¤å…ƒç´ çš„æƒ…å†µï¼›ç„¶åæ…¢æŒ‡é’ˆæŒ‡å‘ä¼ªå¤´ç»“ç‚¹ï¼Œå¿«æŒ‡é’ˆä»å¤´ç»“ç‚¹å¼€å§‹éå†ã€‚

  - å¦‚æœå¿«æŒ‡é’ˆèŠ‚ç‚¹ä¸åé¢èŠ‚ç‚¹å€¼ç›¸ç­‰ï¼Œåˆ™è·³è¿‡å…¨éƒ¨é‡å¤èŠ‚ç‚¹ã€‚ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼Œè·³è¿‡ä¹‹åå¦‚æœé“¾è¡¨å·²ç»ç»“æŸï¼Œåˆ™éœ€è¦å°†æ…¢æŒ‡é’ˆæŒ‡å‘ nullã€‚
  - å¦‚æœå¿«æŒ‡é’ˆèŠ‚ç‚¹ä¸åé¢èŠ‚ç‚¹ä¸ç›¸ç­‰ï¼Œåˆ™è¡¨æ˜ä¸æ˜¯é‡å¤èŠ‚ç‚¹ã€‚åˆ™å°†æ…¢æŒ‡é’ˆçš„åç»§èŠ‚ç‚¹æŒ‡å‘å¿«æŒ‡é’ˆèŠ‚ç‚¹ï¼Œç„¶åå°†å¿«æ…¢æŒ‡é’ˆéƒ½å¾€å‰ç§»åŠ¨ä¸€æ­¥ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy.next;
        while ( fast != null ) {
            // å¿«æŒ‡é’ˆå»æ¢æµ‹ä¸é‡å¤çš„èŠ‚ç‚¹
            if ( fast.next != null && fast.val == fast.next.val ) {
                // æ¢æµ‹åˆ°é‡å¤èŠ‚ç‚¹ï¼Œè·³è¿‡é‡å¤å…ƒç´ 
                while ( fast.next != null && fast.val == fast.next.val ) {
                    fast = fast.next;
                }
                // æŒ‡å‘äº†æœ€åä¸€ä¸ªé‡å¤èŠ‚ç‚¹ï¼Œå¾€å‰ç§»åŠ¨ä¸€æ­¥
                fast = fast.next;
                // åé¢ä¸ºç©ºï¼Œåˆ™å°†æ…¢æŒ‡é’ˆæŒ‡å‘ null
                if ( fast == null ) {
                    slow.next = null;
                }
            } else {
                // æ¢æµ‹åˆ°ä¸é‡å¤èŠ‚ç‚¹ï¼Œå°†æ…¢æŒ‡é’ˆæŒ‡å‘èŠ‚ç‚¹ï¼Œå¹¶å¾€å‰ç§»åŠ¨
                slow.next = fast;
                slow = slow.next;
                fast = fast.next;
            }
        }
        return dummy.next;
    }
}
```

:::

// #endregion 0082

## 0083 âœ…

// #region 0083

- [ğŸŸ¢ 83 - åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)
  > ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ (é‡å¤å…ƒç´ ä¿ç•™ä¸€ä¸ª)ã€‚

        ğŸŒ°
            è¾“å…¥ï¼š1 -> 1 -> 1 -> 2 -> 3
            è¾“å‡ºï¼š1 -> 2 -> 3

::: details ğŸ’¡

ã€æ€è·¯1ã€‘åŒæŒ‡é’ˆæ³•ï¼Œå–å·§æ–¹æ¡ˆï¼Œç±»ä¼¼æ’åºæ•°ç»„ä¸­çš„åˆ é™¤é‡å¤å…ƒç´ æ–¹æ¡ˆï¼Œæ¯æ¬¡åˆ¤æ–­å€¼ä¸ä¸€æ ·æ—¶ï¼Œå°†æ…¢æŒ‡é’ˆå¾€å‰ç§»åŠ¨ï¼Œå°†å¿«æŒ‡é’ˆä¸­çš„å€¼èµ‹å€¼åˆ°æ…¢æŒ‡é’ˆä½ç½®ã€‚

ã€æ€è·¯2ã€‘æ€è·¯ 1 è™½ç„¶å¾—åˆ°ç»“æœæ˜¯æ­£ç¡®ï¼Œä½†æ˜¯å´æ”¹å˜äº†èŠ‚ç‚¹ã€‚ ä¼˜åŒ–æ€è·¯ 1 æ–¹æ¡ˆï¼Œæ¯æ¬¡åˆ¤æ–­å€¼ä¸ä¸€æ ·æ—¶ï¼Œä¸è¿›è¡Œèµ‹å€¼ï¼Œç›´æ¥å°†æ…¢æŒ‡é’ˆæŒ‡å‘å¿«æŒ‡é’ˆèŠ‚ç‚¹ã€‚

::: code-tabs

@tab java æ€è·¯1
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // å¿«æŒ‡é’ˆå€¼ä¸æ…¢æŒ‡é’ˆæŒ‡ä¸ä¸€æ ·æ—¶ï¼Œå°†æ…¢æŒ‡é’ˆå¾€å‰ç§»åŠ¨ï¼Œ
            if ( fast.val != slow.val ) {
                slow = slow.next;
                slow.val = fast.val;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

@tab java æ€è·¯2
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if ( head == null ) return null;
        ListNode fast = head;
        ListNode slow = head;
        while ( fast != null ) {
            // å€¼ä¸ç›¸ç­‰æ—¶ï¼Œå°†æ…¢æŒ‡é’ˆæŒ‡å‘å¿«æŒ‡é’ˆèŠ‚ç‚¹ï¼Œå¹¶å°†æ…¢æŒ‡é’ˆå¾€å‰ç§»åŠ¨
            if ( fast.val != slow.val ) {
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```

:::

// #endregion 0083

## 0084

// #region 0084

- [ğŸ”´ 84 - æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢](https://leetcode.cn/problems/largest-rectangle-in-histogram)

::: details ğŸ’¡

:::

// #endregion 0084

## 0085

// #region 0085

- [ğŸ”´ 85 - æœ€å¤§çŸ©å½¢](https://leetcode.cn/problems/maximal-rectangle)

::: details ğŸ’¡

:::

// #endregion 0085

## 0086 âœ…

// #region 0086

- [ğŸŸ  86 - åˆ†éš”é“¾è¡¨](https://leetcode.cn/problems/partition-list)
  > æ ¹æ®ç»™å®šå€¼å°†é“¾è¡¨å…ƒç´ åˆ†å‰²ä¸ºå°äºå’Œå¤§äºç­‰äºè¯¥å€¼çš„ä¸¤éƒ¨åˆ†ã€‚å¹¶ä¿æŒèŠ‚ç‚¹å…ƒç´ ç›¸å¯¹ä½ç½®ã€‚

        ğŸŒ°
            
            è¾“å…¥ï¼šhead = [1,4,3,2,5,2], x = 3
            è¾“å‡ºï¼š[1,2,2,4,3,5]

::: details ğŸ’¡

ã€æ€è·¯ã€‘å°†åŸé“¾è¡¨æŒ‰ç…§å€¼å¤§å°åˆ†éš”æˆä¸¤æ¡é“¾è¡¨ï¼Œæœ€ååˆå¹¶æˆç»“æœé“¾è¡¨ã€‚

::: code-tabs

@tab java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode l1 = new ListNode(); // å°äº x é“¾è¡¨
        ListNode l2 = new ListNode(); // å¤§äº x é“¾è¡¨
        ListNode p1 = l1;
        ListNode p2 = l2;
        // éå†é“¾è¡¨ï¼ŒæŒ‰ç…§å¤§å°å°†åŸé“¾è¡¨åˆ†æˆä¸¤æ¡é“¾è¡¨ï¼Œåˆ†è§£æ—¶éœ€è¦æ³¨æ„åˆ†è§£èŠ‚ç‚¹ä¸åŸé“¾è¡¨çš„æ–­å¼€é—®é¢˜ã€‚
        ListNode p = head;
        while ( p != null ) {
            if ( p.val < x ) {
                p1.next = p;    // å°†èŠ‚ç‚¹æ·»åŠ åˆ°å°äº x é“¾è¡¨
                p = p.next;     // é“¾è¡¨æŒ‡é’ˆå‰è¿›
                p1 = p1.next;   // å°äº x é“¾è¡¨æŒ‡é’ˆå‰è¿›
                p1.next = null; // å¹¶å°†å°äº x é“¾è¡¨ä¸åŸé“¾è¡¨æ–­å¼€
            } else {
                p2.next = p;    
                p = p.next;
                p2 = p2.next;
                p2.next = null;
            }
        }
        // åˆå¹¶æˆä¸€æ¡
        p1.next = l2.next;
        return l1.next; 
    }
}
```

@tab swift
```swift
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *     }
 * }
 */
class Solution {
    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {
        let minHead = ListNode(0)
        var min: ListNode? = minHead
        let maxHead = ListNode(0)
        var max: ListNode? = maxHead
        var node = head
        // æ ¹æ®å€¼å¤§å°åˆ›å»ºäº†ä¸¤æ¡æ–°é“¾è¡¨ï¼Œæœ€ååˆå¹¶ã€‚è¿™æ ·ä¸éœ€è¦å¤„ç†é“¾è¡¨æ–­å¼€çš„é—®é¢˜ã€‚
        while node != nil {
            guard let n = node  else { break }
            if n.val < x {
                min?.next = ListNode(n.val)
                min = min?.next
            } else {
                max?.next = ListNode(n.val)
                max = max?.next
            }
            node = n.next
        }
        min?.next = maxHead.next
        return minHead.next
    }
}
```

:::

// #endregion 0086

## 0087

// #region 0087

- [ğŸ”´ 87 - æ‰°ä¹±å­—ç¬¦ä¸²](https://leetcode.cn/problems/scramble-string)

::: details ğŸ’¡

:::

// #endregion 0087

## 0088

// #region 0088

- [ğŸŸ¢ 88 - åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode.cn/problems/merge-sorted-array)
    > ç»™ä½ ä¸¤ä¸ªæŒ‰ â€œéé€’å‡é¡ºåºâ€ æ’åˆ—çš„æ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œå¦æœ‰ä¸¤ä¸ªæ•´æ•° m å’Œ n ï¼Œåˆ†åˆ«è¡¨ç¤º nums1 å’Œ nums2 ä¸­çš„å…ƒç´ æ•°ç›®ã€‚è¯·åˆå¹¶ nums2 åˆ° nums1 (nums1 æ•°ç»„é•¿åº¦ä¸º m+n) ä¸­ï¼Œä½¿åˆå¹¶åçš„æ•°ç»„åŒæ ·æŒ‰ â€œéé€’å‡é¡ºåºâ€ æ’åˆ—ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šnums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
            è¾“å‡ºï¼š[1,2,2,3,5,6]

::: details ğŸ’¡

ã€æ€è·¯ã€‘ä½¿ç”¨åŒæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸¤ä¸ªæ•°ç»„çš„æœ‰å…ƒç´ çš„å°¾éƒ¨ï¼Œä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ€»é•¿åº¦çš„ä½ç½®ç´¢å¼•ã€‚å€’åºéå†ä¸¤ä¸ªæ•°ç»„ï¼Œæ¯”è¾ƒå¤§å°ï¼Œå°†å¤§çš„å…ƒç´ ï¼ŒåŠ å…¥ç»“æœæ•°ç»„ nums1 å°¾éƒ¨æŒ‡é’ˆçš„åœ°æ–¹ã€‚ç»“æŸä¹‹åï¼Œå¦‚æœ nums2 æ•°ç»„ä¸­è¿˜æœ‰å…ƒç´ ï¼Œåˆ™ç›´æ¥å€’åºåŠ å…¥ç»“æœ nums1 æ•°ç»„ä¸­å³å¯ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            int num1 = nums1[i];
            int num2 = nums2[j];
            // æ¯”è¾ƒæ•°æ®å¤§å°ï¼Œå°†æ•°æ®åŠ å…¥ç»“æœæ•°ç»„ä¸­
            if (num2 >= num1) { 
                nums1[k] = num2;
                j -= 1;
            } else {
                nums1[k] = num1;
                i -= 1;
            }
            k -= 1;
        }   
        // å¦‚æœ nums2 è¿˜æœ‰å…ƒç´ ï¼Œç›´æ¥åŠ å…¥åˆ°ç»“æœæ•°ç»„ä¸­
        while (j >= 0) {
            nums1[k] = nums2[j];
            j -= 1;
            k -= 1;
        }
    }
}
```

@tab swift
```swift
class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        var i = m - 1;
        var j = n - 1;
        var k = m + n - 1;
        while ( i >= 0 && j >= 0 ) {
            if ( nums1[i] >= nums2[j] ) {
                nums1[k] = nums1[i]
                i -= 1
            } else {
                nums1[k] = nums2[j]
                j -= 1
            }
            k -= 1
        }
        while ( j >= 0 ) {
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
        } 
    }
}
```

:::

// #endregion 0088

## 0089

// #region 0089

- [ğŸŸ  89 - æ ¼é›·ç¼–ç ](https://leetcode.cn/problems/gray-code)

::: details ğŸ’¡

:::

// #endregion 0089

## 0090 âœ…

// #region 0090

- [ğŸŸ  90 - å­é›† II](https://leetcode.cn/problems/subsets-ii)
    
        ğŸŒ°
            è¾“å…¥ï¼šnums = [1,2,2]
            è¾“å‡ºï¼š[[],[1],[1,2],[1,2,2],[2],[2,2]]
    
::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution {
    List<List<Integer>> result = new LinkedList();
    List<Integer> track = new LinkedList();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // æ ¸å¿ƒç‚¹åœ¨äºä¿è¯ç›¸åŒå…ƒç´ çš„ç›¸åŒä½ç½®ä¿æŒä¸å˜
        Arrays.sort(nums);
        backtrack(nums, 0);
        return result;
    }

    void backtrack(int[] nums, int start) {
        result.add(new LinkedList(track));
        for (int i = start; i < nums.length; i++) {
            // å‰ªæé€»è¾‘ï¼šé¿å…å›æº¯ä¹‹ç›¸åŒçš„å…ƒç´ 
            if (i > start && nums[i] == nums[i - 1]) continue;
            track.add(nums[i]);
            backtrack(nums, i + 1);
            track.removeLast();
        }
    }
}
```

@tab swift
```swift
class Solution {
    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {
        backtrack(nums.sorted(), start: 0, track: [])
        return res
    }
    private var res = [[Int]]()
    private func backtrack(_ nums: [Int], start: Int, track: [Int]) {
        res.append(track)

        var track = track
        for i in start..<nums.count {
            if i > start, nums[i] == nums[i - 1] { continue }
            track.append(nums[i])
            backtrack(nums, start: i + 1, track: track)
            track.removeLast()
        }
    }
}
```

:::

// #endregion 0090

## 0091

// #region 0091

- [ğŸŸ  91 - è§£ç æ–¹æ³•](https://leetcode.cn/problems/decode-ways)

::: details ğŸ’¡

:::

// #endregion 0091

## 0092 âœ…

// #region 0092

- [ğŸŸ  92 - åè½¬é“¾è¡¨ II](https://leetcode.cn/problems/reverse-linked-list-ii/)
  > é€šè¿‡å•é“¾è¡¨çš„å¤´ç»“ç‚¹ head å’Œä¸¤ä¸ªæ•´æ•° left å’Œ right (left <= right)ï¼Œåè½¬é“¾è¡¨ä» left åˆ° right ä½ç½®çš„é“¾è¡¨èŠ‚ç‚¹ï¼Œè¿”å›åè½¬åçš„é“¾è¡¨ã€‚

        ğŸŒ° 1 -> 2 -> 3 -> 4 -> 5
            è¾“å…¥ï¼šhead = [1,2,3,4,5], left = 2, right = 4
            è¾“å‡ºï¼š[1,4,3,2,5]
            
::: details ğŸ’¡

ã€æ€è·¯ã€‘å…ˆé€šè¿‡éå†ï¼Œå¾—åˆ°åè½¬åŒºåŸŸçš„å·¦å³èŠ‚ç‚¹ï¼Œé€šè¿‡è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥è¿›è¡Œè¯¥åŒºåŸŸçš„é“¾è¡¨çš„åè½¬ï¼Œåè½¬ä¹‹åé€šè¿‡è¿™ä¸¤ä¸ªèŠ‚ç‚¹å°†åè½¬åçš„é“¾è¡¨è¿æ¥èµ·æ¥ã€‚

::: code-tabs

@tab java 
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left >= right) return head;
        // ç»™é“¾è¡¨åŠ å¤´ï¼Œè§£å†³å¤´ç»“ç‚¹ä¹Ÿå‚ä¸åè½¬çš„é—®é¢˜
        ListNode dummy = new ListNode();
        dummy.next = head;
        // éå†å¾—åˆ°å·¦å³èŠ‚ç‚¹
        ListNode leftNode = dummy; // å·¦èŠ‚ç‚¹ï¼šåè½¬çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
        ListNode rightNode = dummy; // å³èŠ‚ç‚¹ï¼šåè½¬çš„åä¸€ä¸ªèŠ‚ç‚¹
        for (int i = 0; i < right + 1; i++) {
            if (i < left - 1) {
                leftNode = leftNode.next;
            }
            rightNode = rightNode.next;
        }
        // åè½¬çš„å¤´ç»“ç‚¹
        ListNode reverseHead = leftNode.next;
        // å°†å·¦èŠ‚ç‚¹ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘åè½¬åçš„å¤´ç»“ç‚¹
        leftNode.next = reverse(reverseHead, rightNode);
        // åè½¬çš„å¤´ç»“ç‚¹ï¼Œåè½¬åå˜ä¸ºäº†å°¾ç»“ç‚¹ï¼ŒæŒ‡å‘æœ‰å³èŠ‚ç‚¹
        reverseHead.next = rightNode;
        return dummy.next;
    }

    // åè½¬æŒ‡å®šèŒƒå›´èŠ‚ç‚¹ï¼Œåˆ° tail ä¸ºæ­¢(tail ä¸å‚ä¸åè½¬)
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode result = null;
        ListNode node = head;
        while (node != tail) {
            ListNode temp = node.next;

            node.next = result;
            result = node;

            node = temp;
        }
        return result;
    }
}
```

  > å¦‚æœä½¿ç”¨è¿­ä»£ï¼Œåº”è¯¥æ€ä¹ˆå¤„ç†ï¼Ÿ
  
  > ä½¿ç”¨ä¸€è¶Ÿæ‰«æå®Œæˆåè½¬å—ï¼Ÿ

:::

// #endregion 0092

## 0093

// #region 0093

- [ğŸŸ  93 - å¤åŸ IP åœ°å€](https://leetcode.cn/problems/restore-ip-addresses)

::: details ğŸ’¡

:::

// #endregion 0093

## 0094 âœ…

// #region 0094

- [ğŸŸ¢ 94 - äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal)

::: details ğŸ’¡

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);
        return list;
    }

    void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        list.add(root.val); // ä¸­åºä½ç½®ï¼Œæ·»åŠ å€¼
        traversal(root.right);
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func inorderTraversal(_ root: TreeNode?) -> [Int] {
        guard let root = root else { return [] }
        var result = [Int]()
        result.append(contentsOf: inorderTraversal(root.left))
        result.append(root.val)
        result.append(contentsOf: inorderTraversal(root.right))
        return result
    }
}
```

:::

// #endregion 0094

## 0095

// #region 0095

- [ğŸŸ  95 - ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II](https://leetcode.cn/problems/unique-binary-search-trees-ii)

::: details ğŸ’¡

:::

// #endregion 0095

## 0096

// #region 0096

- [ğŸŸ  96 - ä¸åŒçš„äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/unique-binary-search-trees)

::: details ğŸ’¡

:::

// #endregion 0096

## 0097

// #region 0097

- [ğŸŸ  97 - äº¤é”™å­—ç¬¦ä¸²](https://leetcode.cn/problems/interleaving-string)

::: details ğŸ’¡

:::

// #endregion 0097

## 0098 âœ…

// #region 0098

- [ğŸŸ  98 - éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/validate-binary-search-tree)
    > ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚
    > æœ‰æ•ˆäºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
    >   èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
    >   èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
    >   æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šroot = [2,1,3]
            è¾“å‡ºï¼štrue
        ğŸŒ°
            è¾“å…¥ï¼šroot = [5,1,4,null,null,3,6]
            è¾“å‡ºï¼šfalse
            è§£é‡Šï¼šæ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ 5 ï¼Œä½†æ˜¯å³å­èŠ‚ç‚¹çš„å€¼æ˜¯ 4 ã€‚
            
::: details ğŸ’¡

ã€æ€è·¯1ã€‘é€’å½’ï¼Œ

ã€æ€è·¯2ã€‘ä¸­åºéå†ï¼Œ

::: code-tabs

@tab swift è§£æ³•1
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func isValidBST(_ root: TreeNode?) -> Bool {
        isValidBST(root, min: nil, max: nil)
    }
    private func isValidBST(_ root: TreeNode?, min: TreeNode?, max: TreeNode?) -> Bool {
        guard let root = root else { return true }
        if let min = min, root.val <= min.val { return false }
        if let max = max, root.val >= max.val { return false }
        
        return isValidBST(root.left, min: min, max: root) && isValidBST(root.right, min: root, max: max)
    }
}
```

@tab java è§£æ³•2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean isValid(TreeNode root, long min, long max) {
        if (root == null) return true;
        if (root.val <= min || root.val >= max) return false;
        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);
    }
}
```

:::

// #endregion 0098

## 0099

// #region 0099

- [ğŸŸ  99 - æ¢å¤äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/recover-binary-search-tree)

::: details ğŸ’¡

:::

// #endregion 0099
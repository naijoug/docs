---
title: 0500 ~ 0599
icon: hashtag

index: true

---

<!-- more -->

## 0500

// #region 0500

- [ğŸŸ¢ 500 - é”®ç›˜è¡Œ](https://leetcode.cn/problems/keyboard-row)

::: details ğŸ’¡

:::

// #endregion 0500

## 0503

// #region 0503

- [ğŸŸ  503 - ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II](https://leetcode.cn/problems/next-greater-element-ii)

::: details ğŸ’¡

:::

// #endregion 0503

## 0509 âœ…

// #region 0509

- [ğŸŸ¢ 509 - æ–æ³¢é‚£å¥‘æ•°](https://leetcode.cn/problems/fibonacci-number)
    > f(0) = 0
    > f(1) = 1
    > n > 1, f(n) = f(n - 1) + f(n - 2) 
    
::: details ğŸ’¡

ã€æ€è·¯1ã€‘ç›´æ¥æ ¹æ®å‡½æ•°å…³ç³»ï¼Œè¿›è¡Œé€’å½’æ±‚è§£

ã€æ€è·¯2ã€‘å¾ªç¯

ã€æ€è·¯3ã€‘åŠ¨æ€è§„åˆ’ï¼Œè§£å†³`æ€è·¯1`ä¸­çš„é‡å å­é—®é¢˜

::: code-tabs

@tab java è§£æ³•1
```java 
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        return fib(n - 1) + fib(n - 2);
    }
}
```

@tab java è§£æ³•2
```java
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;
        int fn2 = 0;
        int fn1 = 1;
        int fn = fn1 + fn2;
        for(int i = 2; i < n; i++) {
            fn2 = fn1;
            fn1 = fn;
            fn = fn1 + fn2;
        }
        return fn;
    }
}
```

@tab java è§£æ³•3
```java
class Solution {
    Map<Integer, Integer> dp = new HashMap();
    public int fib(int n) {
        if (n < 2) return n;
        if (dp.containsKey(n)) {
            return dp.get(n);
        }
        int fn = fib(n - 1) + fib(n - 2);
        dp.put(n, fn); // å°†è®¡ç®—çš„å€¼æ”¾å…¥ dp è¡¨ä¸­
        return fn;
    }
}
```

:::

// #endregion 0509

## 0514

// #region 0514

- [ğŸ”´ 514 - è‡ªç”±ä¹‹è·¯](https://leetcode.cn/problems/freedom-trail)

::: details ğŸ’¡

:::

// #endregion 0514

## 0516

// #region 0516

- [ğŸŸ  516 - æœ€é•¿å›æ–‡å­åºåˆ—](https://leetcode.cn/problems/longest-palindromic-subsequence)

::: details ğŸ’¡

:::

// #endregion 0516

## 0518

// #region 0518

- [ğŸŸ  518 - é›¶é’±å…‘æ¢ II](https://leetcode.cn/problems/coin-change-ii)

::: details ğŸ’¡

:::

// #endregion 0518

## 0528

// #region 0528

- [ğŸŸ  528 - æŒ‰æƒé‡éšæœºé€‰æ‹©](https://leetcode.cn/problems/random-pick-with-weight)

::: details ğŸ’¡

:::

// #endregion 0528

## 0538

// #region 0538

- [ğŸŸ  538 - æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘](https://leetcode.cn/problems/convert-bst-to-greater-tree)

::: details ğŸ’¡

:::

// #endregion 0538

## 0541 âœ…

// #region 0541

- [ğŸŸ¢ 541 - åè½¬å­—ç¬¦ä¸² II](https://leetcode.cn/problems/reverse-string-ii)

::: details ğŸ’¡

::: code-tabs

@tab java
```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] chars = s.toCharArray();
        int length = chars.length;
        // è®¡ç®— 2k å­—ç¬¦æ¬¡æ•°ï¼Œè¿›è¡Œåè½¬
        int count = length / (k * 2);
        for (int i = 0; i < count; i++) {
            reverse(chars, i*2*k, i*2*k + k - 1);
        }
        // è®¡ç®—å‰©ä½™å­—ç¬¦æ•°
        int remainder = length % (k * 2);
        if ( remainder < k ) {
            reverse(chars, count*2*k, count*2*k + remainder - 1);
        } else if ( remainder >= k && remainder < 2*k ) {
            reverse(chars, count*2*k, count*2*k + k - 1);
        }
        return new String(chars);
    }

    /// åè½¬å­—ç¬¦æ•°ç»„æŒ‡å®šç´¢å¼•èŒƒå›´å­—ç¬¦
    void reverse(char[] chars, int left, int right) {
        while ( left < right ) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left += 1;
            right -= 1;
        }
    }
}
```

:::

// #endregion 0541

## 0543 âœ…

// #region 0543

- [ğŸŸ¢ 543 - äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree)
    > äºŒå‰æ ‘çš„ç›´å¾„ï¼šä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€é•¿è·¯å¾„ï¼Œè·¯å¾„å¯ä»¥ç»è¿‡æ ¹èŠ‚ç‚¹ã€‚
    
        ğŸŒ°
            è¾“å…¥ï¼šroot = [1,2,3,4,5]
            è¾“å‡ºï¼š3
            è§£é‡Šï¼š3 ï¼Œå–è·¯å¾„ [4,2,1,3] æˆ– [5,2,1,3] çš„é•¿åº¦ã€‚
                1
               / \
              2   3
             / \
            4   5  
    
::: details ğŸ’¡

ã€æ€è·¯ã€‘ä¸€ä¸ªèŠ‚ç‚¹çš„æœ€é•¿ç›´å¾„ï¼Œå°±æ˜¯è¯¥èŠ‚ç‚¹å·¦å³å­æ ‘æœ€å¤§æ·±åº¦ä¹‹å’Œ

::: code-tabs

@tab java
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int maxDiameter = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return maxDiameter;
    }
    
    /// ä¸€ä¸ªèŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦
    int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        // å½“å‰èŠ‚ç‚¹çš„æœ€é•¿ç›´å¾„
        int nodeDiameter = leftDepth + rightDepth;
        maxDiameter = Integer.max(maxDiameter, nodeDiameter);
        return Integer.max(leftDepth, rightDepth) + 1;
    }
}
```

@tab swift
```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {

    var diameter: Int = 0

    func diameterOfBinaryTree(_ root: TreeNode?) -> Int {
        maxDepth(root)
        return diameter
    }

    @discardableResult
    private func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return 0 }

        let leftMax = maxDepth(root.left)
        let rightMax = maxDepth(root.right)
        diameter = max(diameter, leftMax + rightMax)

        return max(leftMax, rightMax) + 1
    }
}
```

:::

// #endregion 0543

## 0567 âœ…

// #region 0567

- [ğŸŸ  567 - å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.cn/problems/permutation-in-string)
    > ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² s1 å’Œ s2 ï¼Œå†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ s2 æ˜¯å¦åŒ…å« s1 çš„æ’åˆ—ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚æ¢å¥è¯è¯´ï¼Œs1 çš„æ’åˆ—ä¹‹ä¸€æ˜¯ s2 çš„ å­ä¸² ã€‚

        ğŸŒ°
            è¾“å…¥ï¼šs1 = "ab" s2 = "eidbaooo"
            è¾“å‡ºï¼štrue
        ğŸŒ°
            è¾“å…¥ï¼šs1= "ab" s2 = "eidboaoo"
            è¾“å‡ºï¼šfalse
        
::: details ğŸ’¡

ã€æ€è·¯ã€‘æ»‘åŠ¨çª—å£

::: code-tabs

@tab java
```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        char[] sChars = s2.toCharArray();
        char[] tChars = s1.toCharArray();
        
        Map<Character, Integer> need = new HashMap();
        int needCount = 0;
        // å†™å…¥æ’åˆ—éœ€è¦çš„å­—ç¬¦
        for (char c : tChars) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        // çª—å£å·¦å³æŒ‡é’ˆ
        int left = 0;
        int right = 0;
        // çª—å£è¡¨ï¼Œä¿å­˜å·²å­˜å…¥çš„å­—ç¬¦
        Map<Character, Integer> window = new HashMap();
        // æ‰©å¤§çª—å£
        while (right < sChars.length) {
            char rc = sChars[right];
            right += 1; 
            if (need.containsKey(rc)) {
                // æ˜¯éœ€è¦çš„å­—ç¬¦ï¼ŒåŠ å…¥çª—å£ä¸­
                window.put(rc, window.getOrDefault(rc, 0) + 1);
                if (window.get(rc).equals(need.get(rc))) {
                    needCount += 1;
                }
            }
            // çª—å£å¤§äºç›®æ ‡ä¸²é•¿åº¦ï¼Œç¼©å°çª—å£
            while (right - left >= tChars.length) {
                if (needCount == need.size()) 
                    return true;
                char lc = sChars[left];
                left += 1;
                if (window.containsKey(lc)) {
                    // æ˜¯çª—å£å­—ç¬¦å¦‚æœæ•°é‡ç­‰äºè¦æ±‚æ•°ï¼Œå³å°† -1ï¼Œæ‰€ä»¥éœ€æ±‚æ•°å‡å°‘
                    if (window.get(lc).equals(need.get(lc))) {
                        needCount -= 1;
                    }
                    window.put(lc, window.getOrDefault(lc, 0) - 1);
                }
            }
        }
        return false;
    }
}
```

@tab swift
```swift
class Solution {
    func checkInclusion(_ s1: String, _ s2: String) -> Bool {
        let char1s = [Character](s1)
        let char2s = [Character](s2)
        var needs = [Character: Int]()
        for char in char1s {
            needs[char] = (needs[char] ?? 0) + 1
        }
        func isOk() -> Bool {
            !needs.values.contains(where: { $0 > 0 })
        }
        var start = 0
        var end = 0
        while end < char2s.count {
            let char = char2s[end]
            if needs.keys.contains(char) {
                needs[char] = (needs[char] ?? 0) - 1
            }
            end += 1
            guard isOk() else { continue }
            while isOk(), start < end {
                guard end - start == char1s.count else {
                    let char = char2s[start]
                    if needs.keys.contains(char) {
                        needs[char] = (needs[char] ?? 0) + 1
                    }
                    start += 1
                    continue
                }
                return true
            }
        }
        return false
    }
}
```

:::

// #endregion 0567

## 0577

// #region 0577

- [ğŸŸ¢ 577 - åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ III](https://leetcode.cn/problems/reverse-words-in-a-string-iii)

::: details ğŸ’¡

ã€æ€è·¯ã€‘é€šè¿‡ç©ºæ ¼å»å®šä½æ¯ä¸€ä¸ªå•è¯çš„å·¦è¾¹å’Œå³è¾¹ï¼Œç„¶ååè½¬æ¯ä¸€ä¸ªå•è¯ã€‚

::: code-tabs

@tab java
```java
class Solution {
    public String reverseWords(String s) {
        char[] chars = s.toCharArray();
        int left = findLeft(chars, 0);
        int right = findRight(chars, left);
        while ( left < chars.length ) {
            // åè½¬å•è¯
            reverse(chars, left, right);
            // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå•è¯å·¦è¾¹
            left = findLeft(chars, right + 1);
            // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå•è¯å³è¾¹
            right = findRight(chars, left);
        }
        return new String(chars);
    }

    /// å®šä½å•è¯å³è¾¹ç´¢å¼•
    int findRight(char[] chars, int i) {
        // æœ€åä¸€ä¸ªå•è¯ç»“å°¾
        if ( i == (chars.length - 1) && chars[i] != ' ') {
            return i;
        }
        // ç©ºæ ¼å‰é¢å•è¯ç»“å°¾
        while ( (i + 1) < chars.length ) {
            if ( chars[i] != ' ' && chars[i + 1] == ' ' ) {
                break;
            }
            i += 1;
        }
        return i;
    }

    /// å®šä½å•è¯å·¦è¾¹ç´¢å¼•
    int findLeft(char[] chars, int i) {
        // ç¬¬ä¸€ä¸ªå•è¯å¼€å¤´
        if ( i == 0 && chars[i] != ' ') {
            return i;
        }
        // ç©ºæ ¼åé¢å•è¯å¼€å¤´
        while ( i > 0 && (i + 1) < chars.length ) {
            if ( chars[i] == ' ' && chars[i + 1] != ' ' ) {
                break;
            }
            i += 1;
        }
        return i + 1;
    }
    /// åè½¬æŒ‡å®šç´¢å¼•èŒƒå›´å­—ç¬¦
    void reverse(char[] chars, int left, int right) {
        while ( left < right ) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left += 1;
            right -= 1;
        }
    }
}
```

:::

// #endregion 0577

## 0583

// #region 0583

- [ğŸŸ  583 - ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ](https://leetcode.cn/problems/delete-operation-for-two-strings)

::: details ğŸ’¡

:::

// #endregion 0583

## 0589 âœ…

// #region 0589

- [ğŸŸ¢ 589 - N å‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/n-ary-tree-preorder-traversal)

::: details ğŸ’¡

ã€æ€è·¯1ã€‘é€’å½’ï¼Œåœ¨å‰åºä½ç½®è¿›è¡Œæ•°æ®æ”¶é›†

ã€æ€è·¯2ã€‘è¿­ä»£ï¼Œä½¿ç”¨æ ˆçš„æ•°æ®ç»“æ„æ¨¡æ‹Ÿé€’å½’è¿‡ç¨‹ä¸­çš„è°ƒç”¨æ ˆ

::: code-tabs

@tab java è§£æ³•1
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> preorder(Node root) {
        traverse(root);
        return list;
    }

    void traverse(Node root) {
        if (root == null) return;
        list.add(root.val);
        for (Node node : root.children) {
            traverse(node);
        }
    }
}
```

@tab swift è§£æ³•2 ğŸ’¯
```swift
/**
 * Definition for a Node.
 * public class Node {
 *     public var val: Int
 *     public var children: [Node]
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.children = []
 *     }
 * }
 */

class Solution {
    func preorder(_ root: Node?) -> [Int] {
        guard let root else { return [] }
        var stack = [Node]()
        stack.append(root)
        var nums = [Int]()
        while !stack.isEmpty {
            // æ ˆé¡¶å–å‡ºå…ƒç´ 
            var node: Node = stack.removeLast()
            nums.append(node.val)
            // å­èŠ‚ç‚¹å€’åºå…¥æ ˆ
            for child in node.children.reversed() {
                stack.append(child)
            }
        }
        return nums
    }
}
```

:::

// #endregion 0589

## 0590 âœ…

// #region 0590

- [ğŸŸ¢ 590 - N å‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/n-ary-tree-postorder-traversal)

::: details ğŸ’¡

ã€æ€è·¯1ã€‘é€’å½’ï¼Œååºä½ç½®è¿›è¡Œæ•°æ®æ”¶é›†

ã€æ€è·¯2ã€‘è¿­ä»£ä¼˜åŒ–ï¼Œè¿›è¡Œå‰åºæ•°æ®æ”¶é›†åï¼Œè¿›è¡Œåè½¬

::: code-tabs

@tab java è§£æ³•1
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    List<Integer> list = new ArrayList();
    public List<Integer> postorder(Node root) {
        traverse(root);
        return list;
    }

    void traverse(Node root) {
        if (root == null) return;
        for(Node node : root.children) {
            traverse(node);
        }
        list.add(root.val); // ååºä½ç½®ï¼Œæ·»åŠ å€¼
    }
}
```

@tab swift è§£æ³•2 ğŸ’¯
```swift
/**
 * Definition for a Node.
 * public class Node {
 *     public var val: Int
 *     public var children: [Node]
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.children = []
 *     }
 * }
 */

class Solution {
    func postorder(_ root: Node?) -> [Int] {
    	guard let root else { return [] }
        var stack = [Node]()
        stack.append(root)
        var nums = [Int]()
        while !stack.isEmpty {
            var node = stack.removeLast()
            for child in node.children {
                stack.append(child)
            }
            nums.append(node.val)
        }
        return nums.reversed()
    }
}
```

:::

// #endregion 0590
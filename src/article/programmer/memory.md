---
title: “内存”那些事
icon: hashtag

index: false

---

<!-- more -->

  “内存”顾名思义就是我们平常所说的电脑内存条。专业术语：随机存取存储器 `RAM`(Random Access Memory)。这个随机存取是重点，表明了存储器的特性，指定的是访问存储器的任意位置数据的时间周期都是恒定的。

## 存储器

| 访问方式 | 存储器
| -- | --
| 顺序存取(Sequential Access) | 这类存储器已经比较远古，磁带、黑胶唱片。
| 随机存取(Random Access) | 内存条 `RAM`(Random Access Memory)、磁盘存储器 `HDD`(Hard Disk Drive)、固态硬盘 `SSD` (Solid-State Drive)。

  顺序存取的介质，访问数据时都必须重头开始，所以访问速度是不如随机存储的存储器的。使用过的磁带的朋友应该很好理解这个过程，每次要听指定位置的歌曲，都必须重头开始不停快进才能定位指定位置。那说完顺序存取存储器，那接下来说说随机存取存储器的问题。

  大家都是随机存取(Random Access)为什么“内存”访问速度快？
    
  这些存储的访问速度的快慢就与存储数据介质材料和制造工艺有关。
  
| 存储器 | 制造工艺 | 工作原理
| -- | -- | --
| RAM | 半导体   | 通过改变电子状态来实现数据存储
| HDD | 磁性材料 | 通过磁头对磁盘的的磁性状态改变，来实现数据存储
| SSD | 晶体管   | 通过向晶体管加电，改变电荷数量来实现数据的存储

## 内存分区

  一个程序启动时，会被操作系统分配一块内存区域。程序运行过程中，又将得到的这块内存区域分为如下五个区域。其中代码区、常量区、全局/静态区大小在程序加载之后，大小不变。栈区和堆区的内存大小会根据程序运行过程中动态调整。

| 分区 | 说明
| -- | --
| 代码区       | 存放程序的二进制代码，这块区域在程序加载到内存中之后大小不变
| 常量区       | 程序定义的常量存储区域
| 全局/静态区   | 存放程序定义的全局和静态变量
| 栈区         | 由操作系统分配和管理，主要存储局部变量、函数参数等
| 堆区         | 由程序员手动申请和释放，如果管理不当会导致内存泄漏的问题

## 栈(stack) vs 堆(heap)

  内存中存在栈区和堆区，数据结构中存在栈和堆，那么这两者有什么关系？
  
  对于内存栈区来说，确实底层工作方式使用了栈的数据结构。遵循后进先出 `LIFO`(Last In First Out) 的原则。函数调用过程中，局部变量会被压入栈区，函数调用结束后，会从栈顶弹出。这也是栈区访问效率高于堆区的原因。
  
  而内存堆区，其实与堆这种数据结构就没有太大关系了。`heap` 在英语中表示一堆、许多的意思，表示一堆可以供程序员自由支配使用的内存区域。堆区的内存分配管理方案就与底层的操作系统以及所使用的编程语言有关了。使用的数据结构包括链表、位图、平衡二叉搜素树等。常用的内存分配算法：最佳适配算法、最差适配算法、首次适配算法、循环首次适配算法等。
  
  “栈溢出”：程序运行时，操作系统会分配一块固定大小的内存作为栈区。如果递归层数较多、申请临时变量过大等都可能触发栈溢出的问题。
  
  “内存不足”：堆区内存大小，是可以动态扩容的。但是这个大小也是有限，当程序发生内存泄漏，申请堆区内存不断增长，当达到操作系统设自动的内存阈值，就会触发内存不足的问题。

## 内存管理
  
  堆区的内存是由程序员申请使用，大多数现代编程语言为了提高编程效率，都实现了自动内存管理。而垃圾回收 `GC`(Garbage Collection)是自动内存管理中常使用的技术。

| 垃圾回收技术 | 说明
| -- | --
| 标记清除 (Mark - Sweep)       | 标记阶段遍历内存区域，标记对象的是否还存活；清除阶段，将已不在使用的内存区域回收清理。
| 引用计数 (Reference Counting) | 顾名思义，堆每块分配的内存区域对象设置一个计数器。每当引用一次该内存区域数据时，进行计数器 +1，不使用时进行 -1。当引用计数为 0 时表明该区域内存可以回收。引用计数会存在循环引用的问题。
| 分代回收 (Generational)       | 将内存划分为若干代(新生代、老年代)，经过多次垃圾回收仍然存活的对象会被移动到老年代区域。

| 编程语言 | 内存管理
| -- | --
| `C++`         | C++ 11 之后添加了智能指针，使用引用计数计数
| `Java`        | 分代垃圾回收技术
| `Python`      | 以引用计数为主，结合使用标记清除和分代回收技术
| `Swift`       | 自动引用计数 `ARC`(Automatic Reference Counting) 
| `JavaScript`  | 标记-清除(Mark Sweep)技术

## 内存对齐

  先说说数据的内存分布，基础的数据类型来说，`Int` 在 32 位机器上占用 4 字节，在 64 位机器上占用 8 个字节；`Float` 占用 4 个字节；`Double` 占用 8 字节；`Bool` 占用 1 字节；`String` 占用 16 字节。`struct` 结构体的内存占用与其包含的数据类型的占用有关系；`class` 是引用类型，所以内存占用就是指针内存占用，在 32位机器上占用 4 字节，64 位机器上占用 8 字节。
  
  还需要了解一个概念就是内存与 CPU 的交互。我们常说的 32 位、64位指的就是计算 CPU 的最大计算能力，也就是 CPU 上的寄存器的宽度。而 CPU 与内存交互调度的过程中，数据总线调度的最大宽度就是寄存器的这个宽度。为了提高 CPU 读取内存效率，最好在一个时钟周期内，读取数据的宽度刚好为这个宽度为最优。
  
  数据类型根据类型不同，占用的字节数可能存在不会刚好等于这个宽度。而“内存对齐”就是为了解决这个问题的。为了提高 CPU 读取内存效率，64 位机器来说，会将数据按照 8 字节的倍数进行对齐和排列，这样 CPU 在读取过程会，数据的起始地址都是 8 的倍数(例如 Float 类型数据只占用 4 个字节，后面会填充 4 个字节的空隙，后面再布局其它类型数据)。这样会照成一定的内存浪费，但是提高了 CPU 处理速度，是一种以空间换时间的优化方案。

## 内存泄漏

  对于计算机来说内存是有限了，程序使用内存时，如果申请了内存而未释放，这就会引起内存泄漏。通俗一点理解，将内存比如成一堆砖头，如果使用内存的码农都只借砖头，而不将砖头换回来，最后就会造成计算内存不足。
---
title: 面向对象
icon: hashtag

index: true

---

## 类结构

### 构造函数

```dart
class Car {
  // 类实例属性
  String color;
  int speed;

  // 类静态属性
  static int wheel = 4;
    
  // 构造函数
  Car(this.color, this.speed);
  
  // 命名构造函数 
  Car.build(String color, int speed)
    : color = color,
      speed = speed;
    
  // 实例方法
  void run() {
    print('This car color is $color, speed is $speed.');
  }
}
var car = Car('Red', 80);
car = Car.build('Blue', 100);
car.run();
```

### `get/set` - “属性访问器”

> `get` 和 `set` 是用于封装对象的属性的特殊方法。

```dart
class Circle {
  // 半径属性
  double radius;
  
  Circle(this.radius);

  // get 方法，获取圆的直径
  double get diameter => radius * 2;
  // set 方法，传入圆的直径，设置为圆的半径
  void set diameter(double diameter) => this.radius = diameter / 2;
}
Circle circle = Circle(5);
print(circle.diameter);  // 10
circle.diameter = 6;
print(circle.radius);    // 3
```

### `factory` - “工厂构造函数”

```dart
class Singleton {
  // 私有构造函数
  Singleton._privateConstructor();
    
  // 保存实例
  static final Singleton _instance = Singleton._privateConstructor();
    
  // 工厂构造函数
  factory Singleton() {
    return _instance;
  }
}

void main() {
  var s1 = Singleton();
  var s2 = Singleton();
  print(identical(s1, s2));  // true
}
```

### `extension` - “类扩展”

```dart
// 匿名扩展(仅所在文件可用): 字符串扩展
extension on String {
    void debug() {
        print(this);
    }
}
// 命名扩展：字符串扩展
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}

void main() {
  "hello".debug(); // hello
  print('42'.parseInt());       // 42
  print('3.14'.parseDouble());  // 3.14
}
```

------

## 面向对象

### 封装

```dart
class Square {
  // _ : 通过下划线，定义私有属性
  double _side;

  Square(this._side);

  // 通过方法来间接访问属性
  double getArea() {
    return _side * _side;
  }
}
var square = Square(3);
print(square.getArea()); // 9.0
```

### 继承

#### 抽象类

```dart
// 使用 abstract 声明抽象类
abstract class Animal {
  void makeSound();
  void eat() => print("Eating...");
}
//  - 继承方式使用抽象类: 仅需要实现未实现的方法
class Dog extends Animal {
  @override
  void makeSound() => print("Woof!!!");
}
//  - 接口方式使用抽象类：需要实现所有抽象类中的方法和属性
class Cat implements Animal {
  @override
  void makeSound() => print("Meow!!!");

  @override
  void eat() => print("The cat is eating...");
}
Dog dog = Dog();
dog.makeSound();  // Woof!!!
dog.eat();        // Eating...
Cat cat = Cat();
cat.makeSound();  // Meow!!!
cat.eat();        // The cat is eating...
```

#### 接口

> `Dart` 中没有接口，可以通过 `implements` 一个类或抽象类来实现接口功能。

```dart
//  - 通过实现一个类，来实现接口功能
class Flyable {
  void fly();
}
class Bird implements Flyable {
  @override
  void fly() {
    print('The bird is flying');
  }
}
class Airplane implements Flyable {
  @override
  void fly() {
    print('The airplane is flying');
  }
}
Bird bird = Bird();
bird.fly();     // The bird is flying
Airplane airplane = Airplane();
airplane.fly(); // The airplane is flying
```

#### `mixin` - “混入”

> `with` - 混入功能

```dart
// mixin - 蓝牙功能
mixin Bluetooth {
  void bluetoothConnection() {
    print("Bluetooth connection established.");
  }
}
// mixin - wifi 功能
mixin Wifi {
  void wifiConnection() {
    print("WiFi connection established.");
  }
}
// 父类 - 智能设备
class SmartDevice {
  void powerOn(){
    print("Device powered on.");
  }
}
// 智能手机：继承父类 `SmartDevice` 混入 `Bluetooth、Wifi` 功能
class SmartPhone extends SmartDevice with Bluetooth, Wifi {
  void allConnections() {
    powerOn();
    bluetoothConnection();
    wifiConnection();
  }
}

SmartPhone phone = SmartPhone();
phone.allConnections();
```

> `on` - 混入限制

```dart
// 抽象类
abstract class Hero {
  String heroName;
}
// minxin 限定只有实现 Hero 抽象类的类才能混入该功能
mixin Ability on Hero {
  String specialAbility() {
    return '$heroName’s special ability activated!';
  }
}
// 继承 Hero 抽象类，并混入 Ability 功能
class SuperHero extends Hero with Ability {
  SuperHero(this.heroName);

  @override
  final String heroName;
}

SuperHero superman = SuperHero('Superman');
print(superman.specialAbility());  // Superman's special ability activated!
```

### 多态

> 多态性：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

```dart
// 抽象类：形状
abstract class Shape {
  double getArea();
}
// 矩形
class Rectangle implements Shape {
  final double width, height;
  Rectangle(this.width, this.height);
  
  @override
  double getArea() {
    return width * height;
  }
}
// 圆形
class Circle implements Shape {
  final double radius;
  Circle(this.radius);

  @override
  double getArea() {
    return 3.14 * radius * radius;
  }
}
// 打印形状
void printArea(Shape shape) {
  print(shape.getArea());
}

void main() {
  // 父类指针指向子类对象
  Shape rect = Rectangle(3, 4);
  Shape circ = Circle(5);

  printArea(rect); // 12
  printArea(circ); // 78.5
}
```

